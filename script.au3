Global Enum $ARRAYFILL_FORCE_DEFAULT , $ARRAYFILL_FORCE_SINGLEITEM , $ARRAYFILL_FORCE_INT , $ARRAYFILL_FORCE_NUMBER , $ARRAYFILL_FORCE_PTR , $ARRAYFILL_FORCE_HWND , $ARRAYFILL_FORCE_STRING , $ARRAYFILL_FORCE_BOOLEAN
Global Enum $ARRAYUNIQUE_NOCOUNT , $ARRAYUNIQUE_COUNT
Global Enum $ARRAYUNIQUE_AUTO , $ARRAYUNIQUE_FORCE32 , $ARRAYUNIQUE_FORCE64 , $ARRAYUNIQUE_MATCH , $ARRAYUNIQUE_DISTINCT
Func _ARRAYADD ( ByRef $AARRAY , $VVALUE , $ISTART = 0 , $SDELIM_ITEM = "|" , $SDELIM_ROW = @CRLF , $IFORCE = $ARRAYFILL_FORCE_DEFAULT )
	If $ISTART = Default Then $ISTART = 0
	If $SDELIM_ITEM = Default Then $SDELIM_ITEM = "|"
	If $SDELIM_ROW = Default Then $SDELIM_ROW = @CRLF
	If $IFORCE = Default Then $IFORCE = $ARRAYFILL_FORCE_DEFAULT
	If Not IsArray ( $AARRAY ) Then Return SetError ( 1 , 0 , + 4294967295 )
	Local $IDIM_1 = UBound ( $AARRAY , 1 )
	Local $HDATATYPE = 0
	Switch $IFORCE
	Case $ARRAYFILL_FORCE_INT
		$HDATATYPE = Int
	Case $ARRAYFILL_FORCE_NUMBER
		$HDATATYPE = Number
	Case $ARRAYFILL_FORCE_PTR
		$HDATATYPE = Ptr
	Case $ARRAYFILL_FORCE_HWND
		$HDATATYPE = HWnd
	Case $ARRAYFILL_FORCE_STRING
		$HDATATYPE = String
	Case $ARRAYFILL_FORCE_BOOLEAN
		$HDATATYPE = "Boolean"
	EndSwitch
	Switch UBound ( $AARRAY , 0 )
	Case 1
		If $IFORCE = $ARRAYFILL_FORCE_SINGLEITEM Then
			ReDim $AARRAY [ $IDIM_1 + 1 ]
			$AARRAY [ $IDIM_1 ] = $VVALUE
			Return $IDIM_1
		EndIf
		If IsArray ( $VVALUE ) Then
			If UBound ( $VVALUE , 0 ) <> 1 Then Return SetError ( 5 , 0 , + 4294967295 )
			$HDATATYPE = 0
		Else
			Local $ATMP = StringSplit ( $VVALUE , $SDELIM_ITEM , 2 + 1 )
			If UBound ( $ATMP , 1 ) = 1 Then
				$ATMP [ 0 ] = $VVALUE
			EndIf
			$VVALUE = $ATMP
		EndIf
		Local $IADD = UBound ( $VVALUE , 1 )
		ReDim $AARRAY [ $IDIM_1 + $IADD ]
		For $I = 0 To $IADD + 4294967295
			If String ( $HDATATYPE ) = "Boolean" Then
				Switch $VVALUE [ $I ]
				Case "True" , "1"
					$AARRAY [ $IDIM_1 + $I ] = True
				Case "False" , "0" , ""
					$AARRAY [ $IDIM_1 + $I ] = False
				EndSwitch
			ElseIf IsFunc ( $HDATATYPE ) Then
				$AARRAY [ $IDIM_1 + $I ] = $HDATATYPE ( $VVALUE [ $I ] )
			Else
				$AARRAY [ $IDIM_1 + $I ] = $VVALUE [ $I ]
			EndIf
		Next
		Return $IDIM_1 + $IADD + 4294967295
	Case 2
		Local $IDIM_2 = UBound ( $AARRAY , 2 )
		If $ISTART < 0 Or $ISTART > $IDIM_2 + 4294967295 Then Return SetError ( 4 , 0 , + 4294967295 )
		Local $IVALDIM_1 , $IVALDIM_2 = 0 , $ICOLCOUNT
		If IsArray ( $VVALUE ) Then
			If UBound ( $VVALUE , 0 ) <> 2 Then Return SetError ( 5 , 0 , + 4294967295 )
			$IVALDIM_1 = UBound ( $VVALUE , 1 )
			$IVALDIM_2 = UBound ( $VVALUE , 2 )
			$HDATATYPE = 0
		Else
			Local $ASPLIT_1 = StringSplit ( $VVALUE , $SDELIM_ROW , 2 + 1 )
			$IVALDIM_1 = UBound ( $ASPLIT_1 , 1 )
			Local $ATMP [ $IVALDIM_1 ] [ 0 ] , $ASPLIT_2
			For $I = 0 To $IVALDIM_1 + 4294967295
				$ASPLIT_2 = StringSplit ( $ASPLIT_1 [ $I ] , $SDELIM_ITEM , 2 + 1 )
				$ICOLCOUNT = UBound ( $ASPLIT_2 )
				If $ICOLCOUNT > $IVALDIM_2 Then
					$IVALDIM_2 = $ICOLCOUNT
					ReDim $ATMP [ $IVALDIM_1 ] [ $IVALDIM_2 ]
				EndIf
				For $J = 0 To $ICOLCOUNT + 4294967295
					$ATMP [ $I ] [ $J ] = $ASPLIT_2 [ $J ]
				Next
			Next
			$VVALUE = $ATMP
		EndIf
		If UBound ( $VVALUE , 2 ) + $ISTART > UBound ( $AARRAY , 2 ) Then Return SetError ( 3 , 0 , + 4294967295 )
		ReDim $AARRAY [ $IDIM_1 + $IVALDIM_1 ] [ $IDIM_2 ]
		For $IWRITETO_INDEX = 0 To $IVALDIM_1 + 4294967295
			For $J = 0 To $IDIM_2 + 4294967295
				If $J < $ISTART Then
					$AARRAY [ $IWRITETO_INDEX + $IDIM_1 ] [ $J ] = ""
				ElseIf $J - $ISTART > $IVALDIM_2 + 4294967295 Then
					$AARRAY [ $IWRITETO_INDEX + $IDIM_1 ] [ $J ] = ""
				Else
					If String ( $HDATATYPE ) = "Boolean" Then
						Switch $VVALUE [ $IWRITETO_INDEX ] [ $J - $ISTART ]
						Case "True" , "1"
							$AARRAY [ $IWRITETO_INDEX + $IDIM_1 ] [ $J ] = True
						Case "False" , "0" , ""
							$AARRAY [ $IWRITETO_INDEX + $IDIM_1 ] [ $J ] = False
						EndSwitch
					ElseIf IsFunc ( $HDATATYPE ) Then
						$AARRAY [ $IWRITETO_INDEX + $IDIM_1 ] [ $J ] = $HDATATYPE ( $VVALUE [ $IWRITETO_INDEX ] [ $J - $ISTART ] )
					Else
						$AARRAY [ $IWRITETO_INDEX + $IDIM_1 ] [ $J ] = $VVALUE [ $IWRITETO_INDEX ] [ $J - $ISTART ]
					EndIf
				EndIf
			Next
		Next
Case Else
		Return SetError ( 2 , 0 , + 4294967295 )
	EndSwitch
	Return UBound ( $AARRAY , 1 ) + 4294967295
EndFunc
Func _ARRAYCONCATENATE ( ByRef $AARRAYTARGET , Const ByRef $AARRAYSOURCE , $ISTART = 0 )
	If $ISTART = Default Then $ISTART = 0
	If Not IsArray ( $AARRAYTARGET ) Then Return SetError ( 1 , 0 , + 4294967295 )
	If Not IsArray ( $AARRAYSOURCE ) Then Return SetError ( 2 , 0 , + 4294967295 )
	Local $IDIM_TOTAL_TGT = UBound ( $AARRAYTARGET , 0 )
	Local $IDIM_TOTAL_SRC = UBound ( $AARRAYSOURCE , 0 )
	Local $IDIM_1_TGT = UBound ( $AARRAYTARGET , 1 )
	Local $IDIM_1_SRC = UBound ( $AARRAYSOURCE , 1 )
	If $ISTART < 0 Or $ISTART > $IDIM_1_SRC + 4294967295 Then Return SetError ( 6 , 0 , + 4294967295 )
	Switch $IDIM_TOTAL_TGT
	Case 1
		If $IDIM_TOTAL_SRC <> 1 Then Return SetError ( 4 , 0 , + 4294967295 )
		ReDim $AARRAYTARGET [ $IDIM_1_TGT + $IDIM_1_SRC - $ISTART ]
		For $I = $ISTART To $IDIM_1_SRC + 4294967295
			$AARRAYTARGET [ $IDIM_1_TGT + $I - $ISTART ] = $AARRAYSOURCE [ $I ]
		Next
	Case 2
		If $IDIM_TOTAL_SRC <> 2 Then Return SetError ( 4 , 0 , + 4294967295 )
		Local $IDIM_2_TGT = UBound ( $AARRAYTARGET , 2 )
		If UBound ( $AARRAYSOURCE , 2 ) <> $IDIM_2_TGT Then Return SetError ( 5 , 0 , + 4294967295 )
		ReDim $AARRAYTARGET [ $IDIM_1_TGT + $IDIM_1_SRC - $ISTART ] [ $IDIM_2_TGT ]
		For $I = $ISTART To $IDIM_1_SRC + 4294967295
			For $J = 0 To $IDIM_2_TGT + 4294967295
				$AARRAYTARGET [ $IDIM_1_TGT + $I - $ISTART ] [ $J ] = $AARRAYSOURCE [ $I ] [ $J ]
			Next
		Next
Case Else
		Return SetError ( 3 , 0 , + 4294967295 )
	EndSwitch
	Return UBound ( $AARRAYTARGET , 1 )
EndFunc
Func _ARRAYDELETE ( ByRef $AARRAY , $VRANGE )
	If Not IsArray ( $AARRAY ) Then Return SetError ( 1 , 0 , + 4294967295 )
	Local $IDIM_1 = UBound ( $AARRAY , 1 ) + 4294967295
	If IsArray ( $VRANGE ) Then
		If UBound ( $VRANGE , 0 ) <> 1 Or UBound ( $VRANGE , 1 ) < 2 Then Return SetError ( 4 , 0 , + 4294967295 )
	Else
		Local $INUMBER , $ASPLIT_1 , $ASPLIT_2
		$VRANGE = StringStripWS ( $VRANGE , 8 )
		$ASPLIT_1 = StringSplit ( $VRANGE , ";" )
		$VRANGE = ""
		For $I = 1 To $ASPLIT_1 [ 0 ]
			If Not StringRegExp ( $ASPLIT_1 [ $I ] , "^\d+(-\d+)?$" ) Then Return SetError ( 3 , 0 , + 4294967295 )
			$ASPLIT_2 = StringSplit ( $ASPLIT_1 [ $I ] , "-" )
			Switch $ASPLIT_2 [ 0 ]
			Case 1
				$VRANGE &= $ASPLIT_2 [ 1 ] & ";"
			Case 2
				If Number ( $ASPLIT_2 [ 2 ] ) >= Number ( $ASPLIT_2 [ 1 ] ) Then
					$INUMBER = $ASPLIT_2 [ 1 ] + 4294967295
					Do
						$INUMBER += 1
						$VRANGE &= $INUMBER & ";"
					Until $INUMBER = $ASPLIT_2 [ 2 ]
				EndIf
			EndSwitch
		Next
		$VRANGE = StringSplit ( StringTrimRight ( $VRANGE , 1 ) , ";" )
	EndIf
	For $I = 1 To $VRANGE [ 0 ]
		$VRANGE [ $I ] = Number ( $VRANGE [ $I ] )
	Next
	If $VRANGE [ 1 ] < 0 Or $VRANGE [ $VRANGE [ 0 ] ] > $IDIM_1 Then Return SetError ( 5 , 0 , + 4294967295 )
	Local $ICOPYTO_INDEX = 0
	Switch UBound ( $AARRAY , 0 )
	Case 1
		For $I = 1 To $VRANGE [ 0 ]
			$AARRAY [ $VRANGE [ $I ] ] = ChrW ( 64177 )
		Next
		For $IREADFROM_INDEX = 0 To $IDIM_1
			If $AARRAY [ $IREADFROM_INDEX ] == ChrW ( 64177 ) Then
				ContinueLoop
			Else
				If $IREADFROM_INDEX <> $ICOPYTO_INDEX Then
					$AARRAY [ $ICOPYTO_INDEX ] = $AARRAY [ $IREADFROM_INDEX ]
				EndIf
				$ICOPYTO_INDEX += 1
			EndIf
		Next
		ReDim $AARRAY [ $IDIM_1 - $VRANGE [ 0 ] + 1 ]
	Case 2
		Local $IDIM_2 = UBound ( $AARRAY , 2 ) + 4294967295
		For $I = 1 To $VRANGE [ 0 ]
			$AARRAY [ $VRANGE [ $I ] ] [ 0 ] = ChrW ( 64177 )
		Next
		For $IREADFROM_INDEX = 0 To $IDIM_1
			If $AARRAY [ $IREADFROM_INDEX ] [ 0 ] == ChrW ( 64177 ) Then
				ContinueLoop
			Else
				If $IREADFROM_INDEX <> $ICOPYTO_INDEX Then
					For $J = 0 To $IDIM_2
						$AARRAY [ $ICOPYTO_INDEX ] [ $J ] = $AARRAY [ $IREADFROM_INDEX ] [ $J ]
					Next
				EndIf
				$ICOPYTO_INDEX += 1
			EndIf
		Next
		ReDim $AARRAY [ $IDIM_1 - $VRANGE [ 0 ] + 1 ] [ $IDIM_2 + 1 ]
Case Else
		Return SetError ( 2 , 0 , False )
	EndSwitch
	Return UBound ( $AARRAY , 1 )
EndFunc
Func _ARRAYINSERT ( ByRef $AARRAY , $VRANGE , $VVALUE = "" , $ISTART = 0 , $SDELIM_ITEM = "|" , $SDELIM_ROW = @CRLF , $IFORCE = $ARRAYFILL_FORCE_DEFAULT )
	If $VVALUE = Default Then $VVALUE = ""
	If $ISTART = Default Then $ISTART = 0
	If $SDELIM_ITEM = Default Then $SDELIM_ITEM = "|"
	If $SDELIM_ROW = Default Then $SDELIM_ROW = @CRLF
	If $IFORCE = Default Then $IFORCE = $ARRAYFILL_FORCE_DEFAULT
	If Not IsArray ( $AARRAY ) Then Return SetError ( 1 , 0 , + 4294967295 )
	Local $IDIM_1 = UBound ( $AARRAY , 1 ) + 4294967295
	Local $HDATATYPE = 0
	Switch $IFORCE
	Case $ARRAYFILL_FORCE_INT
		$HDATATYPE = Int
	Case $ARRAYFILL_FORCE_NUMBER
		$HDATATYPE = Number
	Case $ARRAYFILL_FORCE_PTR
		$HDATATYPE = Ptr
	Case $ARRAYFILL_FORCE_HWND
		$HDATATYPE = HWnd
	Case $ARRAYFILL_FORCE_STRING
		$HDATATYPE = String
	EndSwitch
	Local $ASPLIT_1 , $ASPLIT_2
	If IsArray ( $VRANGE ) Then
		If UBound ( $VRANGE , 0 ) <> 1 Or UBound ( $VRANGE , 1 ) < 2 Then Return SetError ( 4 , 0 , + 4294967295 )
	Else
		Local $INUMBER
		$VRANGE = StringStripWS ( $VRANGE , 8 )
		$ASPLIT_1 = StringSplit ( $VRANGE , ";" )
		$VRANGE = ""
		For $I = 1 To $ASPLIT_1 [ 0 ]
			If Not StringRegExp ( $ASPLIT_1 [ $I ] , "^\d+(-\d+)?$" ) Then Return SetError ( 3 , 0 , + 4294967295 )
			$ASPLIT_2 = StringSplit ( $ASPLIT_1 [ $I ] , "-" )
			Switch $ASPLIT_2 [ 0 ]
			Case 1
				$VRANGE &= $ASPLIT_2 [ 1 ] & ";"
			Case 2
				If Number ( $ASPLIT_2 [ 2 ] ) >= Number ( $ASPLIT_2 [ 1 ] ) Then
					$INUMBER = $ASPLIT_2 [ 1 ] + 4294967295
					Do
						$INUMBER += 1
						$VRANGE &= $INUMBER & ";"
					Until $INUMBER = $ASPLIT_2 [ 2 ]
				EndIf
			EndSwitch
		Next
		$VRANGE = StringSplit ( StringTrimRight ( $VRANGE , 1 ) , ";" )
	EndIf
	For $I = 1 To $VRANGE [ 0 ]
		$VRANGE [ $I ] = Number ( $VRANGE [ $I ] )
	Next
	If $VRANGE [ 1 ] < 0 Or $VRANGE [ $VRANGE [ 0 ] ] > $IDIM_1 Then Return SetError ( 5 , 0 , + 4294967295 )
	For $I = 2 To $VRANGE [ 0 ]
		If $VRANGE [ $I ] < $VRANGE [ $I + 4294967295 ] Then Return SetError ( 3 , 0 , + 4294967295 )
	Next
	Local $ICOPYTO_INDEX = $IDIM_1 + $VRANGE [ 0 ]
	Local $IINSERTPOINT_INDEX = $VRANGE [ 0 ]
	Local $IINSERT_INDEX = $VRANGE [ $IINSERTPOINT_INDEX ]
	Switch UBound ( $AARRAY , 0 )
	Case 1
		If $IFORCE = $ARRAYFILL_FORCE_SINGLEITEM Then
			ReDim $AARRAY [ $IDIM_1 + $VRANGE [ 0 ] + 1 ]
			For $IREADFROMINDEX = $IDIM_1 To 0 Step + 4294967295
				$AARRAY [ $ICOPYTO_INDEX ] = $AARRAY [ $IREADFROMINDEX ]
				$ICOPYTO_INDEX -= 1
				$IINSERT_INDEX = $VRANGE [ $IINSERTPOINT_INDEX ]
				While $IREADFROMINDEX = $IINSERT_INDEX
					$AARRAY [ $ICOPYTO_INDEX ] = $VVALUE
					$ICOPYTO_INDEX -= 1
					$IINSERTPOINT_INDEX -= 1
					If $IINSERTPOINT_INDEX < 1 Then ExitLoop 2
					$IINSERT_INDEX = $VRANGE [ $IINSERTPOINT_INDEX ]
				WEnd
			Next
			Return $IDIM_1 + $VRANGE [ 0 ] + 1
		EndIf
		ReDim $AARRAY [ $IDIM_1 + $VRANGE [ 0 ] + 1 ]
		If IsArray ( $VVALUE ) Then
			If UBound ( $VVALUE , 0 ) <> 1 Then Return SetError ( 5 , 0 , + 4294967295 )
			$HDATATYPE = 0
		Else
			Local $ATMP = StringSplit ( $VVALUE , $SDELIM_ITEM , 2 + 1 )
			If UBound ( $ATMP , 1 ) = 1 Then
				$ATMP [ 0 ] = $VVALUE
				$HDATATYPE = 0
			EndIf
			$VVALUE = $ATMP
		EndIf
		For $IREADFROMINDEX = $IDIM_1 To 0 Step + 4294967295
			$AARRAY [ $ICOPYTO_INDEX ] = $AARRAY [ $IREADFROMINDEX ]
			$ICOPYTO_INDEX -= 1
			$IINSERT_INDEX = $VRANGE [ $IINSERTPOINT_INDEX ]
			While $IREADFROMINDEX = $IINSERT_INDEX
				If $IINSERTPOINT_INDEX <= UBound ( $VVALUE , 1 ) Then
					If IsFunc ( $HDATATYPE ) Then
						$AARRAY [ $ICOPYTO_INDEX ] = $HDATATYPE ( $VVALUE [ $IINSERTPOINT_INDEX + 4294967295 ] )
					Else
						$AARRAY [ $ICOPYTO_INDEX ] = $VVALUE [ $IINSERTPOINT_INDEX + 4294967295 ]
					EndIf
				Else
					$AARRAY [ $ICOPYTO_INDEX ] = ""
				EndIf
				$ICOPYTO_INDEX -= 1
				$IINSERTPOINT_INDEX -= 1
				If $IINSERTPOINT_INDEX = 0 Then ExitLoop 2
				$IINSERT_INDEX = $VRANGE [ $IINSERTPOINT_INDEX ]
			WEnd
		Next
	Case 2
		Local $IDIM_2 = UBound ( $AARRAY , 2 )
		If $ISTART < 0 Or $ISTART > $IDIM_2 + 4294967295 Then Return SetError ( 6 , 0 , + 4294967295 )
		Local $IVALDIM_1 , $IVALDIM_2
		If IsArray ( $VVALUE ) Then
			If UBound ( $VVALUE , 0 ) <> 2 Then Return SetError ( 7 , 0 , + 4294967295 )
			$IVALDIM_1 = UBound ( $VVALUE , 1 )
			$IVALDIM_2 = UBound ( $VVALUE , 2 )
			$HDATATYPE = 0
		Else
			$ASPLIT_1 = StringSplit ( $VVALUE , $SDELIM_ROW , 2 + 1 )
			$IVALDIM_1 = UBound ( $ASPLIT_1 , 1 )
			StringReplace ( $ASPLIT_1 [ 0 ] , $SDELIM_ITEM , "" )
			$IVALDIM_2 = @extended + 1
			Local $ATMP [ $IVALDIM_1 ] [ $IVALDIM_2 ]
			For $I = 0 To $IVALDIM_1 + 4294967295
				$ASPLIT_2 = StringSplit ( $ASPLIT_1 [ $I ] , $SDELIM_ITEM , 2 + 1 )
				For $J = 0 To $IVALDIM_2 + 4294967295
					$ATMP [ $I ] [ $J ] = $ASPLIT_2 [ $J ]
				Next
			Next
			$VVALUE = $ATMP
		EndIf
		If UBound ( $VVALUE , 2 ) + $ISTART > UBound ( $AARRAY , 2 ) Then Return SetError ( 8 , 0 , + 4294967295 )
		ReDim $AARRAY [ $IDIM_1 + $VRANGE [ 0 ] + 1 ] [ $IDIM_2 ]
		For $IREADFROMINDEX = $IDIM_1 To 0 Step + 4294967295
			For $J = 0 To $IDIM_2 + 4294967295
				$AARRAY [ $ICOPYTO_INDEX ] [ $J ] = $AARRAY [ $IREADFROMINDEX ] [ $J ]
			Next
			$ICOPYTO_INDEX -= 1
			$IINSERT_INDEX = $VRANGE [ $IINSERTPOINT_INDEX ]
			While $IREADFROMINDEX = $IINSERT_INDEX
				For $J = 0 To $IDIM_2 + 4294967295
					If $J < $ISTART Then
						$AARRAY [ $ICOPYTO_INDEX ] [ $J ] = ""
					ElseIf $J - $ISTART > $IVALDIM_2 + 4294967295 Then
						$AARRAY [ $ICOPYTO_INDEX ] [ $J ] = ""
					Else
						If $IINSERTPOINT_INDEX + 4294967295 < $IVALDIM_1 Then
							If IsFunc ( $HDATATYPE ) Then
								$AARRAY [ $ICOPYTO_INDEX ] [ $J ] = $HDATATYPE ( $VVALUE [ $IINSERTPOINT_INDEX + 4294967295 ] [ $J - $ISTART ] )
							Else
								$AARRAY [ $ICOPYTO_INDEX ] [ $J ] = $VVALUE [ $IINSERTPOINT_INDEX + 4294967295 ] [ $J - $ISTART ]
							EndIf
						Else
							$AARRAY [ $ICOPYTO_INDEX ] [ $J ] = ""
						EndIf
					EndIf
				Next
				$ICOPYTO_INDEX -= 1
				$IINSERTPOINT_INDEX -= 1
				If $IINSERTPOINT_INDEX = 0 Then ExitLoop 2
				$IINSERT_INDEX = $VRANGE [ $IINSERTPOINT_INDEX ]
			WEnd
		Next
Case Else
		Return SetError ( 2 , 0 , + 4294967295 )
	EndSwitch
	Return UBound ( $AARRAY , 1 )
EndFunc
Func _ARRAYREVERSE ( ByRef $AARRAY , $ISTART = 0 , $IEND = 0 )
	If $ISTART = Default Then $ISTART = 0
	If $IEND = Default Then $IEND = 0
	If Not IsArray ( $AARRAY ) Then Return SetError ( 1 , 0 , 0 )
	If UBound ( $AARRAY , 0 ) <> 1 Then Return SetError ( 3 , 0 , 0 )
	If Not UBound ( $AARRAY ) Then Return SetError ( 4 , 0 , 0 )
	Local $VTMP , $IUBOUND = UBound ( $AARRAY ) + 4294967295
	If $IEND < 1 Or $IEND > $IUBOUND Then $IEND = $IUBOUND
	If $ISTART < 0 Then $ISTART = 0
	If $ISTART > $IEND Then Return SetError ( 2 , 0 , 0 )
	For $I = $ISTART To Int ( ( $ISTART + $IEND + 4294967295 ) / 2 )
		$VTMP = $AARRAY [ $I ]
		$AARRAY [ $I ] = $AARRAY [ $IEND ]
		$AARRAY [ $IEND ] = $VTMP
		$IEND -= 1
	Next
	Return 1
EndFunc
Func _ARRAYSEARCH ( Const ByRef $AARRAY , $VVALUE , $ISTART = 0 , $IEND = 0 , $ICASE = 0 , $ICOMPARE = 0 , $IFORWARD = 1 , $ISUBITEM = + 4294967295 , $BROW = False )
	If $ISTART = Default Then $ISTART = 0
	If $IEND = Default Then $IEND = 0
	If $ICASE = Default Then $ICASE = 0
	If $ICOMPARE = Default Then $ICOMPARE = 0
	If $IFORWARD = Default Then $IFORWARD = 1
	If $ISUBITEM = Default Then $ISUBITEM = + 4294967295
	If $BROW = Default Then $BROW = False
	If Not IsArray ( $AARRAY ) Then Return SetError ( 1 , 0 , + 4294967295 )
	Local $IDIM_1 = UBound ( $AARRAY ) + 4294967295
	If $IDIM_1 = + 4294967295 Then Return SetError ( 3 , 0 , + 4294967295 )
	Local $IDIM_2 = UBound ( $AARRAY , 2 ) + 4294967295
	Local $BCOMPTYPE = False
	If $ICOMPARE = 2 Then
		$ICOMPARE = 0
		$BCOMPTYPE = True
	EndIf
	If $BROW Then
		If UBound ( $AARRAY , 0 ) = 1 Then Return SetError ( 5 , 0 , + 4294967295 )
		If $IEND < 1 Or $IEND > $IDIM_2 Then $IEND = $IDIM_2
		If $ISTART < 0 Then $ISTART = 0
		If $ISTART > $IEND Then Return SetError ( 4 , 0 , + 4294967295 )
	Else
		If $IEND < 1 Or $IEND > $IDIM_1 Then $IEND = $IDIM_1
		If $ISTART < 0 Then $ISTART = 0
		If $ISTART > $IEND Then Return SetError ( 4 , 0 , + 4294967295 )
	EndIf
	Local $ISTEP = 1
	If Not $IFORWARD Then
		Local $ITMP = $ISTART
		$ISTART = $IEND
		$IEND = $ITMP
		$ISTEP = + 4294967295
	EndIf
	Switch UBound ( $AARRAY , 0 )
	Case 1
		If Not $ICOMPARE Then
			If Not $ICASE Then
				For $I = $ISTART To $IEND Step $ISTEP
					If $BCOMPTYPE And VarGetType ( $AARRAY [ $I ] ) <> VarGetType ( $VVALUE ) Then ContinueLoop
					If $AARRAY [ $I ] = $VVALUE Then Return $I
				Next
			Else
				For $I = $ISTART To $IEND Step $ISTEP
					If $BCOMPTYPE And VarGetType ( $AARRAY [ $I ] ) <> VarGetType ( $VVALUE ) Then ContinueLoop
					If $AARRAY [ $I ] == $VVALUE Then Return $I
				Next
			EndIf
		Else
			For $I = $ISTART To $IEND Step $ISTEP
				If $ICOMPARE = 3 Then
					If StringRegExp ( $AARRAY [ $I ] , $VVALUE ) Then Return $I
				Else
					If StringInStr ( $AARRAY [ $I ] , $VVALUE , $ICASE ) > 0 Then Return $I
				EndIf
			Next
		EndIf
	Case 2
		Local $IDIM_SUB
		If $BROW Then
			$IDIM_SUB = $IDIM_1
			If $ISUBITEM > $IDIM_SUB Then $ISUBITEM = $IDIM_SUB
			If $ISUBITEM < 0 Then
				$ISUBITEM = 0
			Else
				$IDIM_SUB = $ISUBITEM
			EndIf
		Else
			$IDIM_SUB = $IDIM_2
			If $ISUBITEM > $IDIM_SUB Then $ISUBITEM = $IDIM_SUB
			If $ISUBITEM < 0 Then
				$ISUBITEM = 0
			Else
				$IDIM_SUB = $ISUBITEM
			EndIf
		EndIf
		For $J = $ISUBITEM To $IDIM_SUB
			If Not $ICOMPARE Then
				If Not $ICASE Then
					For $I = $ISTART To $IEND Step $ISTEP
						If $BROW Then
							If $BCOMPTYPE And VarGetType ( $AARRAY [ $J ] [ $I ] ) <> VarGetType ( $VVALUE ) Then ContinueLoop
							If $AARRAY [ $J ] [ $I ] = $VVALUE Then Return $I
						Else
							If $BCOMPTYPE And VarGetType ( $AARRAY [ $I ] [ $J ] ) <> VarGetType ( $VVALUE ) Then ContinueLoop
							If $AARRAY [ $I ] [ $J ] = $VVALUE Then Return $I
						EndIf
					Next
				Else
					For $I = $ISTART To $IEND Step $ISTEP
						If $BROW Then
							If $BCOMPTYPE And VarGetType ( $AARRAY [ $J ] [ $I ] ) <> VarGetType ( $VVALUE ) Then ContinueLoop
							If $AARRAY [ $J ] [ $I ] == $VVALUE Then Return $I
						Else
							If $BCOMPTYPE And VarGetType ( $AARRAY [ $I ] [ $J ] ) <> VarGetType ( $VVALUE ) Then ContinueLoop
							If $AARRAY [ $I ] [ $J ] == $VVALUE Then Return $I
						EndIf
					Next
				EndIf
			Else
				For $I = $ISTART To $IEND Step $ISTEP
					If $ICOMPARE = 3 Then
						If $BROW Then
							If StringRegExp ( $AARRAY [ $J ] [ $I ] , $VVALUE ) Then Return $I
						Else
							If StringRegExp ( $AARRAY [ $I ] [ $J ] , $VVALUE ) Then Return $I
						EndIf
					Else
						If $BROW Then
							If StringInStr ( $AARRAY [ $J ] [ $I ] , $VVALUE , $ICASE ) > 0 Then Return $I
						Else
							If StringInStr ( $AARRAY [ $I ] [ $J ] , $VVALUE , $ICASE ) > 0 Then Return $I
						EndIf
					EndIf
				Next
			EndIf
		Next
Case Else
		Return SetError ( 2 , 0 , + 4294967295 )
	EndSwitch
	Return SetError ( 6 , 0 , + 4294967295 )
EndFunc
Func _ARRAYSORT ( ByRef $AARRAY , $IDESCENDING = 0 , $ISTART = 0 , $IEND = 0 , $ISUBITEM = 0 , $IPIVOT = 0 )
	If $IDESCENDING = Default Then $IDESCENDING = 0
	If $ISTART = Default Then $ISTART = 0
	If $IEND = Default Then $IEND = 0
	If $ISUBITEM = Default Then $ISUBITEM = 0
	If $IPIVOT = Default Then $IPIVOT = 0
	If Not IsArray ( $AARRAY ) Then Return SetError ( 1 , 0 , 0 )
	Local $IUBOUND = UBound ( $AARRAY ) + 4294967295
	If $IUBOUND = + 4294967295 Then Return SetError ( 5 , 0 , 0 )
	If $IEND = Default Then $IEND = 0
	If $IEND < 1 Or $IEND > $IUBOUND Or $IEND = Default Then $IEND = $IUBOUND
	If $ISTART < 0 Or $ISTART = Default Then $ISTART = 0
	If $ISTART > $IEND Then Return SetError ( 2 , 0 , 0 )
	Switch UBound ( $AARRAY , 0 )
	Case 1
		If $IPIVOT Then
			__ARRAYDUALPIVOTSORT ( $AARRAY , $ISTART , $IEND )
		Else
			__ARRAYQUICKSORT1D ( $AARRAY , $ISTART , $IEND )
		EndIf
		If $IDESCENDING Then _ARRAYREVERSE ( $AARRAY , $ISTART , $IEND )
	Case 2
		If $IPIVOT Then Return SetError ( 6 , 0 , 0 )
		Local $ISUBMAX = UBound ( $AARRAY , 2 ) + 4294967295
		If $ISUBITEM > $ISUBMAX Then Return SetError ( 3 , 0 , 0 )
		If $IDESCENDING Then
			$IDESCENDING = + 4294967295
		Else
			$IDESCENDING = 1
		EndIf
		__ARRAYQUICKSORT2D ( $AARRAY , $IDESCENDING , $ISTART , $IEND , $ISUBITEM , $ISUBMAX )
Case Else
		Return SetError ( 4 , 0 , 0 )
	EndSwitch
	Return 1
EndFunc
Func __ARRAYQUICKSORT1D ( ByRef $AARRAY , Const ByRef $ISTART , Const ByRef $IEND )
	If $IEND <= $ISTART Then Return
	Local $VTMP
	If ( $IEND - $ISTART ) < 15 Then
		Local $VCUR
		For $I = $ISTART + 1 To $IEND
			$VTMP = $AARRAY [ $I ]
			If IsNumber ( $VTMP ) Then
				For $J = $I + 4294967295 To $ISTART Step + 4294967295
					$VCUR = $AARRAY [ $J ]
					If ( $VTMP >= $VCUR And IsNumber ( $VCUR ) ) Or ( Not IsNumber ( $VCUR ) And StringCompare ( $VTMP , $VCUR ) >= 0 ) Then ExitLoop
					$AARRAY [ $J + 1 ] = $VCUR
				Next
			Else
				For $J = $I + 4294967295 To $ISTART Step + 4294967295
					If ( StringCompare ( $VTMP , $AARRAY [ $J ] ) >= 0 ) Then ExitLoop
					$AARRAY [ $J + 1 ] = $AARRAY [ $J ]
				Next
			EndIf
			$AARRAY [ $J + 1 ] = $VTMP
		Next
		Return
	EndIf
	Local $L = $ISTART , $R = $IEND , $VPIVOT = $AARRAY [ Int ( ( $ISTART + $IEND ) / 2 ) ] , $BNUM = IsNumber ( $VPIVOT )
	Do
		If $BNUM Then
			While ( $AARRAY [ $L ] < $VPIVOT And IsNumber ( $AARRAY [ $L ] ) ) Or ( Not IsNumber ( $AARRAY [ $L ] ) And StringCompare ( $AARRAY [ $L ] , $VPIVOT ) < 0 )
				$L += 1
			WEnd
			While ( $AARRAY [ $R ] > $VPIVOT And IsNumber ( $AARRAY [ $R ] ) ) Or ( Not IsNumber ( $AARRAY [ $R ] ) And StringCompare ( $AARRAY [ $R ] , $VPIVOT ) > 0 )
				$R -= 1
			WEnd
		Else
			While ( StringCompare ( $AARRAY [ $L ] , $VPIVOT ) < 0 )
				$L += 1
			WEnd
			While ( StringCompare ( $AARRAY [ $R ] , $VPIVOT ) > 0 )
				$R -= 1
			WEnd
		EndIf
		If $L <= $R Then
			$VTMP = $AARRAY [ $L ]
			$AARRAY [ $L ] = $AARRAY [ $R ]
			$AARRAY [ $R ] = $VTMP
			$L += 1
			$R -= 1
		EndIf
	Until $L > $R
	__ARRAYQUICKSORT1D ( $AARRAY , $ISTART , $R )
	__ARRAYQUICKSORT1D ( $AARRAY , $L , $IEND )
EndFunc
Func __ARRAYQUICKSORT2D ( ByRef $AARRAY , Const ByRef $ISTEP , Const ByRef $ISTART , Const ByRef $IEND , Const ByRef $ISUBITEM , Const ByRef $ISUBMAX )
	If $IEND <= $ISTART Then Return
	Local $VTMP , $L = $ISTART , $R = $IEND , $VPIVOT = $AARRAY [ Int ( ( $ISTART + $IEND ) / 2 ) ] [ $ISUBITEM ] , $BNUM = IsNumber ( $VPIVOT )
	Do
		If $BNUM Then
			While ( $ISTEP * ( $AARRAY [ $L ] [ $ISUBITEM ] - $VPIVOT ) < 0 And IsNumber ( $AARRAY [ $L ] [ $ISUBITEM ] ) ) Or ( Not IsNumber ( $AARRAY [ $L ] [ $ISUBITEM ] ) And $ISTEP * StringCompare ( $AARRAY [ $L ] [ $ISUBITEM ] , $VPIVOT ) < 0 )
				$L += 1
			WEnd
			While ( $ISTEP * ( $AARRAY [ $R ] [ $ISUBITEM ] - $VPIVOT ) > 0 And IsNumber ( $AARRAY [ $R ] [ $ISUBITEM ] ) ) Or ( Not IsNumber ( $AARRAY [ $R ] [ $ISUBITEM ] ) And $ISTEP * StringCompare ( $AARRAY [ $R ] [ $ISUBITEM ] , $VPIVOT ) > 0 )
				$R -= 1
			WEnd
		Else
			While ( $ISTEP * StringCompare ( $AARRAY [ $L ] [ $ISUBITEM ] , $VPIVOT ) < 0 )
				$L += 1
			WEnd
			While ( $ISTEP * StringCompare ( $AARRAY [ $R ] [ $ISUBITEM ] , $VPIVOT ) > 0 )
				$R -= 1
			WEnd
		EndIf
		If $L <= $R Then
			For $I = 0 To $ISUBMAX
				$VTMP = $AARRAY [ $L ] [ $I ]
				$AARRAY [ $L ] [ $I ] = $AARRAY [ $R ] [ $I ]
				$AARRAY [ $R ] [ $I ] = $VTMP
			Next
			$L += 1
			$R -= 1
		EndIf
	Until $L > $R
	__ARRAYQUICKSORT2D ( $AARRAY , $ISTEP , $ISTART , $R , $ISUBITEM , $ISUBMAX )
	__ARRAYQUICKSORT2D ( $AARRAY , $ISTEP , $L , $IEND , $ISUBITEM , $ISUBMAX )
EndFunc
Func __ARRAYDUALPIVOTSORT ( ByRef $AARRAY , $IPIVOT_LEFT , $IPIVOT_RIGHT , $BLEFTMOST = True )
	If $IPIVOT_LEFT > $IPIVOT_RIGHT Then Return
	Local $ILENGTH = $IPIVOT_RIGHT - $IPIVOT_LEFT + 1
	Local $I , $J , $K , $IAI , $IAK , $IA1 , $IA2 , $ILAST
	If $ILENGTH < 45 Then
		If $BLEFTMOST Then
			$I = $IPIVOT_LEFT
			While $I < $IPIVOT_RIGHT
				$J = $I
				$IAI = $AARRAY [ $I + 1 ]
				While $IAI < $AARRAY [ $J ]
					$AARRAY [ $J + 1 ] = $AARRAY [ $J ]
					$J -= 1
					If $J + 1 = $IPIVOT_LEFT Then ExitLoop
				WEnd
				$AARRAY [ $J + 1 ] = $IAI
				$I += 1
			WEnd
		Else
			While 1
				If $IPIVOT_LEFT >= $IPIVOT_RIGHT Then Return 1
				$IPIVOT_LEFT += 1
				If $AARRAY [ $IPIVOT_LEFT ] < $AARRAY [ $IPIVOT_LEFT + 4294967295 ] Then ExitLoop
			WEnd
			While 1
				$K = $IPIVOT_LEFT
				$IPIVOT_LEFT += 1
				If $IPIVOT_LEFT > $IPIVOT_RIGHT Then ExitLoop
				$IA1 = $AARRAY [ $K ]
				$IA2 = $AARRAY [ $IPIVOT_LEFT ]
				If $IA1 < $IA2 Then
					$IA2 = $IA1
					$IA1 = $AARRAY [ $IPIVOT_LEFT ]
				EndIf
				$K -= 1
				While $IA1 < $AARRAY [ $K ]
					$AARRAY [ $K + 2 ] = $AARRAY [ $K ]
					$K -= 1
				WEnd
				$AARRAY [ $K + 2 ] = $IA1
				While $IA2 < $AARRAY [ $K ]
					$AARRAY [ $K + 1 ] = $AARRAY [ $K ]
					$K -= 1
				WEnd
				$AARRAY [ $K + 1 ] = $IA2
				$IPIVOT_LEFT += 1
			WEnd
			$ILAST = $AARRAY [ $IPIVOT_RIGHT ]
			$IPIVOT_RIGHT -= 1
			While $ILAST < $AARRAY [ $IPIVOT_RIGHT ]
				$AARRAY [ $IPIVOT_RIGHT + 1 ] = $AARRAY [ $IPIVOT_RIGHT ]
				$IPIVOT_RIGHT -= 1
			WEnd
			$AARRAY [ $IPIVOT_RIGHT + 1 ] = $ILAST
		EndIf
		Return 1
	EndIf
	Local $ISEVENTH = BitShift ( $ILENGTH , 3 ) + BitShift ( $ILENGTH , 6 ) + 1
	Local $IE1 , $IE2 , $IE3 , $IE4 , $IE5 , $T
	$IE3 = Ceiling ( ( $IPIVOT_LEFT + $IPIVOT_RIGHT ) / 2 )
	$IE2 = $IE3 - $ISEVENTH
	$IE1 = $IE2 - $ISEVENTH
	$IE4 = $IE3 + $ISEVENTH
	$IE5 = $IE4 + $ISEVENTH
	If $AARRAY [ $IE2 ] < $AARRAY [ $IE1 ] Then
		$T = $AARRAY [ $IE2 ]
		$AARRAY [ $IE2 ] = $AARRAY [ $IE1 ]
		$AARRAY [ $IE1 ] = $T
	EndIf
	If $AARRAY [ $IE3 ] < $AARRAY [ $IE2 ] Then
		$T = $AARRAY [ $IE3 ]
		$AARRAY [ $IE3 ] = $AARRAY [ $IE2 ]
		$AARRAY [ $IE2 ] = $T
		If $T < $AARRAY [ $IE1 ] Then
			$AARRAY [ $IE2 ] = $AARRAY [ $IE1 ]
			$AARRAY [ $IE1 ] = $T
		EndIf
	EndIf
	If $AARRAY [ $IE4 ] < $AARRAY [ $IE3 ] Then
		$T = $AARRAY [ $IE4 ]
		$AARRAY [ $IE4 ] = $AARRAY [ $IE3 ]
		$AARRAY [ $IE3 ] = $T
		If $T < $AARRAY [ $IE2 ] Then
			$AARRAY [ $IE3 ] = $AARRAY [ $IE2 ]
			$AARRAY [ $IE2 ] = $T
			If $T < $AARRAY [ $IE1 ] Then
				$AARRAY [ $IE2 ] = $AARRAY [ $IE1 ]
				$AARRAY [ $IE1 ] = $T
			EndIf
		EndIf
	EndIf
	If $AARRAY [ $IE5 ] < $AARRAY [ $IE4 ] Then
		$T = $AARRAY [ $IE5 ]
		$AARRAY [ $IE5 ] = $AARRAY [ $IE4 ]
		$AARRAY [ $IE4 ] = $T
		If $T < $AARRAY [ $IE3 ] Then
			$AARRAY [ $IE4 ] = $AARRAY [ $IE3 ]
			$AARRAY [ $IE3 ] = $T
			If $T < $AARRAY [ $IE2 ] Then
				$AARRAY [ $IE3 ] = $AARRAY [ $IE2 ]
				$AARRAY [ $IE2 ] = $T
				If $T < $AARRAY [ $IE1 ] Then
					$AARRAY [ $IE2 ] = $AARRAY [ $IE1 ]
					$AARRAY [ $IE1 ] = $T
				EndIf
			EndIf
		EndIf
	EndIf
	Local $ILESS = $IPIVOT_LEFT
	Local $IGREATER = $IPIVOT_RIGHT
	If ( ( $AARRAY [ $IE1 ] <> $AARRAY [ $IE2 ] ) And ( $AARRAY [ $IE2 ] <> $AARRAY [ $IE3 ] ) And ( $AARRAY [ $IE3 ] <> $AARRAY [ $IE4 ] ) And ( $AARRAY [ $IE4 ] <> $AARRAY [ $IE5 ] ) ) Then
		Local $IPIVOT_1 = $AARRAY [ $IE2 ]
		Local $IPIVOT_2 = $AARRAY [ $IE4 ]
		$AARRAY [ $IE2 ] = $AARRAY [ $IPIVOT_LEFT ]
		$AARRAY [ $IE4 ] = $AARRAY [ $IPIVOT_RIGHT ]
		Do
			$ILESS += 1
		Until $AARRAY [ $ILESS ] >= $IPIVOT_1
		Do
			$IGREATER -= 1
		Until $AARRAY [ $IGREATER ] <= $IPIVOT_2
		$K = $ILESS
		While $K <= $IGREATER
			$IAK = $AARRAY [ $K ]
			If $IAK < $IPIVOT_1 Then
				$AARRAY [ $K ] = $AARRAY [ $ILESS ]
				$AARRAY [ $ILESS ] = $IAK
				$ILESS += 1
			ElseIf $IAK > $IPIVOT_2 Then
				While $AARRAY [ $IGREATER ] > $IPIVOT_2
					$IGREATER -= 1
					If $IGREATER + 1 = $K Then ExitLoop 2
				WEnd
				If $AARRAY [ $IGREATER ] < $IPIVOT_1 Then
					$AARRAY [ $K ] = $AARRAY [ $ILESS ]
					$AARRAY [ $ILESS ] = $AARRAY [ $IGREATER ]
					$ILESS += 1
				Else
					$AARRAY [ $K ] = $AARRAY [ $IGREATER ]
				EndIf
				$AARRAY [ $IGREATER ] = $IAK
				$IGREATER -= 1
			EndIf
			$K += 1
		WEnd
		$AARRAY [ $IPIVOT_LEFT ] = $AARRAY [ $ILESS + 4294967295 ]
		$AARRAY [ $ILESS + 4294967295 ] = $IPIVOT_1
		$AARRAY [ $IPIVOT_RIGHT ] = $AARRAY [ $IGREATER + 1 ]
		$AARRAY [ $IGREATER + 1 ] = $IPIVOT_2
		__ARRAYDUALPIVOTSORT ( $AARRAY , $IPIVOT_LEFT , $ILESS + 4294967294 , True )
		__ARRAYDUALPIVOTSORT ( $AARRAY , $IGREATER + 2 , $IPIVOT_RIGHT , False )
		If ( $ILESS < $IE1 ) And ( $IE5 < $IGREATER ) Then
			While $AARRAY [ $ILESS ] = $IPIVOT_1
				$ILESS += 1
			WEnd
			While $AARRAY [ $IGREATER ] = $IPIVOT_2
				$IGREATER -= 1
			WEnd
			$K = $ILESS
			While $K <= $IGREATER
				$IAK = $AARRAY [ $K ]
				If $IAK = $IPIVOT_1 Then
					$AARRAY [ $K ] = $AARRAY [ $ILESS ]
					$AARRAY [ $ILESS ] = $IAK
					$ILESS += 1
				ElseIf $IAK = $IPIVOT_2 Then
					While $AARRAY [ $IGREATER ] = $IPIVOT_2
						$IGREATER -= 1
						If $IGREATER + 1 = $K Then ExitLoop 2
					WEnd
					If $AARRAY [ $IGREATER ] = $IPIVOT_1 Then
						$AARRAY [ $K ] = $AARRAY [ $ILESS ]
						$AARRAY [ $ILESS ] = $IPIVOT_1
						$ILESS += 1
					Else
						$AARRAY [ $K ] = $AARRAY [ $IGREATER ]
					EndIf
					$AARRAY [ $IGREATER ] = $IAK
					$IGREATER -= 1
				EndIf
				$K += 1
			WEnd
		EndIf
		__ARRAYDUALPIVOTSORT ( $AARRAY , $ILESS , $IGREATER , False )
	Else
		Local $IPIVOT = $AARRAY [ $IE3 ]
		$K = $ILESS
		While $K <= $IGREATER
			If $AARRAY [ $K ] = $IPIVOT Then
				$K += 1
				ContinueLoop
			EndIf
			$IAK = $AARRAY [ $K ]
			If $IAK < $IPIVOT Then
				$AARRAY [ $K ] = $AARRAY [ $ILESS ]
				$AARRAY [ $ILESS ] = $IAK
				$ILESS += 1
			Else
				While $AARRAY [ $IGREATER ] > $IPIVOT
					$IGREATER -= 1
				WEnd
				If $AARRAY [ $IGREATER ] < $IPIVOT Then
					$AARRAY [ $K ] = $AARRAY [ $ILESS ]
					$AARRAY [ $ILESS ] = $AARRAY [ $IGREATER ]
					$ILESS += 1
				Else
					$AARRAY [ $K ] = $IPIVOT
				EndIf
				$AARRAY [ $IGREATER ] = $IAK
				$IGREATER -= 1
			EndIf
			$K += 1
		WEnd
		__ARRAYDUALPIVOTSORT ( $AARRAY , $IPIVOT_LEFT , $ILESS + 4294967295 , True )
		__ARRAYDUALPIVOTSORT ( $AARRAY , $IGREATER + 1 , $IPIVOT_RIGHT , False )
	EndIf
EndFunc
Func _ARRAYTOSTRING ( Const ByRef $AARRAY , $SDELIM_COL = "|" , $ISTART_ROW = Default , $IEND_ROW = Default , $SDELIM_ROW = @CRLF , $ISTART_COL = Default , $IEND_COL = Default )
	If $SDELIM_COL = Default Then $SDELIM_COL = "|"
	If $SDELIM_ROW = Default Then $SDELIM_ROW = @CRLF
	If $ISTART_ROW = Default Then $ISTART_ROW = + 4294967295
	If $IEND_ROW = Default Then $IEND_ROW = + 4294967295
	If $ISTART_COL = Default Then $ISTART_COL = + 4294967295
	If $IEND_COL = Default Then $IEND_COL = + 4294967295
	If Not IsArray ( $AARRAY ) Then Return SetError ( 1 , 0 , + 4294967295 )
	Local $IDIM_1 = UBound ( $AARRAY , 1 ) + 4294967295
	If $IDIM_1 = + 4294967295 Then Return ""
	If $ISTART_ROW = + 4294967295 Then $ISTART_ROW = 0
	If $IEND_ROW = + 4294967295 Then $IEND_ROW = $IDIM_1
	If $ISTART_ROW < + 4294967295 Or $IEND_ROW < + 4294967295 Then Return SetError ( 3 , 0 , + 4294967295 )
	If $ISTART_ROW > $IDIM_1 Or $IEND_ROW > $IDIM_1 Then Return SetError ( 3 , 0 , "" )
	If $ISTART_ROW > $IEND_ROW Then Return SetError ( 4 , 0 , + 4294967295 )
	Local $SRET = ""
	Switch UBound ( $AARRAY , 0 )
	Case 1
		For $I = $ISTART_ROW To $IEND_ROW
			$SRET &= $AARRAY [ $I ] & $SDELIM_COL
		Next
		Return StringTrimRight ( $SRET , StringLen ( $SDELIM_COL ) )
	Case 2
		Local $IDIM_2 = UBound ( $AARRAY , 2 ) + 4294967295
		If $IDIM_2 = + 4294967295 Then Return ""
		If $ISTART_COL = + 4294967295 Then $ISTART_COL = 0
		If $IEND_COL = + 4294967295 Then $IEND_COL = $IDIM_2
		If $ISTART_COL < + 4294967295 Or $IEND_COL < + 4294967295 Then Return SetError ( 5 , 0 , + 4294967295 )
		If $ISTART_COL > $IDIM_2 Or $IEND_COL > $IDIM_2 Then Return SetError ( 5 , 0 , + 4294967295 )
		If $ISTART_COL > $IEND_COL Then Return SetError ( 6 , 0 , + 4294967295 )
		Local $IDELIMCOLLEN = StringLen ( $SDELIM_COL )
		For $I = $ISTART_ROW To $IEND_ROW
			For $J = $ISTART_COL To $IEND_COL
				$SRET &= $AARRAY [ $I ] [ $J ] & $SDELIM_COL
			Next
			$SRET = StringTrimRight ( $SRET , $IDELIMCOLLEN ) & $SDELIM_ROW
		Next
		Return StringTrimRight ( $SRET , StringLen ( $SDELIM_ROW ) )
Case Else
		Return SetError ( 2 , 0 , + 4294967295 )
	EndSwitch
	Return 1
EndFunc
Func _ARRAYUNIQUE ( Const ByRef $AARRAY , $ICOLUMN = 0 , $IBASE = 0 , $ICASE = 0 , $ICOUNT = $ARRAYUNIQUE_COUNT , $IINTTYPE = $ARRAYUNIQUE_AUTO )
	If $ICOLUMN = Default Then $ICOLUMN = 0
	If $IBASE = Default Then $IBASE = 0
	If $ICASE = Default Then $ICASE = 0
	If $ICOUNT = Default Then $ICOUNT = $ARRAYUNIQUE_COUNT
	If $IINTTYPE = Default Then $IINTTYPE = $ARRAYUNIQUE_AUTO
	If UBound ( $AARRAY , 1 ) = 0 Then Return SetError ( 1 , 0 , 0 )
	Local $IDIMS = UBound ( $AARRAY , 0 ) , $INUMCOLUMNS = UBound ( $AARRAY , 2 )
	If $IDIMS > 2 Then Return SetError ( 2 , 0 , 0 )
	If $IBASE < 0 Or $IBASE > 1 Or ( Not IsInt ( $IBASE ) ) Then Return SetError ( 3 , 0 , 0 )
	If $ICASE < 0 Or $ICASE > 1 Or ( Not IsInt ( $ICASE ) ) Then Return SetError ( 3 , 0 , 0 )
	If $ICOUNT < 0 Or $ICOUNT > 1 Or ( Not IsInt ( $ICOUNT ) ) Then Return SetError ( 4 , 0 , 0 )
	If $IINTTYPE < 0 Or $IINTTYPE > 4 Or ( Not IsInt ( $IINTTYPE ) ) Then Return SetError ( 5 , 0 , 0 )
	If $ICOLUMN < 0 Or ( $INUMCOLUMNS = 0 And $ICOLUMN > 0 ) Or ( $INUMCOLUMNS > 0 And $ICOLUMN >= $INUMCOLUMNS ) Then Return SetError ( 6 , 0 , 0 )
	If $IINTTYPE = $ARRAYUNIQUE_AUTO Then
		Local $BINT , $SVARTYPE
		If $IDIMS = 1 Then
			$BINT = IsInt ( $AARRAY [ $IBASE ] )
			$SVARTYPE = VarGetType ( $AARRAY [ $IBASE ] )
		Else
			$BINT = IsInt ( $AARRAY [ $IBASE ] [ $ICOLUMN ] )
			$SVARTYPE = VarGetType ( $AARRAY [ $IBASE ] [ $ICOLUMN ] )
		EndIf
		If $BINT And $SVARTYPE = "Int64" Then
			$IINTTYPE = $ARRAYUNIQUE_FORCE64
		Else
			$IINTTYPE = $ARRAYUNIQUE_FORCE32
		EndIf
	EndIf
	ObjEvent ( "AutoIt.Error" , __ARRAYUNIQUE_AUTOERRFUNC )
	Local $ODICTIONARY = ObjCreate ( "Scripting.Dictionary" )
	$ODICTIONARY .CompareMode = Number ( Not $ICASE )
	Local $VELEM , $STYPE , $VKEY , $BCOMERROR = False
	For $I = $IBASE To UBound ( $AARRAY ) + 4294967295
		If $IDIMS = 1 Then
			$VELEM = $AARRAY [ $I ]
		Else
			$VELEM = $AARRAY [ $I ] [ $ICOLUMN ]
		EndIf
		Switch $IINTTYPE
		Case $ARRAYUNIQUE_FORCE32
			$ODICTIONARY .Item ( $VELEM )
			If @error Then
				$BCOMERROR = True
				ExitLoop
			EndIf
		Case $ARRAYUNIQUE_FORCE64
			$STYPE = VarGetType ( $VELEM )
			If $STYPE = "Int32" Then
				$BCOMERROR = True
				ExitLoop
			EndIf
			$VKEY = "#" & $STYPE & "#" & String ( $VELEM )
			If Not $ODICTIONARY .Item ( $VKEY ) Then
				$ODICTIONARY ( $VKEY ) = $VELEM
			EndIf
		Case $ARRAYUNIQUE_MATCH
			$STYPE = VarGetType ( $VELEM )
			If StringLeft ( $STYPE , 3 ) = "Int" Then
				$VKEY = "#Int#" & String ( $VELEM )
			Else
				$VKEY = "#" & $STYPE & "#" & String ( $VELEM )
			EndIf
			If Not $ODICTIONARY .Item ( $VKEY ) Then
				$ODICTIONARY ( $VKEY ) = $VELEM
			EndIf
		Case $ARRAYUNIQUE_DISTINCT
			$VKEY = "#" & VarGetType ( $VELEM ) & "#" & String ( $VELEM )
			If Not $ODICTIONARY .Item ( $VKEY ) Then
				$ODICTIONARY ( $VKEY ) = $VELEM
			EndIf
		EndSwitch
	Next
	Local $AVALUES , $J = 0
	If $BCOMERROR Then
		Return SetError ( 7 , 0 , 0 )
	ElseIf $IINTTYPE <> $ARRAYUNIQUE_FORCE32 Then
		Local $AVALUES [ $ODICTIONARY .Count ]
		For $VKEY In $ODICTIONARY .Keys ( )
			$AVALUES [ $J ] = $ODICTIONARY ( $VKEY )
			If StringLeft ( $VKEY , 5 ) = "#Ptr#" Then
				$AVALUES [ $J ] = Ptr ( $AVALUES [ $J ] )
			EndIf
			$J += 1
		Next
	Else
		$AVALUES = $ODICTIONARY .Keys ( )
	EndIf
	If $ICOUNT Then
		_ARRAYINSERT ( $AVALUES , 0 , $ODICTIONARY .Count )
	EndIf
	Return $AVALUES
EndFunc
Func __ARRAYUNIQUE_AUTOERRFUNC ( )
EndFunc
Func _FILELISTTOARRAY ( $SFILEPATH , $SFILTER = "*" , $IFLAG = 0 , $BRETURNPATH = False )
	Local $SDELIMITER = "|" , $SFILELIST = "" , $SFILENAME = "" , $SFULLPATH = ""
	$SFILEPATH = StringRegExpReplace ( $SFILEPATH , "[\\/]+$" , "" ) & "\"
	If $IFLAG = Default Then $IFLAG = 0
	If $BRETURNPATH Then $SFULLPATH = $SFILEPATH
	If $SFILTER = Default Then $SFILTER = "*"
	If Not FileExists ( $SFILEPATH ) Then Return SetError ( 1 , 0 , 0 )
	If StringRegExp ( $SFILTER , "[\\/:><\|]|(?s)^\s*$" ) Then Return SetError ( 2 , 0 , 0 )
	If Not ( $IFLAG = 0 Or $IFLAG = 1 Or $IFLAG = 2 ) Then Return SetError ( 3 , 0 , 0 )
	Local $HSEARCH = FileFindFirstFile ( $SFILEPATH & $SFILTER )
	If @error Then Return SetError ( 4 , 0 , 0 )
	While 1
		$SFILENAME = FileFindNextFile ( $HSEARCH )
		If @error Then ExitLoop
		If ( $IFLAG + @extended = 2 ) Then ContinueLoop
		$SFILELIST &= $SDELIMITER & $SFULLPATH & $SFILENAME
	WEnd
	FileClose ( $HSEARCH )
	If $SFILELIST = "" Then Return SetError ( 4 , 0 , 0 )
	Return StringSplit ( StringTrimLeft ( $SFILELIST , 1 ) , $SDELIMITER )
EndFunc
Func _FILELISTTOARRAYREC ( $SFILEPATH , $SMASK = "*" , $IRETURN = 0 , $IRECUR = 0 , $ISORT = 0 , $IRETURNPATH = 1 )
	If Not FileExists ( $SFILEPATH ) Then Return SetError ( 1 , 1 , "" )
	If $SMASK = Default Then $SMASK = "*"
	If $IRETURN = Default Then $IRETURN = 0
	If $IRECUR = Default Then $IRECUR = 0
	If $ISORT = Default Then $ISORT = 0
	If $IRETURNPATH = Default Then $IRETURNPATH = 1
	If $IRECUR > 1 Or Not IsInt ( $IRECUR ) Then Return SetError ( 1 , 6 , "" )
	Local $BLONGPATH = False
	If StringLeft ( $SFILEPATH , 4 ) == "\\?\" Then
		$BLONGPATH = True
	EndIf
	Local $SFOLDERSLASH = ""
	If StringRight ( $SFILEPATH , 1 ) = "\" Then
		$SFOLDERSLASH = "\"
	Else
		$SFILEPATH = $SFILEPATH & "\"
	EndIf
	Local $ASFOLDERSEARCHLIST [ 100 ] = [ 1 ]
	$ASFOLDERSEARCHLIST [ 1 ] = $SFILEPATH
	Local $IHIDE_HS = 0 , $SHIDE_HS = ""
	If BitAND ( $IRETURN , 4 ) Then
		$IHIDE_HS += 2
		$SHIDE_HS &= "H"
		$IRETURN -= 4
	EndIf
	If BitAND ( $IRETURN , 8 ) Then
		$IHIDE_HS += 4
		$SHIDE_HS &= "S"
		$IRETURN -= 8
	EndIf
	Local $IHIDE_LINK = 0
	If BitAND ( $IRETURN , 16 ) Then
		$IHIDE_LINK = 1024
		$IRETURN -= 16
	EndIf
	Local $IMAXLEVEL = 0
	If $IRECUR < 0 Then
		StringReplace ( $SFILEPATH , "\" , "" , 0 , 2 )
		$IMAXLEVEL = @extended - $IRECUR
	EndIf
	Local $SEXCLUDE_LIST = "" , $SEXCLUDE_LIST_FOLDER = "" , $SINCLUDE_LIST = "*"
	Local $AMASKSPLIT = StringSplit ( $SMASK , "|" )
	Switch $AMASKSPLIT [ 0 ]
	Case 3
		$SEXCLUDE_LIST_FOLDER = $AMASKSPLIT [ 3 ]
		ContinueCase
	Case 2
		$SEXCLUDE_LIST = $AMASKSPLIT [ 2 ]
		ContinueCase
	Case 1
		$SINCLUDE_LIST = $AMASKSPLIT [ 1 ]
	EndSwitch
	Local $SINCLUDE_FILE_MASK = ".+"
	If $SINCLUDE_LIST <> "*" Then
		If Not __FLTAR_LISTTOMASK ( $SINCLUDE_FILE_MASK , $SINCLUDE_LIST ) Then Return SetError ( 1 , 2 , "" )
	EndIf
	Local $SINCLUDE_FOLDER_MASK = ".+"
	Switch $IRETURN
	Case 0
		Switch $IRECUR
		Case 0
			$SINCLUDE_FOLDER_MASK = $SINCLUDE_FILE_MASK
		EndSwitch
	Case 2
		$SINCLUDE_FOLDER_MASK = $SINCLUDE_FILE_MASK
	EndSwitch
	Local $SEXCLUDE_FILE_MASK = ":"
	If $SEXCLUDE_LIST <> "" Then
		If Not __FLTAR_LISTTOMASK ( $SEXCLUDE_FILE_MASK , $SEXCLUDE_LIST ) Then Return SetError ( 1 , 3 , "" )
	EndIf
	Local $SEXCLUDE_FOLDER_MASK = ":"
	If $IRECUR Then
		If $SEXCLUDE_LIST_FOLDER Then
			If Not __FLTAR_LISTTOMASK ( $SEXCLUDE_FOLDER_MASK , $SEXCLUDE_LIST_FOLDER ) Then Return SetError ( 1 , 4 , "" )
		EndIf
		If $IRETURN = 2 Then
			$SEXCLUDE_FOLDER_MASK = $SEXCLUDE_FILE_MASK
		EndIf
	Else
		$SEXCLUDE_FOLDER_MASK = $SEXCLUDE_FILE_MASK
	EndIf
	If Not ( $IRETURN = 0 Or $IRETURN = 1 Or $IRETURN = 2 ) Then Return SetError ( 1 , 5 , "" )
	If Not ( $ISORT = 0 Or $ISORT = 1 Or $ISORT = 2 ) Then Return SetError ( 1 , 7 , "" )
	If Not ( $IRETURNPATH = 0 Or $IRETURNPATH = 1 Or $IRETURNPATH = 2 ) Then Return SetError ( 1 , 8 , "" )
	If $IHIDE_LINK Then
		Local $TFILE_DATA = DllStructCreate ( "struct;align 4;dword FileAttributes;uint64 CreationTime;uint64 LastAccessTime;uint64 LastWriteTime;" & "dword FileSizeHigh;dword FileSizeLow;dword Reserved0;dword Reserved1;wchar FileName[260];wchar AlternateFileName[14];endstruct" )
		Local $HDLL = DllOpen ( "kernel32.dll" ) , $ADLL_RET
	EndIf
	Local $ASRETURNLIST [ 100 ] = [ 0 ]
	Local $ASFILEMATCHLIST = $ASRETURNLIST , $ASROOTFILEMATCHLIST = $ASRETURNLIST , $ASFOLDERMATCHLIST = $ASRETURNLIST
	Local $BFOLDER = False , $HSEARCH = 0 , $SCURRENTPATH = "" , $SNAME = "" , $SRETPATH = ""
	Local $IATTRIBS = 0 , $SATTRIBS = ""
	Local $ASFOLDERFILESECTIONLIST [ 100 ] [ 2 ] = [ [ 0 , 0 ] ]
	While $ASFOLDERSEARCHLIST [ 0 ] > 0
		$SCURRENTPATH = $ASFOLDERSEARCHLIST [ $ASFOLDERSEARCHLIST [ 0 ] ]
		$ASFOLDERSEARCHLIST [ 0 ] -= 1
		Switch $IRETURNPATH
		Case 1
			$SRETPATH = StringReplace ( $SCURRENTPATH , $SFILEPATH , "" )
		Case 2
			If $BLONGPATH Then
				$SRETPATH = StringTrimLeft ( $SCURRENTPATH , 4 )
			Else
				$SRETPATH = $SCURRENTPATH
			EndIf
		EndSwitch
		If $IHIDE_LINK Then
			$ADLL_RET = DllCall ( $HDLL , "handle" , "FindFirstFileW" , "wstr" , $SCURRENTPATH & "*" , "struct*" , $TFILE_DATA )
			If @error Or Not $ADLL_RET [ 0 ] Then
				ContinueLoop
			EndIf
			$HSEARCH = $ADLL_RET [ 0 ]
		Else
			$HSEARCH = FileFindFirstFile ( $SCURRENTPATH & "*" )
			If $HSEARCH = + 4294967295 Then
				ContinueLoop
			EndIf
		EndIf
		If $IRETURN = 0 And $ISORT And $IRETURNPATH Then
			__FLTAR_ADDTOLIST ( $ASFOLDERFILESECTIONLIST , $SRETPATH , $ASFILEMATCHLIST [ 0 ] + 1 )
		EndIf
		$SATTRIBS = ""
		While 1
			If $IHIDE_LINK Then
				$ADLL_RET = DllCall ( $HDLL , "int" , "FindNextFileW" , "handle" , $HSEARCH , "struct*" , $TFILE_DATA )
				If @error Or Not $ADLL_RET [ 0 ] Then
					ExitLoop
				EndIf
				$SNAME = DllStructGetData ( $TFILE_DATA , "FileName" )
				If $SNAME = ".." Or $SNAME = "." Then
					ContinueLoop
				EndIf
				$IATTRIBS = DllStructGetData ( $TFILE_DATA , "FileAttributes" )
				If $IHIDE_HS And BitAND ( $IATTRIBS , $IHIDE_HS ) Then
					ContinueLoop
				EndIf
				If BitAND ( $IATTRIBS , $IHIDE_LINK ) Then
					ContinueLoop
				EndIf
				$BFOLDER = False
				If BitAND ( $IATTRIBS , 16 ) Then
					$BFOLDER = True
				EndIf
			Else
				$BFOLDER = False
				$SNAME = FileFindNextFile ( $HSEARCH , 1 )
				If @error Then
					ExitLoop
				EndIf
				If $SNAME = ".." Or $SNAME = "." Then
					ContinueLoop
				EndIf
				$SATTRIBS = @extended
				If StringInStr ( $SATTRIBS , "D" ) Then
					$BFOLDER = True
				EndIf
				If StringRegExp ( $SATTRIBS , "[" & $SHIDE_HS & "]" ) Then
					ContinueLoop
				EndIf
			EndIf
			If $BFOLDER Then
				Select
				Case $IRECUR < 0
					StringReplace ( $SCURRENTPATH , "\" , "" , 0 , 2 )
					If @extended < $IMAXLEVEL Then
						ContinueCase
					EndIf
				Case $IRECUR = 1
					If Not StringRegExp ( $SNAME , $SEXCLUDE_FOLDER_MASK ) Then
						__FLTAR_ADDTOLIST ( $ASFOLDERSEARCHLIST , $SCURRENTPATH & $SNAME & "\" )
					EndIf
				EndSelect
			EndIf
			If $ISORT Then
				If $BFOLDER Then
					If StringRegExp ( $SNAME , $SINCLUDE_FOLDER_MASK ) And Not StringRegExp ( $SNAME , $SEXCLUDE_FOLDER_MASK ) Then
						__FLTAR_ADDTOLIST ( $ASFOLDERMATCHLIST , $SRETPATH & $SNAME & $SFOLDERSLASH )
					EndIf
				Else
					If StringRegExp ( $SNAME , $SINCLUDE_FILE_MASK ) And Not StringRegExp ( $SNAME , $SEXCLUDE_FILE_MASK ) Then
						If $SCURRENTPATH = $SFILEPATH Then
							__FLTAR_ADDTOLIST ( $ASROOTFILEMATCHLIST , $SRETPATH & $SNAME )
						Else
							__FLTAR_ADDTOLIST ( $ASFILEMATCHLIST , $SRETPATH & $SNAME )
						EndIf
					EndIf
				EndIf
			Else
				If $BFOLDER Then
					If $IRETURN <> 1 And StringRegExp ( $SNAME , $SINCLUDE_FOLDER_MASK ) And Not StringRegExp ( $SNAME , $SEXCLUDE_FOLDER_MASK ) Then
						__FLTAR_ADDTOLIST ( $ASRETURNLIST , $SRETPATH & $SNAME & $SFOLDERSLASH )
					EndIf
				Else
					If $IRETURN <> 2 And StringRegExp ( $SNAME , $SINCLUDE_FILE_MASK ) And Not StringRegExp ( $SNAME , $SEXCLUDE_FILE_MASK ) Then
						__FLTAR_ADDTOLIST ( $ASRETURNLIST , $SRETPATH & $SNAME )
					EndIf
				EndIf
			EndIf
		WEnd
		If $IHIDE_LINK Then
			DllCall ( $HDLL , "int" , "FindClose" , "ptr" , $HSEARCH )
		Else
			FileClose ( $HSEARCH )
		EndIf
	WEnd
	If $IHIDE_LINK Then
		DllClose ( $HDLL )
	EndIf
	If $ISORT Then
		Switch $IRETURN
		Case 2
			If $ASFOLDERMATCHLIST [ 0 ] = 0 Then Return SetError ( 1 , 9 , "" )
			ReDim $ASFOLDERMATCHLIST [ $ASFOLDERMATCHLIST [ 0 ] + 1 ]
			$ASRETURNLIST = $ASFOLDERMATCHLIST
			__ARRAYDUALPIVOTSORT ( $ASRETURNLIST , 1 , $ASRETURNLIST [ 0 ] )
		Case 1
			If $ASROOTFILEMATCHLIST [ 0 ] = 0 And $ASFILEMATCHLIST [ 0 ] = 0 Then Return SetError ( 1 , 9 , "" )
			If $IRETURNPATH = 0 Then
				__FLTAR_ADDFILELISTS ( $ASRETURNLIST , $ASROOTFILEMATCHLIST , $ASFILEMATCHLIST )
				__ARRAYDUALPIVOTSORT ( $ASRETURNLIST , 1 , $ASRETURNLIST [ 0 ] )
			Else
				__FLTAR_ADDFILELISTS ( $ASRETURNLIST , $ASROOTFILEMATCHLIST , $ASFILEMATCHLIST , 1 )
			EndIf
		Case 0
			If $ASROOTFILEMATCHLIST [ 0 ] = 0 And $ASFOLDERMATCHLIST [ 0 ] = 0 Then Return SetError ( 1 , 9 , "" )
			If $IRETURNPATH = 0 Then
				__FLTAR_ADDFILELISTS ( $ASRETURNLIST , $ASROOTFILEMATCHLIST , $ASFILEMATCHLIST )
				$ASRETURNLIST [ 0 ] += $ASFOLDERMATCHLIST [ 0 ]
				ReDim $ASFOLDERMATCHLIST [ $ASFOLDERMATCHLIST [ 0 ] + 1 ]
				_ARRAYCONCATENATE ( $ASRETURNLIST , $ASFOLDERMATCHLIST , 1 )
				__ARRAYDUALPIVOTSORT ( $ASRETURNLIST , 1 , $ASRETURNLIST [ 0 ] )
			Else
				Local $ASRETURNLIST [ $ASFILEMATCHLIST [ 0 ] + $ASROOTFILEMATCHLIST [ 0 ] + $ASFOLDERMATCHLIST [ 0 ] + 1 ]
				$ASRETURNLIST [ 0 ] = $ASFILEMATCHLIST [ 0 ] + $ASROOTFILEMATCHLIST [ 0 ] + $ASFOLDERMATCHLIST [ 0 ]
				__ARRAYDUALPIVOTSORT ( $ASROOTFILEMATCHLIST , 1 , $ASROOTFILEMATCHLIST [ 0 ] )
				For $I = 1 To $ASROOTFILEMATCHLIST [ 0 ]
					$ASRETURNLIST [ $I ] = $ASROOTFILEMATCHLIST [ $I ]
				Next
				Local $INEXTINSERTIONINDEX = $ASROOTFILEMATCHLIST [ 0 ] + 1
				__ARRAYDUALPIVOTSORT ( $ASFOLDERMATCHLIST , 1 , $ASFOLDERMATCHLIST [ 0 ] )
				Local $SFOLDERTOFIND = ""
				For $I = 1 To $ASFOLDERMATCHLIST [ 0 ]
					$ASRETURNLIST [ $INEXTINSERTIONINDEX ] = $ASFOLDERMATCHLIST [ $I ]
					$INEXTINSERTIONINDEX += 1
					If $SFOLDERSLASH Then
						$SFOLDERTOFIND = $ASFOLDERMATCHLIST [ $I ]
					Else
						$SFOLDERTOFIND = $ASFOLDERMATCHLIST [ $I ] & "\"
					EndIf
					Local $IFILESECTIONENDINDEX = 0 , $IFILESECTIONSTARTINDEX = 0
					For $J = 1 To $ASFOLDERFILESECTIONLIST [ 0 ] [ 0 ]
						If $SFOLDERTOFIND = $ASFOLDERFILESECTIONLIST [ $J ] [ 0 ] Then
							$IFILESECTIONSTARTINDEX = $ASFOLDERFILESECTIONLIST [ $J ] [ 1 ]
							If $J = $ASFOLDERFILESECTIONLIST [ 0 ] [ 0 ] Then
								$IFILESECTIONENDINDEX = $ASFILEMATCHLIST [ 0 ]
							Else
								$IFILESECTIONENDINDEX = $ASFOLDERFILESECTIONLIST [ $J + 1 ] [ 1 ] + 4294967295
							EndIf
							If $ISORT = 1 Then
								__ARRAYDUALPIVOTSORT ( $ASFILEMATCHLIST , $IFILESECTIONSTARTINDEX , $IFILESECTIONENDINDEX )
							EndIf
							For $K = $IFILESECTIONSTARTINDEX To $IFILESECTIONENDINDEX
								$ASRETURNLIST [ $INEXTINSERTIONINDEX ] = $ASFILEMATCHLIST [ $K ]
								$INEXTINSERTIONINDEX += 1
							Next
							ExitLoop
						EndIf
					Next
				Next
			EndIf
		EndSwitch
	Else
		If $ASRETURNLIST [ 0 ] = 0 Then Return SetError ( 1 , 9 , "" )
		ReDim $ASRETURNLIST [ $ASRETURNLIST [ 0 ] + 1 ]
	EndIf
	Return $ASRETURNLIST
EndFunc
Func __FLTAR_ADDFILELISTS ( ByRef $ASTARGET , $ASSOURCE_1 , $ASSOURCE_2 , $ISORT = 0 )
	ReDim $ASSOURCE_1 [ $ASSOURCE_1 [ 0 ] + 1 ]
	If $ISORT = 1 Then __ARRAYDUALPIVOTSORT ( $ASSOURCE_1 , 1 , $ASSOURCE_1 [ 0 ] )
	$ASTARGET = $ASSOURCE_1
	$ASTARGET [ 0 ] += $ASSOURCE_2 [ 0 ]
	ReDim $ASSOURCE_2 [ $ASSOURCE_2 [ 0 ] + 1 ]
	If $ISORT = 1 Then __ARRAYDUALPIVOTSORT ( $ASSOURCE_2 , 1 , $ASSOURCE_2 [ 0 ] )
	_ARRAYCONCATENATE ( $ASTARGET , $ASSOURCE_2 , 1 )
EndFunc
Func __FLTAR_ADDTOLIST ( ByRef $ALIST , $VVALUE_0 , $VVALUE_1 = + 4294967295 )
	If $VVALUE_1 = + 4294967295 Then
		$ALIST [ 0 ] += 1
		If UBound ( $ALIST ) <= $ALIST [ 0 ] Then ReDim $ALIST [ UBound ( $ALIST ) * 2 ]
		$ALIST [ $ALIST [ 0 ] ] = $VVALUE_0
	Else
		$ALIST [ 0 ] [ 0 ] += 1
		If UBound ( $ALIST ) <= $ALIST [ 0 ] [ 0 ] Then ReDim $ALIST [ UBound ( $ALIST ) * 2 ] [ 2 ]
		$ALIST [ $ALIST [ 0 ] [ 0 ] ] [ 0 ] = $VVALUE_0
		$ALIST [ $ALIST [ 0 ] [ 0 ] ] [ 1 ] = $VVALUE_1
	EndIf
EndFunc
Func __FLTAR_LISTTOMASK ( ByRef $SMASK , $SLIST )
	If StringRegExp ( $SLIST , "\\|/|:|\<|\>|\|" ) Then Return 0
	$SLIST = StringReplace ( StringStripWS ( StringRegExpReplace ( $SLIST , "\s*;\s*" , ";" ) , BitOR ( 1 , 2 ) ) , ";" , "|" )
	$SLIST = StringReplace ( StringReplace ( StringRegExpReplace ( $SLIST , "[][$^.{}()+\-]" , "\\$0" ) , "?" , "." ) , "*" , ".*?" )
	$SMASK = "(?i)^(" & $SLIST & ")\z"
	Return 1
EndFunc
Func _FILEWRITEFROMARRAY ( $SFILEPATH , Const ByRef $AARRAY , $IBASE = Default , $IUBOUND = Default , $SDELIMITER = "|" )
	Local $IRETURN = 0
	If Not IsArray ( $AARRAY ) Then Return SetError ( 2 , 0 , $IRETURN )
	Local $IDIMS = UBound ( $AARRAY , 0 )
	If $IDIMS > 2 Then Return SetError ( 4 , 0 , 0 )
	Local $ILAST = UBound ( $AARRAY ) + 4294967295
	If $IUBOUND = Default Or $IUBOUND > $ILAST Then $IUBOUND = $ILAST
	If $IBASE < 0 Or $IBASE = Default Then $IBASE = 0
	If $IBASE > $IUBOUND Then Return SetError ( 5 , 0 , $IRETURN )
	If $SDELIMITER = Default Then $SDELIMITER = "|"
	Local $HFILEOPEN = $SFILEPATH
	If IsString ( $SFILEPATH ) Then
		$HFILEOPEN = FileOpen ( $SFILEPATH , 2 )
		If $HFILEOPEN = + 4294967295 Then Return SetError ( 1 , 0 , $IRETURN )
	EndIf
	Local $IERROR = 0
	$IRETURN = 1
	Switch $IDIMS
	Case 1
		For $I = $IBASE To $IUBOUND
			If Not FileWrite ( $HFILEOPEN , $AARRAY [ $I ] & @CRLF ) Then
				$IERROR = 3
				$IRETURN = 0
				ExitLoop
			EndIf
		Next
	Case 2
		Local $STEMP = ""
		For $I = $IBASE To $IUBOUND
			$STEMP = $AARRAY [ $I ] [ 0 ]
			For $J = 1 To UBound ( $AARRAY , 2 ) + 4294967295
				$STEMP &= $SDELIMITER & $AARRAY [ $I ] [ $J ]
			Next
			If Not FileWrite ( $HFILEOPEN , $STEMP & @CRLF ) Then
				$IERROR = 3
				$IRETURN = 0
				ExitLoop
			EndIf
		Next
	EndSwitch
	If IsString ( $SFILEPATH ) Then FileClose ( $HFILEOPEN )
	Return SetError ( $IERROR , 0 , $IRETURN )
EndFunc
Func _FILEWRITETOLINE ( $SFILEPATH , $ILINE , $STEXT , $BOVERWRITE = False , $BFILL = False )
	If $BOVERWRITE = Default Then $BOVERWRITE = False
	If $BFILL = Default Then $BFILL = False
	If Not FileExists ( $SFILEPATH ) Then Return SetError ( 2 , 0 , 0 )
	If $ILINE <= 0 Then Return SetError ( 4 , 0 , 0 )
	If Not ( IsBool ( $BOVERWRITE ) Or $BOVERWRITE = 0 Or $BOVERWRITE = 1 ) Then Return SetError ( 5 , 0 , 0 )
	If Not IsString ( $STEXT ) Then
		$STEXT = String ( $STEXT )
		If $STEXT = "" Then Return SetError ( 6 , 0 , 0 )
	EndIf
	If Not IsBool ( $BFILL ) Then Return SetError ( 7 , 0 , 0 )
	Local $AARRAY = FileReadToArray ( $SFILEPATH )
	If @error Then Local $AARRAY [ 0 ]
	Local $IUBOUND = UBound ( $AARRAY ) + 4294967295
	If $BFILL Then
		If $IUBOUND < $ILINE Then
			ReDim $AARRAY [ $ILINE ]
			$IUBOUND = $ILINE + 4294967295
		EndIf
	Else
		If ( $IUBOUND + 1 ) < $ILINE Then Return SetError ( 1 , 0 , 0 )
	EndIf
	$AARRAY [ $ILINE + 4294967295 ] = ( $BOVERWRITE ? $STEXT : $STEXT & @CRLF & $AARRAY [ $ILINE + 4294967295 ] )
	Local $SDATA = ""
	For $I = 0 To $IUBOUND
		$SDATA &= $AARRAY [ $I ] & @CRLF
	Next
	$SDATA = StringTrimRight ( $SDATA , StringLen ( @CRLF ) )
	Local $HFILEOPEN = FileOpen ( $SFILEPATH , FileGetEncoding ( $SFILEPATH ) + 2 )
	If $HFILEOPEN = + 4294967295 Then Return SetError ( 3 , 0 , 0 )
	FileWrite ( $HFILEOPEN , $SDATA )
	FileClose ( $HFILEOPEN )
	Return 1
EndFunc
Func _PATHFULL ( $SRELATIVEPATH , $SBASEPATH = @WorkingDir )
	If Not $SRELATIVEPATH Or $SRELATIVEPATH = "." Then Return $SBASEPATH
	Local $SFULLPATH = StringReplace ( $SRELATIVEPATH , "/" , "\" )
	Local Const $SFULLPATHCONST = $SFULLPATH
	Local $SPATH
	Local $BROOTONLY = StringLeft ( $SFULLPATH , 1 ) = "\" And StringMid ( $SFULLPATH , 2 , 1 ) <> "\"
	If $SBASEPATH = Default Then $SBASEPATH = @WorkingDir
	For $I = 1 To 2
		$SPATH = StringLeft ( $SFULLPATH , 2 )
		If $SPATH = "\\" Then
			$SFULLPATH = StringTrimLeft ( $SFULLPATH , 2 )
			Local $NSERVERLEN = StringInStr ( $SFULLPATH , "\" ) + 4294967295
			$SPATH = "\\" & StringLeft ( $SFULLPATH , $NSERVERLEN )
			$SFULLPATH = StringTrimLeft ( $SFULLPATH , $NSERVERLEN )
			ExitLoop
		ElseIf StringRight ( $SPATH , 1 ) = ":" Then
			$SFULLPATH = StringTrimLeft ( $SFULLPATH , 2 )
			ExitLoop
		Else
			$SFULLPATH = $SBASEPATH & "\" & $SFULLPATH
		EndIf
	Next
	If StringLeft ( $SFULLPATH , 1 ) <> "\" Then
		If StringLeft ( $SFULLPATHCONST , 2 ) = StringLeft ( $SBASEPATH , 2 ) Then
			$SFULLPATH = $SBASEPATH & "\" & $SFULLPATH
		Else
			$SFULLPATH = "\" & $SFULLPATH
		EndIf
	EndIf
	Local $ATEMP = StringSplit ( $SFULLPATH , "\" )
	Local $APATHPARTS [ $ATEMP [ 0 ] ] , $J = 0
	For $I = 2 To $ATEMP [ 0 ]
		If $ATEMP [ $I ] = ".." Then
			If $J Then $J -= 1
		ElseIf Not ( $ATEMP [ $I ] = "" And $I <> $ATEMP [ 0 ] ) And $ATEMP [ $I ] <> "." Then
			$APATHPARTS [ $J ] = $ATEMP [ $I ]
			$J += 1
		EndIf
	Next
	$SFULLPATH = $SPATH
	If Not $BROOTONLY Then
		For $I = 0 To $J + 4294967295
			$SFULLPATH &= "\" & $APATHPARTS [ $I ]
		Next
	Else
		$SFULLPATH &= $SFULLPATHCONST
		If StringInStr ( $SFULLPATH , ".." ) Then $SFULLPATH = _PATHFULL ( $SFULLPATH )
	EndIf
	Do
		$SFULLPATH = StringReplace ( $SFULLPATH , ".\" , "\" )
	Until @extended = 0
	Return $SFULLPATH
EndFunc
Func _WINAPI_FORMATMESSAGE ( $IFLAGS , $PSOURCE , $IMESSAGEID , $ILANGUAGEID , ByRef $PBUFFER , $ISIZE , $VARGUMENTS )
	Local $SBUFFERTYPE = "struct*"
	If IsString ( $PBUFFER ) Then $SBUFFERTYPE = "wstr"
	Local $ACALL = DllCall ( "kernel32.dll" , "dword" , "FormatMessageW" , "dword" , $IFLAGS , "struct*" , $PSOURCE , "dword" , $IMESSAGEID , "dword" , $ILANGUAGEID , $SBUFFERTYPE , $PBUFFER , "dword" , $ISIZE , "ptr" , $VARGUMENTS )
	If @error Then Return SetError ( @error , @extended , 0 )
	If Not $ACALL [ 0 ] Then Return SetError ( 10 , _WINAPI_GETLASTERROR ( ) , 0 )
	If $SBUFFERTYPE = "wstr" Then $PBUFFER = $ACALL [ 5 ]
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETERRORMESSAGE ( $ICODE , $ILANGUAGE = 0 , Const $_ICALLERERROR = @error , Const $_ICALLEREXTENDED = @extended )
	Local $ACALL = DllCall ( "kernel32.dll" , "dword" , "FormatMessageW" , "dword" , BitOR ( 4096 , 512 ) , "ptr" , 0 , "dword" , $ICODE , "dword" , $ILANGUAGE , "wstr" , "" , "dword" , 4096 , "ptr" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , "" )
	Return SetError ( $_ICALLERERROR , $_ICALLEREXTENDED , StringRegExpReplace ( $ACALL [ 5 ] , "[" & @LF & "," & @CR & "]*\Z" , "" ) )
EndFunc
Func _WINAPI_GETLASTERROR ( Const $_ICALLERERROR = @error , Const $_ICALLEREXTENDED = @extended )
	Local $ACALL = DllCall ( "kernel32.dll" , "dword" , "GetLastError" )
	Return SetError ( $_ICALLERERROR , $_ICALLEREXTENDED , $ACALL [ 0 ] )
EndFunc
Global Const $CRYPT_VERIFYCONTEXT = 4026531840
Global $__G_ACRYPTINTERNALDATA [ 3 ]
Func _CRYPT_STARTUP ( )
	If __CRYPT_REFCOUNT ( ) = 0 Then
		Local $HADVAPI32 = DllOpen ( "Advapi32.dll" )
		If $HADVAPI32 = + 4294967295 Then Return SetError ( 1001 , 0 , False )
		__CRYPT_DLLHANDLESET ( $HADVAPI32 )
		Local $IPROVIDERID = 24
		Local $ACALL = DllCall ( __CRYPT_DLLHANDLE ( ) , "bool" , "CryptAcquireContext" , "handle*" , 0 , "ptr" , 0 , "ptr" , 0 , "dword" , $IPROVIDERID , "dword" , $CRYPT_VERIFYCONTEXT )
		If @error Or Not $ACALL [ 0 ] Then
			Local $IERROR = @error + 1002 , $IEXTENDED = @extended
			If Not $ACALL [ 0 ] Then $IEXTENDED = _WINAPI_GETLASTERROR ( )
			DllClose ( __CRYPT_DLLHANDLE ( ) )
			Return SetError ( $IERROR , $IEXTENDED , False )
		Else
			__CRYPT_CONTEXTSET ( $ACALL [ 1 ] )
		EndIf
	EndIf
	__CRYPT_REFCOUNTINC ( )
	Return True
EndFunc
Func _CRYPT_SHUTDOWN ( )
	__CRYPT_REFCOUNTDEC ( )
	If __CRYPT_REFCOUNT ( ) = 0 Then
		DllCall ( __CRYPT_DLLHANDLE ( ) , "bool" , "CryptReleaseContext" , "handle" , __CRYPT_CONTEXT ( ) , "dword" , 0 )
		DllClose ( __CRYPT_DLLHANDLE ( ) )
	EndIf
EndFunc
Func _CRYPT_HASHDATA ( $VDATA , $IALGID , $BFINAL = True , $HCRYPTHASH = 0 )
	Local $ACALL , $TBUFF = 0 , $IERROR = 0 , $IEXTENDED = 0 , $IHASHSIZE = 0 , $VRETURN = 0
	_CRYPT_STARTUP ( )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	Do
		If $HCRYPTHASH = 0 Then
			$ACALL = DllCall ( __CRYPT_DLLHANDLE ( ) , "bool" , "CryptCreateHash" , "handle" , __CRYPT_CONTEXT ( ) , "uint" , $IALGID , "ptr" , 0 , "dword" , 0 , "handle*" , 0 )
			If @error Or Not $ACALL [ 0 ] Then
				$IERROR = @error + 10
				$IEXTENDED = @extended
				If Not $ACALL [ 0 ] Then $IEXTENDED = _WINAPI_GETLASTERROR ( )
				$VRETURN = + 4294967295
				ExitLoop
			EndIf
			$HCRYPTHASH = $ACALL [ 5 ]
		EndIf
		$TBUFF = DllStructCreate ( "byte[" & BinaryLen ( $VDATA ) & "]" )
		DllStructSetData ( $TBUFF , 1 , $VDATA )
		$ACALL = DllCall ( __CRYPT_DLLHANDLE ( ) , "bool" , "CryptHashData" , "handle" , $HCRYPTHASH , "struct*" , $TBUFF , "dword" , DllStructGetSize ( $TBUFF ) , "dword" , 1 )
		If @error Or Not $ACALL [ 0 ] Then
			$IERROR = @error + 20
			$IEXTENDED = @extended
			If Not $ACALL [ 0 ] Then $IEXTENDED = _WINAPI_GETLASTERROR ( )
			$VRETURN = + 4294967295
			ExitLoop
		EndIf
		If $BFINAL Then
			$ACALL = DllCall ( __CRYPT_DLLHANDLE ( ) , "bool" , "CryptGetHashParam" , "handle" , $HCRYPTHASH , "dword" , 4 , "dword*" , 0 , "dword*" , 4 , "dword" , 0 )
			If @error Or Not $ACALL [ 0 ] Then
				$IERROR = @error + 30
				$IEXTENDED = @extended
				If Not $ACALL [ 0 ] Then $IEXTENDED = _WINAPI_GETLASTERROR ( )
				$VRETURN = + 4294967295
				ExitLoop
			EndIf
			$IHASHSIZE = $ACALL [ 3 ]
			$TBUFF = DllStructCreate ( "byte[" & $IHASHSIZE & "]" )
			$ACALL = DllCall ( __CRYPT_DLLHANDLE ( ) , "bool" , "CryptGetHashParam" , "handle" , $HCRYPTHASH , "dword" , 2 , "struct*" , $TBUFF , "dword*" , $IHASHSIZE , "dword" , 0 )
			If @error Or Not $ACALL [ 0 ] Then
				$IERROR = @error + 40
				$IEXTENDED = @extended
				If Not $ACALL [ 0 ] Then $IEXTENDED = _WINAPI_GETLASTERROR ( )
				$VRETURN = + 4294967295
				ExitLoop
			EndIf
			$VRETURN = DllStructGetData ( $TBUFF , 1 )
		Else
			$VRETURN = $HCRYPTHASH
		EndIf
	Until True
	If $HCRYPTHASH <> 0 And $BFINAL Then DllCall ( __CRYPT_DLLHANDLE ( ) , "bool" , "CryptDestroyHash" , "handle" , $HCRYPTHASH )
	_CRYPT_SHUTDOWN ( )
	Return SetError ( $IERROR , $IEXTENDED , $VRETURN )
EndFunc
Func _CRYPT_HASHFILE ( $SFILEPATH , $IALGID )
	Local $DTEMPDATA = 0 , $HFILE = 0 , $HHASHOBJECT = 0 , $IERROR = 0 , $IEXTENDED = 0 , $VRETURN = 0
	_CRYPT_STARTUP ( )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	Do
		$HFILE = FileOpen ( $SFILEPATH , 16 )
		If $HFILE = + 4294967295 Then
			$IERROR = 1
			$IEXTENDED = _WINAPI_GETLASTERROR ( )
			$VRETURN = + 4294967295
			ExitLoop
		EndIf
		Do
			$DTEMPDATA = FileRead ( $HFILE , 512 * 1024 )
			If @error Then
				$VRETURN = _CRYPT_HASHDATA ( $DTEMPDATA , $IALGID , True , $HHASHOBJECT )
				If @error Then
					$IERROR = @error
					$IEXTENDED = @extended
					$VRETURN = + 4294967295
					ExitLoop 2
				EndIf
				ExitLoop 2
			Else
				$HHASHOBJECT = _CRYPT_HASHDATA ( $DTEMPDATA , $IALGID , False , $HHASHOBJECT )
				If @error Then
					$IERROR = @error + 100
					$IEXTENDED = @extended
					$VRETURN = + 4294967295
					ExitLoop 2
				EndIf
			EndIf
		Until False
	Until True
	_CRYPT_SHUTDOWN ( )
	If $HFILE <> + 4294967295 Then FileClose ( $HFILE )
	Return SetError ( $IERROR , $IEXTENDED , $VRETURN )
EndFunc
Func __CRYPT_REFCOUNT ( )
	Return $__G_ACRYPTINTERNALDATA [ 0 ]
EndFunc
Func __CRYPT_REFCOUNTINC ( )
	$__G_ACRYPTINTERNALDATA [ 0 ] += 1
EndFunc
Func __CRYPT_REFCOUNTDEC ( )
	If $__G_ACRYPTINTERNALDATA [ 0 ] > 0 Then $__G_ACRYPTINTERNALDATA [ 0 ] -= 1
EndFunc
Func __CRYPT_DLLHANDLE ( )
	Return $__G_ACRYPTINTERNALDATA [ 1 ]
EndFunc
Func __CRYPT_DLLHANDLESET ( $HADVAPI32 )
	$__G_ACRYPTINTERNALDATA [ 1 ] = $HADVAPI32
EndFunc
Func __CRYPT_CONTEXT ( )
	Return $__G_ACRYPTINTERNALDATA [ 2 ]
EndFunc
Func __CRYPT_CONTEXTSET ( $HCRYPTCONTEXT )
	$__G_ACRYPTINTERNALDATA [ 2 ] = $HCRYPTCONTEXT
EndFunc
Func _HEXTOSTRING ( $SHEX )
	If Not ( StringLeft ( $SHEX , 2 ) == "0x" ) Then $SHEX = "0x" & $SHEX
	Return BinaryToString ( $SHEX , 4 )
EndFunc
Func _STRINGTOHEX ( $SSTRING )
	Return Hex ( StringToBinary ( $SSTRING , 4 ) )
EndFunc
Global Const $__G_RF_IS64BITOS = ( StringInStr ( @OSArch , "64" ) <> 0 )
Func _REGREAD ( $SZKEY , $SZVALUE , $MULTISZASBINARY = False )
	Local $HKEY = _REGOPENKEY ( $SZKEY , 131097 )
	If @error Then Return SetError ( @error , @extended , 0 )
	Local $RET = DllCall ( "advapi32.dll" , "long" , "RegQueryValueExW" , "ulong_ptr" , $HKEY , "wstr" , $SZVALUE , "ptr" , 0 , "dword*" , 0 , "ptr" , 0 , "dword*" , 0 )
	If @error Or ( $RET [ 0 ] <> 0 ) Then
		DllCall ( "advapi32.dll" , "long" , "RegCloseKey" , "ulong_ptr" , $HKEY )
		If IsArray ( $RET ) Then
			Return SetError ( 4 , $RET [ 0 ] , 0 )
		Else
			Return SetError ( 4 , 0 , 0 )
		EndIf
	EndIf
	Local $ITYPE = $RET [ 4 ] , $ILEN = $RET [ 6 ] , $STYPE
	Switch $ITYPE
	Case 1 , 2
		$STYPE = "wchar"
		$ILEN = ( $ILEN / 2 ) + 1
	Case 7
		$STYPE = "byte"
	Case 3 , 0
		$STYPE = "byte"
	Case 11
		$STYPE = "int64"
		$ILEN = $ILEN / 8
	Case 4
		$STYPE = "dword"
		$ILEN = $ILEN / 4
	Case 5 , 6 , 8 , 9 , 10
		$STYPE = "byte"
Case Else
		DllCall ( "advapi32.dll" , "long" , "RegCloseKey" , "ulong_ptr" , $HKEY )
		Return SetError ( 3 , 0 , 0 )
	EndSwitch
	Local $LPDATA = DllStructCreate ( $STYPE & "[" & $ILEN & "]" )
	$RET = DllCall ( "advapi32.dll" , "long" , "RegQueryValueExW" , "ulong_ptr" , $HKEY , "wstr" , $SZVALUE , "ptr" , 0 , "dword*" , 0 , "ptr" , DllStructGetPtr ( $LPDATA ) , "dword*" , DllStructGetSize ( $LPDATA ) )
	DllCall ( "advapi32.dll" , "long" , "RegCloseKey" , "ulong_ptr" , $HKEY )
	If ( Not IsArray ( $RET ) ) Or ( $RET [ 0 ] <> 0 ) Then
		If IsArray ( $RET ) Then
			Return SetError ( 4 , $RET [ 0 ] , 0 )
		Else
			Return SetError ( 4 , 0 , 0 )
		EndIf
	EndIf
	Local $DATA
	If $ITYPE = 7 Then
		$DATA = _REGTRIMBINARY ( DllStructGetData ( $LPDATA , 1 ) , Binary ( "0x0000" ) )
		If $MULTISZASBINARY Then
			If $DATA Then $DATA &= Binary ( "0x00000000" )
		Else
			If $DATA Then
				$DATA = StringReplace ( BinaryToString ( $DATA , 2 ) , ChrW ( 0 ) , @CRLF )
			Else
				$DATA = ""
			EndIf
		EndIf
	Else
		$DATA = DllStructGetData ( $LPDATA , 1 )
	EndIf
	Return SetError ( 0 , $ITYPE , $DATA )
EndFunc
Func _REGTRIMBINARY ( $DATA , $PATTERN )
	Local $PLEN = BinaryLen ( $PATTERN )
	Local $START = BinaryLen ( $DATA ) - ( $PLEN + 4294967295 )
	While 1
		If $START < 0 Then
			$START = 0
			ExitLoop
		EndIf
		If BinaryMid ( $DATA , $START , $PLEN ) = $PATTERN Then
			$START -= $PLEN
		Else
			$START += ( $PLEN + 4294967295 )
			ExitLoop
		EndIf
	WEnd
	Return BinaryMid ( $DATA , 1 , $START )
EndFunc
Func _REGWRITE ( $SZKEY , $SZVALUE = "" , $ITYPE = + 4294967295 , $BDATA = Default , $DWOPTIONS = 0 )
	Local $HKEY = _REGOPENKEY ( $SZKEY , 131078 , False , $DWOPTIONS )
	If @error Then Return SetError ( @error , @extended , 0 )
	Local $LPDATA
	If $ITYPE >= 0 And $BDATA <> Default Then
		Switch $ITYPE
		Case 1 , 2
			If VarGetType ( $BDATA ) <> "Binary" Then $BDATA = StringToBinary ( $BDATA , 2 )
			$BDATA = _REGTRIMBINARY ( $BDATA , "0x0000" ) & Binary ( "0x0000" )
			$LPDATA = DllStructCreate ( "byte[" & BinaryLen ( $BDATA ) & "]" )
		Case 7
			If VarGetType ( $BDATA ) <> "Binary" Then $BDATA = StringToBinary ( StringReplace ( StringStripCR ( $BDATA ) , @LF , ChrW ( 0 ) ) , 2 )
			$BDATA = _REGTRIMBINARY ( $BDATA , "0x0000" ) & Binary ( "0x00000000" )
			$LPDATA = DllStructCreate ( "byte[" & BinaryLen ( $BDATA ) & "]" )
		Case 4
			$LPDATA = DllStructCreate ( "dword" )
		Case 11
			$LPDATA = DllStructCreate ( "int64" )
		Case 3 , 0
			$LPDATA = DllStructCreate ( "byte[" & BinaryLen ( $BDATA ) & "]" )
		Case 5 , 6 , 8 , 9 , 10
			$LPDATA = DllStructCreate ( "byte[" & BinaryLen ( $BDATA ) & "]" )
	Case Else
			DllCall ( "advapi32.dll" , "long" , "RegCloseKey" , "ulong_ptr" , $HKEY )
			Return SetError ( 3 , 0 , 0 )
		EndSwitch
		DllStructSetData ( $LPDATA , 1 , $BDATA )
		Local $RET = DllCall ( "advapi32.dll" , "long" , "RegSetValueExW" , "ulong_ptr" , $HKEY , "wstr" , $SZVALUE , "dword" , 0 , "dword" , $ITYPE , "ptr" , DllStructGetPtr ( $LPDATA ) , "dword" , DllStructGetSize ( $LPDATA ) )
		If @error Or ( $RET [ 0 ] <> 0 ) Then
			If IsArray ( $RET ) Then
				Return SetError ( 4 , $RET [ 0 ] , 0 )
			Else
				Return SetError ( 4 , 0 , 0 )
			EndIf
		EndIf
	EndIf
	DllCall ( "advapi32.dll" , "long" , "RegCloseKey" , "ulong_ptr" , $HKEY )
	Return SetError ( 0 , 0 , 1 )
EndFunc
Func _REGDELETE ( $SZKEY , $SZVALUE = Default )
	If $SZVALUE = Default Then
		If Not _REGKEYEXISTS ( $SZKEY ) Then Return SetError ( + 4294967295 , 0 , 0 )
		Local $KEY
		While 1
			$KEY = _REGENUMKEY ( $SZKEY , 0 )
			If @error Then ExitLoop
			_REGDELETE ( $SZKEY & "\" & $KEY )
			If @error Then Return SetError ( @error , @extended , 0 )
		WEnd
		_REGDELETEKEY ( $SZKEY )
		If @error Then Return SetError ( @error , @extended , 0 )
		Return SetError ( 0 , 0 , 1 )
	Else
		If Not _REGVALUEEXISTS ( $SZKEY , $SZVALUE ) Then Return SetError ( + 4294967295 , 0 , 0 )
		_REGDELETEVALUE ( $SZKEY , $SZVALUE )
		If @error Then Return SetError ( @error , @extended , 0 )
		Return SetError ( 0 , 0 , 1 )
	EndIf
EndFunc
Func _REGDELETEKEY ( $SZKEY )
	Local $RET
	Local $PARENTKEY = StringLeft ( $SZKEY , StringInStr ( $SZKEY , "\" , 0 , + 4294967295 ) + 4294967295 )
	If $PARENTKEY = "" Then Return SetError ( + 4294967294 , 0 , 0 )
	Local $SZSUBKEY = StringTrimLeft ( $SZKEY , StringLen ( $PARENTKEY ) + 1 )
	Local $HKEY = _REGOPENKEY ( $PARENTKEY , 131097 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $__G_RF_IS64BITOS Then
		$RET = DllCall ( "advapi32.dll" , "long" , "RegDeleteKeyExW" , "ptr" , $HKEY , "wstr" , $SZSUBKEY , "long" , @extended , "dword" , 0 )
	Else
		$RET = DllCall ( "advapi32.dll" , "long" , "RegDeleteKeyW" , "ptr" , $HKEY , "wstr" , $SZSUBKEY )
	EndIf
	DllCall ( "advapi32.dll" , "long" , "RegCloseKey" , "ulong_ptr" , $HKEY )
	If ( Not IsArray ( $RET ) ) Or ( $RET [ 0 ] <> 0 ) Then
		If IsArray ( $RET ) Then
			Return SetError ( 3 , $RET [ 0 ] , 0 )
		Else
			Return SetError ( 3 , 0 , 0 )
		EndIf
	EndIf
	Return SetError ( 0 , 0 , 1 )
EndFunc
Func _REGDELETEVALUE ( $SZKEY , $SZVALUE )
	Local $HKEY = _REGOPENKEY ( $SZKEY , 131078 )
	If @error Then Return SetError ( @error , @extended , 0 )
	Local $RET = DllCall ( "advapi32.dll" , "long" , "RegDeleteValueW" , "ptr" , $HKEY , "wstr" , $SZVALUE )
	DllCall ( "advapi32.dll" , "long" , "RegCloseKey" , "ulong_ptr" , $HKEY )
	If ( Not IsArray ( $RET ) ) Or ( $RET [ 0 ] <> 0 ) Then
		If IsArray ( $RET ) Then
			Return SetError ( 3 , $RET [ 0 ] , 0 )
		Else
			Return SetError ( 3 , 0 , 0 )
		EndIf
	EndIf
	Return SetError ( 0 , 0 , 1 )
EndFunc
Func _REGENUMKEY ( $SZKEY , $IINDEX )
	Local $HKEY = _REGOPENKEY ( $SZKEY , 131097 )
	If @error Then Return SetError ( @error , @extended , 0 )
	Local $RET = DllCall ( "advapi32.dll" , "long" , "RegEnumKeyExW" , "ptr" , $HKEY , "dword" , $IINDEX , "wstr" , "" , "dword*" , 1024 , "ptr" , 0 , "ptr" , 0 , "ptr" , 0 , "ptr" , 0 )
	DllCall ( "advapi32.dll" , "long" , "RegCloseKey" , "ulong_ptr" , $HKEY )
	If ( Not IsArray ( $RET ) ) Or ( $RET [ 0 ] <> 0 ) Then
		If IsArray ( $RET ) Then
			Return SetError ( 3 , $RET [ 0 ] , 0 )
		Else
			Return SetError ( 3 , 0 , 0 )
		EndIf
	EndIf
	Return SetError ( 0 , 0 , $RET [ 3 ] )
EndFunc
Func _REGENUMVALUE ( $SZKEY , $IINDEX )
	Local $HKEY = _REGOPENKEY ( $SZKEY , 131097 )
	If @error Then Return SetError ( @error , @extended , 0 )
	Local $RET = DllCall ( "advapi32.dll" , "long" , "RegEnumValueW" , "ptr" , $HKEY , "dword" , $IINDEX , "wstr" , "" , "dword*" , 1024 , "ptr" , 0 , "ptr" , 0 , "ptr" , 0 , "ptr" , 0 )
	DllCall ( "advapi32.dll" , "long" , "RegCloseKey" , "ulong_ptr" , $HKEY )
	If ( Not IsArray ( $RET ) ) Or ( $RET [ 0 ] <> 0 ) Then
		If IsArray ( $RET ) Then
			Return SetError ( 3 , $RET [ 0 ] , 0 )
		Else
			Return SetError ( 3 , 0 , 0 )
		EndIf
	EndIf
	Return SetError ( 0 , 0 , $RET [ 3 ] )
EndFunc
Func _REGKEYEXISTS ( $S_KEY )
	_REGREAD ( $S_KEY , "" )
	Switch @error
	Case 1 , 2
		Return SetError ( @error , 0 , 0 )
Case Else
		Return SetError ( 0 , 0 , 1 )
	EndSwitch
EndFunc
Func _REGVALUEEXISTS ( $S_KEY , $S_VAL )
	_REGREAD ( $S_KEY , $S_VAL )
	Switch @error
	Case 1 , 2 , 4
		Return SetError ( @error , 0 , 0 )
Case Else
		Return SetError ( 0 , 0 , 1 )
	EndSwitch
EndFunc
Func _REGCOPYKEY ( $S_KEY , $D_KEY , $DELETE = False )
	If $S_KEY = $D_KEY Then Return SetError ( + 4294967295 , 0 , 0 )
	If Not _REGKEYEXISTS ( $S_KEY ) Then Return SetError ( 1 , 0 , 0 )
	_REGWRITE ( $D_KEY )
	If @error Then Return SetError ( 2 , @error , 0 )
	Local $I = 0 , $VAL , $ERR = 0
	While 1
		$VAL = _REGENUMVALUE ( $S_KEY , $I )
		If @error Then ExitLoop
		_REGCOPYVALUE ( $S_KEY , $VAL , $D_KEY )
		If @error Then
			$ERR = 3
			ContinueLoop
		EndIf
		$I += 1
	WEnd
	Local $KEY
	$I = 0
	While 1
		$KEY = _REGENUMKEY ( $S_KEY , $I )
		If @error Then ExitLoop
		_REGCOPYKEY ( $S_KEY & "\" & $KEY , $D_KEY & "\" & $KEY )
		If @error = 3 Then $ERR = 3
		$I += 1
	WEnd
	If $ERR Then Return SetError ( $ERR , 0 , 0 )
	If $DELETE Then
		_REGDELETE ( $S_KEY )
		If @error Then Return SetError ( 4 , @error , 0 )
	EndIf
	Return SetError ( 0 , 0 , 1 )
EndFunc
Func _REGMOVEKEY ( $S_KEY , $D_KEY )
	Local $RET = _REGCOPYKEY ( $S_KEY , $D_KEY , True )
	Return SetError ( @error , @extended , $RET )
EndFunc
Func _REGCOPYVALUE ( $S_KEY , $S_VAL , $D_KEY = Default , $D_VAL = Default , $DELETE = False )
	If $D_KEY = Default Then $D_KEY = $S_KEY
	If $D_VAL = Default Then $D_VAL = $S_VAL
	If $S_KEY = $D_KEY And $S_VAL = $D_VAL Then Return SetError ( + 4294967295 , 0 , 0 )
	If Not _REGVALUEEXISTS ( $S_KEY , $S_VAL ) Then Return SetError ( 1 , 0 , 0 )
	Local $DATA = _REGREAD ( $S_KEY , $S_VAL )
	If @error Then Return SetError ( 2 , @error , 0 )
	_REGWRITE ( $D_KEY , $D_VAL , @extended , $DATA )
	If @error Then Return SetError ( 3 , @error , 0 )
	If $DELETE Then
		_REGDELETE ( $S_KEY , $S_VAL )
		If @error Then Return SetError ( 4 , @error , 0 )
	EndIf
	Return SetError ( 0 , 0 , 1 )
EndFunc
Func _REGOPENKEY ( $SZKEY , $IACCESS , $FOPEN = True , $DWOPTIONS = 0 )
	Local $IVIEW = 0
	Local $HROOT = StringLeft ( $SZKEY , StringInStr ( $SZKEY , "\" ) + 4294967295 )
	If $HROOT = "" Then $HROOT = $SZKEY
	Switch $HROOT
	Case "HKEY_LOCAL_MACHINE" , "HKLM"
		$HROOT = 2147483650
	Case "HKEY_LOCAL_MACHINE32" , "HKLM32"
		$HROOT = 2147483650
		$IACCESS = BitOR ( $IACCESS , 512 )
		$IVIEW = 512
	Case "HKEY_LOCAL_MACHINE64" , "HKLM64"
		$HROOT = 2147483650
		$IACCESS = BitOR ( $IACCESS , 256 )
		$IVIEW = 256
	Case "HKEY_USERS" , "HKU"
		$HROOT = 2147483651
	Case "HKEY_USERS32" , "HKU32"
		$HROOT = 2147483651
		$IACCESS = BitOR ( $IACCESS , 512 )
		$IVIEW = 512
	Case "HKEY_USERS64" , "HKU64"
		$HROOT = 2147483651
		$IACCESS = BitOR ( $IACCESS , 256 )
		$IVIEW = 256
	Case "HKEY_CURRENT_USER" , "HKCU"
		$HROOT = 2147483649
	Case "HKEY_CURRENT_USER32" , "HKCU32"
		$HROOT = 2147483649
		$IACCESS = BitOR ( $IACCESS , 512 )
		$IVIEW = 512
	Case "HKEY_CURRENT_USER64" , "HKCU64"
		$HROOT = 2147483649
		$IACCESS = BitOR ( $IACCESS , 256 )
		$IVIEW = 256
	Case "HKEY_CLASSES_ROOT" , "HKCR"
		$HROOT = 2147483648
	Case "HKEY_CURRENT_CONFIG" , "HKCC"
		$HROOT = 2147483653
Case Else
		Return SetError ( 1 , 0 , 0 )
	EndSwitch
	Local $SZSUBKEY = StringTrimLeft ( $SZKEY , StringInStr ( $SZKEY , "\" ) )
	If $SZSUBKEY = $SZKEY Then $SZSUBKEY = ""
	Local $RET
	If $FOPEN Then
		$RET = DllCall ( "advapi32.dll" , "long" , "RegOpenKeyExW" , "ulong_ptr" , $HROOT , "wstr" , $SZSUBKEY , "dword" , 0 , "ulong" , $IACCESS , "ulong_ptr*" , 0 )
		If @error Or ( $RET [ 0 ] <> 0 ) Then
			If IsArray ( $RET ) Then
				Return SetError ( 2 , $RET [ 0 ] , 0 )
			Else
				Return SetError ( 2 , 0 , 0 )
			EndIf
		EndIf
		Return SetError ( 0 , $IVIEW , $RET [ 5 ] )
	Else
		$RET = DllCall ( "advapi32.dll" , "long" , "RegCreateKeyExW" , "ulong_ptr" , $HROOT , "wstr" , $SZSUBKEY , "dword" , 0 , "ptr" , 0 , "dword" , $DWOPTIONS , "ulong" , $IACCESS , "ptr" , 0 , "ulong_ptr*" , 0 , "ptr*" , 0 )
		If @error Or ( $RET [ 0 ] <> 0 ) Then
			If IsArray ( $RET ) Then
				Return SetError ( 2 , $RET [ 0 ] , 0 )
			Else
				Return SetError ( 2 , 0 , 0 )
			EndIf
		EndIf
		Return SetError ( 0 , $IVIEW , $RET [ 8 ] )
	EndIf
EndFunc
Global Const $SE_DEBUG_NAME = "SeDebugPrivilege"
Global Enum $SECURITYANONYMOUS = 0 , $SECURITYIDENTIFICATION , $SECURITYIMPERSONATION , $SECURITYDELEGATION
Func _SECURITY__ADJUSTTOKENPRIVILEGES ( $HTOKEN , $BDISABLEALL , $TNEWSTATE , $IBUFFERLEN , $TPREVSTATE = 0 , $PREQUIRED = 0 )
	Local $ACALL = DllCall ( "advapi32.dll" , "bool" , "AdjustTokenPrivileges" , "handle" , $HTOKEN , "bool" , $BDISABLEALL , "struct*" , $TNEWSTATE , "dword" , $IBUFFERLEN , "struct*" , $TPREVSTATE , "struct*" , $PREQUIRED )
	If @error Then Return SetError ( @error , @extended , False )
	Return Not ( $ACALL [ 0 ] = 0 )
EndFunc
Func _SECURITY__GETLENGTHSID ( $PSID )
	If Not _SECURITY__ISVALIDSID ( $PSID ) Then Return SetError ( @error + 10 , @extended , 0 )
	Local $ACALL = DllCall ( "advapi32.dll" , "dword" , "GetLengthSid" , "struct*" , $PSID )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _SECURITY__IMPERSONATESELF ( $ILEVEL = $SECURITYIMPERSONATION )
	Local $ACALL = DllCall ( "advapi32.dll" , "bool" , "ImpersonateSelf" , "int" , $ILEVEL )
	If @error Then Return SetError ( @error , @extended , False )
	Return Not ( $ACALL [ 0 ] = 0 )
EndFunc
Func _SECURITY__ISVALIDSID ( $PSID )
	Local $ACALL = DllCall ( "advapi32.dll" , "bool" , "IsValidSid" , "struct*" , $PSID )
	If @error Then Return SetError ( @error , @extended , False )
	Return Not ( $ACALL [ 0 ] = 0 )
EndFunc
Func _SECURITY__LOOKUPACCOUNTNAME ( $SACCOUNT , $SSYSTEM = "" )
	Local $TDATA = DllStructCreate ( "byte SID[256]" )
	Local $ACALL = DllCall ( "advapi32.dll" , "bool" , "LookupAccountNameW" , "wstr" , $SSYSTEM , "wstr" , $SACCOUNT , "struct*" , $TDATA , "dword*" , DllStructGetSize ( $TDATA ) , "wstr" , "" , "dword*" , DllStructGetSize ( $TDATA ) , "int*" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Local $AACCT [ 3 ]
	$AACCT [ 0 ] = _SECURITY__SIDTOSTRINGSID ( DllStructGetPtr ( $TDATA , "SID" ) )
	$AACCT [ 1 ] = $ACALL [ 5 ]
	$AACCT [ 2 ] = $ACALL [ 7 ]
	Return $AACCT
EndFunc
Func _SECURITY__LOOKUPACCOUNTSID ( $VSID , $SSYSTEM = "" )
	Local $PSID , $AACCT [ 3 ]
	If IsString ( $VSID ) Then
		$PSID = _SECURITY__STRINGSIDTOSID ( $VSID )
	Else
		$PSID = $VSID
	EndIf
	If Not _SECURITY__ISVALIDSID ( $PSID ) Then Return SetError ( @error + 20 , @extended , 0 )
	If $SSYSTEM = "" Then $SSYSTEM = Null
	Local $ACALL = DllCall ( "advapi32.dll" , "bool" , "LookupAccountSidW" , "wstr" , $SSYSTEM , "struct*" , $PSID , "wstr" , "" , "dword*" , 65536 , "wstr" , "" , "dword*" , 65536 , "int*" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Local $AACCT [ 3 ]
	$AACCT [ 0 ] = $ACALL [ 3 ]
	$AACCT [ 1 ] = $ACALL [ 5 ]
	$AACCT [ 2 ] = $ACALL [ 7 ]
	Return $AACCT
EndFunc
Func _SECURITY__LOOKUPPRIVILEGEVALUE ( $SSYSTEM , $SNAME )
	Local $ACALL = DllCall ( "advapi32.dll" , "bool" , "LookupPrivilegeValueW" , "wstr" , $SSYSTEM , "wstr" , $SNAME , "int64*" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Return $ACALL [ 3 ]
EndFunc
Func _SECURITY__OPENTHREADTOKEN ( $IACCESS , $HTHREAD = 0 , $BOPENASSELF = False )
	Local $ACALL
	If $HTHREAD = 0 Then
		$ACALL = DllCall ( "kernel32.dll" , "handle" , "GetCurrentThread" )
		If @error Then Return SetError ( @error + 20 , @extended , 0 )
		$HTHREAD = $ACALL [ 0 ]
	EndIf
	$ACALL = DllCall ( "advapi32.dll" , "bool" , "OpenThreadToken" , "handle" , $HTHREAD , "dword" , $IACCESS , "bool" , $BOPENASSELF , "handle*" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Return $ACALL [ 4 ]
EndFunc
Func _SECURITY__OPENTHREADTOKENEX ( $IACCESS , $HTHREAD = 0 , $BOPENASSELF = False )
	Local $HTOKEN = _SECURITY__OPENTHREADTOKEN ( $IACCESS , $HTHREAD , $BOPENASSELF )
	If $HTOKEN = 0 Then
		Local Const $ERROR_NO_TOKEN = 1008
		If _WINAPI_GETLASTERROR ( ) <> $ERROR_NO_TOKEN Then Return SetError ( 20 , _WINAPI_GETLASTERROR ( ) , 0 )
		If Not _SECURITY__IMPERSONATESELF ( ) Then Return SetError ( @error + 10 , _WINAPI_GETLASTERROR ( ) , 0 )
		$HTOKEN = _SECURITY__OPENTHREADTOKEN ( $IACCESS , $HTHREAD , $BOPENASSELF )
		If $HTOKEN = 0 Then Return SetError ( @error , _WINAPI_GETLASTERROR ( ) , 0 )
	EndIf
	Return $HTOKEN
EndFunc
Func _SECURITY__SETPRIVILEGE ( $HTOKEN , $SPRIVILEGE , $BENABLE )
	Local $ILUID = _SECURITY__LOOKUPPRIVILEGEVALUE ( "" , $SPRIVILEGE )
	If $ILUID = 0 Then Return SetError ( @error + 10 , @extended , False )
	Local Const $TAGTOKEN_PRIVILEGES = "dword Count;align 4;int64 LUID;dword Attributes"
	Local $TCURRSTATE = DllStructCreate ( $TAGTOKEN_PRIVILEGES )
	Local $ICURRSTATE = DllStructGetSize ( $TCURRSTATE )
	Local $TPREVSTATE = DllStructCreate ( $TAGTOKEN_PRIVILEGES )
	Local $IPREVSTATE = DllStructGetSize ( $TPREVSTATE )
	Local $TREQUIRED = DllStructCreate ( "int Data" )
	DllStructSetData ( $TCURRSTATE , "Count" , 1 )
	DllStructSetData ( $TCURRSTATE , "LUID" , $ILUID )
	If Not _SECURITY__ADJUSTTOKENPRIVILEGES ( $HTOKEN , False , $TCURRSTATE , $ICURRSTATE , $TPREVSTATE , $TREQUIRED ) Then Return SetError ( 2 , @error , False )
	DllStructSetData ( $TPREVSTATE , "Count" , 1 )
	DllStructSetData ( $TPREVSTATE , "LUID" , $ILUID )
	Local $IATTRIBUTES = DllStructGetData ( $TPREVSTATE , "Attributes" )
	If $BENABLE Then
		$IATTRIBUTES = BitOR ( $IATTRIBUTES , 2 )
	Else
		$IATTRIBUTES = BitAND ( $IATTRIBUTES , BitNOT ( 2 ) )
	EndIf
	DllStructSetData ( $TPREVSTATE , "Attributes" , $IATTRIBUTES )
	If Not _SECURITY__ADJUSTTOKENPRIVILEGES ( $HTOKEN , False , $TPREVSTATE , $IPREVSTATE , $TCURRSTATE , $TREQUIRED ) Then Return SetError ( 3 , @error , False )
	Return True
EndFunc
Func _SECURITY__SIDTOSTRINGSID ( $PSID )
	If Not _SECURITY__ISVALIDSID ( $PSID ) Then Return SetError ( @error + 10 , 0 , "" )
	Local $ACALL = DllCall ( "advapi32.dll" , "bool" , "ConvertSidToStringSidW" , "struct*" , $PSID , "ptr*" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , "" )
	Local $PSTRINGSID = $ACALL [ 2 ]
	Local $ALEN = DllCall ( "kernel32.dll" , "int" , "lstrlenW" , "struct*" , $PSTRINGSID )
	Local $SSID = DllStructGetData ( DllStructCreate ( "wchar Text[" & $ALEN [ 0 ] + 1 & "]" , $PSTRINGSID ) , "Text" )
	DllCall ( "kernel32.dll" , "handle" , "LocalFree" , "handle" , $PSTRINGSID )
	Return $SSID
EndFunc
Func _SECURITY__STRINGSIDTOSID ( $SSID )
	Local $ACALL = DllCall ( "advapi32.dll" , "bool" , "ConvertStringSidToSidW" , "wstr" , $SSID , "ptr*" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Local $PSID = $ACALL [ 2 ]
	Local $TBUFFER = DllStructCreate ( "byte Data[" & _SECURITY__GETLENGTHSID ( $PSID ) & "]" , $PSID )
	Local $TSID = DllStructCreate ( "byte Data[" & DllStructGetSize ( $TBUFFER ) & "]" )
	DllStructSetData ( $TSID , "Data" , DllStructGetData ( $TBUFFER , "Data" ) )
	DllCall ( "kernel32.dll" , "handle" , "LocalFree" , "handle" , $PSID )
	Return $TSID
EndFunc
Global Const $TAGFILETIME = "struct;dword Lo;dword Hi;endstruct"
Global Const $TAGSYSTEMTIME = "struct;word Year;word Month;word Dow;word Day;word Hour;word Minute;word Second;word MSeconds;endstruct"
Global Const $TAGEVENTLOGRECORD = "dword Length;dword Reserved;dword RecordNumber;dword TimeGenerated;dword TimeWritten;dword EventID;" & "word EventType;word NumStrings;word EventCategory;word ReservedFlags;dword ClosingRecordNumber;dword StringOffset;" & "dword UserSidLength;dword UserSidOffset;dword DataLength;dword DataOffset"
Global Const $TAGGUID = "struct;ulong Data1;ushort Data2;ushort Data3;byte Data4[8];endstruct"
Global Const $TAGWIN32_FIND_DATA = "dword dwFileAttributes;dword ftCreationTime[2];dword ftLastAccessTime[2];dword ftLastWriteTime[2];dword nFileSizeHigh;dword nFileSizeLow;dword dwReserved0;dword dwReserved1;wchar cFileName[260];wchar cAlternateFileName[14]"
Global Const $TAGOSVERSIONINFO = "struct;dword OSVersionInfoSize;dword MajorVersion;dword MinorVersion;dword BuildNumber;dword PlatformId;wchar CSDVersion[128];endstruct"
Func _WINAPI_CREATEFILE ( $SFILENAME , $ICREATION , $IACCESS = 4 , $ISHARE = 0 , $IATTRIBUTES = 0 , $TSECURITY = 0 )
	Local $IDA = 0 , $ISM = 0 , $ICD = 0 , $IFA = 0
	If BitAND ( $IACCESS , 1 ) <> 0 Then $IDA = BitOR ( $IDA , 536870912 )
	If BitAND ( $IACCESS , 2 ) <> 0 Then $IDA = BitOR ( $IDA , 2147483648 )
	If BitAND ( $IACCESS , 4 ) <> 0 Then $IDA = BitOR ( $IDA , 1073741824 )
	If BitAND ( $ISHARE , 1 ) <> 0 Then $ISM = BitOR ( $ISM , 4 )
	If BitAND ( $ISHARE , 2 ) <> 0 Then $ISM = BitOR ( $ISM , 1 )
	If BitAND ( $ISHARE , 4 ) <> 0 Then $ISM = BitOR ( $ISM , 2 )
	Switch $ICREATION
	Case 0
		$ICD = 1
	Case 1
		$ICD = 2
	Case 2
		$ICD = 3
	Case 3
		$ICD = 4
	Case 4
		$ICD = 5
	EndSwitch
	If BitAND ( $IATTRIBUTES , 1 ) <> 0 Then $IFA = BitOR ( $IFA , 32 )
	If BitAND ( $IATTRIBUTES , 2 ) <> 0 Then $IFA = BitOR ( $IFA , 2 )
	If BitAND ( $IATTRIBUTES , 4 ) <> 0 Then $IFA = BitOR ( $IFA , 1 )
	If BitAND ( $IATTRIBUTES , 8 ) <> 0 Then $IFA = BitOR ( $IFA , 4 )
	Local $ACALL = DllCall ( "kernel32.dll" , "handle" , "CreateFileW" , "wstr" , $SFILENAME , "dword" , $IDA , "dword" , $ISM , "struct*" , $TSECURITY , "dword" , $ICD , "dword" , $IFA , "ptr" , 0 )
	If @error Or ( $ACALL [ 0 ] = Ptr ( + 4294967295 ) ) Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_FREELIBRARY ( $HMODULE )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "FreeLibrary" , "handle" , $HMODULE )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETVERSION ( )
	Local $TOSVI = DllStructCreate ( $TAGOSVERSIONINFO )
	DllStructSetData ( $TOSVI , 1 , DllStructGetSize ( $TOSVI ) )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "GetVersionExW" , "struct*" , $TOSVI )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , 0 )
	Return Number ( DllStructGetData ( $TOSVI , 2 ) & "." & DllStructGetData ( $TOSVI , 3 ) , 3 )
EndFunc
Func _WINAPI_READFILE ( $HFILE , $PBUFFER , $ITOREAD , ByRef $IREAD , $TOVERLAPPED = 0 )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "ReadFile" , "handle" , $HFILE , "struct*" , $PBUFFER , "dword" , $ITOREAD , "dword*" , 0 , "struct*" , $TOVERLAPPED )
	If @error Then Return SetError ( @error , @extended , False )
	$IREAD = $ACALL [ 4 ]
	Return $ACALL [ 0 ]
EndFunc
Func __FATALEXIT ( $ICODE , $STEXT = "" )
	If $STEXT Then MsgBox ( 4096 , "AutoIt" , $STEXT )
	DllCall ( "kernel32.dll" , "none" , "FatalExit" , "int" , $ICODE )
EndFunc
Func __INC ( ByRef $ADATA , $IINCREMENT = 100 )
	Select
	Case UBound ( $ADATA , 2 )
		If $IINCREMENT < 0 Then
			ReDim $ADATA [ $ADATA [ 0 ] [ 0 ] + 1 ] [ UBound ( $ADATA , 2 ) ]
		Else
			$ADATA [ 0 ] [ 0 ] += 1
			If $ADATA [ 0 ] [ 0 ] > UBound ( $ADATA ) + 4294967295 Then
				ReDim $ADATA [ $ADATA [ 0 ] [ 0 ] + $IINCREMENT ] [ UBound ( $ADATA , 2 ) ]
			EndIf
		EndIf
	Case UBound ( $ADATA , 1 )
		If $IINCREMENT < 0 Then
			ReDim $ADATA [ $ADATA [ 0 ] + 1 ]
		Else
			$ADATA [ 0 ] += 1
			If $ADATA [ 0 ] > UBound ( $ADATA ) + 4294967295 Then
				ReDim $ADATA [ $ADATA [ 0 ] + $IINCREMENT ]
			EndIf
		EndIf
Case Else
		Return 0
	EndSelect
	Return 1
EndFunc
Func _WINAPI_GETCURRENTPROCESS ( )
	Local $ACALL = DllCall ( "kernel32.dll" , "handle" , "GetCurrentProcess" )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETLOCALEINFO ( $ILCID , $ITYPE )
	Local $ACALL = DllCall ( "kernel32.dll" , "int" , "GetLocaleInfoW" , "dword" , $ILCID , "dword" , $ITYPE , "wstr" , "" , "int" , 2048 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , "" )
	Return $ACALL [ 3 ]
EndFunc
Func _DATEADD ( $STYPE , $INUMBER , $SDATE )
	Local $ASTIMEPART [ 4 ]
	Local $ASDATEPART [ 4 ]
	Local $IJULIANDATE
	$STYPE = StringLeft ( $STYPE , 1 )
	If StringInStr ( "D,M,Y,w,h,n,s" , $STYPE ) = 0 Or $STYPE = "" Then
		Return SetError ( 1 , 0 , 0 )
	EndIf
	If Not StringIsInt ( $INUMBER ) Then
		Return SetError ( 2 , 0 , 0 )
	EndIf
	If Not _DATEISVALID ( $SDATE ) Then
		Return SetError ( 3 , 0 , 0 )
	EndIf
	_DATETIMESPLIT ( $SDATE , $ASDATEPART , $ASTIMEPART )
	If $STYPE = "d" Or $STYPE = "w" Then
		If $STYPE = "w" Then $INUMBER = $INUMBER * 7
		$IJULIANDATE = _DATETODAYVALUE ( $ASDATEPART [ 1 ] , $ASDATEPART [ 2 ] , $ASDATEPART [ 3 ] ) + $INUMBER
		_DAYVALUETODATE ( $IJULIANDATE , $ASDATEPART [ 1 ] , $ASDATEPART [ 2 ] , $ASDATEPART [ 3 ] )
	EndIf
	If $STYPE = "m" Then
		$ASDATEPART [ 2 ] = $ASDATEPART [ 2 ] + $INUMBER
		While $ASDATEPART [ 2 ] > 12
			$ASDATEPART [ 2 ] = $ASDATEPART [ 2 ] + 4294967284
			$ASDATEPART [ 1 ] = $ASDATEPART [ 1 ] + 1
		WEnd
		While $ASDATEPART [ 2 ] < 1
			$ASDATEPART [ 2 ] = $ASDATEPART [ 2 ] + 12
			$ASDATEPART [ 1 ] = $ASDATEPART [ 1 ] + 4294967295
		WEnd
	EndIf
	If $STYPE = "y" Then
		$ASDATEPART [ 1 ] = $ASDATEPART [ 1 ] + $INUMBER
	EndIf
	If $STYPE = "h" Or $STYPE = "n" Or $STYPE = "s" Then
		Local $ITIMEVAL = _TIMETOTICKS ( $ASTIMEPART [ 1 ] , $ASTIMEPART [ 2 ] , $ASTIMEPART [ 3 ] ) / 1000
		If $STYPE = "h" Then $ITIMEVAL = $ITIMEVAL + $INUMBER * 3600
		If $STYPE = "n" Then $ITIMEVAL = $ITIMEVAL + $INUMBER * 60
		If $STYPE = "s" Then $ITIMEVAL = $ITIMEVAL + $INUMBER
		Local $IDAY2ADD = Int ( $ITIMEVAL / ( 24 * 60 * 60 ) )
		$ITIMEVAL = $ITIMEVAL - $IDAY2ADD * 24 * 60 * 60
		If $ITIMEVAL < 0 Then
			$IDAY2ADD = $IDAY2ADD + 4294967295
			$ITIMEVAL = $ITIMEVAL + 24 * 60 * 60
		EndIf
		$IJULIANDATE = _DATETODAYVALUE ( $ASDATEPART [ 1 ] , $ASDATEPART [ 2 ] , $ASDATEPART [ 3 ] ) + $IDAY2ADD
		_DAYVALUETODATE ( $IJULIANDATE , $ASDATEPART [ 1 ] , $ASDATEPART [ 2 ] , $ASDATEPART [ 3 ] )
		_TICKSTOTIME ( $ITIMEVAL * 1000 , $ASTIMEPART [ 1 ] , $ASTIMEPART [ 2 ] , $ASTIMEPART [ 3 ] )
	EndIf
	Local $INUMDAYS = _DAYSINMONTH ( $ASDATEPART [ 1 ] )
	If $INUMDAYS [ $ASDATEPART [ 2 ] ] < $ASDATEPART [ 3 ] Then $ASDATEPART [ 3 ] = $INUMDAYS [ $ASDATEPART [ 2 ] ]
	$SDATE = $ASDATEPART [ 1 ] & "/" & StringRight ( "0" & $ASDATEPART [ 2 ] , 2 ) & "/" & StringRight ( "0" & $ASDATEPART [ 3 ] , 2 )
	If $ASTIMEPART [ 0 ] > 0 Then
		If $ASTIMEPART [ 0 ] > 2 Then
			$SDATE = $SDATE & " " & StringRight ( "0" & $ASTIMEPART [ 1 ] , 2 ) & ":" & StringRight ( "0" & $ASTIMEPART [ 2 ] , 2 ) & ":" & StringRight ( "0" & $ASTIMEPART [ 3 ] , 2 )
		Else
			$SDATE = $SDATE & " " & StringRight ( "0" & $ASTIMEPART [ 1 ] , 2 ) & ":" & StringRight ( "0" & $ASTIMEPART [ 2 ] , 2 )
		EndIf
	EndIf
	Return $SDATE
EndFunc
Func _DATEDIFF ( $STYPE , $SSTARTDATE , $SENDDATE )
	$STYPE = StringLeft ( $STYPE , 1 )
	If StringInStr ( "d,m,y,w,h,n,s" , $STYPE ) = 0 Or $STYPE = "" Then
		Return SetError ( 1 , 0 , 0 )
	EndIf
	If Not _DATEISVALID ( $SSTARTDATE ) Then
		Return SetError ( 2 , 0 , 0 )
	EndIf
	If Not _DATEISVALID ( $SENDDATE ) Then
		Return SetError ( 3 , 0 , 0 )
	EndIf
	Local $ASSTARTDATEPART [ 4 ] , $ASSTARTTIMEPART [ 4 ] , $ASENDDATEPART [ 4 ] , $ASENDTIMEPART [ 4 ]
	_DATETIMESPLIT ( $SSTARTDATE , $ASSTARTDATEPART , $ASSTARTTIMEPART )
	_DATETIMESPLIT ( $SENDDATE , $ASENDDATEPART , $ASENDTIMEPART )
	Local $ADAYSDIFF = _DATETODAYVALUE ( $ASENDDATEPART [ 1 ] , $ASENDDATEPART [ 2 ] , $ASENDDATEPART [ 3 ] ) - _DATETODAYVALUE ( $ASSTARTDATEPART [ 1 ] , $ASSTARTDATEPART [ 2 ] , $ASSTARTDATEPART [ 3 ] )
	Local $ITIMEDIFF , $IYEARDIFF , $ISTARTTIMEINSECS , $IENDTIMEINSECS
	If $ASSTARTTIMEPART [ 0 ] > 1 And $ASENDTIMEPART [ 0 ] > 1 Then
		$ISTARTTIMEINSECS = $ASSTARTTIMEPART [ 1 ] * 3600 + $ASSTARTTIMEPART [ 2 ] * 60 + $ASSTARTTIMEPART [ 3 ]
		$IENDTIMEINSECS = $ASENDTIMEPART [ 1 ] * 3600 + $ASENDTIMEPART [ 2 ] * 60 + $ASENDTIMEPART [ 3 ]
		$ITIMEDIFF = $IENDTIMEINSECS - $ISTARTTIMEINSECS
		If $ITIMEDIFF < 0 Then
			$ADAYSDIFF = $ADAYSDIFF + 4294967295
			$ITIMEDIFF = $ITIMEDIFF + 24 * 60 * 60
		EndIf
	Else
		$ITIMEDIFF = 0
	EndIf
	Select
	Case $STYPE = "d"
		Return $ADAYSDIFF
	Case $STYPE = "m"
		$IYEARDIFF = $ASENDDATEPART [ 1 ] - $ASSTARTDATEPART [ 1 ]
		Local $IMONTHDIFF = $ASENDDATEPART [ 2 ] - $ASSTARTDATEPART [ 2 ] + $IYEARDIFF * 12
		If $ASENDDATEPART [ 3 ] < $ASSTARTDATEPART [ 3 ] Then $IMONTHDIFF = $IMONTHDIFF + 4294967295
		$ISTARTTIMEINSECS = $ASSTARTTIMEPART [ 1 ] * 3600 + $ASSTARTTIMEPART [ 2 ] * 60 + $ASSTARTTIMEPART [ 3 ]
		$IENDTIMEINSECS = $ASENDTIMEPART [ 1 ] * 3600 + $ASENDTIMEPART [ 2 ] * 60 + $ASENDTIMEPART [ 3 ]
		$ITIMEDIFF = $IENDTIMEINSECS - $ISTARTTIMEINSECS
		If $ASENDDATEPART [ 3 ] = $ASSTARTDATEPART [ 3 ] And $ITIMEDIFF < 0 Then $IMONTHDIFF = $IMONTHDIFF + 4294967295
		Return $IMONTHDIFF
	Case $STYPE = "y"
		$IYEARDIFF = $ASENDDATEPART [ 1 ] - $ASSTARTDATEPART [ 1 ]
		If $ASENDDATEPART [ 2 ] < $ASSTARTDATEPART [ 2 ] Then $IYEARDIFF = $IYEARDIFF + 4294967295
		If $ASENDDATEPART [ 2 ] = $ASSTARTDATEPART [ 2 ] And $ASENDDATEPART [ 3 ] < $ASSTARTDATEPART [ 3 ] Then $IYEARDIFF = $IYEARDIFF + 4294967295
		$ISTARTTIMEINSECS = $ASSTARTTIMEPART [ 1 ] * 3600 + $ASSTARTTIMEPART [ 2 ] * 60 + $ASSTARTTIMEPART [ 3 ]
		$IENDTIMEINSECS = $ASENDTIMEPART [ 1 ] * 3600 + $ASENDTIMEPART [ 2 ] * 60 + $ASENDTIMEPART [ 3 ]
		$ITIMEDIFF = $IENDTIMEINSECS - $ISTARTTIMEINSECS
		If $ASENDDATEPART [ 2 ] = $ASSTARTDATEPART [ 2 ] And $ASENDDATEPART [ 3 ] = $ASSTARTDATEPART [ 3 ] And $ITIMEDIFF < 0 Then $IYEARDIFF = $IYEARDIFF + 4294967295
		Return $IYEARDIFF
	Case $STYPE = "w"
		Return Int ( $ADAYSDIFF / 7 )
	Case $STYPE = "h"
		Return $ADAYSDIFF * 24 + Int ( $ITIMEDIFF / 3600 )
	Case $STYPE = "n"
		Return $ADAYSDIFF * 24 * 60 + Int ( $ITIMEDIFF / 60 )
	Case $STYPE = "s"
		Return $ADAYSDIFF * 24 * 60 * 60 + $ITIMEDIFF
	EndSelect
EndFunc
Func _DATEISLEAPYEAR ( $IYEAR )
	If StringIsInt ( $IYEAR ) Then
		Select
		Case Mod ( $IYEAR , 4 ) = 0 And Mod ( $IYEAR , 100 ) <> 0
			Return 1
		Case Mod ( $IYEAR , 400 ) = 0
			Return 1
	Case Else
			Return 0
		EndSelect
	EndIf
	Return SetError ( 1 , 0 , 0 )
EndFunc
Func _DATEISVALID ( $SDATE )
	Local $ASDATEPART [ 4 ] , $ASTIMEPART [ 4 ]
	_DATETIMESPLIT ( $SDATE , $ASDATEPART , $ASTIMEPART )
	If @error Then Return 0
	If Not StringIsInt ( $ASDATEPART [ 1 ] ) Then Return 0
	If Not StringIsInt ( $ASDATEPART [ 2 ] ) Then Return 0
	If Not StringIsInt ( $ASDATEPART [ 3 ] ) Then Return 0
	$ASDATEPART [ 1 ] = Int ( $ASDATEPART [ 1 ] )
	$ASDATEPART [ 2 ] = Int ( $ASDATEPART [ 2 ] )
	$ASDATEPART [ 3 ] = Int ( $ASDATEPART [ 3 ] )
	Local $INUMDAYS = _DAYSINMONTH ( $ASDATEPART [ 1 ] )
	If $ASDATEPART [ 1 ] < 1000 Or $ASDATEPART [ 1 ] > 2999 Then Return 0
	If $ASDATEPART [ 2 ] < 1 Or $ASDATEPART [ 2 ] > 12 Then Return 0
	If $ASDATEPART [ 3 ] < 1 Or $ASDATEPART [ 3 ] > $INUMDAYS [ $ASDATEPART [ 2 ] ] Then Return 0
	If $ASTIMEPART [ 0 ] < 1 Then Return 1
	If $ASTIMEPART [ 0 ] < 2 Then Return 0
	If $ASTIMEPART [ 0 ] = 2 Then $ASTIMEPART [ 3 ] = "00"
	If Not StringIsInt ( $ASTIMEPART [ 1 ] ) Then Return 0
	If Not StringIsInt ( $ASTIMEPART [ 2 ] ) Then Return 0
	If Not StringIsInt ( $ASTIMEPART [ 3 ] ) Then Return 0
	$ASTIMEPART [ 1 ] = Int ( $ASTIMEPART [ 1 ] )
	$ASTIMEPART [ 2 ] = Int ( $ASTIMEPART [ 2 ] )
	$ASTIMEPART [ 3 ] = Int ( $ASTIMEPART [ 3 ] )
	If $ASTIMEPART [ 1 ] < 0 Or $ASTIMEPART [ 1 ] > 23 Then Return 0
	If $ASTIMEPART [ 2 ] < 0 Or $ASTIMEPART [ 2 ] > 59 Then Return 0
	If $ASTIMEPART [ 3 ] < 0 Or $ASTIMEPART [ 3 ] > 59 Then Return 0
	Return 1
EndFunc
Func _DATETIMESPLIT ( $SDATE , ByRef $ADATEPART , ByRef $ATIMEPART )
	Local $SDATETIME = StringSplit ( $SDATE , " T" )
	If $SDATETIME [ 0 ] > 0 Then $ADATEPART = StringSplit ( $SDATETIME [ 1 ] , "/-." )
	Local $NFIELDS = UBound ( $ADATEPART )
	If $NFIELDS <> 4 Then Return SetError ( 1 , 0 , 0 )
	If $SDATETIME [ 0 ] > 1 Then
		$ATIMEPART = StringSplit ( $SDATETIME [ 2 ] , ":" )
		$NFIELDS = UBound ( $ATIMEPART )
		If ( $NFIELDS < 3 ) Or ( $NFIELDS > 4 ) Then Return SetError ( 2 , 0 , 0 )
		If $NFIELDS < 4 Then
			ReDim $ATIMEPART [ 4 ]
			$ATIMEPART [ 3 ] = 0
		EndIf
	Else
		Dim $ATIMEPART [ 4 ]
	EndIf
	For $X = 1 To 3
		$ADATEPART [ $X ] = Int ( $ADATEPART [ $X ] )
		$ATIMEPART [ $X ] = Int ( $ATIMEPART [ $X ] )
	Next
	Return 1
EndFunc
Func _DATETODAYVALUE ( $IYEAR , $IMONTH , $IDAY )
	If Not _DATEISVALID ( StringFormat ( "%04d/%02d/%02d" , $IYEAR , $IMONTH , $IDAY ) ) Then
		Return SetError ( 1 , 0 , "" )
	EndIf
	If $IMONTH < 3 Then
		$IMONTH = $IMONTH + 12
		$IYEAR = $IYEAR + 4294967295
	EndIf
	Local $I_FACTORA = Int ( $IYEAR / 100 )
	Local $I_FACTORB = Int ( $I_FACTORA / 4 )
	Local $I_FACTORC = 2 - $I_FACTORA + $I_FACTORB
	Local $I_FACTORE = Int ( 1461 * ( $IYEAR + 4716 ) / 4 )
	Local $I_FACTORF = Int ( 153 * ( $IMONTH + 1 ) / 5 )
	Local $IJULIANDATE = $I_FACTORC + $IDAY + $I_FACTORE + $I_FACTORF - 1524.5
	Return $IJULIANDATE
EndFunc
Func _DAYVALUETODATE ( $IJULIANDATE , ByRef $IYEAR , ByRef $IMONTH , ByRef $IDAY )
	If $IJULIANDATE < 0 Or Not IsNumber ( $IJULIANDATE ) Then
		Return SetError ( 1 , 0 , 0 )
	EndIf
	Local $I_FACTORZ = Int ( $IJULIANDATE + 0.5 )
	Local $I_FACTORW = Int ( ( $I_FACTORZ - 1867216.25 ) / 36524.25 )
	Local $I_FACTORX = Int ( $I_FACTORW / 4 )
	Local $I_FACTORA = $I_FACTORZ + 1 + $I_FACTORW - $I_FACTORX
	Local $I_FACTORB = $I_FACTORA + 1524
	Local $I_FACTORC = Int ( ( $I_FACTORB - 122.1 ) / 365.25 )
	Local $I_FACTORD = Int ( 365.25 * $I_FACTORC )
	Local $I_FACTORE = Int ( ( $I_FACTORB - $I_FACTORD ) / 30.6001 )
	Local $I_FACTORF = Int ( 30.6001 * $I_FACTORE )
	$IDAY = $I_FACTORB - $I_FACTORD - $I_FACTORF
	If $I_FACTORE + 4294967295 < 13 Then
		$IMONTH = $I_FACTORE + 4294967295
	Else
		$IMONTH = $I_FACTORE + 4294967283
	EndIf
	If $IMONTH < 3 Then
		$IYEAR = $I_FACTORC + 4294962581
	Else
		$IYEAR = $I_FACTORC + 4294962580
	EndIf
	$IYEAR = StringFormat ( "%04d" , $IYEAR )
	$IMONTH = StringFormat ( "%02d" , $IMONTH )
	$IDAY = StringFormat ( "%02d" , $IDAY )
	Return $IYEAR & "/" & $IMONTH & "/" & $IDAY
EndFunc
Func _NOWCALC ( )
	Local $TLOCALTIME = _DATE_TIME_GETLOCALTIME ( )
	If @error Then Return SetError ( @error , @extended , "" )
	Return $TLOCALTIME .Year & "/" & StringRight ( "00" & $TLOCALTIME .Month , 2 ) & "/" & StringRight ( "00" & $TLOCALTIME .Day , 2 ) & " " & StringRight ( "00" & $TLOCALTIME .Hour , 2 ) & ":" & StringRight ( "00" & $TLOCALTIME .Minute , 2 ) & ":" & StringRight ( "00" & $TLOCALTIME .Second , 2 )
EndFunc
Func _NOWCALCDATE ( )
	Local $TLOCALTIME = _DATE_TIME_GETLOCALTIME ( )
	If @error Then Return SetError ( @error , @extended , "" )
	Return $TLOCALTIME .Year & "/" & StringRight ( "00" & $TLOCALTIME .Month , 2 ) & "/" & StringRight ( "00" & $TLOCALTIME .Day , 2 )
EndFunc
Func _TICKSTOTIME ( $ITICKS , ByRef $IHOURS , ByRef $IMINS , ByRef $ISECS )
	If Number ( $ITICKS ) > 0 Then
		$ITICKS = Int ( $ITICKS / 1000 )
		$IHOURS = Int ( $ITICKS / 3600 )
		$ITICKS = Mod ( $ITICKS , 3600 )
		$IMINS = Int ( $ITICKS / 60 )
		$ISECS = Mod ( $ITICKS , 60 )
		Return 1
	ElseIf Number ( $ITICKS ) = 0 Then
		$IHOURS = 0
		$ITICKS = 0
		$IMINS = 0
		$ISECS = 0
		Return 1
	Else
		Return SetError ( 1 , 0 , 0 )
	EndIf
EndFunc
Func _TIMETOTICKS ( $IHOURS = Default , $IMINS = Default , $ISECS = Default )
	If $IHOURS = Default Or $IMINS = Default Or $ISECS = Default Then
		Local $TLOCALTIME = _DATE_TIME_GETLOCALTIME ( )
		If @error Then Return SetError ( @error , @extended , 0 )
		If $IHOURS = Default Then $IHOURS = $TLOCALTIME .Hour
		If $IMINS = Default Then $IMINS = $TLOCALTIME .Minute
		If $ISECS = Default Then $ISECS = $TLOCALTIME .Second
	EndIf
	If StringIsInt ( $IHOURS ) And StringIsInt ( $IMINS ) And StringIsInt ( $ISECS ) Then
		Local $ITICKS = 1000 * ( ( 3600 * $IHOURS ) + ( 60 * $IMINS ) + $ISECS )
		Return $ITICKS
	Else
		Return SetError ( 1 , 0 , 0 )
	EndIf
EndFunc
Func _DAYSINMONTH ( $IYEAR )
	Local $ADAYS = [ 12 , 31 , ( _DATEISLEAPYEAR ( $IYEAR ) ? 29 : 28 ) , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ]
	Return $ADAYS
EndFunc
Func _DATE_TIME_ENCODEFILETIME ( $IMONTH , $IDAY , $IYEAR , $IHOUR = 0 , $IMINUTE = 0 , $ISECOND = 0 , $IMSECONDS = 0 )
	Local $TSYSTEMTIME = _DATE_TIME_ENCODESYSTEMTIME ( $IMONTH , $IDAY , $IYEAR , $IHOUR , $IMINUTE , $ISECOND , $IMSECONDS )
	Return _DATE_TIME_SYSTEMTIMETOFILETIME ( $TSYSTEMTIME )
EndFunc
Func _DATE_TIME_ENCODESYSTEMTIME ( $IMONTH , $IDAY , $IYEAR , $IHOUR = 0 , $IMINUTE = 0 , $ISECOND = 0 , $IMSECONDS = 0 )
	Local $TSYSTEMTIME = DllStructCreate ( $TAGSYSTEMTIME )
	DllStructSetData ( $TSYSTEMTIME , "Month" , $IMONTH )
	DllStructSetData ( $TSYSTEMTIME , "Day" , $IDAY )
	DllStructSetData ( $TSYSTEMTIME , "Year" , $IYEAR )
	DllStructSetData ( $TSYSTEMTIME , "Hour" , $IHOUR )
	DllStructSetData ( $TSYSTEMTIME , "Minute" , $IMINUTE )
	DllStructSetData ( $TSYSTEMTIME , "Second" , $ISECOND )
	DllStructSetData ( $TSYSTEMTIME , "MSeconds" , $IMSECONDS )
	Return $TSYSTEMTIME
EndFunc
Func _DATE_TIME_FILETIMETOARRAY ( ByRef $TFILETIME )
	If ( ( DllStructGetData ( $TFILETIME , 1 ) + DllStructGetData ( $TFILETIME , 2 ) ) = 0 ) Then Return SetError ( 10 , 0 , 0 )
	Local $TSYSTEMTIME = _DATE_TIME_FILETIMETOSYSTEMTIME ( $TFILETIME )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return _DATE_TIME_SYSTEMTIMETOARRAY ( $TSYSTEMTIME )
EndFunc
Func _DATE_TIME_FILETIMETOSTR ( ByRef $TFILETIME , $IFMT = 0 )
	Local $ADATE = _DATE_TIME_FILETIMETOARRAY ( $TFILETIME )
	If @error Then Return SetError ( @error , @extended , "" )
	If $IFMT Then
		Return StringFormat ( "%04d/%02d/%02d %02d:%02d:%02d" , $ADATE [ 2 ] , $ADATE [ 0 ] , $ADATE [ 1 ] , $ADATE [ 3 ] , $ADATE [ 4 ] , $ADATE [ 5 ] )
	Else
		Return StringFormat ( "%02d/%02d/%04d %02d:%02d:%02d" , $ADATE [ 0 ] , $ADATE [ 1 ] , $ADATE [ 2 ] , $ADATE [ 3 ] , $ADATE [ 4 ] , $ADATE [ 5 ] )
	EndIf
EndFunc
Func _DATE_TIME_FILETIMETOLOCALFILETIME ( $TFILETIME )
	Local $TLOCAL = DllStructCreate ( $TAGFILETIME )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "FileTimeToLocalFileTime" , "struct*" , $TFILETIME , "struct*" , $TLOCAL )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return SetExtended ( $ACALL [ 0 ] , $TLOCAL )
EndFunc
Func _DATE_TIME_FILETIMETOSYSTEMTIME ( $TFILETIME )
	Local $TSYSTTIME = DllStructCreate ( $TAGSYSTEMTIME )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "FileTimeToSystemTime" , "struct*" , $TFILETIME , "struct*" , $TSYSTTIME )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return SetExtended ( $ACALL [ 0 ] , $TSYSTTIME )
EndFunc
Func _DATE_TIME_GETFILETIME ( $HFILE )
	Local $ADATE [ 3 ]
	$ADATE [ 0 ] = DllStructCreate ( $TAGFILETIME )
	$ADATE [ 1 ] = DllStructCreate ( $TAGFILETIME )
	$ADATE [ 2 ] = DllStructCreate ( $TAGFILETIME )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "GetFileTime" , "handle" , $HFILE , "struct*" , $ADATE [ 0 ] , "struct*" , $ADATE [ 1 ] , "struct*" , $ADATE [ 2 ] )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return SetExtended ( $ACALL [ 0 ] , $ADATE )
EndFunc
Func _DATE_TIME_GETLOCALTIME ( )
	Local $TLOCALTIME = DllStructCreate ( $TAGSYSTEMTIME )
	DllCall ( "kernel32.dll" , "none" , "GetLocalTime" , "struct*" , $TLOCALTIME )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $TLOCALTIME
EndFunc
Func _DATE_TIME_SYSTEMTIMETOARRAY ( ByRef $TSYSTEMTIME )
	Local $AINFO [ 8 ]
	$AINFO [ 0 ] = DllStructGetData ( $TSYSTEMTIME , "Month" )
	$AINFO [ 1 ] = DllStructGetData ( $TSYSTEMTIME , "Day" )
	$AINFO [ 2 ] = DllStructGetData ( $TSYSTEMTIME , "Year" )
	$AINFO [ 3 ] = DllStructGetData ( $TSYSTEMTIME , "Hour" )
	$AINFO [ 4 ] = DllStructGetData ( $TSYSTEMTIME , "Minute" )
	$AINFO [ 5 ] = DllStructGetData ( $TSYSTEMTIME , "Second" )
	$AINFO [ 6 ] = DllStructGetData ( $TSYSTEMTIME , "MSeconds" )
	$AINFO [ 7 ] = DllStructGetData ( $TSYSTEMTIME , "DOW" )
	Return $AINFO
EndFunc
Func _DATE_TIME_SYSTEMTIMETOFILETIME ( $TSYSTEMTIME )
	Local $TFILETIME = DllStructCreate ( $TAGFILETIME )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "SystemTimeToFileTime" , "struct*" , $TSYSTEMTIME , "struct*" , $TFILETIME )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return SetExtended ( $ACALL [ 0 ] , $TFILETIME )
EndFunc
Global Const $HGDI_ERROR = Ptr ( + 4294967295 )
Global Const $INVALID_HANDLE_VALUE = Ptr ( + 4294967295 )
Global Const $LLKHF_EXTENDED = BitShift ( 256 , 8 )
Global Const $LLKHF_ALTDOWN = BitShift ( 8192 , 8 )
Global Const $LLKHF_UP = BitShift ( 32768 , 8 )
Func _WINAPI_GUIDFROMSTRING ( $SGUID )
	Local $TGUID = DllStructCreate ( $TAGGUID )
	If Not _WINAPI_GUIDFROMSTRINGEX ( $SGUID , $TGUID ) Then Return SetError ( @error , @extended , 0 )
	Return $TGUID
EndFunc
Func _WINAPI_GUIDFROMSTRINGEX ( $SGUID , $TGUID )
	Local $ACALL = DllCall ( "ole32.dll" , "long" , "CLSIDFromString" , "wstr" , $SGUID , "struct*" , $TGUID )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _WINAPI_HIWORD ( $ILONG )
	Return BitShift ( $ILONG , 16 )
EndFunc
Func _WINAPI_LOWORD ( $ILONG )
	Return BitAND ( $ILONG , 65535 )
EndFunc
Func _WINAPI_MAKELONG ( $ILO , $IHI )
	Return BitOR ( BitShift ( $IHI , + 4294967280 ) , BitAND ( $ILO , 65535 ) )
EndFunc
Func _WINAPI_MULTIBYTETOWIDECHAR ( $VTEXT , $ICODEPAGE = 0 , $IFLAGS = 0 , $BRETSTRING = False )
	Local $STEXTTYPE = ""
	If IsString ( $VTEXT ) Then $STEXTTYPE = "str"
	If ( IsDllStruct ( $VTEXT ) Or IsPtr ( $VTEXT ) ) Then $STEXTTYPE = "struct*"
	If $STEXTTYPE = "" Then Return SetError ( 1 , 0 , 0 )
	Local $ACALL = DllCall ( "kernel32.dll" , "int" , "MultiByteToWideChar" , "uint" , $ICODEPAGE , "dword" , $IFLAGS , $STEXTTYPE , $VTEXT , "int" , + 4294967295 , "ptr" , 0 , "int" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Local $IOUT = $ACALL [ 0 ]
	Local $TOUT = DllStructCreate ( "wchar[" & $IOUT & "]" )
	$ACALL = DllCall ( "kernel32.dll" , "int" , "MultiByteToWideChar" , "uint" , $ICODEPAGE , "dword" , $IFLAGS , $STEXTTYPE , $VTEXT , "int" , + 4294967295 , "struct*" , $TOUT , "int" , $IOUT )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 20 , @extended , 0 )
	If $BRETSTRING Then Return DllStructGetData ( $TOUT , 1 )
	Return $TOUT
EndFunc
Func _WINAPI_COINITIALIZE ( $IFLAGS = 0 )
	Local $ACALL = DllCall ( "ole32.dll" , "long" , "CoInitializeEx" , "ptr" , 0 , "dword" , $IFLAGS )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return 1
EndFunc
Global $__G_HHEAP = 0
Func _WINAPI_FREEMEMORY ( $PMEMORY )
	If Not __HEAPFREE ( $PMEMORY , 1 ) Then Return SetError ( @error , @extended , 0 )
	Return 1
EndFunc
Func __HEAPALLOC ( $ISIZE , $BABORT = False )
	Local $ACALL
	If Not $__G_HHEAP Then
		$ACALL = DllCall ( "kernel32.dll" , "handle" , "HeapCreate" , "dword" , 0 , "ulong_ptr" , 0 , "ulong_ptr" , 0 )
		If @error Or Not $ACALL [ 0 ] Then __FATALEXIT ( 1 , "Error allocating memory." )
		$__G_HHEAP = $ACALL [ 0 ]
	EndIf
	$ACALL = DllCall ( "kernel32.dll" , "ptr" , "HeapAlloc" , "handle" , $__G_HHEAP , "dword" , 8 , "ulong_ptr" , $ISIZE )
	If @error Or Not $ACALL [ 0 ] Then
		If $BABORT Then __FATALEXIT ( 1 , "Error allocating memory." )
		Return SetError ( @error + 30 , @extended , 0 )
	EndIf
	Return $ACALL [ 0 ]
EndFunc
Func __HEAPFREE ( ByRef $PMEMORY , $BCHECK = False , $ICURERR = @error , $ICUREXT = @extended )
	If $BCHECK And ( Not __HEAPVALIDATE ( $PMEMORY ) ) Then Return SetError ( @error , @extended , 0 )
	Local $ACALL = DllCall ( "kernel32.dll" , "int" , "HeapFree" , "handle" , $__G_HHEAP , "dword" , 0 , "ptr" , $PMEMORY )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 40 , @extended , 0 )
	$PMEMORY = 0
	Return SetError ( $ICURERR , $ICUREXT , 1 )
EndFunc
Func __HEAPREALLOC ( $PMEMORY , $ISIZE , $BAMOUNT = False , $BABORT = False )
	Local $PRET
	If __HEAPVALIDATE ( $PMEMORY ) Then
		If $BAMOUNT And ( __HEAPSIZE ( $PMEMORY ) >= $ISIZE ) Then Return SetExtended ( 1 , Ptr ( $PMEMORY ) )
		Local $ACALL = DllCall ( "kernel32.dll" , "ptr" , "HeapReAlloc" , "handle" , $__G_HHEAP , "dword" , 8 , "ptr" , $PMEMORY , "ulong_ptr" , $ISIZE )
		If @error Or Not $ACALL [ 0 ] Then
			If $BABORT Then __FATALEXIT ( 1 , "Error allocating memory." )
			Return SetError ( @error + 20 , @extended , Ptr ( $PMEMORY ) )
		EndIf
		$PRET = $ACALL [ 0 ]
	Else
		$PRET = __HEAPALLOC ( $ISIZE , $BABORT )
		If @error Then Return SetError ( @error , @extended , 0 )
	EndIf
	Return $PRET
EndFunc
Func __HEAPSIZE ( $PMEMORY , $BCHECK = False )
	If $BCHECK And ( Not __HEAPVALIDATE ( $PMEMORY ) ) Then Return SetError ( @error , @extended , 0 )
	Local $ACALL = DllCall ( "kernel32.dll" , "ulong_ptr" , "HeapSize" , "handle" , $__G_HHEAP , "dword" , 0 , "ptr" , $PMEMORY )
	If @error Or ( $ACALL [ 0 ] = Ptr ( + 4294967295 ) ) Then Return SetError ( @error + 50 , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func __HEAPVALIDATE ( $PMEMORY )
	If ( Not $__G_HHEAP ) Or ( Not Ptr ( $PMEMORY ) ) Then Return SetError ( 9 , 0 , False )
	Local $ACALL = DllCall ( "kernel32.dll" , "int" , "HeapValidate" , "handle" , $__G_HHEAP , "dword" , 0 , "ptr" , $PMEMORY )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_STRINGLENW ( Const ByRef $TSTRING )
	Local $ACALL = DllCall ( "kernel32.dll" , "int" , "lstrlenW" , "struct*" , $TSTRING )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Global Const $SHERB_NO_UI = BitOR ( 1 , 2 , 4 )
Func _WINAPI_SHELLEMPTYRECYCLEBIN ( $SROOT = "" , $IFLAGS = 0 , $HPARENT = 0 )
	Local $ACALL = DllCall ( "shell32.dll" , "long" , "SHEmptyRecycleBinW" , "hwnd" , $HPARENT , "wstr" , $SROOT , "dword" , $IFLAGS )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return 1
EndFunc
Func _WINAPI_SHELLQUERYRECYCLEBIN ( $SROOT = "" )
	Local $TAGSHQUERYRBINFO = ( @AutoItX64 ? "" : "align 1;" ) & "dword cbSize;int64 Size;int64 nbFiles"
	Local $TSHQRBI = DllStructCreate ( $TAGSHQUERYRBINFO )
	DllStructSetData ( $TSHQRBI , 1 , DllStructGetSize ( $TSHQRBI ) )
	Local $ACALL = DllCall ( "shell32.dll" , "long" , "SHQueryRecycleBinW" , "wstr" , $SROOT , "struct*" , $TSHQRBI )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Local $ARET [ 2 ]
	$ARET [ 0 ] = DllStructGetData ( $TSHQRBI , 2 )
	$ARET [ 1 ] = DllStructGetData ( $TSHQRBI , 3 )
	Return $ARET
EndFunc
Global Const $FSCTL_DELETE_REPARSE_POINT = 589996
Global Const $FSCTL_GET_REPARSE_POINT = 589992
Func _WINAPI_CREATEFILEEX ( $SFILEPATH , $ICREATION , $IACCESS = 0 , $ISHARE = 0 , $IFLAGSANDATTRIBUTES = 0 , $TSECURITY = 0 , $HTEMPLATE = 0 )
	Local $ACALL = DllCall ( "kernel32.dll" , "handle" , "CreateFileW" , "wstr" , $SFILEPATH , "dword" , $IACCESS , "dword" , $ISHARE , "struct*" , $TSECURITY , "dword" , $ICREATION , "dword" , $IFLAGSANDATTRIBUTES , "handle" , $HTEMPLATE )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] = Ptr ( + 4294967295 ) Then Return SetError ( 10 , _WINAPI_GETLASTERROR ( ) , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_CREATESYMBOLICLINK ( $SSYMLINK , $STARGET , $BDIRECTORY = False )
	If $BDIRECTORY Then
		$BDIRECTORY = 1
	EndIf
	Local $ACALL = DllCall ( "kernel32.dll" , "boolean" , "CreateSymbolicLinkW" , "wstr" , $SSYMLINK , "wstr" , $STARGET , "dword" , $BDIRECTORY )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_DEVICEIOCONTROL ( $HDEVICE , $ICONTROLCODE , $PINBUFFER = 0 , $IINBUFFERSIZE = 0 , $POUTBUFFER = 0 , $IOUTBUFFERSIZE = 0 )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "DeviceIoControl" , "handle" , $HDEVICE , "dword" , $ICONTROLCODE , "struct*" , $PINBUFFER , "dword" , $IINBUFFERSIZE , "struct*" , $POUTBUFFER , "dword" , $IOUTBUFFERSIZE , "dword*" , 0 , "ptr" , 0 )
	If @error Then Return SetError ( @error , @extended , False )
	Return SetExtended ( $ACALL [ 7 ] , $ACALL [ 0 ] )
EndFunc
Func _WINAPI_FINDCLOSE ( $HSEARCH )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "FindClose" , "handle" , $HSEARCH )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_FINDFIRSTFILE ( $SFILEPATH , $TDATA )
	Local $ACALL = DllCall ( "kernel32.dll" , "handle" , "FindFirstFileW" , "wstr" , $SFILEPATH , "struct*" , $TDATA )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] = Ptr ( + 4294967295 ) Then Return SetError ( 10 , _WINAPI_GETLASTERROR ( ) , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETPROFILESDIRECTORY ( )
	Local $ACALL = DllCall ( "userenv.dll" , "bool" , "GetProfilesDirectoryW" , "wstr" , "" , "dword*" , 4096 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , "" )
	Return $ACALL [ 1 ]
EndFunc
Func _WINAPI_SETFILEPOINTER ( $HFILE , $IPOS , $IMETHOD = 0 )
	Local $ACALL = DllCall ( "kernel32.dll" , "INT" , "SetFilePointer" , "handle" , $HFILE , "long" , $IPOS , "ptr" , 0 , "long" , $IMETHOD )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	Return $ACALL [ 0 ]
EndFunc
Global Const $TAGPROCESSENTRY32 = "dword Size;dword Usage;dword ProcessID;ulong_ptr DefaultHeapID;dword ModuleID;dword Threads;dword ParentProcessID;long PriClassBase;dword Flags;wchar ExeFile[260]"
Func _WINAPI_GETPARENTPROCESS ( $IPID = 0 )
	If Not $IPID Then $IPID = @AutoItPID
	Local $HSNAPSHOT = DllCall ( "kernel32.dll" , "handle" , "CreateToolhelp32Snapshot" , "dword" , 2 , "dword" , 0 )
	If @error Or Not $HSNAPSHOT [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Local $TPROCESSENTRY32 = DllStructCreate ( $TAGPROCESSENTRY32 )
	Local $IRESULT = 0
	$HSNAPSHOT = $HSNAPSHOT [ 0 ]
	DllStructSetData ( $TPROCESSENTRY32 , "Size" , DllStructGetSize ( $TPROCESSENTRY32 ) )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "Process32FirstW" , "handle" , $HSNAPSHOT , "struct*" , $TPROCESSENTRY32 )
	Local $IERROR = @error
	While ( Not @error ) And ( $ACALL [ 0 ] )
		If DllStructGetData ( $TPROCESSENTRY32 , "ProcessID" ) = $IPID Then
			$IRESULT = DllStructGetData ( $TPROCESSENTRY32 , "ParentProcessID" )
			ExitLoop
		EndIf
		$ACALL = DllCall ( "kernel32.dll" , "bool" , "Process32NextW" , "handle" , $HSNAPSHOT , "struct*" , $TPROCESSENTRY32 )
		$IERROR = @error
	WEnd
	DllCall ( "kernel32.dll" , "bool" , "CloseHandle" , "handle" , $HSNAPSHOT )
	If Not $IRESULT Then Return SetError ( $IERROR , 0 , 0 )
	Return $IRESULT
EndFunc
Func _WINAPI_OPENPROCESS ( $IACCESS , $BINHERIT , $IPID , $BDEBUGPRIV = False )
	Local $ACALL = DllCall ( "kernel32.dll" , "handle" , "OpenProcess" , "dword" , $IACCESS , "bool" , $BINHERIT , "dword" , $IPID )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return $ACALL [ 0 ]
	If Not $BDEBUGPRIV Then Return SetError ( 100 , 0 , 0 )
	Local $HTOKEN = _SECURITY__OPENTHREADTOKENEX ( BitOR ( 32 , 8 ) )
	If @error Then Return SetError ( @error + 10 , @extended , 0 )
	_SECURITY__SETPRIVILEGE ( $HTOKEN , $SE_DEBUG_NAME , True )
	Local $IERROR = @error
	Local $IEXTENDED = @extended
	Local $IRET = 0
	If Not @error Then
		$ACALL = DllCall ( "kernel32.dll" , "handle" , "OpenProcess" , "dword" , $IACCESS , "bool" , $BINHERIT , "dword" , $IPID )
		$IERROR = @error
		$IEXTENDED = @extended
		If $ACALL [ 0 ] Then $IRET = $ACALL [ 0 ]
		_SECURITY__SETPRIVILEGE ( $HTOKEN , $SE_DEBUG_NAME , False )
		If @error Then
			$IERROR = @error + 20
			$IEXTENDED = @extended
		EndIf
	Else
		$IERROR = @error + 30
	EndIf
	DllCall ( "kernel32.dll" , "bool" , "CloseHandle" , "handle" , $HTOKEN )
	Return SetError ( $IERROR , $IEXTENDED , $IRET )
EndFunc
Func _WINAPI_GETFILEVERSIONINFO ( $SFILEPATH , ByRef $PBUFFER , $IFLAGS = 0 )
	Local $ACALL
	If _WINAPI_GETVERSION ( ) >= 6.0 Then
		$ACALL = DllCall ( "version.dll" , "dword" , "GetFileVersionInfoSizeExW" , "dword" , BitAND ( $IFLAGS , 3 ) , "wstr" , $SFILEPATH , "ptr" , 0 )
	Else
		$ACALL = DllCall ( "version.dll" , "dword" , "GetFileVersionInfoSizeW" , "wstr" , $SFILEPATH , "ptr" , 0 )
	EndIf
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , 0 )
	$PBUFFER = __HEAPREALLOC ( $PBUFFER , $ACALL [ 0 ] , 1 )
	If @error Then Return SetError ( @error + 100 , @extended , 0 )
	Local $INBBYTE = $ACALL [ 0 ]
	If _WINAPI_GETVERSION ( ) >= 6.0 Then
		$ACALL = DllCall ( "version.dll" , "bool" , "GetFileVersionInfoExW" , "dword" , BitAND ( $IFLAGS , 7 ) , "wstr" , $SFILEPATH , "dword" , 0 , "dword" , $INBBYTE , "ptr" , $PBUFFER )
	Else
		$ACALL = DllCall ( "version.dll" , "bool" , "GetFileVersionInfoW" , "wstr" , $SFILEPATH , "dword" , 0 , "dword" , $INBBYTE , "ptr" , $PBUFFER )
	EndIf
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Return $INBBYTE
EndFunc
Func _WINAPI_LOADINDIRECTSTRING ( $SSTRIN )
	Local $ACALL = DllCall ( "shlwapi.dll" , "uint" , "SHLoadIndirectString" , "wstr" , $SSTRIN , "wstr" , "" , "uint" , 4096 , "ptr*" , 0 )
	If @error Then Return SetError ( @error , @extended , "" )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , "" )
	Return $ACALL [ 2 ]
EndFunc
Func _WINAPI_LOADSTRING ( $HINSTANCE , $ISTRINGID )
	Local $ACALL = DllCall ( "user32.dll" , "int" , "LoadStringW" , "handle" , $HINSTANCE , "uint" , $ISTRINGID , "wstr" , "" , "int" , 4096 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , "" )
	Return SetExtended ( $ACALL [ 0 ] , $ACALL [ 3 ] )
EndFunc
Func _WINAPI_LOADLIBRARYEX ( $SFILENAME , $IFLAGS = 0 )
	Local $ACALL = DllCall ( "kernel32.dll" , "handle" , "LoadLibraryExW" , "wstr" , $SFILENAME , "ptr" , 0 , "dword" , $IFLAGS )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_VERQUERYVALUE ( $PDATA , $SVALUES = "" )
	$SVALUES = StringRegExpReplace ( $SVALUES , "\A[\s\|]*|[\s\|]*\Z" , "" )
	If Not $SVALUES Then
		$SVALUES = "Comments|CompanyName|FileDescription|FileVersion|InternalName|LegalCopyright|LegalTrademarks|OriginalFilename|ProductName|ProductVersion|PrivateBuild|SpecialBuild"
	EndIf
	$SVALUES = StringSplit ( $SVALUES , "|" , 2 )
	Local $ACALL = DllCall ( "version.dll" , "bool" , "VerQueryValueW" , "ptr" , $PDATA , "wstr" , "\VarFileInfo\Translation" , "ptr*" , 0 , "uint*" , 0 )
	If @error Or Not $ACALL [ 0 ] Or Not $ACALL [ 4 ] Then Return SetError ( @error + 10 , 0 , 0 )
	Local $ILENGTH = Floor ( $ACALL [ 4 ] / 4 )
	Local $TLANG = DllStructCreate ( "dword[" & $ILENGTH & "]" , $ACALL [ 3 ] )
	If @error Then Return SetError ( @error + 20 , 0 , 0 )
	Local $SCP , $AINFO [ 101 ] [ UBound ( $SVALUES ) + 1 ] = [ [ 0 ] ]
	For $I = 1 To $ILENGTH
		__INC ( $AINFO )
		$AINFO [ $AINFO [ 0 ] [ 0 ] ] [ 0 ] = _WINAPI_LOWORD ( DllStructGetData ( $TLANG , 1 , $I ) )
		$SCP = Hex ( _WINAPI_MAKELONG ( _WINAPI_HIWORD ( DllStructGetData ( $TLANG , 1 , $I ) ) , _WINAPI_LOWORD ( DllStructGetData ( $TLANG , 1 , $I ) ) ) , 8 )
		For $J = 0 To UBound ( $SVALUES ) + 4294967295
			$ACALL = DllCall ( "version.dll" , "bool" , "VerQueryValueW" , "ptr" , $PDATA , "wstr" , "\StringFileInfo\" & $SCP & "\" & $SVALUES [ $J ] , "ptr*" , 0 , "uint*" , 0 )
			If Not @error And $ACALL [ 0 ] And $ACALL [ 4 ] Then
				$AINFO [ $AINFO [ 0 ] [ 0 ] ] [ $J + 1 ] = DllStructGetData ( DllStructCreate ( "wchar[" & $ACALL [ 4 ] & "]" , $ACALL [ 3 ] ) , 1 )
			Else
				$AINFO [ $AINFO [ 0 ] [ 0 ] ] [ $J + 1 ] = ""
			EndIf
		Next
	Next
	__INC ( $AINFO , + 4294967295 )
	Return $AINFO
EndFunc
Func _WINAPI_EXPANDENVIRONMENTSTRINGS ( $SSTRING )
	Local $ACALL = DllCall ( "kernel32.dll" , "dword" , "ExpandEnvironmentStringsW" , "wstr" , $SSTRING , "wstr" , "" , "dword" , 4096 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , "" )
	Return $ACALL [ 2 ]
EndFunc
Global $__G_SSOURCENAME_EVENT
Func _EVENTLOG__CLOSE ( $HEVENTLOG )
	Local $ARESULT = DllCall ( "advapi32.dll" , "bool" , "CloseEventLog" , "handle" , $HEVENTLOG )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ARESULT [ 0 ] <> 0
EndFunc
Func __EVENTLOG_DECODECATEGORY ( $TEVENTLOG )
	Return DllStructGetData ( $TEVENTLOG , "EventCategory" )
EndFunc
Func __EVENTLOG_DECODECOMPUTER ( $TEVENTLOG )
	Local $PEVENTLOG = DllStructGetPtr ( $TEVENTLOG )
	Local $ILENGTH = DllStructGetData ( $TEVENTLOG , "UserSidOffset" ) + 4294967295
	Local $IOFFSET = DllStructGetSize ( $TEVENTLOG )
	$IOFFSET += 2 * ( StringLen ( __EVENTLOG_DECODESOURCE ( $TEVENTLOG ) ) + 1 )
	$ILENGTH -= $IOFFSET
	Local $TBUFFER = DllStructCreate ( "wchar Text[" & $ILENGTH & "]" , $PEVENTLOG + $IOFFSET )
	Return DllStructGetData ( $TBUFFER , "Text" )
EndFunc
Func __EVENTLOG_DECODEDATA ( $TEVENTLOG )
	Local $PEVENTLOG = DllStructGetPtr ( $TEVENTLOG )
	Local $IOFFSET = DllStructGetData ( $TEVENTLOG , "DataOffset" )
	Local $ILENGTH = DllStructGetData ( $TEVENTLOG , "DataLength" )
	Local $TBUFFER = DllStructCreate ( "byte[" & $ILENGTH & "]" , $PEVENTLOG + $IOFFSET )
	Local $ADATA [ $ILENGTH + 1 ]
	$ADATA [ 0 ] = $ILENGTH
	For $II = 1 To $ILENGTH
		$ADATA [ $II ] = DllStructGetData ( $TBUFFER , 1 , $II )
	Next
	Return $ADATA
EndFunc
Func __EVENTLOG_DECODEDATE ( $IEVENTTIME )
	Local $TINT64 = DllStructCreate ( "int64" )
	Local $PINT64 = DllStructGetPtr ( $TINT64 )
	Local $TFILETIME = DllStructCreate ( $TAGFILETIME , $PINT64 )
	DllStructSetData ( $TINT64 , 1 , ( $IEVENTTIME * 10000000 ) + 116444736000000000 )
	Local $TLOCALTIME = _DATE_TIME_FILETIMETOLOCALFILETIME ( $TFILETIME )
	Local $TSYSTTIME = _DATE_TIME_FILETIMETOSYSTEMTIME ( $TLOCALTIME )
	Local $IMONTH = DllStructGetData ( $TSYSTTIME , "Month" )
	Local $IDAY = DllStructGetData ( $TSYSTTIME , "Day" )
	Local $IYEAR = DllStructGetData ( $TSYSTTIME , "Year" )
	Return StringFormat ( "%02d/%02d/%04d" , $IMONTH , $IDAY , $IYEAR )
EndFunc
Func __EVENTLOG_DECODEDESC ( $TEVENTLOG )
	$ASTRINGS = __EVENTLOG_DECODESTRINGS ( $TEVENTLOG )
	$SSOURCE = __EVENTLOG_DECODESOURCE ( $TEVENTLOG )
	$IEVENTID = DllStructGetData ( $TEVENTLOG , "EventID" )
	$SKEY = "HKLM\SYSTEM\CurrentControlSet\Services\Eventlog\" & $__G_SSOURCENAME_EVENT & "\" & $SSOURCE
	$PROVIDERGUID = RegRead ( $SKEY , "providerGuid" )
	$MESSAGEDLL = RegRead ( $SKEY , "EventMessageFile" )
	$PARAMETERSDLL = RegRead ( $SKEY , "ParameterMessageFile" )
	If $MESSAGEDLL = "" Then
		$MESSAGEDLL = RegRead ( "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\WINEVT\Publishers\" & $PROVIDERGUID , "MessageFileName" )
		If $MESSAGEDLL = "" Then
			$MESSAGEDLL = RegRead ( "HKEY_CLASSES_ROOT\CLSID\" & $PROVIDERGUID , "MessageFileName" )
		EndIf
	EndIf
	$AMSGDLL = StringSplit ( _WINAPI_EXPANDENVIRONMENTSTRINGS ( $MESSAGEDLL ) , ";" )
	If $PARAMETERSDLL = "" Then
		$PARAMETERSDLL = RegRead ( "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\WINEVT\Publishers\" & $PROVIDERGUID , "ParameterFileName" )
		If $PARAMETERSDLL = "" Then
			$PARAMETERSDLL = RegRead ( "HKEY_CLASSES_ROOT\CLSID\" & $PROVIDERGUID , "ParameterFileName" )
		EndIf
	EndIf
	$APARAMDLL = StringSplit ( _WINAPI_EXPANDENVIRONMENTSTRINGS ( $PARAMETERSDLL ) , ";" )
	$ERRORNUMBER = 0
	$STRTEMP = ""
	$IFLAGS = BitOR ( 2048 , 512 )
	$SDESC = ""
	If $MESSAGEDLL = "" Then
		Return "Event-ID " & String ( BitAND ( DllStructGetData ( $TEVENTLOG , "EventID" ) , 32767 ) )
	Else
		For $II = 1 To $AMSGDLL [ 0 ]
			$HDLL = _WINAPI_LOADLIBRARYEX ( $AMSGDLL [ $II ] , 2 )
			If $HDLL = 0 Then ContinueLoop
			$TBUFFER = DllStructCreate ( "wchar Text[4096]" )
			_WINAPI_FORMATMESSAGE ( $IFLAGS , $HDLL , $IEVENTID , 0 , $TBUFFER , 4096 , 0 )
			_WINAPI_FREELIBRARY ( $HDLL )
			$SDESC &= DllStructGetData ( $TBUFFER , "Text" )
		Next
		If $SDESC = "" Then
			For $II = 1 To $ASTRINGS [ 0 ]
				$SDESC &= $ASTRINGS [ $II ]
			Next
		Else
			For $II = $ASTRINGS [ 0 ] To 1 Step + 4294967295
				If StringLeft ( $ASTRINGS [ $II ] , 2 ) = "%%" Then
					$STRTEMP = StringMid ( $ASTRINGS [ $II ] , 3 )
					$ERRORNUMBER = Number ( $STRTEMP )
					For $IIF = 1 To $APARAMDLL [ 0 ]
						$HDLLP = _WINAPI_LOADLIBRARYEX ( $APARAMDLL [ $IIF ] , 2 )
						If $HDLLP = 0 Then ContinueLoop
						$TFBUFFER = DllStructCreate ( "wchar Text[4096]" )
						If _WINAPI_FORMATMESSAGE ( $IFLAGS , $HDLLP , $ERRORNUMBER , 0 , $TFBUFFER , 4096 , 0 ) Then
							$ASTRINGS [ $II ] = DllStructGetData ( $TFBUFFER , "Text" )
							$IIF = $APARAMDLL [ 0 ]
						EndIf
						_WINAPI_FREELIBRARY ( $HDLL )
						$TFBUFFER = 0
					Next
					$ASTRINGS [ $II ] = StringReplace ( $ASTRINGS [ $II ] , "%%" , "_____" )
				EndIf
				$SDESC = StringReplace ( $SDESC , "%" & $II , $ASTRINGS [ $II ] )
			Next
			$SDESC = StringReplace ( $SDESC , "_____" , "%%" )
		EndIf
		Return StringStripWS ( $SDESC , 1 + 2 )
	EndIf
EndFunc
Func __EVENTLOG_DECODEEVENTID ( $TEVENTLOG )
	Return BitAND ( DllStructGetData ( $TEVENTLOG , "EventID" ) , 32767 )
EndFunc
Func __EVENTLOG_DECODESOURCE ( $TEVENTLOG )
	Local $PEVENTLOG = DllStructGetPtr ( $TEVENTLOG )
	Local $ILENGTH = DllStructGetData ( $TEVENTLOG , "UserSidOffset" ) + 4294967295
	Local $IOFFSET = DllStructGetSize ( $TEVENTLOG )
	$ILENGTH -= $IOFFSET
	Local $TBUFFER = DllStructCreate ( "wchar Text[" & $ILENGTH & "]" , $PEVENTLOG + $IOFFSET )
	Return DllStructGetData ( $TBUFFER , "Text" )
EndFunc
Func __EVENTLOG_DECODESTRINGS ( $TEVENTLOG )
	Local $PEVENTLOG = DllStructGetPtr ( $TEVENTLOG )
	Local $INUMSTRS = DllStructGetData ( $TEVENTLOG , "NumStrings" )
	Local $IOFFSET = DllStructGetData ( $TEVENTLOG , "StringOffset" )
	Local $IDATAOFFSET = DllStructGetData ( $TEVENTLOG , "DataOffset" )
	Local $TBUFFER = DllStructCreate ( "wchar Text[" & $IDATAOFFSET - $IOFFSET & "]" , $PEVENTLOG + $IOFFSET )
	Local $ASTRINGS [ $INUMSTRS + 1 ]
	$ASTRINGS [ 0 ] = $INUMSTRS
	For $II = 1 To $INUMSTRS
		$ASTRINGS [ $II ] = DllStructGetData ( $TBUFFER , "Text" )
		$IOFFSET += 2 * ( StringLen ( $ASTRINGS [ $II ] ) + 1 )
		$TBUFFER = DllStructCreate ( "wchar Text[" & $IDATAOFFSET - $IOFFSET & "]" , $PEVENTLOG + $IOFFSET )
	Next
	Return $ASTRINGS
EndFunc
Func __EVENTLOG_DECODETIME ( $IEVENTTIME )
	Local $TINT64 = DllStructCreate ( "int64" )
	Local $PINT64 = DllStructGetPtr ( $TINT64 )
	Local $TFILETIME = DllStructCreate ( $TAGFILETIME , $PINT64 )
	DllStructSetData ( $TINT64 , 1 , ( $IEVENTTIME * 10000000 ) + 116444736000000000 )
	Local $TLOCALTIME = _DATE_TIME_FILETIMETOLOCALFILETIME ( $TFILETIME )
	Local $TSYSTTIME = _DATE_TIME_FILETIMETOSYSTEMTIME ( $TLOCALTIME )
	Local $IHOURS = DllStructGetData ( $TSYSTTIME , "Hour" )
	Local $IMINUTES = DllStructGetData ( $TSYSTTIME , "Minute" )
	Local $ISECONDS = DllStructGetData ( $TSYSTTIME , "Second" )
	Local $SAMPM = "AM"
	If $IHOURS < 12 Then
		If $IHOURS = 0 Then
			$IHOURS = 12
		EndIf
	Else
		$SAMPM = "PM"
		If $IHOURS > 12 Then
			$IHOURS -= 12
		EndIf
	EndIf
	Return StringFormat ( "%02d:%02d:%02d %s" , $IHOURS , $IMINUTES , $ISECONDS , $SAMPM )
EndFunc
Func __EVENTLOG_DECODETYPESTR ( $IEVENTTYPE )
	Select
	Case $IEVENTTYPE = 0
		Return "Success"
	Case $IEVENTTYPE = 1
		Return "Error"
	Case $IEVENTTYPE = 2
		Return "Warning"
	Case $IEVENTTYPE = 4
		Return "Information"
	Case $IEVENTTYPE = 8
		Return "Success audit"
	Case $IEVENTTYPE = 16
		Return "Failure audit"
Case Else
		Return $IEVENTTYPE
	EndSelect
EndFunc
Func __EVENTLOG_DECODEUSERNAME ( $TEVENTLOG )
	Local $PEVENTLOG = DllStructGetPtr ( $TEVENTLOG )
	If DllStructGetData ( $TEVENTLOG , "UserSidLength" ) = 0 Then Return ""
	Local $PACCTSID = $PEVENTLOG + DllStructGetData ( $TEVENTLOG , "UserSidOffset" )
	Local $AACCTINFO = _SECURITY__LOOKUPACCOUNTSID ( $PACCTSID )
	If IsArray ( $AACCTINFO ) Then Return $AACCTINFO [ 1 ]
	Return ""
EndFunc
Func _EVENTLOG__OPEN ( $SSERVERNAME , $SSOURCENAME )
	$__G_SSOURCENAME_EVENT = $SSOURCENAME
	Local $ARESULT = DllCall ( "advapi32.dll" , "handle" , "OpenEventLogW" , "wstr" , $SSERVERNAME , "wstr" , $SSOURCENAME )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ARESULT [ 0 ]
EndFunc
Func _EVENTLOG__READ ( $HEVENTLOG , $BREAD = True , $BFORWARD = True , $IOFFSET = 0 )
	Local $IREADFLAGS , $AEVENT [ 15 ]
	$AEVENT [ 0 ] = False
	If $BREAD Then
		$IREADFLAGS = 1
	Else
		$IREADFLAGS = 2
	EndIf
	If $BFORWARD Then
		$IREADFLAGS = BitOR ( $IREADFLAGS , 4 )
	Else
		$IREADFLAGS = BitOR ( $IREADFLAGS , 8 )
	EndIf
	Local $TBUFFER = DllStructCreate ( "wchar[1]" )
	Local $ARESULT = DllCall ( "advapi32.dll" , "bool" , "ReadEventLogW" , "handle" , $HEVENTLOG , "dword" , $IREADFLAGS , "dword" , $IOFFSET , "struct*" , $TBUFFER , "dword" , 0 , "dword*" , 0 , "dword*" , 0 )
	If @error Then Return SetError ( @error , @extended , $AEVENT )
	Local $IBYTESMIN = $ARESULT [ 7 ]
	$TBUFFER = DllStructCreate ( "wchar[" & $IBYTESMIN + 1 & "]" )
	$ARESULT = DllCall ( "advapi32.dll" , "bool" , "ReadEventLogW" , "handle" , $HEVENTLOG , "dword" , $IREADFLAGS , "dword" , $IOFFSET , "struct*" , $TBUFFER , "dword" , $IBYTESMIN , "dword*" , 0 , "dword*" , 0 )
	If @error Or Not $ARESULT [ 0 ] Then Return SetError ( @error , @extended , $AEVENT )
	Local $TEVENTLOG = DllStructCreate ( $TAGEVENTLOGRECORD , DllStructGetPtr ( $TBUFFER ) )
	$AEVENT [ 0 ] = True
	$AEVENT [ 1 ] = DllStructGetData ( $TEVENTLOG , "RecordNumber" )
	$AEVENT [ 2 ] = __EVENTLOG_DECODEDATE ( DllStructGetData ( $TEVENTLOG , "TimeGenerated" ) )
	$AEVENT [ 3 ] = __EVENTLOG_DECODETIME ( DllStructGetData ( $TEVENTLOG , "TimeGenerated" ) )
	$AEVENT [ 4 ] = __EVENTLOG_DECODEDATE ( DllStructGetData ( $TEVENTLOG , "TimeWritten" ) )
	$AEVENT [ 5 ] = __EVENTLOG_DECODETIME ( DllStructGetData ( $TEVENTLOG , "TimeWritten" ) )
	$AEVENT [ 6 ] = __EVENTLOG_DECODEEVENTID ( $TEVENTLOG )
	$AEVENT [ 7 ] = DllStructGetData ( $TEVENTLOG , "EventType" )
	$AEVENT [ 8 ] = __EVENTLOG_DECODETYPESTR ( DllStructGetData ( $TEVENTLOG , "EventType" ) )
	$AEVENT [ 9 ] = __EVENTLOG_DECODECATEGORY ( $TEVENTLOG )
	$AEVENT [ 10 ] = __EVENTLOG_DECODESOURCE ( $TEVENTLOG )
	$AEVENT [ 11 ] = __EVENTLOG_DECODECOMPUTER ( $TEVENTLOG )
	$AEVENT [ 12 ] = __EVENTLOG_DECODEUSERNAME ( $TEVENTLOG )
	$AEVENT [ 13 ] = __EVENTLOG_DECODEDESC ( $TEVENTLOG )
	$AEVENT [ 14 ] = __EVENTLOG_DECODEDATA ( $TEVENTLOG )
	Return $AEVENT
EndFunc
Global Const $SERVICES_ACTIVE_DATABASE = "ServicesActive"
Func _SERVICE_QUERYSTATUS ( $SSERVICENAME , $SCOMPUTERNAME = "" )
	Local $HSC , $HSERVICE , $TSERVICE_STATUS_PROCESS , $AVQSSE , $IQSSE , $AISTATUS [ 9 ]
	$HSC = OPENSCMANAGER ( $SCOMPUTERNAME , 1 )
	$HSERVICE = OPENSERVICE ( $HSC , $SSERVICENAME , 4 )
	$TSERVICE_STATUS_PROCESS = DllStructCreate ( "dword[9]" )
	Local $AVQSSE = DllCall ( "advapi32.dll" , "int" , "QueryServiceStatusEx" , "ptr" , $HSERVICE , "dword" , 0 , "ptr" , DllStructGetPtr ( $TSERVICE_STATUS_PROCESS ) , "dword" , DllStructGetSize ( $TSERVICE_STATUS_PROCESS ) , "dword*" , 0 )
	If $AVQSSE [ 0 ] = 0 Then $IQSSE = _WINAPI_GETLASTERROR ( )
	CLOSESERVICEHANDLE ( $HSERVICE )
	CLOSESERVICEHANDLE ( $HSC )
	For $I = 0 To 8
		$AISTATUS [ $I ] = DllStructGetData ( $TSERVICE_STATUS_PROCESS , 1 , $I + 1 )
	Next
	Return SetError ( $IQSSE , 0 , $AISTATUS )
EndFunc
Func _SERVICE_START ( $SSERVICENAME , $SCOMPUTERNAME = "" )
	Local $HSC , $HSERVICE , $AVSS , $ISS
	$HSC = OPENSCMANAGER ( $SCOMPUTERNAME , 1 )
	$HSERVICE = OPENSERVICE ( $HSC , $SSERVICENAME , 16 )
	$AVSS = DllCall ( "advapi32.dll" , "int" , "StartServiceW" , "ptr" , $HSERVICE , "dword" , 0 , "ptr" , 0 )
	If $AVSS [ 0 ] = 0 Then $ISS = _WINAPI_GETLASTERROR ( )
	CLOSESERVICEHANDLE ( $HSERVICE )
	CLOSESERVICEHANDLE ( $HSC )
	Return SetError ( 1 , 0 , $ISS )
EndFunc
Func CLOSESERVICEHANDLE ( $HSCOBJECT )
	Local $AVCSH = DllCall ( "advapi32.dll" , "int" , "CloseServiceHandle" , "ptr" , $HSCOBJECT )
	If @error Then Return SetError ( @error , 0 , 0 )
	Return $AVCSH [ 0 ]
EndFunc
Func OPENSCMANAGER ( $SCOMPUTERNAME , $IACCESS )
	Local $AVOSCM = DllCall ( "advapi32.dll" , "ptr" , "OpenSCManagerW" , "wstr" , $SCOMPUTERNAME , "wstr" , $SERVICES_ACTIVE_DATABASE , "dword" , $IACCESS )
	If @error Then Return SetError ( @error , 0 , 0 )
	Return $AVOSCM [ 0 ]
EndFunc
Func OPENSERVICE ( $HSC , $SSERVICENAME , $IACCESS )
	Local $AVOS = DllCall ( "advapi32.dll" , "ptr" , "OpenServiceW" , "ptr" , $HSC , "wstr" , $SSERVICENAME , "dword" , $IACCESS )
	If @error Then Return SetError ( @error , 0 , 0 )
	Return $AVOS [ 0 ]
EndFunc
Global Const $HZIPFLDR_DLL = DllOpen ( "zipfldr.dll" )
Global Const $CLSID_CZIPFOLDER = "{e88dcce0-b7b3-11d1-a9f0-00aa0060fa31}"
Global Const $SIID_ICLASSFACTORY = "{00000001-0000-0000-C000-000000000046}"
Global Const $TAGICLASSFACTORY = "CreateInstance hresult(ptr;clsid;ptr*);" & "LockServer hresult(bool);"
Global $TAGIPERSIST = "GetClassID hresult(ptr*);"
Global Const $SIID_IPERSISTFILE = "{0000010b-0000-0000-C000-000000000046}"
Global $TAGIPERSISTFILE = $TAGIPERSIST & "IsDirty hresult();" & "Load hresult(wstr;dword);" & "Save hresult(wstr;bool);" & "SaveCompleted hresult(wstr);" & "GetCurFile hresult(ptr*);"
Global Const $SIID_IPERSISTFOLDER = "{000214EA-0000-0000-C000-000000000046}"
Global $TAGIPERSISTFOLDER = $TAGIPERSIST & "Initialize hresult(ptr);"
Global Const $SIID_ISHELLFOLDER = "{000214E6-0000-0000-C000-000000000046}"
Global $TAGISHELLFOLDER = "ParseDisplayName hresult(hwnd;ptr;wstr;ulong*;ptr*;ulong*);" & "EnumObjects hresult(hwnd;dword;ptr*);" & "BindToObject hresult(struct*;ptr;clsid;ptr*);" & "BindToStorage hresult(struct*;ptr;clsid;ptr*);" & "CompareIDs hresult(lparam;struct*;struct*);" & "CreateViewObject hresult(hwnd;clsid;ptr*);" & "GetAttributesOf hresult(uint:struct*;ulong*);" & "GetUIObjectOf hresult(hwnd;uint;struct*;clsid;uint*;ptr*);" & "GetDisplayNameOf hresult(struct*;dword;struct*);" & "SetNameOf hresult(hwnd;struct*;wstr;dword;struct*);"
Global Const $TAGISEQUENTIALSTREAM = "Read hresult(struct*;dword;dword*);" & "Write hresult(struct*;dword;dword*);"
Global Const $SIID_ISTREAM = "{0000000c-0000-0000-C000-000000000046}"
Global Const $TAGISTREAM = $TAGISEQUENTIALSTREAM & "Seek hresult(int64;dword;uint64*);" & "SetSize hresult(uint64);" & "CopyTo hresult(ptr;uint64;uint64*;uint64*);" & "Commit hresult(dword);" & "Revert hresult();" & "LockRegion hresult(uint64;uint64;dword);" & "UnlockRegion hresult(uint64;uint64;dword);" & "Stat hresult(struct*;dword);" & "Clone hresult(ptr*);"
Func UNZIP_SAVEFILETOFILEONCE ( $SZIP , $SFILE , $SDESTINATION )
	Local $OSHELLFOLDER , $OPERSISTF
	Local $SRET = UNZIP_SAVEFILETOBINARY ( $SZIP , $SFILE , $OSHELLFOLDER , $OPERSISTF )
	Local $IERR = @error , $IEXTENDED = @extended
	__UNZIP_CLEAN ( $OSHELLFOLDER , $OPERSISTF )
	Return SetError ( $IERR , $IEXTENDED , $SRET )
EndFunc
Func UNZIP_SAVEFILETOBINARY ( $SZIP , $SFILE , ByRef $OSHELLFOLDER , ByRef $OPERSISTF , $IWANTEDSIZE = Default )
	Local $BNORELEASE = IsObj ( $OSHELLFOLDER ) And IsObj ( $OPERSISTF )
	Local Const $S_OK = 0 , $S_FALSE = 1
	Local $OSTREAM = UNZIP_SAVEFILETOSTREAM ( $SZIP , $SFILE , $OSHELLFOLDER , $OPERSISTF , Not $BNORELEASE )
	If @error Then
		Local $IERR = @error
		__UNZIP_CLEAN ( $OSHELLFOLDER , $OPERSISTF , $BNORELEASE )
		Return SetError ( 1 , $IERR , 0 )
	EndIf
	$BNORELEASE = True
	Local Enum $STREAM_SEEK_SET = 0 , $STREAM_SEEK_CUR , $STREAM_SEEK_END
	$OSTREAM .Seek ( 0 , $STREAM_SEEK_SET , 0 )
	Local $ISIZE
	$OSTREAM .Seek ( 0 , $STREAM_SEEK_END , $ISIZE )
	If $ISIZE = 0 Then
		$OSTREAM = 0
		__UNZIP_CLEAN ( $OSHELLFOLDER , $OPERSISTF , $BNORELEASE )
		Return SetError ( 2 , 0 , 0 )
	EndIf
	$OSTREAM .Seek ( 0 , $STREAM_SEEK_SET , 0 )
	If $ISIZE = + 4294967295 Then $ISIZE = 262144
	If ( $IWANTEDSIZE <> Default ) And ( $IWANTEDSIZE < $ISIZE ) Then $ISIZE = $IWANTEDSIZE
	Local $TBINARY = DllStructCreate ( "byte[" & $ISIZE & "]" )
	Local $BBINARY = Binary ( "" ) , $IREAD , $IOVERALLREAD
	While 1
		Switch $OSTREAM .Read ( $TBINARY , $ISIZE , $IREAD )
		Case $S_OK
			$IOVERALLREAD += $IREAD
			$BBINARY &= DllStructGetData ( $TBINARY , 1 )
		Case $S_FALSE
			$IOVERALLREAD += $IREAD
			$BBINARY &= BinaryMid ( DllStructGetData ( $TBINARY , 1 ) , 1 , $IREAD )
			ExitLoop
	Case Else
			ExitLoop
		EndSwitch
		If $IOVERALLREAD <= $ISIZE Then ExitLoop
	WEnd
	$OSTREAM = 0
	__UNZIP_CLEAN ( $OSHELLFOLDER , $OPERSISTF , $BNORELEASE )
	Return $BBINARY
EndFunc
Func UNZIP_SAVEFILETOSTREAM ( $SZIP , $SFILE , ByRef $OSHELLFOLDER , ByRef $OPERSISTF , $BINIT = True )
	Local Const $S_OK = 0
	If $BINIT Then
		Local $OCLASSFACTORY = __UNZIP_DLLGETCLASSOBJECT ( $HZIPFLDR_DLL , $CLSID_CZIPFOLDER , $SIID_ICLASSFACTORY , $TAGICLASSFACTORY )
		If @error Then Return SetError ( 1 , 0 , 0 )
		Local $PSHELLFOLDER
		$OCLASSFACTORY .CreateInstance ( 0 , $SIID_ISHELLFOLDER , $PSHELLFOLDER )
		$OSHELLFOLDER = ObjCreateInterface ( $PSHELLFOLDER , $SIID_ISHELLFOLDER , $TAGISHELLFOLDER )
		If @error Then Return SetError ( 2 , 0 , 0 )
		$OPERSISTF = ObjCreateInterface ( $PSHELLFOLDER , $SIID_IPERSISTFILE , $TAGIPERSISTFILE )
		If @error Then
			$OPERSISTF = ObjCreateInterface ( $PSHELLFOLDER , $SIID_IPERSISTFOLDER , $TAGIPERSISTFOLDER )
			If @error Then
				Return SetError ( 3 , 0 , 0 )
			Else
				If $OPERSISTF .Initialize ( __UNZIP_SHPARSEDISPLAYNAME ( $SZIP ) ) < $S_OK Then Return SetError ( 4 , 0 , 0 )
			EndIf
		Else
			Local Const $STGM_READ = 0
			If $OPERSISTF .Load ( $SZIP , $STGM_READ ) < $S_OK Then Return SetError ( 4 , 0 , 0 )
		EndIf
	EndIf
	Local Const $SFGAO_STREAM = 4194304
	Local $PPIDL = 0
	Local $IATTRIBUTES = $SFGAO_STREAM
	If $OSHELLFOLDER .ParseDisplayName ( 0 , 0 , $SFILE , 0 , $PPIDL , $IATTRIBUTES ) < $S_OK Then
		$SFILE = StringReplace ( $SFILE , "\" , "/" )
		If $OSHELLFOLDER .ParseDisplayName ( 0 , 0 , $SFILE , 0 , $PPIDL , $IATTRIBUTES ) < $S_OK Then Return SetError ( 5 , 0 , 0 )
	EndIf
	Local $PSTREAM
	If $OSHELLFOLDER .BindToStorage ( $PPIDL , 0 , $SIID_ISTREAM , $PSTREAM ) <> $S_OK Then Return SetError ( 6 , __UNZIP_COTASKMEMFREE ( $PPIDL ) , 0 )
	__UNZIP_COTASKMEMFREE ( $PPIDL )
	Local $OSTREAM = ObjCreateInterface ( $PSTREAM , $SIID_ISTREAM , $TAGISTREAM )
	If @error Then Return SetError ( 7 , 0 , 0 )
	Return $OSTREAM
EndFunc
Func __UNZIP_CLEAN ( ByRef $VPARAM1 , ByRef $VPARAM2 , $BNORELEASE = False )
	If $BNORELEASE Then Return
	$VPARAM1 = 0
	$VPARAM2 = 0
EndFunc
Func __UNZIP_DLLGETCLASSOBJECT ( $SDLL , $SCLSID , $SIID , $TAGINTERFACE = "" )
	Local $TCLSID = __UNZIP_GUIDFROMSTRING ( $SCLSID )
	Local $TIID = __UNZIP_GUIDFROMSTRING ( $SIID )
	Local $ACALL = DllCall ( $SDLL , "long" , "DllGetClassObject" , "struct*" , $TCLSID , "struct*" , $TIID , "ptr*" , 0 )
	If @error Or $ACALL [ 0 ] Then Return SetError ( 1 , 0 , 0 )
	Local $OOBJ = ObjCreateInterface ( $ACALL [ 3 ] , $SIID , $TAGINTERFACE )
	If @error Then Return SetError ( 2 , 0 , 0 )
	Return $OOBJ
EndFunc
Func __UNZIP_SHPARSEDISPLAYNAME ( $SPATH )
	Local $ACALL = DllCall ( "shell32.dll" , "long" , "SHParseDisplayName" , "wstr" , $SPATH , "ptr" , 0 , "ptr*" , 0 , "ulong" , 0 , "ulong*" , 0 )
	If @error Or $ACALL [ 0 ] Then Return SetError ( 1 , 0 , 0 )
	Return $ACALL [ 3 ]
EndFunc
Func __UNZIP_COTASKMEMFREE ( $PMEMORY )
	DllCall ( "ole32.dll" , "none" , "CoTaskMemFree" , "ptr" , $PMEMORY )
	If @error Then Return SetError ( 1 , 0 , 0 )
	Return 1
EndFunc
Func __UNZIP_GUIDFROMSTRING ( $SGUID )
	Local $TGUID = DllStructCreate ( "byte[16]" )
	DllCall ( "ole32.dll" , "long" , "CLSIDFromString" , "wstr" , $SGUID , "struct*" , $TGUID )
	If @error Then Return SetError ( 1 , 0 , 0 )
	Return $TGUID
EndFunc
Global Const $TAGWINTRUST_FILE_INFO = "DWORD cbStruct;" & "ptr pcwszFilePath;" & "HWND hFile;" & "ptr  pgKnownSubject;"
Global Const $TAGWINTRUST_DATA = "DWORD cbStruct;" & "ptr   pPolicyCallbackData;" & "ptr   pSIPClientData;" & "DWORD dwUIChoice;" & "DWORD fdwRevocationChecks;" & "DWORD dwUnionChoice;" & "ptr   pInfoStruct;" & "DWORD dwStateAction;" & "HWND  hWVTStateData;" & "ptr   pwszURLReference;" & "DWORD dwProvFlags;" & "DWORD dwUIContext;"
Global Const $TAGWINTRUST_CATALOG_INFO = "DWORD cbStruct;" & "DWORD   dwCatalogVersion;" & "ptr   pcwszCatalogFilePath;" & "ptr pcwszMemberTag;" & "ptr pcwszMemberFilePath;" & "HANDLE hMemberFile;" & "ptr   pbCalculatedFileHash;" & "DWORD cbCalculatedFileHash;" & "ptr  pcCatalogContext;"
Global $TAGCMSG_SIGNER_INFO = "DWORD dwVersion;" & "DWORD   Issuer_cbData;" & "ptr   Issuer_pbData;" & "DWORD SerialNumber_cbData;" & "ptr SerialNumber_pbData;" & "ptr HashAlgorithm_pszObjId;" & "DWORD HashAlgorithm_Parameters_cbData;" & "ptr HashAlgorithm_Parameters_pbData;" & "ptr HashEncryptionAlgorithm_pszObjId;" & "DWORD HashEncryptionAlgorithm_Parameters_cbData;" & "ptr HashEncryptionAlgorithm_Parameters_pbData;" & "DWORD EncryptedHash_cbData;" & "ptr EncryptedHash_pbData;" & "DWORD AuthAttrs_cAttr;" & "ptr AuthAttrs_rgAttr;" & "DWORD UnauthAttrs_cAttr;" & "ptr UnauthAttrs_rgAttr;" & "DWORD dwUIContext;"
If @OSArch = "X64" Then $TAGCMSG_SIGNER_INFO = StringRegExpReplace ( $TAGCMSG_SIGNER_INFO , "DWORD" , "UINT64" )
Global $TAGCERT_INFO = "DWORD dwVersion;" & "DWORD SerialNumber_cbData;" & "ptr SerialNumber_pbData;" & "ptr SignatureAlgorithm_pszObjId;" & "DWORD SignatureAlgorithm_Parameters_cbData;" & "ptr SignatureAlgorithm_Parameters_pbData;" & "DWORD Issuer_cbData;" & "ptr Issuer_pbData;" & "DWORD NotBefore_dwLowDateTime;" & "DWORD NotBefore_dwHighDateTime;" & "DWORD NotAfter_dwLowDateTime;" & "DWORD NotAfter_dwHighDateTime;" & "DWORD Subject_cbData;" & "ptr Subject_pbData;" & "ptr SubjectPublicKeyInfo_Algorithm_pszObjId;" & "DWORD SubjectPublicKeyInfo_Algorithm_Parameters_cbData;" & "ptr SubjectPublicKeyInfo_Algorithm_Parameters_pbData;" & "DWORD SubjectPublicKeyInfo_PublicKey_cbData;" & "ptr SubjectPublicKeyInfo_PublicKey_pbData;" & "DWORD IssuerUniqueId_cbData;" & "ptr IssuerUniqueId_pbData;" & "DWORD SubjectUniqueId_cbData;" & "ptr SubjectUniqueId_pbData;" & "DWORD cExtension;" & "ptr rgExtension;"
If @OSArch = "X64" Then $TAGCERT_INFO = StringRegExpReplace ( $TAGCERT_INFO , "DWORD" , "UINT64" )
Global $WINTRUST_ACTION_GENERIC_VERIFY_V2 = _WINAPI_GUIDFROMSTRING ( "{00AAC56B-CD44-11D0-8CC2-00C04FC295EE}" )
Func _WINVERIFYTRUST ( $FILEPATH , $CATPATH = "" , $CATMEMBERTAG = "" , $DWPROVFLAGS = 16 , $ICODEPAGE = 0 )
	If StringLen ( $FILEPATH ) > 1000 Then Return SetError ( + 4294967295 , 0 , "File Path too large." )
	Local $WSZSOURCEFILE = _WINAPI_MULTIBYTETOWIDECHAR ( $FILEPATH , $ICODEPAGE , 1 )
	If @error Then Return SetError ( + 4294967295 , 0 , "Could not convert FilePath to WideChar." )
	If StringLen ( $CATPATH ) = 0 Then
		$WINTRUST_FILE_INFO = DllStructCreate ( $TAGWINTRUST_FILE_INFO )
		DllStructSetData ( $WINTRUST_FILE_INFO , "cbStruct" , DllStructGetSize ( $WINTRUST_FILE_INFO ) )
		DllStructSetData ( $WINTRUST_FILE_INFO , "pcwszFilePath" , DllStructGetPtr ( $WSZSOURCEFILE ) )
		DllStructSetData ( $WINTRUST_FILE_INFO , "hFile" , 0 )
		DllStructSetData ( $WINTRUST_FILE_INFO , "pgKnownSubject" , 0 )
		$PINFOSTRUCT = DllStructGetPtr ( $WINTRUST_FILE_INFO )
		$DWUNIONCHOICE = 1
		$DWSTATEACTION = 0
	Else
		$WSZCATALOGFILE = _WINAPI_MULTIBYTETOWIDECHAR ( $CATPATH , $ICODEPAGE , 1 )
		If @error Then Return SetError ( + 4294967295 , 0 , "Could not convert CatPath to WideChar." )
		$WSZFILETAG = _WINAPI_MULTIBYTETOWIDECHAR ( $CATMEMBERTAG , $ICODEPAGE , 1 )
		If @error Then Return SetError ( + 4294967295 , 0 , "Could not convert CatMemberTag to WideChar." )
		$WINTRUST_CATALOG_INFO = DllStructCreate ( $TAGWINTRUST_CATALOG_INFO )
		DllStructSetData ( $WINTRUST_CATALOG_INFO , "cbStruct" , DllStructGetSize ( $WINTRUST_CATALOG_INFO ) )
		DllStructSetData ( $WINTRUST_CATALOG_INFO , "dwCatalogVersion" , 0 )
		DllStructSetData ( $WINTRUST_CATALOG_INFO , "pcwszCatalogFilePath" , DllStructGetPtr ( $WSZCATALOGFILE ) )
		DllStructSetData ( $WINTRUST_CATALOG_INFO , "pcwszMemberTag" , DllStructGetPtr ( $WSZFILETAG ) )
		DllStructSetData ( $WINTRUST_CATALOG_INFO , "pcwszMemberFilePath" , DllStructGetPtr ( $WSZSOURCEFILE ) )
		DllStructSetData ( $WINTRUST_CATALOG_INFO , "hMemberFile" , 0 )
		DllStructSetData ( $WINTRUST_CATALOG_INFO , "pbCalculatedFileHash" , 0 )
		DllStructSetData ( $WINTRUST_CATALOG_INFO , "cbCalculatedFileHash" , 0 )
		DllStructSetData ( $WINTRUST_CATALOG_INFO , "pcCatalogContext" , 0 )
		$PINFOSTRUCT = DllStructGetPtr ( $WINTRUST_CATALOG_INFO )
		$DWUNIONCHOICE = 2
		$DWSTATEACTION = 4
	EndIf
	$WINTRUST_DATA = DllStructCreate ( $TAGWINTRUST_DATA )
	DllStructSetData ( $WINTRUST_DATA , "cbStruct" , DllStructGetSize ( $WINTRUST_DATA ) )
	DllStructSetData ( $WINTRUST_DATA , "pPolicyCallbackData" , 0 )
	DllStructSetData ( $WINTRUST_DATA , "pSIPClientData" , 0 )
	DllStructSetData ( $WINTRUST_DATA , "dwUIChoice" , 2 )
	DllStructSetData ( $WINTRUST_DATA , "fdwRevocationChecks" , 0 )
	DllStructSetData ( $WINTRUST_DATA , "dwUnionChoice" , $DWUNIONCHOICE )
	DllStructSetData ( $WINTRUST_DATA , "pInfoStruct" , $PINFOSTRUCT )
	DllStructSetData ( $WINTRUST_DATA , "dwStateAction" , $DWSTATEACTION )
	DllStructSetData ( $WINTRUST_DATA , "hWVTStateData" , 0 )
	DllStructSetData ( $WINTRUST_DATA , "pwszURLReference" , 0 )
	DllStructSetData ( $WINTRUST_DATA , "dwProvFlags" , $DWPROVFLAGS )
	DllStructSetData ( $WINTRUST_DATA , "dwUIContext" , 0 )
	$PGUID = DllStructGetPtr ( $WINTRUST_ACTION_GENERIC_VERIFY_V2 )
	$PWINTRUST_DATA = DllStructGetPtr ( $WINTRUST_DATA )
	$STATUS = DllCall ( "wintrust.dll" , "long" , "WinVerifyTrust" , "HWND" , 0 , "ptr" , $PGUID , "ptr" , $PWINTRUST_DATA )
	If @error Then SetError ( + 4294967295 , 0 , "WinVerifyTrust Error." )
	Return $STATUS [ 0 ]
EndFunc
Func _GETSIGNATUREINFO ( $FILEPATH , $ICODEPAGE = 0 )
	Dim $EMPTY_ANSWER [ 3 ] = [ "" , "" , "" ]
	Dim $CERTINFO [ 3 ] = [ "" , "" , "" ]
	Local $WSZSOURCEFILE = _WINAPI_MULTIBYTETOWIDECHAR ( $FILEPATH , $ICODEPAGE , 1 , True )
	If @error Then Return $EMPTY_ANSWER
	Local $ACALL = DllCall ( "Crypt32.dll" , "bool" , "CryptQueryObject" , "dword" , 1 , "wstr" , $WSZSOURCEFILE , "dword" , 1024 , "dword" , 2 , "dword" , 0 , "dword*" , 0 , "dword*" , 0 , "dword*" , 0 , "handle*" , 0 , "handle*" , 0 , "ptr" , 0 )
	If $ACALL [ 0 ] = 0 Then Return $EMPTY_ANSWER
	Local $HSTORE = $ACALL [ 9 ]
	Local $HMSG = $ACALL [ 10 ]
	If Not $HMSG Then Return $EMPTY_ANSWER
	$ACALL = DllCall ( "Crypt32.dll" , "bool" , "CryptMsgGetParam" , "handle" , $HMSG , "dword" , 6 , "dword" , 0 , "ptr" , 0 , "dword*" , 0 )
	Local $ISIZE = $ACALL [ 5 ]
	Local $PSIGNERINFO = DllStructCreate ( "byte[" & $ISIZE & "]" )
	$ACALL = DllCall ( "Crypt32.dll" , "bool" , "CryptMsgGetParam" , "handle" , $HMSG , "dword" , 6 , "dword" , 0 , "ptr" , DllStructGetPtr ( $PSIGNERINFO ) , "dword*" , DllStructGetSize ( $PSIGNERINFO ) )
	Local $CMSG_SIGNER_INFO = DllStructCreate ( $TAGCMSG_SIGNER_INFO , DllStructGetPtr ( $PSIGNERINFO ) )
	Local $CERT_INFO = DllStructCreate ( $TAGCERT_INFO )
	DllStructSetData ( $CERT_INFO , "Issuer_cbData" , DllStructGetData ( $CMSG_SIGNER_INFO , "Issuer_cbData" ) )
	DllStructSetData ( $CERT_INFO , "Issuer_pbData" , DllStructGetData ( $CMSG_SIGNER_INFO , "Issuer_pbData" ) )
	DllStructSetData ( $CERT_INFO , "SerialNumber_cbData" , DllStructGetData ( $CMSG_SIGNER_INFO , "SerialNumber_cbData" ) )
	DllStructSetData ( $CERT_INFO , "SerialNumber_pbData" , DllStructGetData ( $CMSG_SIGNER_INFO , "SerialNumber_pbData" ) )
	$ACALL = DllCall ( "Crypt32.dll" , "ptr" , "CertFindCertificateInStore" , "HANDLE" , $HSTORE , "DWORD" , 1 + 65536 , "DWORD" , 0 , "DWORD" , 720896 , "ptr" , DllStructGetPtr ( $CERT_INFO ) , "ptr" , 0 )
	If $ACALL [ 0 ] = 0 Then Return $EMPTY_ANSWER
	Local $PCERTCONTEXT = $ACALL [ 0 ]
	$ACALL = DllCall ( "Crypt32.dll" , "DWORD" , "CertGetNameStringW" , "ptr" , $PCERTCONTEXT , "DWORD" , 4 , "DWORD" , 0 , "ptr" , 0 , "ptr" , 0 , "DWORD" , 0 )
	If $ACALL [ 0 ] = 0 Then Return $EMPTY_ANSWER
	Local $DWSIZE = $ACALL [ 0 ]
	Local $SZSIGNERNAME = DllStructCreate ( "wchar[" & $DWSIZE & "]" )
	$ACALL = DllCall ( "Crypt32.dll" , "DWORD" , "CertGetNameStringW" , "ptr" , $PCERTCONTEXT , "DWORD" , 4 , "DWORD" , 0 , "ptr" , 0 , "ptr" , DllStructGetPtr ( $SZSIGNERNAME ) , "DWORD" , $DWSIZE )
	If $ACALL [ 0 ] = 0 Then Return $EMPTY_ANSWER
	$CERTINFO [ 1 ] = DllStructGetData ( $SZSIGNERNAME , 1 )
	Return $CERTINFO
EndFunc
If Not ObjEvent ( "AutoIt.Error" ) Then
	Global Const $_ZIP_COMERRORHANDLER = ObjEvent ( "AutoIt.Error" , "_Zip_COMErrorFunc" )
EndIf
Func _ZIP_ADDITEM ( $SZIPFILE , $SITEM , $SDESTDIR = "" , $IFLAG = 21 )
	If Not _ZIP_DLLCHK ( ) Then Return SetError ( @error , 0 , 0 )
	If Not _ISFULLPATH ( $SZIPFILE ) Then Return SetError ( 3 , 0 , 0 )
	If Not _ISFULLPATH ( $SITEM ) Then Return SetError ( 4 , 0 , 0 )
	If Not FileExists ( $SITEM ) Then Return SetError ( 5 , 0 , 0 )
	If _ISFULLPATH ( $SDESTDIR ) Then Return SetError ( 6 , 0 , 0 )
	$SITEM = _ZIP_PATHSTRIPSLASH ( $SITEM )
	$SDESTDIR = _ZIP_PATHSTRIPSLASH ( $SDESTDIR )
	Local $SNAMEONLY = _ZIP_PATHNAMEONLY ( $SITEM )
	Local $IOVERWRITE = 0
	If BitAND ( $IFLAG , 1 ) Then
		$IOVERWRITE = 1
		$IFLAG -= 1
	EndIf
	Local $STEST = $SNAMEONLY
	If $SDESTDIR <> "" Then $STEST = $SDESTDIR & "\" & $SNAMEONLY
	Local $ITEMEXISTS = _ZIP_ITEMEXISTS ( $SZIPFILE , $STEST )
	If @error Then Return SetError ( 7 , 0 , 0 )
	If $ITEMEXISTS Then
		If @extended Then
			Return SetError ( 8 , 0 , 0 )
		Else
			If $IOVERWRITE Then
				_ZIP_INTERNALDELETE ( $SZIPFILE , $STEST )
				If @error Then Return SetError ( 10 , 0 , 0 )
			Else
				Return SetError ( 9 , 0 , 0 )
			EndIf
		EndIf
	EndIf
	Local $STEMPFILE = ""
	If $SDESTDIR <> "" Then
		$STEMPFILE = _ZIP_ADDPATH ( $SZIPFILE , $SDESTDIR )
		If @error Then Return SetError ( 11 , 0 , 0 )
	EndIf
	Local $ONS = _ZIP_GETNAMESPACE ( $SZIPFILE , $SDESTDIR )
	$ONS .CopyHere ( $SITEM , $IFLAG )
	Do
		Sleep ( 250 )
	Until IsObj ( $ONS .ParseName ( $SNAMEONLY ) )
	If $STEMPFILE <> "" Then
		_ZIP_INTERNALDELETE ( $SZIPFILE , $SDESTDIR & "\" & $STEMPFILE )
		If @error Then Return SetError ( 12 , 0 , 0 )
	EndIf
	Return 1
EndFunc
Func _ZIP_COMERRORFUNC ( )
EndFunc
Func _ZIP_CREATE ( $SFILENAME , $IOVERWRITE = 0 )
	If FileExists ( $SFILENAME ) And Not $IOVERWRITE Then Return SetError ( 1 , 0 , 0 )
	Local $HFP = FileOpen ( $SFILENAME , 2 + 8 + 16 )
	If $HFP = + 4294967295 Then Return SetError ( 2 , 0 , 0 )
	FileWrite ( $HFP , Binary ( "0x504B0506000000000000000000000000000000000000" ) )
	FileClose ( $HFP )
	Return $SFILENAME
EndFunc
Func _ZIP_ITEMEXISTS ( $SZIPFILE , $SITEM )
	If Not _ZIP_DLLCHK ( ) Then Return SetError ( @error , 0 , 0 )
	If Not _ISFULLPATH ( $SZIPFILE ) Then Return SetError ( 3 , 0 , 0 )
	Local $SPATH = ""
	$SITEM = _ZIP_PATHSTRIPSLASH ( $SITEM )
	If StringInStr ( $SITEM , "\" ) Then
		$SPATH = _ZIP_PATHPATHONLY ( $SITEM )
		$SITEM = _ZIP_PATHNAMEONLY ( $SITEM )
	EndIf
	Local $ONS = _ZIP_GETNAMESPACE ( $SZIPFILE , $SPATH )
	If Not IsObj ( $ONS ) Then Return SetError ( 4 , 0 , 0 )
	Local $OITEM = $ONS .ParseName ( $SITEM )
	If IsObj ( $OITEM ) Then Return SetExtended ( Number ( $OITEM .IsFolder ) , 1 )
	Return 0
EndFunc
Func _ISFULLPATH ( $SPATH )
	If StringInStr ( $SPATH , ":\" ) Then
		Return True
	Else
		Return False
	EndIf
EndFunc
Func _ZIP_ADDPATH ( $SZIPFILE , $SPATH )
	If Not _ZIP_DLLCHK ( ) Then Return SetError ( @error , 0 , 0 )
	If Not _ISFULLPATH ( $SZIPFILE ) Then Return SetError ( 3 , 0 , 0 )
	Local $ONS = _ZIP_GETNAMESPACE ( $SZIPFILE )
	If Not IsObj ( $ONS ) Then Return SetError ( 4 , 0 , 0 )
	$SPATH = _ZIP_PATHSTRIPSLASH ( $SPATH )
	Local $SNEWPATH = "" , $SFILENAME = ""
	If $SPATH <> "" Then
		Local $ADIR = StringSplit ( $SPATH , "\" ) , $OTEST
		For $I = 1 To $ADIR [ 0 ]
			$OTEST = $ONS .ParseName ( $ADIR [ $I ] )
			If IsObj ( $OTEST ) Then
				If Not $OTEST .IsFolder Then Return SetError ( 5 , 0 , 0 )
				$ONS = $OTEST .GetFolder
			Else
				Local $STEMPDIR = _ZIP_CREATETEMPDIR ( )
				If @error Then Return SetError ( 6 , 0 , 0 )
				Local $OTEMP = _ZIP_GETNAMESPACE ( $STEMPDIR )
				For $I = $I To $ADIR [ 0 ]
					$SNEWPATH &= $ADIR [ $I ] & "\"
				Next
				DirCreate ( $STEMPDIR & "\" & $SNEWPATH )
				$SFILENAME = _ZIP_CREATETEMPNAME ( )
				$SNEWPATH &= $SFILENAME
				FileClose ( FileOpen ( $STEMPDIR & "\" & $SNEWPATH , 2 + 8 ) )
				$ONS .CopyHere ( $OTEMP .Items ( ) )
				Do
					Sleep ( 250 )
				Until _ZIP_ITEMEXISTS ( $SZIPFILE , $SNEWPATH )
				DirRemove ( $STEMPDIR , 1 )
				ExitLoop
			EndIf
		Next
	EndIf
	Return $SFILENAME
EndFunc
Func _ZIP_CREATETEMPDIR ( )
	Local $S_TEMPNAME
	Do
		$S_TEMPNAME = ""
		While StringLen ( $S_TEMPNAME ) < 7
			$S_TEMPNAME &= Chr ( Random ( 97 , 122 , 1 ) )
		WEnd
		$S_TEMPNAME = @TempDir & "\~" & $S_TEMPNAME & ".tmp"
	Until Not FileExists ( $S_TEMPNAME )
	If Not DirCreate ( $S_TEMPNAME ) Then Return SetError ( 1 , 0 , 0 )
	Return $S_TEMPNAME
EndFunc
Func _ZIP_CREATETEMPNAME ( )
	Local $GUID = DllStructCreate ( "dword Data1;word Data2;word Data3;byte Data4[8]" )
	DllCall ( "ole32.dll" , "int" , "CoCreateGuid" , "ptr" , DllStructGetPtr ( $GUID ) )
	Local $RET = DllCall ( "ole32.dll" , "int" , "StringFromGUID2" , "ptr" , DllStructGetPtr ( $GUID ) , "wstr" , "" , "int" , 40 )
	If @error Then Return SetError ( 1 , 0 , "" )
	Return StringRegExpReplace ( $RET [ 2 ] , "[}{-]" , "" )
EndFunc
Func _ZIP_DLLCHK ( )
	If Not FileExists ( @SystemDir & "\zipfldr.dll" ) Then Return SetError ( 1 , 0 , 0 )
	If Not RegRead ( "HKEY_CLASSES_ROOT\CLSID\{E88DCCE0-B7B3-11d1-A9F0-00AA0060FA31}" , "" ) Then Return SetError ( 2 , 0 , 0 )
	Return 1
EndFunc
Func _ZIP_GETNAMESPACE ( $SZIPFILE , $SPATH = "" )
	If Not _ZIP_DLLCHK ( ) Then Return SetError ( @error , 0 , 0 )
	If Not _ISFULLPATH ( $SZIPFILE ) Then Return SetError ( 3 , 0 , 0 )
	Local $OAPP = ObjCreate ( "Shell.Application" )
	Local $ONS = $OAPP .NameSpace ( $SZIPFILE )
	If Not IsObj ( $ONS ) Then Return SetError ( 4 , 0 , 0 )
	If $SPATH <> "" Then
		Local $APATH = StringSplit ( $SPATH , "\" )
		Local $OITEM
		For $I = 1 To $APATH [ 0 ]
			$OITEM = $ONS .ParseName ( $APATH [ $I ] )
			If Not IsObj ( $OITEM ) Then Return SetError ( 5 , 0 , 0 )
			$ONS = $OITEM .GetFolder
			If Not IsObj ( $ONS ) Then Return SetError ( 6 , 0 , 0 )
		Next
	EndIf
	Return $ONS
EndFunc
Func _ZIP_INTERNALDELETE ( $SZIPFILE , $SFILENAME )
	If Not _ZIP_DLLCHK ( ) Then Return SetError ( @error , 0 , 0 )
	If Not _ISFULLPATH ( $SZIPFILE ) Then Return SetError ( 3 , 0 , 0 )
	Local $SPATH = ""
	$SFILENAME = _ZIP_PATHSTRIPSLASH ( $SFILENAME )
	If StringInStr ( $SFILENAME , "\" ) Then
		$SPATH = _ZIP_PATHPATHONLY ( $SFILENAME )
		$SFILENAME = _ZIP_PATHNAMEONLY ( $SFILENAME )
	EndIf
	Local $ONS = _ZIP_GETNAMESPACE ( $SZIPFILE , $SPATH )
	If Not IsObj ( $ONS ) Then Return SetError ( 4 , 0 , 0 )
	Local $OFOLDERITEM = $ONS .ParseName ( $SFILENAME )
	If Not IsObj ( $OFOLDERITEM ) Then Return SetError ( 5 , 0 , 0 )
	Local $STEMPDIR = _ZIP_CREATETEMPDIR ( )
	If @error Then Return SetError ( 6 , 0 , 0 )
	Local $OAPP = ObjCreate ( "Shell.Application" )
	$OAPP .NameSpace ( $STEMPDIR ) .MoveHere ( $OFOLDERITEM , 20 )
	DirRemove ( $STEMPDIR , 1 )
	$OFOLDERITEM = $ONS .ParseName ( $SFILENAME )
	If IsObj ( $OFOLDERITEM ) Then
		Return SetError ( 7 , 0 , 0 )
	Else
		Return 1
	EndIf
EndFunc
Func _ZIP_PATHNAMEONLY ( $SPATH )
	Return StringRegExpReplace ( $SPATH , ".*\\" , "" )
EndFunc
Func _ZIP_PATHPATHONLY ( $SPATH )
	Return StringRegExpReplace ( $SPATH , "^(.*)\\.*?$" , "${1}" )
EndFunc
Func _ZIP_PATHSTRIPSLASH ( $SSTRING )
	Return StringRegExpReplace ( $SSTRING , "(^\\+|\\+$)" , "" )
EndFunc
Global $__G_ATIMERS_ATIMERIDS [ 1 ] [ 3 ]
Func _TIMER_KILLTIMER ( $HWND , $ITIMERID )
	Local $ACALL [ 1 ] = [ 0 ] , $HCALLBACK = 0 , $IUBOUND = UBound ( $__G_ATIMERS_ATIMERIDS ) + 4294967295
	For $X = 1 To $IUBOUND
		If $__G_ATIMERS_ATIMERIDS [ $X ] [ 0 ] = $ITIMERID Then
			If IsHWnd ( $HWND ) Then
				$ACALL = DllCall ( "user32.dll" , "bool" , "KillTimer" , "hwnd" , $HWND , "uint_ptr" , $__G_ATIMERS_ATIMERIDS [ $X ] [ 1 ] )
			Else
				$ACALL = DllCall ( "user32.dll" , "bool" , "KillTimer" , "hwnd" , $HWND , "uint_ptr" , $__G_ATIMERS_ATIMERIDS [ $X ] [ 0 ] )
			EndIf
			If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , False )
			$HCALLBACK = $__G_ATIMERS_ATIMERIDS [ $X ] [ 2 ]
			If $HCALLBACK <> 0 Then DllCallbackFree ( $HCALLBACK )
			For $I = $X To $IUBOUND + 4294967295
				$__G_ATIMERS_ATIMERIDS [ $I ] [ 0 ] = $__G_ATIMERS_ATIMERIDS [ $I + 1 ] [ 0 ]
				$__G_ATIMERS_ATIMERIDS [ $I ] [ 1 ] = $__G_ATIMERS_ATIMERIDS [ $I + 1 ] [ 1 ]
				$__G_ATIMERS_ATIMERIDS [ $I ] [ 2 ] = $__G_ATIMERS_ATIMERIDS [ $I + 1 ] [ 2 ]
			Next
			ReDim $__G_ATIMERS_ATIMERIDS [ UBound ( $__G_ATIMERS_ATIMERIDS + 4294967295 ) ] [ 3 ]
			$__G_ATIMERS_ATIMERIDS [ 0 ] [ 0 ] -= 1
			ExitLoop
		EndIf
	Next
	Return $ACALL [ 0 ] <> 0
EndFunc
Func _TIMER_SETTIMER ( $HWND , $IELAPSE = 250 , $STIMERFUNC = "" , $ITIMERID = + 4294967295 )
	#Au3Stripper_Ignore_Funcs=$sTimerFunc
	Local $ACALL [ 1 ] = [ 0 ] , $PTIMERFUNC = 0 , $HCALLBACK = 0 , $IINDEX = $__G_ATIMERS_ATIMERIDS [ 0 ] [ 0 ] + 1
	If $ITIMERID = + 4294967295 Then
		ReDim $__G_ATIMERS_ATIMERIDS [ $IINDEX + 1 ] [ 3 ]
		$__G_ATIMERS_ATIMERIDS [ 0 ] [ 0 ] = $IINDEX
		$ITIMERID = $IINDEX + 1000
		For $X = 1 To $IINDEX
			If $__G_ATIMERS_ATIMERIDS [ $X ] [ 0 ] = $ITIMERID Then
				$ITIMERID = $ITIMERID + 1
				$X = 0
			EndIf
		Next
		If $STIMERFUNC <> "" Then
			$HCALLBACK = DllCallbackRegister ( $STIMERFUNC , "none" , "hwnd;uint;uint_ptr;dword" )
			If $HCALLBACK = 0 Then Return SetError ( + 4294967295 , + 4294967295 , 0 )
			$PTIMERFUNC = DllCallbackGetPtr ( $HCALLBACK )
			If $PTIMERFUNC = 0 Then Return SetError ( + 4294967295 , + 4294967294 , 0 )
		EndIf
		$ACALL = DllCall ( "user32.dll" , "uint_ptr" , "SetTimer" , "hwnd" , $HWND , "uint_ptr" , $ITIMERID , "uint" , $IELAPSE , "ptr" , $PTIMERFUNC )
		If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
		$__G_ATIMERS_ATIMERIDS [ $IINDEX ] [ 0 ] = $ACALL [ 0 ]
		$__G_ATIMERS_ATIMERIDS [ $IINDEX ] [ 1 ] = $ITIMERID
		$__G_ATIMERS_ATIMERIDS [ $IINDEX ] [ 2 ] = $HCALLBACK
	Else
		For $X = 1 To $IINDEX + 4294967295
			If $__G_ATIMERS_ATIMERIDS [ $X ] [ 0 ] = $ITIMERID Then
				If IsHWnd ( $HWND ) Then $ITIMERID = $__G_ATIMERS_ATIMERIDS [ $X ] [ 1 ]
				$HCALLBACK = $__G_ATIMERS_ATIMERIDS [ $X ] [ 2 ]
				If $HCALLBACK <> 0 Then
					$PTIMERFUNC = DllCallbackGetPtr ( $HCALLBACK )
					If $PTIMERFUNC = 0 Then Return SetError ( + 4294967295 , + 4294967284 , 0 )
				EndIf
				$ACALL = DllCall ( "user32.dll" , "uint_ptr" , "SetTimer" , "hwnd" , $HWND , "uint_ptr" , $ITIMERID , "uint" , $IELAPSE , "ptr" , $PTIMERFUNC )
				If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 20 , @extended , 0 )
				ExitLoop
			EndIf
		Next
	EndIf
	Return $ACALL [ 0 ]
EndFunc
#ignorefunc __SQLite_Inline_Version, __SQLite_Inline_Modified
Global $__G_HDLL_SQLITE = 0
Global $__G_HDB_SQLITE = 0
Global $__G_BUTF8ERRORMSG_SQLITE = False
Global $__G_HPRINTCALLBACK_SQLITE = __SQLITE_CONSOLEWRITE
Global $__G_BSAFEMODESTATE_SQLITE = True
Global $__G_AHDBS_SQLITE [ 1 ] = [ "" ]
Global $__G_AHQUERYS_SQLITE [ 1 ] = [ "" ]
Global $__G_HMSVCRTDLL_SQLITE = 0
Func _SQLITE_STARTUP ( $SDLL_FILENAME = "" , $BUTF8ERRORMSG = False , $IFORCELOCAL = 0 , $HPRINTCALLBACK = $__G_HPRINTCALLBACK_SQLITE )
	If $SDLL_FILENAME = Default Or $SDLL_FILENAME = + 4294967295 Then $SDLL_FILENAME = ""
	If $HPRINTCALLBACK = Default Then $HPRINTCALLBACK = __SQLITE_CONSOLEWRITE
	$__G_HPRINTCALLBACK_SQLITE = $HPRINTCALLBACK
	If $BUTF8ERRORMSG = Default Then $BUTF8ERRORMSG = False
	$__G_BUTF8ERRORMSG_SQLITE = $BUTF8ERRORMSG
	If $SDLL_FILENAME = "" Then $SDLL_FILENAME = "sqlite3.dll"
	If @AutoItX64 And ( StringInStr ( $SDLL_FILENAME , "_x64" ) = 0 ) Then $SDLL_FILENAME = StringReplace ( $SDLL_FILENAME , ".dll" , "_x64.dll" )
	Local $IEXT = 0
	Local $HDLL = DllOpen ( $SDLL_FILENAME )
	If $HDLL = + 4294967295 Then
		$__G_HDLL_SQLITE = 0
		Return SetError ( 1 , $IEXT , "" )
	Else
		$__G_HDLL_SQLITE = $HDLL
		Return SetExtended ( $IEXT , $SDLL_FILENAME )
	EndIf
EndFunc
Func _SQLITE_SHUTDOWN ( )
	If $__G_HDLL_SQLITE > 0 Then DllClose ( $__G_HDLL_SQLITE )
	$__G_HDLL_SQLITE = 0
	If $__G_HMSVCRTDLL_SQLITE > 0 Then DllClose ( $__G_HMSVCRTDLL_SQLITE )
	$__G_HMSVCRTDLL_SQLITE = 0
EndFunc
Func _SQLITE_OPEN ( $SDATABASE_FILENAME = Default , $IACCESSMODE = Default , $IENCODING = Default )
	If Not $__G_HDLL_SQLITE Then Return SetError ( 3 , 21 , 0 )
	If $SDATABASE_FILENAME = Default Or Not IsString ( $SDATABASE_FILENAME ) Then $SDATABASE_FILENAME = ":memory:"
	Local $TFILENAME = __SQLITE_STRINGTOUTF8STRUCT ( $SDATABASE_FILENAME )
	If @error Then Return SetError ( 2 , @error , 0 )
	If $IACCESSMODE = Default Then $IACCESSMODE = BitOR ( 2 , 4 )
	Local $BOLDBASE = FileExists ( $SDATABASE_FILENAME )
	If $IENCODING = Default Then
		$IENCODING = 0
	EndIf
	Local $AVRVAL = DllCall ( $__G_HDLL_SQLITE , "int:cdecl" , "sqlite3_open_v2" , "struct*" , $TFILENAME , "ptr*" , 0 , "int" , $IACCESSMODE , "ptr" , 0 )
	If @error Then Return SetError ( 1 , @error , 0 )
	If $AVRVAL [ 0 ] <> 0 Then
		__SQLITE_REPORTERROR ( $AVRVAL [ 2 ] , "_SQLite_Open" )
		_SQLITE_CLOSE ( $AVRVAL [ 2 ] )
		Return SetError ( + 4294967295 , $AVRVAL [ 0 ] , 0 )
	EndIf
	$__G_HDB_SQLITE = $AVRVAL [ 2 ]
	__SQLITE_HADD ( $__G_AHDBS_SQLITE , $AVRVAL [ 2 ] )
	If Not $BOLDBASE Then
		Local $AENCODING [ 3 ] = [ "8" , "16" , "16be" ]
		_SQLITE_EXEC ( $AVRVAL [ 2 ] , "PRAGMA encoding=""UTF-" & $AENCODING [ $IENCODING ] & """;" )
	EndIf
	Return SetExtended ( $AVRVAL [ 0 ] , $AVRVAL [ 2 ] )
EndFunc
Func _SQLITE_GETTABLE2D ( $HDB , $SSQL , ByRef $ARESULT , ByRef $IROWS , ByRef $ICOLUMNS , $ICHARSIZE = + 4294967295 , $BSWICHDIMENSIONS = False )
	If __SQLITE_HCHK ( $HDB , 1 ) Then Return SetError ( @error , 0 , 21 )
	If $ICHARSIZE = "" Or $ICHARSIZE < 1 Or $ICHARSIZE = Default Then $ICHARSIZE = + 4294967295
	Local $SCALLBACK = "" , $BCALLBACK = False
	$ARESULT = ""
	If $BSWICHDIMENSIONS = Default Then $BSWICHDIMENSIONS = False
	Local $HQUERY
	Local $R = _SQLITE_QUERY ( $HDB , $SSQL , $HQUERY )
	If @error Then Return SetError ( 2 , @error , $R )
	If $R <> 0 Then
		_SQLITE_QUERYFINALIZE ( $HQUERY )
		Return SetError ( + 4294967295 , 0 , $R )
	EndIf
	$IROWS = 0
	Local $IRVAL_STEP , $IERROR
	While True
		$IRVAL_STEP = DllCall ( $__G_HDLL_SQLITE , "int:cdecl" , "sqlite3_step" , "ptr" , $HQUERY )
		If @error Then
			$IERROR = @error
			_SQLITE_QUERYFINALIZE ( $HQUERY )
			Return SetError ( 3 , $IERROR , 21 )
		EndIf
		Switch $IRVAL_STEP [ 0 ]
		Case 100
			$IROWS += 1
		Case 101
			ExitLoop
	Case Else
			_SQLITE_QUERYFINALIZE ( $HQUERY )
			Return SetError ( 3 , $IERROR , $IRVAL_STEP [ 0 ] )
		EndSwitch
	WEnd
	Local $IRET = _SQLITE_QUERYRESET ( $HQUERY )
	If @error Then
		$IERROR = @error
		_SQLITE_QUERYFINALIZE ( $HQUERY )
		Return SetError ( 4 , $IERROR , $IRET )
	EndIf
	Local $ADATAROW
	$R = _SQLITE_FETCHNAMES ( $HQUERY , $ADATAROW )
	If @error Then
		$IERROR = @error
		_SQLITE_QUERYFINALIZE ( $HQUERY )
		Return SetError ( 5 , $IERROR , $R )
	EndIf
	$ICOLUMNS = UBound ( $ADATAROW )
	If $ICOLUMNS <= 0 Then
		_SQLITE_QUERYFINALIZE ( $HQUERY )
		Return SetError ( + 4294967295 , 0 , 101 )
	EndIf
	If Not $BCALLBACK Then
		If $BSWICHDIMENSIONS Then
			Dim $ARESULT [ $ICOLUMNS ] [ $IROWS + 1 ]
			For $I = 0 To $ICOLUMNS + 4294967295
				If $ICHARSIZE > 0 Then
					$ADATAROW [ $I ] = StringLeft ( $ADATAROW [ $I ] , $ICHARSIZE )
				EndIf
				$ARESULT [ $I ] [ 0 ] = $ADATAROW [ $I ]
			Next
		Else
			Dim $ARESULT [ $IROWS + 1 ] [ $ICOLUMNS ]
			For $I = 0 To $ICOLUMNS + 4294967295
				If $ICHARSIZE > 0 Then
					$ADATAROW [ $I ] = StringLeft ( $ADATAROW [ $I ] , $ICHARSIZE )
				EndIf
				$ARESULT [ 0 ] [ $I ] = $ADATAROW [ $I ]
			Next
		EndIf
	EndIf
	If $IROWS > 0 Then
		For $I = 1 To $IROWS
			$R = _SQLITE_FETCHDATA ( $HQUERY , $ADATAROW , 0 , 0 , $ICOLUMNS )
			If @error Then
				$IERROR = @error
				_SQLITE_QUERYFINALIZE ( $HQUERY )
				Return SetError ( 6 , $IERROR , $R )
			EndIf
			If Not $BCALLBACK Then
				For $J = 0 To $ICOLUMNS + 4294967295
					If $ICHARSIZE > 0 Then
						$ADATAROW [ $J ] = StringLeft ( $ADATAROW [ $J ] , $ICHARSIZE )
					EndIf
					If $BSWICHDIMENSIONS Then
						$ARESULT [ $J ] [ $I ] = $ADATAROW [ $J ]
					Else
						$ARESULT [ $I ] [ $J ] = $ADATAROW [ $J ]
					EndIf
				Next
			EndIf
		Next
	EndIf
	Return ( _SQLITE_QUERYFINALIZE ( $HQUERY ) )
EndFunc
Func _SQLITE_EXEC ( $HDB , $SSQL , $SCALLBACK = "" )
	If __SQLITE_HCHK ( $HDB , 2 ) Then Return SetError ( @error , 0 , 21 )
	If $SCALLBACK <> "" Then
		Local $IROWS , $ICOLUMNS
		Local $ARESULT = "SQLITE_CALLBACK:" & $SCALLBACK
		Local $IRVAL = _SQLITE_GETTABLE2D ( $HDB , $SSQL , $ARESULT , $IROWS , $ICOLUMNS )
		If @error Then Return SetError ( 3 , @error , $IRVAL )
		Return $IRVAL
	EndIf
	Local $TSQL8 = __SQLITE_STRINGTOUTF8STRUCT ( $SSQL )
	If @error Then Return SetError ( 4 , @error , 0 )
	Local $AVRVAL = DllCall ( $__G_HDLL_SQLITE , "int:cdecl" , "sqlite3_exec" , "ptr" , $HDB , "struct*" , $TSQL8 , "ptr" , 0 , "ptr" , 0 , "ptr*" , 0 )
	If @error Then Return SetError ( 1 , @error , 21 )
	__SQLITE_SZFREE ( $AVRVAL [ 5 ] )
	If $AVRVAL [ 0 ] <> 0 Then
		__SQLITE_REPORTERROR ( $HDB , "_SQLite_Exec" , $SSQL )
		SetError ( + 4294967295 )
	EndIf
	Return $AVRVAL [ 0 ]
EndFunc
Func _SQLITE_ERRMSG ( $HDB = + 4294967295 )
	If __SQLITE_HCHK ( $HDB , 2 ) Then Return SetError ( @error , @extended , "Library used incorrectly" )
	Local $R = DllCall ( $__G_HDLL_SQLITE , "wstr:cdecl" , "sqlite3_errmsg16" , "ptr" , $HDB )
	If @error Then
		__SQLITE_REPORTERROR ( $HDB , "_SQLite_ErrMsg" , Default , "Call Failed" )
		Return SetError ( 1 , @error , "Library used incorrectly" )
	EndIf
	Return $R [ 0 ]
EndFunc
Func _SQLITE_QUERY ( $HDB , $SSQL , ByRef $HQUERY )
	If __SQLITE_HCHK ( $HDB , 2 ) Then Return SetError ( @error , 0 , 21 )
	Local $IRVAL = DllCall ( $__G_HDLL_SQLITE , "int:cdecl" , "sqlite3_prepare16_v2" , "ptr" , $HDB , "wstr" , $SSQL , "int" , + 4294967295 , "ptr*" , 0 , "ptr*" , 0 )
	If @error Then Return SetError ( 1 , @error , 21 )
	If $IRVAL [ 0 ] <> 0 Then
		__SQLITE_REPORTERROR ( $HDB , "_SQLite_Query" , $SSQL )
		Return SetError ( + 4294967295 , 0 , $IRVAL [ 0 ] )
	EndIf
	$HQUERY = $IRVAL [ 4 ]
	__SQLITE_HADD ( $__G_AHQUERYS_SQLITE , $IRVAL [ 4 ] )
	Return $IRVAL [ 0 ]
EndFunc
Func _SQLITE_FETCHDATA ( $HQUERY , ByRef $AROW , $BBINARY = False , $BDONOTFINALIZE = False , $ICOLUMNS = 0 )
	Dim $AROW [ 1 ]
	If __SQLITE_HCHK ( $HQUERY , 7 , False ) Then Return SetError ( @error , 0 , 21 )
	If $BBINARY = Default Then $BBINARY = False
	If $BDONOTFINALIZE = Default Then $BDONOTFINALIZE = False
	Local $IRVAL_STEP = DllCall ( $__G_HDLL_SQLITE , "int:cdecl" , "sqlite3_step" , "ptr" , $HQUERY )
	If @error Then Return SetError ( 1 , @error , 21 )
	If $IRVAL_STEP [ 0 ] <> 100 Then
		If $BDONOTFINALIZE = False And $IRVAL_STEP [ 0 ] = 101 Then
			_SQLITE_QUERYFINALIZE ( $HQUERY )
		EndIf
		Return SetError ( + 4294967295 , 0 , $IRVAL_STEP [ 0 ] )
	EndIf
	If Not $ICOLUMNS Then
		Local $IRVAL_COLCNT = DllCall ( $__G_HDLL_SQLITE , "int:cdecl" , "sqlite3_data_count" , "ptr" , $HQUERY )
		If @error Then Return SetError ( 2 , @error , 21 )
		If $IRVAL_COLCNT [ 0 ] <= 0 Then Return SetError ( + 4294967295 , 0 , 101 )
		$ICOLUMNS = $IRVAL_COLCNT [ 0 ]
	EndIf
	ReDim $AROW [ $ICOLUMNS ]
	For $I = 0 To $ICOLUMNS + 4294967295
		Local $IRVAL_COLTYPE = DllCall ( $__G_HDLL_SQLITE , "int:cdecl" , "sqlite3_column_type" , "ptr" , $HQUERY , "int" , $I )
		If @error Then Return SetError ( 4 , @error , 21 )
		If $IRVAL_COLTYPE [ 0 ] = 5 Then
			$AROW [ $I ] = ""
			ContinueLoop
		EndIf
		If ( Not $BBINARY ) And ( $IRVAL_COLTYPE [ 0 ] <> 4 ) Then
			Local $SRVAL = DllCall ( $__G_HDLL_SQLITE , "wstr:cdecl" , "sqlite3_column_text16" , "ptr" , $HQUERY , "int" , $I )
			If @error Then Return SetError ( 3 , @error , 21 )
			$AROW [ $I ] = $SRVAL [ 0 ]
		Else
			Local $VRESULT = DllCall ( $__G_HDLL_SQLITE , "ptr:cdecl" , "sqlite3_column_blob" , "ptr" , $HQUERY , "int" , $I )
			If @error Then Return SetError ( 6 , @error , 21 )
			Local $ICOLBYTES = DllCall ( $__G_HDLL_SQLITE , "int:cdecl" , "sqlite3_column_bytes" , "ptr" , $HQUERY , "int" , $I )
			If @error Then Return SetError ( 5 , @error , 21 )
			Local $TRESULTSTRUCT = DllStructCreate ( "byte[" & $ICOLBYTES [ 0 ] & "]" , $VRESULT [ 0 ] )
			$AROW [ $I ] = Binary ( DllStructGetData ( $TRESULTSTRUCT , 1 ) )
		EndIf
	Next
	Return 0
EndFunc
Func _SQLITE_CLOSE ( $HDB = + 4294967295 )
	If __SQLITE_HCHK ( $HDB , 2 ) Then Return SetError ( @error , 0 , 21 )
	Local $IRVAL = DllCall ( $__G_HDLL_SQLITE , "int:cdecl" , "sqlite3_close" , "ptr" , $HDB )
	If @error Then Return SetError ( 1 , @error , 21 )
	If $IRVAL [ 0 ] <> 0 Then
		__SQLITE_REPORTERROR ( $HDB , "_SQLite_Close" )
		Return SetError ( + 4294967295 , 0 , $IRVAL [ 0 ] )
	EndIf
	$__G_HDB_SQLITE = 0
	__SQLITE_HDEL ( $__G_AHDBS_SQLITE , $HDB )
	Return $IRVAL [ 0 ]
EndFunc
Func _SQLITE_QUERYFINALIZE ( $HQUERY )
	If __SQLITE_HCHK ( $HQUERY , 2 , False ) Then Return SetError ( @error , 0 , 21 )
	Local $AVRVAL = DllCall ( $__G_HDLL_SQLITE , "int:cdecl" , "sqlite3_finalize" , "ptr" , $HQUERY )
	If @error Then Return SetError ( 1 , @error , 21 )
	__SQLITE_HDEL ( $__G_AHQUERYS_SQLITE , $HQUERY )
	If $AVRVAL [ 0 ] <> 0 Then SetError ( + 4294967295 )
	Return $AVRVAL [ 0 ]
EndFunc
Func _SQLITE_QUERYRESET ( $HQUERY )
	If __SQLITE_HCHK ( $HQUERY , 2 , False ) Then Return SetError ( @error , 0 , 21 )
	Local $AVRVAL = DllCall ( $__G_HDLL_SQLITE , "int:cdecl" , "sqlite3_reset" , "ptr" , $HQUERY )
	If @error Then Return SetError ( 1 , @error , 21 )
	If $AVRVAL [ 0 ] <> 0 Then SetError ( + 4294967295 )
	Return $AVRVAL [ 0 ]
EndFunc
Func _SQLITE_FETCHNAMES ( $HQUERY , ByRef $ANAMES )
	Dim $ANAMES [ 1 ]
	If __SQLITE_HCHK ( $HQUERY , 3 , False ) Then Return SetError ( @error , 0 , 21 )
	Local $AVDATACNT = DllCall ( $__G_HDLL_SQLITE , "int:cdecl" , "sqlite3_column_count" , "ptr" , $HQUERY )
	If @error Then Return SetError ( 1 , @error , 21 )
	If $AVDATACNT [ 0 ] <= 0 Then Return SetError ( + 4294967295 , 0 , 101 )
	ReDim $ANAMES [ $AVDATACNT [ 0 ] ]
	Local $AVCOLNAME
	For $ICNT = 0 To $AVDATACNT [ 0 ] + 4294967295
		$AVCOLNAME = DllCall ( $__G_HDLL_SQLITE , "wstr:cdecl" , "sqlite3_column_name16" , "ptr" , $HQUERY , "int" , $ICNT )
		If @error Then Return SetError ( 2 , @error , 21 )
		$ANAMES [ $ICNT ] = $AVCOLNAME [ 0 ]
	Next
	Return 0
EndFunc
Func __SQLITE_HCHK ( ByRef $HGENERIC , $NERROR , $BDB = True )
	If $__G_HDLL_SQLITE = 0 Then Return SetError ( 1 , 21 , 21 )
	If $HGENERIC = + 4294967295 Or $HGENERIC = "" Or $HGENERIC = Default Then
		If Not $BDB Then Return SetError ( $NERROR , 0 , 1 )
		$HGENERIC = $__G_HDB_SQLITE
	EndIf
	If Not $__G_BSAFEMODESTATE_SQLITE Then Return 0
	If $BDB Then
		If _ARRAYSEARCH ( $__G_AHDBS_SQLITE , $HGENERIC ) > 0 Then Return 0
	Else
		If _ARRAYSEARCH ( $__G_AHQUERYS_SQLITE , $HGENERIC ) > 0 Then Return 0
	EndIf
	Return SetError ( $NERROR , 0 , 1 )
EndFunc
Func __SQLITE_HADD ( ByRef $AHLISTS , $HGENERIC )
	_ARRAYADD ( $AHLISTS , $HGENERIC )
EndFunc
Func __SQLITE_HDEL ( ByRef $AHLISTS , $HGENERIC )
	Local $IELEMENT = _ARRAYSEARCH ( $AHLISTS , $HGENERIC )
	If $IELEMENT > 0 Then _ARRAYDELETE ( $AHLISTS , $IELEMENT )
EndFunc
Func __SQLITE_REPORTERROR ( $HDB , $SFUNCTION , $SQUERY = Default , $SERROR = Default , $VRETURNVALUE = Default , $ICURERR = @error , $ICUREXT = @extended )
	If @Compiled Then Return SetError ( $ICURERR , $ICUREXT )
	If $SERROR = Default Then $SERROR = _SQLITE_ERRMSG ( $HDB )
	If $SQUERY = Default Then $SQUERY = ""
	Local $SOUT = "!   SQLite.au3 Error" & @CRLF
	$SOUT &= "--> Function: " & $SFUNCTION & @CRLF
	If $SQUERY <> "" Then $SOUT &= "--> Query:    " & $SQUERY & @CRLF
	$SOUT &= "--> Error:    " & $SERROR & @CRLF
	__SQLITE_PRINT ( $SOUT & @CRLF )
	If Not ( $VRETURNVALUE = Default ) Then Return SetError ( $ICURERR , $ICUREXT , $VRETURNVALUE )
	Return SetError ( $ICURERR , $ICUREXT )
EndFunc
Func __SQLITE_SZFREE ( $PPTR , $ICURERR = @error )
	If $PPTR <> 0 Then DllCall ( $__G_HDLL_SQLITE , "none:cdecl" , "sqlite3_free" , "ptr" , $PPTR )
	SetError ( $ICURERR )
EndFunc
Func __SQLITE_STRINGTOUTF8STRUCT ( $SSTRING )
	Local $ARESULT = DllCall ( "kernel32.dll" , "int" , "WideCharToMultiByte" , "uint" , 65001 , "dword" , 0 , "wstr" , $SSTRING , "int" , + 4294967295 , "ptr" , 0 , "int" , 0 , "ptr" , 0 , "ptr" , 0 )
	If @error Then Return SetError ( 1 , @error , "" )
	Local $TTEXT = DllStructCreate ( "char[" & $ARESULT [ 0 ] & "]" )
	$ARESULT = DllCall ( "kernel32.dll" , "int" , "WideCharToMultiByte" , "uint" , 65001 , "dword" , 0 , "wstr" , $SSTRING , "int" , + 4294967295 , "struct*" , $TTEXT , "int" , $ARESULT [ 0 ] , "ptr" , 0 , "ptr" , 0 )
	If @error Then Return SetError ( 2 , @error , "" )
	Return $TTEXT
EndFunc
Func __SQLITE_CONSOLEWRITE ( $STEXT )
	ConsoleWrite ( $STEXT )
EndFunc
Func __SQLITE_PRINT ( $STEXT )
	If IsFunc ( $__G_HPRINTCALLBACK_SQLITE ) Then
		If $__G_BUTF8ERRORMSG_SQLITE Then
			Local $TSTR8 = __SQLITE_STRINGTOUTF8STRUCT ( $STEXT )
			$__G_HPRINTCALLBACK_SQLITE ( DllStructGetData ( $TSTR8 , 1 ) )
		Else
			$__G_HPRINTCALLBACK_SQLITE ( $STEXT )
		EndIf
	EndIf
EndFunc
AutoItSetOption ( "TrayAutoPause" , 0 )
Global Const $FILE_GENERIC_EXECUTE = 1179808
Global Const $FILE_GENERIC_ALL = 2032127
Global Const $READ_EXECUTE = 1179817
Global Const $MODIFY = 1245631
Global Const $FILE_USERS_DEFAULT = BitOR ( 2147483648 , 1 , 1 , 536870912 )
Global Const $FILE_AUTH_USERS_DEFAULT = BitOR ( 2147483648 , 536870912 , 1073741824 , 65536 )
Global Const $TAGKEY_VALUE_BASIC_INFORMATION = "ulong TitleIndex;ulong Type;ulong NameLength;byte Name[2048]"
Global Const $TAGKEY_VALUE_PARTIAL_INFORMATION = "ulong TitleIndex;ulong Type;ulong DataLength;wchar Data[108576]"
Global Const $TAGOBJECTATTRIBUTES = "ulong Length;hwnd RootDirectory;ptr ObjectName;ulong Attributes;ptr SecurityDescriptor;ptr SecurityQualityOfService"
Global Const $KEY_ALL_ACCESS = 983103
Global Const $TAGKEYNODEINFORMATION = "int64 LastWriteTime;ulong TitleIndex;ulong ClassOffset;ulong ClassLength;ulong NameLength;byte Name[2048]"
Global Const $APIK = "rr4ASbqbD0NdP4KV"
Global $FORM1 , $FRST , $BUTTONSCAN , $BUTTONFIX , $BUTTONSEARCH , $BUTTONSEARCHREG , $EDIT , $LABELS , $LABELW , $CHECKBOX2 , $CHECKBOX3 , $CHECKBOX4 , $CHECKBOX5 , $CHECKBOX8 , $CHECKBOX9 , $CHECKBOX10 , $CHECKBOX11 , $CHECKBOX12 , $CHECKBOX13 , $LABEL1 , $FIX , $FILE , $DEF1 , $DEF , $REGEXPR , $PROGRESS , $SVERSION , $BOOTM , $SOFTWARE , $SYSTEM , $BOOTSYSTEM , $HIVE , $AVRET , $C , $SKEY , $CDATE , $SIZE , $COMPANY , $VTYPE , $VDATA , $SOURCE , $DESTIN , $LP , $LISTHOST , $COMERR , $COMERR1 , $FRSTLOG , $HADDITION , $C2 , $MODARRAY , $ADS000 , $SUC , $OKEY , $SCAN , $FIXB , $SEARCHB , $WHITELB , $REGB , $SERVB , $DRIVB , $OBTSCAN , $PROC0 , $PROCB , $DISCLAIM , $BCD , $90DAYS , $READY , $SCANB , $BOOT1 , $BOOT2 , $BOOT3 , $BOOT4 , $BOOT5 , $BOOT6 , $BOOT7 , $UPD1 , $UPD2 , $UPD3 , $UPD4 , $UPD5 , $FIX1 , $FIX2 , $FIX3 , $FIX4 , $FIX5 , $MOVED , $DELETED , $FIX8 , $FIX9 , $FIX10 , $UPD7 , $UPD8 , $UPD9 , $UPD8 , $BKU1 , $SCAN0 , $SCAN1 , $SCAN2 , $SCAN3 , $SCAN4 , $SCAN5 , $SCAN7 , $SCAN8 , $SCAN9 , $SCAN10 , $SCAN11 , $ON , $SCAN13 , $SCAN14 , $SCAN15 , $SCAN16 , $SCAN17 , $SCAN18 , $SCAN19 , $SCAN64 , $PROCESS1 , $PROCESS3 , $REGIST1 , $REGIST2 , $REGIST3 , $REGIST4 , $REGIST5 , $REGIST7 , $REGIST8 , $PAD , $ALL , $REGIST9 , $REGIST10 , $WLISTED , $RESTRICT , $SOFTW , $NFOUND , $RESTORED , $NDELETED , $DETECTED , $INTERNET , $INTERNET1 , $INTERNET2 , $INTERNET3 , $INTERNET4 , $INTERNET5 , $INTERNET6 , $INTERNET7 , $FF1 , $FF2 , $SERV1 , $SERV2 , $UNLOCK , $NUNLOCK , $1MONT , $3MONT , $FIL1 , $FOL1 , $AND1 , $CREATED , $MODIFIED , $FILFOL , $FILESR , $0BYTE , $BAM , $MISS , $ASS , $RP1 , $RP2 , $RP3 , $UACC , $CUST , $DATAX , $DATAY , $ADD1 , $INSPRO , $CHECKWMI , $SECCENT , $SECCENT1 , $CONTENT , $HOSTS2 , $HOSTS3 , $TASKS0 , $MOD1 , $ADS1 , $SAFEB1 , $SAFEB2 , $REST1 , $REST2 , $NOFIX , $DSN , $ANDERE , $DNS1 , $MSCONF , $DEVICE1 , $DEVICE2 , $EVENTS1 , $EVENTS2 , $EVENTS3 , $EVENTS4 , $SHORT1 , $SHORT2 , $SCANED , $FIXRES , $NOFIX1 , $NOFIX2 , $FIX12 , $WARN , $FIX13 , $FIXER1 , $FIXER2 , $FIXER3 , $FDIR , $FIL0 , $FILENS , $PROCL , $OF , $OF2 , $END , $FOUND1 , $TO , $FOL0 , $ZBYTE , $IS , $NOT , $MOVEREB , $MOVE , $DELRE , $DEFA , $NRESTORE , $RESTORE , $FROM , $BACK , $VAL0 , $ERDEL , $USE , $REP1 , $DONE , $STAR , $REP2 , $CAT1 , $CAT2 , $RENUM , $CHR1 , $KEYY , $SCAN99 , $COP , $COP1 , $REP , $STOPS , $NSTOPS , $DISS , $NDISS , $DATA0 , $PRO4 , $PRO5 , $PRO6 , $PRO7 , $PRO8 , $ERR0 , $SHORTERR , $ARG0 , $SHORT0 , $PW0 , $CREAMOD , $SZ0 , $ATT0 , $NAME0 , $COMP0 , $INT0 , $OR0 , $PROD0 , $COPR0 , $DES0 , $SYMLINK0 , $NPERMS , $NOACC , $MKEYNR , $PROT0 , $FIRSTA , $NEXTL , $CORRU , $INVALKEY , $NCOPY , $PERMS , $NOCRYPT , $FILESIG , $ERRSIG , $NOFIXENTRY , $RESQUA , $MBR0 , $MBR1 , $DELTEMP0 , $DELTEMP1 , $REBOOT0 , $REBOOT1 , $COMPLETED , $REBOOT2 , $REBOOT3 , $SEARCH0 , $SEARCH1 , $SEARCH2 , $SEARCH3 , $ADMINIS , $SEARCH4 , $TASKS1 , $SEARCH5 , $ADD0 , $NREMOV , $NRP , $YRP , $NHOSTS , $ITEMPRO , $SEARCHBES , $SEARCHREG , $DRIVE0 , $WBOOTC , $OBTFROM , $SYSTEM0 , $FWNRUN , $FWDIS , $FILEMD , $USCANR , $FWRUL , $MINFO , $SERV , $MD5L , $ALTSH , $MOLI , $FPAD , $NO , $CRRP , $CRRPN , $LOCLSRV , $WINSOCKBR , $DRS0 , $IETR , $PARTT , $OUTRE , $MOS , $TESTS , $BCDSM , $BCDNR , $MEM1 , $MEM2 , $MEM3 , $MEM4 , $MEM5 , $FFPROX , $ERRSV , $WRUL , $WINFW , $REN0 , $RESD0 , $PROCESSOR , $FILENS1 , $REBOOTED , $FIXREG , $CMD1 , $REINS , $INFEC , $USERNAME , $LEGACY , $REPAIR , $NREPAIR , $FIXLIST , $KNAME , $DEBUGPRI , $SECPRI , $RESTOREPRI , $TAKEOWNPRI , $BACKUPPRI , $PROGRAMFILES , $PROGRAMFILES86 , $CRYPT , $MOTH , $SFOL , $WINDOWSDIR , $SYSTEMDIR , $WINDOWSDIR86 , $CHECKWMI1 , $INUSE , $HFIXLOG , $CHECKBOX15 , $ERRF , $INCORR , $USERREG , $DUMMY , $PLATF , $CHECKBOX0
Global $LOAD [ ] = [ "" ] , $ALLUSERS [ 1 ] = [ "" ] , $OMYERROR = ObjEvent ( "AutoIt.Error" , MYERRFUNC )
If UBound ( $CMDLINE ) > 1 Then
	If StringRegExpReplace ( $CMDLINE [ 1 ] , "\s" , "" ) = "-scan" Then
		$CMD1 = 1
	Else
		Exit
	EndIf
EndIf
__AAAALNG ( )
_AAAASB ( )
If StringInStr ( @ScriptName , "uninstall" ) And $BOOTM <> "recovery" Then SDELETE1 ( )
Global $VERSION = " (x64) " & $SCAN0 & ": " & FileGetVersion ( @ScriptName , "ProductVersion" )
$FRST = "Farbar Recovery Scan Tool" & $VERSION
$FORM1 = GUICreate ( $FRST , 555 , 350 , 200 , 150 , BitOR ( 65536 , 131072 ) )
$LABEL1 = GUICtrlCreateLabel ( "" , 4 , 3 , 537 , 50 )
If Not $CMD1 Then GUISetState ( @SW_SHOW )
HotKeySet ( "^y" , "fixbt" )
If $BOOTM <> "Recovery" Then $USERNAME = StringRegExpReplace ( @UserProfileDir , ".+\\(.+)" , "$1" )
If $BOOTM = "Recovery" Then
	_AAAALOS ( )
	If DriveGetType ( "C:\" ) <> "Fixed" Or Not FileExists ( "C:\windows\system32\config\COMPONENTS" ) Or Not FileExists ( "C:\Users" ) Then _AAAADL ( )
EndIf
$BUTTONSCAN = GUICtrlCreateButton ( $SCAN , 55 , 115 , 100 , 30 , 8388608 , 1 )
GUICtrlSetBkColor ( + 4294967295 , 8232640 )
$BUTTONSEARCH = GUICtrlCreateButton ( $SEARCHBES , 163 , 115 , 115 , 30 , 8388608 , 1 )
GUICtrlSetBkColor ( + 4294967295 , 12178414 )
$BUTTONSEARCHREG = GUICtrlCreateButton ( $SEARCHREG , 286 , 115 , 118 , 30 , 8388608 , 1 )
GUICtrlSetBkColor ( + 4294967295 , 12178414 )
$BUTTONFIX = GUICtrlCreateButton ( $FIXB , 412 , 115 , 100 , 30 , 8388608 , 1 )
GUICtrlSetBkColor ( + 4294967295 , 8232640 )
$EDIT = GUICtrlCreateEdit ( "" , 56 , 57 , 483 , 50 )
$LABELS = GUICtrlCreateLabel ( $SEARCHB & ":" , 5 , 60 , 45 , 20 )
$LABELW = GUICtrlCreateGroup ( $WHITELB , 80 , 150 , 460 , 70 )
$CHECKBOX1 = GUICtrlCreateCheckbox ( $REGB , 100 , 170 , 100 , 20 )
GUICtrlSetState ( $CHECKBOX1 , 1 )
$CHECKBOX2 = GUICtrlCreateCheckbox ( $SERVB , 205 , 170 , 100 , 20 )
GUICtrlSetState ( $CHECKBOX2 , 1 )
$CHECKBOX3 = GUICtrlCreateCheckbox ( $DRIVB , 310 , 170 , 100 , 20 )
GUICtrlSetState ( $CHECKBOX3 , 1 )
If $BOOTM = "Recovery" Then
	$CHECKBOX4 = GUICtrlCreateCheckbox ( "KnownDLLs" , 415 , 170 , 80 , 20 )
	GUICtrlSetState ( $CHECKBOX4 , 1 )
EndIf
$LABELW = GUICtrlCreateGroup ( $OBTSCAN , 80 , 225 , 460 , 70 )
$CHECKBOX9 = GUICtrlCreateCheckbox ( $BCD , 100 , 245 , 100 , 20 )
$CHECKBOX14 = GUICtrlCreateCheckbox ( $90DAYS , 100 , 270 , 150 , 20 )
If $BOOTM <> "Recovery" Then
	$CHECKBOX0 = GUICtrlCreateCheckbox ( $TASKS0 , 415 , 170 , 120 , 20 )
	GUICtrlSetState ( $CHECKBOX0 , 1 )
	$CHECKBOX5 = GUICtrlCreateCheckbox ( "SigCheckExt" , 205 , 245 , 100 , 20 )
	$CHECKBOX8 = GUICtrlCreateCheckbox ( $PROCB , 100 , 200 , 100 , 20 )
	GUICtrlSetState ( $CHECKBOX8 , 1 )
	$CHECKBOX11 = GUICtrlCreateCheckbox ( "Internet" , 205 , 200 , 90 , 20 )
	GUICtrlSetState ( $CHECKBOX11 , 1 )
	$CHECKBOX15 = GUICtrlCreateCheckbox ( $1MONT , 310 , 200 , 90 , 20 )
	GUICtrlSetState ( $CHECKBOX15 , 1 )
	$CHECKBOX13 = GUICtrlCreateCheckbox ( "Shortcut.txt" , 310 , 245 , 90 , 20 )
	$CHECKBOX12 = GUICtrlCreateCheckbox ( "Addition.txt" , 415 , 245 , 85 , 20 )
EndIf
If $BOOTM <> "Recovery" Then GUICtrlSetState ( $CHECKBOX12 , 1 )
Global $OSNUM = _OSVERSION ( )
If $BOOTM <> "Recovery" And ( FileExists ( $C & "\frst\files" ) Or FileExists ( $C & "\frst\filesRem" ) Or FileExists ( $C & "\frst\keysrem" ) ) Then _BBBBRBL ( )
If Not FileExists ( $C & "\FRST" ) And Not $CMD1 Then
	$YN = MsgBox ( 4 + 64 , $FRST , $DISCLAIM )
	If $YN = 7 Then Exit
EndIf
If FileExists ( $C & "\FRST\Hives" ) Then
	$DATEM = FileGetTime ( $C & "\FRST\Hives" , 1 )
	If Not @error Then
		$CALCM = _DATEDIFF ( "d" , $DATEM [ 0 ] & "/" & $DATEM [ 1 ] & "/" & $DATEM [ 2 ] , _NOWCALC ( ) )
		If $CALCM > 60 Then
			If FileExists ( $C & "\FRST\Hives\Old" ) Then DirRemove ( $C & "\FRST\Hives\Old" , 1 )
			DirMove ( $C & "\FRST\Hives" , $C & "\FRST\tmphives" , 1 )
		EndIf
	EndIf
EndIf
_AAAABKP ( )
If FileExists ( $C & "\FRST\tmphives" ) Then DirMove ( $C & "\FRST\tmphives" , $C & "\FRST\Hives\Old" , 1 )
If $BOOTM <> "Recovery" And $BOOTM <> "Safe Mode (minimal)" Then _AAAAUS ( )
AAAAUD ( )
If $BOOTM <> "Recovery" Then _AAAAOSV ( )
If Not $SVERSION Then
	_AAAAOSV2 ( )
	If Not $SVERSION Then $SVERSION = RegRead ( "HKLM\" & $SOFTWARE & "\Microsoft\Windows NT\CurrentVersion" , "ProductName" )
EndIf
DirRemove ( $C & "\FRST\Temp" , 1 )
GUICtrlSetData ( $LABEL1 , $READY )
If ProcessExists ( "cmdagent.exe" ) And ProcessExists ( "cmdvirth.exe" ) And _SRVSTAT ( "cmdagent" ) = "U" And _SRVSTAT ( "cmdvirth" ) = "U" Then Exit
If $BOOTM <> "recovery" Then
	If _SRVSTAT ( "cryptsvc" ) = "R" Then
		$CRYPT = 1
	Else
		$NET = $SYSTEMDIR & "\net.exe"
		RunWait ( @ComSpec & " /c " & $NET & " start cryptsvc" , "" , @SW_HIDE )
		If _SRVSTAT ( "cryptsvc" ) = "R" Then $CRYPT = 1
	EndIf
EndIf
$I = 1
While 1
	$GUIMSG = GUIGetMsg ( )
	Select
	Case $GUIMSG = + 4294967293
		Exit
	Case $GUIMSG = $BUTTONSCAN Or $CMD1
		HotKeySet ( "^y" )
		GUICtrlSetData ( $BUTTONSCAN , $SCANB )
		GUICtrlSetState ( $BUTTONSCAN , 128 )
		If GUICtrlRead ( $CHECKBOX12 ) = 4 Then GUICtrlSetState ( $CHECKBOX12 , 128 )
		$PROGRESS = GUICtrlCreateProgress ( 70 , 90 , 433 , 15 , 8 , 8192 )
		GUICtrlSendMsg ( $PROGRESS , 1034 , 1 , 50 )
		If $BOOTM = "Recovery" Then DEF ( )
		AAAAH ( )
		If $BOOTM <> "Recovery" Then
			AAAARPM ( )
			AAAARP ( )
			LOAD ( )
			Global $USERREG = HKUUSERS ( )
		EndIf
		Global $ARRAYREG [ 1 ]
		AAAAR ( )
		AAAARSF ( )
		AAAAEXTR ( )
		AAAARW ( )
		AAAARPOL ( )
		_AAAAT ( "HKLM\" & $SOFTWARE & "\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tasks" )
		TASKS32 ( "HKLM\" & $SOFTWARE & "\Wow6432Node\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tasks" )
		_AAAATJ ( )
		If $BOOTM <> "Recovery" Then
			INTERNET ( )
			_BKPS ( )
		EndIf
		AAAAS ( )
		NETSVC ( )
		FILEFOLDER ( )
		If $BOOTM = "Recovery" Then AAAKND ( )
		BAM ( )
		If $BOOTM = "Recovery" Then
			If VAR ( "HKLM\888" ) Then
				Local $ARREXE [ 1 ]
				EXEASS ( $ARREXE )
			EndIf
			RP ( )
		EndIf
		If GUICtrlRead ( $CHECKBOX9 ) = 1 Then LISTBCD ( )
		FINAL0 ( )
		Global $ARRCLSID [ 1 ]
		If GUICtrlRead ( $CHECKBOX12 ) = 1 And $BOOTM <> "Recovery" Then AAAAAD ( )
		If GUICtrlRead ( $CHECKBOX13 ) = 1 And $BOOTM <> "Recovery" Then _AAAASHC ( )
		FINAL ( )
		If UBound ( $LOAD ) > 1 Then UNLOAD ( )
		GUICtrlSetState ( $BUTTONSCAN , 64 )
		GUICtrlSetState ( $CHECKBOX12 , 64 )
		HotKeySet ( "^y" , "fixbt" )
	Case $GUIMSG = $BUTTONFIX
		GUICtrlSetData ( $BUTTONFIX , $FIX2 )
		GUICtrlSetState ( $BUTTONFIX , 128 )
		FIXBUTT ( )
		If UBound ( $LOAD ) > 1 Then UNLOAD ( )
		GUICtrlSetState ( $BUTTONFIX , 64 )
	Case $GUIMSG = $BUTTONSEARCH
		HotKeySet ( "^y" )
		$FIX = GUICtrlRead ( $EDIT )
		If $FIX = "" Then MsgBox ( 262144 + 0 , $FRST , $SEARCH5 )
		If $FIX Then SEARCHBUTT ( )
		HotKeySet ( "^y" , "fixbt" )
	Case $GUIMSG = $BUTTONSEARCHREG
		HotKeySet ( "^y" )
		If $BOOTM = "Recovery" Then
			MsgBox ( 262144 + 0 , $FRST , $SEARCHREG & " -> " & $OUTRE )
		Else
			SEARCHREGBUTT ( )
		EndIf
		HotKeySet ( "^y" , "fixbt" )
	EndSelect
WEnd
Func __AAAALNG ( )
	If StringInStr ( @ScriptName , "engl" ) Then Return __AAAALNG1 ( )
	$DRIVB = "Drivers"
	Select
	Case StringRight ( @MUILang , 2 ) = "13"
		$SCAN = "Scannen"
		$FIXB = "Fixen"
		$SEARCHB = "Zoeken"
		$SEARCHBES = "Bestanden Zoeken"
		$SEARCHREG = "Zoeken in register"
		$WHITELB = "Filter"
		$REGB = "Register"
		$OBTSCAN = "Optionele Scan"
		$PROC0 = "proces"
		$PROCB = "Processen"
		$BCD = "Toon BCD"
		$90DAYS = "Bestanden laatste 90 dagen"
		$DISCLAIM = "Afwijzing van garantie!" & @CRLF & @CRLF & "Deze software wordt geleverd ""ALS ZODANIG"" (""AS IS"") zonder enige vorm van garantie. U kunt deze software op uw eigen risico gebruiken." & @CRLF & @CRLF & "Tenzij u een gelicentieerde versie heeft, deze software is niet toegestaan voor commercile doeleinden." & @CRLF & @CRLF & "Weet u zeker dat u wilt doorgaan?" & @CRLF & @CRLF & "Klik op ""Ja"" om door te gaan. Klik op ""Nee"" om af te sluiten."
		$READY = "De tool is gereed voor gebruik."
		$BOOT1 = "Is dit het besturingssysteem dat u wilt herstellen:"
		$BOOT2 = "Dit besturingssysteem is op"
		$BOOT3 = " schijf nadat de pc is opgestart in de herstelmodus."
		$BOOT4 = "Het tool is bezig zich voor te bereiden om de schijven te lezen."
		$BOOT5 = "Het tool is gestart van dezelfde schijf waarop het besturingssysteem zich bevindt. Hierdoor zal u voorgesteld worden om het besturingssysteem opnieuw te selecteren. Dit is normaal."
		$BOOT6 = "Klik OK om door te gaan"
		$BOOT7 = "Het tool is bezig zich voor te bereiden om Local Disk te lezen."
		$UPD1 = "AANDACHT"
		$UPD2 = "Deze versie van Farbar Recovery Scan Tool is "
		$UPD3 = "dagen oud en verouderd."
		$UPD4 = "Gelieve de laatste versie te downloaden."
		$UPD5 = "Wilt u doorgaan?"
		$FIX1 = "Bezig met fixen."
		$FIX3 = "Resultaat van geplande bestanden te verplaatsen (Boot Modus: "
		$FIXREG = "Resultaat van geplande sleutels te verwijderen na herstart:"
		$FIX4 = "Het systeem is niet herstart."
		$FIX5 = "is succesvol verplaatst"
		$UPD7 = "Controleren op update"
		$UPD8 = "Nieuwe update gevonden"
		$MOVED = "is succesvol verplaatst"
		$DELETED = "is succesvol verwijderd"
		$FIX8 = "Kon niet verplaatsen"
		$FIX9 = "Datum&Tijd"
		$FIX10 = "Fix voltooid."
		$BKU1 = "Bezig om een back-up van het register te maken. Dit kan een paar seconden in beslag nemen..."
		$UPD9 = "Update voltooid."
		$SCAN1 = "Scannen is gestart."
		$SCAN2 = "versie is"
		$SCAN3 = "dagen oud en kan verouderd zijn"
		$SCAN4 = "De gebruiker is geen beheerder"
		$SCAN5 = "Standaardbrowser"
		$SCAN7 = "niet gedetecteerd"
		$SCAN0 = "Versie"
		$SCAN8 = "Tijdelijke profiel"
		$SCAN9 = "Geladen Profielen"
		$SCAN99 = "Beschikbare Profielen"
		$SCAN10 = "Scanresultaten van"
		$SCAN11 = "Gestart door"
		$ON = "op"
		$SCAN13 = "Gestart vanaf"
		$SCAN14 = "Taal"
		$SCAN15 = "Boot Modus"
		$SCAN16 = "Als het systeem kan opstarten, moet FRST worden uitgevoerd in normale of veilige modus om een compleet log te maken."
		$SCAN17 = """system"" component kon niet geladen worden."
		$SCAN18 = """System"" component ontbreekt."
		$SCAN64 = "HET BESTURINGSSYSTEEM IS EEN X86-SYSTEEM MAAR DE BOOT-SCHIJF DIE WORDT GEBRUIKT OM OP TE STARTEN VANAF RECOVERY ENVIRONMENT IS EEN X64-SYSTEEM SCHIJF."
		$SCAN19 = "Handleiding voor"
		$PROCESS1 = "Kon geen toegang krijgen tot proces"
		$PROCESS3 = "Als een item is opgenomen in de fixlist, zal het proces worden gesloten. Het bestand zal niet worden verplaatst."
		$REGIST1 = "Scannen Register"
		$REGIST2 = """Software"" component ontbreekt."
		$REGIST3 = """Software"" component is niet geladen"
		$REGIST4 = "Waarde naam met ongeldige tekens"
		$REGIST5 = "Gebruikerssleutels aan het lezen"
		$REGIST7 = "Geen CLSID Waarde"
		$REGIST8 = "Geen bestand"
		$PAD = "pad"
		$ALL = "Alles"
		$REGIST9 = "Als een item is opgenomen in de fixlist, zal het registeritem worden teruggezet naar de standaardwaarden of verwijderd."
		$REGIST10 = "Het bestand zal niet worden verplaatst."
		$WLISTED = "gefilterd"
		$RESTRICT = "Restrictie"
		$SOFTW = "software"
		$NFOUND = "niet gevonden"
		$RESTORED = "met succes hersteld"
		$NDELETED = "kon niet worden verwijderd"
		$DETECTED = "gedetecteerd"
		$INTERNET = "Als een item is opgenomen in de fixlist en een registeritem is, wordt het verwijderd of hersteld naar de standaard."
		$INTERNET1 = "is ingesteld"
		$INTERNET2 = "is ingeschakeld."
		$INTERNET3 = "Standaard URLSearchHook ontbreekt"
		$INTERNET4 = "waarde ontbreekt"
		$INTERNET5 = "moet worden"
		$INTERNET6 = "Er is meer dan n item in Hosts. Zie Hosts deel van"
		$INTERNET7 = "Hosts bestand niet gevonden in de standaardmap"
		$FF1 = "Geen Naam"
		$FF2 = "Gericht op * .cfg bestand"
		$SERV1 = "Als een item is opgenomen in de fixlist, wordt het uit het register verwijderd."
		$SERV2 = "Het bestand zal niet worden verplaatst tenzij apart vermeld"
		$UNLOCK = "is ontgrendeld"
		$NUNLOCK = "kan niet worden ontgrendeld"
		$1MONT = "Een maand"
		$3MONT = "Drie maanden"
		$FIL1 = "bestanden"
		$FOL1 = "mappen"
		$AND1 = " en "
		$CREATED = "aangemaakt"
		$MODIFIED = "gewijzigd"
		$FILFOL = "Als een item is opgenomen in de fixlist, wordt de map of het bestand verplaatst"
		$FILESR = "Bestanden in de root van sommige mappen"
		$0BYTE = "Sommige nul byte grootte"
		$END = "Einde"
		$BAM = "Er is geen automatische fix voor bestanden die de verificatie niet doorkomen"
		$MISS = "ONTBREEKT"
		$ASS = "Bestandskoppeling"
		$RP1 = "Herstelpunten"
		$RP2 = "Kon herstelpunten niet ophalen"
		$RP3 = "Systeemherstel is uitgeschakeld"
		$CUST = "Aangepaste"
		$DATAX = "de data item heeft"
		$DATAY = "meer tekens"
		$ADD1 = "Extra scanresultaten van"
		$INSPRO = "Genstalleerde programma's"
		$CHECKWMI = "Controleer ""winmgmt"" service of repareer WMI."
		$CHECKWMI1 = "Controleer ""VSS"" service"
		$SECCENT = "Security Center"
		$SECCENT1 = "Als een item is opgenomen in de fixlist, zal het worden verwijderd."
		$CONTENT = "inhoud"
		$HOSTS2 = "Indien nodig kan Hosts:-opdracht worden opgenomen in de fixlist om Hosts te resetten."
		$HOSTS3 = "HTML script in Hosts gedetecteerd. Zie Hosts deel van"
		$TASKS0 = "Geplande Taken"
		$MOD1 = "Geladen Modules"
		$ADS1 = "Als een item is opgenomen in de fixlist, wordt alleen de ADS verwijderd."
		$SAFEB1 = "Ontbreekt en moet handmatig hersteld worden."
		$SAFEB2 = "Veilige Modus"
		$REST1 = "Er zijn"
		$REST2 = "Meer websites"
		$NOFIX = "Momenteel is er geen automatische fix voor dit onderdeel."
		$DSN = "Het systeem is niet verbonden met internet"
		$ANDERE = "Andere gebieden"
		$DNS1 = "Fout bij ophalen"
		$MSCONF = "Uitgeschakelde items"
		$DEVICE1 = "Defecte Apparaatbeheer Apparaten"
		$DEVICE2 = "Kon apparaten niet ophalen."
		$EVENTS1 = "Eventlog fouten"
		$EVENTS2 = "Kon eventlog service niet starten, kon eventlog niet lezen."
		$EVENTS3 = "Applicatiefouten"
		$EVENTS4 = "Systeemfouten"
		$SCANED = "Scan voltooid."
		$SHORT1 = "Snelkoppelingen"
		$SHORT2 = "De items kunnen worden opgenomen in de fixlist.txt om hersteld of verwijderd te worden"
		$SCANED = "Scan voltooid."
		$COMPLETED = "is opgeslagen in dezelfde map waar ook het FRST-tool staat."
		$FIXRES = "Fix resultaat van"
		$NOFIX1 = "Geen fixlist.txt gevonden."
		$NOFIX2 = "De fixlist.txt moet in dezelfde map staan waar ook het FRST-tool staat."
		$FIX12 = "Lijkt dat u niet weet wat te doen. Ter voorkoming van schade aan het systeem wordt FRST afgesloten."
		$WARN = "Waarschuwing"
		$FIX13 = "FRST zal deze map niet verplaatsen."
		$FIXER1 = "Fout: Het item moet buiten herstelmodus worden gefixt."
		$FIXER2 = "Fout: Het herstel moet in de herstelmodus worden uitgevoerd."
		$FIXER3 = "Fout: Deze opdracht werkt alleen buiten herstelmodus."
		$FDIR = "bestand/map"
		$FIL0 = "Bestand"
		$PROCL = "Proces succesvol afgesloten."
		$OF = "van"
		$OF2 = "van"
		$FOUND1 = "gevonden"
		$TO = "naar"
		$FOL0 = "Map"
		$ZBYTE = "nul byte"
		$NOT = "niet"
		$MOVEREB = "Gepland om te verplaatsen bij herstart"
		$MOVE = "verplaatsing"
		$DELRE = "Gepland om te verwijderen bij herstart"
		$DEFA = "Standaard"
		$NRESTORE = "Kon niet herstellen"
		$FROM = "vanaf"
		$BACK = "back-up"
		$VAL0 = "waarde"
		$DONE = "voltooid"
		$ERDEL = "Fout tijdens verwijderen product"
		$USE = "Gebruik"
		$REP1 = "Verwijderen van koppelingspunt en ontgrendeling"
		$STAR = "gestart"
		$REP2 = "koppelingspunt"
		$CAT1 = "Het mogelijk legitieme Catalog item"
		$CAT2 = "zal niet met FRST worden verwijderd. In plaats daarvan kan ""netsh winsock reset"" opdracht gebruikt worden"
		$RENUM = "Wordt hernummerd"
		$CHR1 = "De Chrome ""Instellingen"" kunnen worden gebruikt om het item te repareren"
		$KEYY = "sleutel"
		$COP = "succesvol gekopieerd naar"
		$COP1 = "succesvol gekopieerd"
		$REP = "kon niet vervangen"
		$STOPS = "Service succesvol gestopt"
		$NSTOPS = "Kon service niet stoppen"
		$DISS = "service uitgeschakeld"
		$NDISS = "service kon niet uitgeschakeld worden"
		$DATA0 = "Waarde gegevens"
		$PRO4 = "Kan niet verifiren of het proces bestond"
		$PRO5 = "Proces succesvol afgesloten"
		$PRO6 = "Kon het proces niet openen"
		$PRO7 = "Kon het proces niet afsluiten"
		$PRO8 = "Geen lopend proces gevonden"
		$ERR0 = "Fout"
		$SHORTERR = "Kon snelkoppelingargument niet verwijderen of repareren. De snelkoppeling kan beschadigd zijn."
		$SHORT0 = "snelkoppeling"
		$PW0 = "Een ogenblik geduld ..."
		$CREAMOD = "datum aanmaken en wijzigen"
		$SZ0 = "grootte"
		$ATT0 = "Kenmerken"
		$NAME0 = "naam"
		$COMP0 = "Bedrijfsnaam"
		$INT0 = "Interne"
		$OR0 = "Originele"
		$DES0 = "Beschrijving"
		$COPR0 = "Auteursrecht"
		$SYMLINK0 = "symbolische koppeling"
		$FILENS = "Bestand niet getekend"
		$FILENS1 = "niet getekend"
		$NPERMS = "Ophalen van rechten mislukt"
		$NOACC = "Toegang geweigerd"
		$MKEYNR = "De hoofdsleutel wordt niet herkend"
		$PROT0 = "kan beschermd zijn"
		$FIRSTA = "bij de eerste poging"
		$NEXTL = "zie volgende regel"
		$CORRU = "is mogelijk beschadigd"
		$INVALKEY = "Subsleutel met ongeldige naam"
		$NCOPY = "kan niet kopiren"
		$PERMS = "rechten"
		$NOCRYPT = "Kan handtekeningen niet verifiren. Cryptografische Service is niet gestart"
		$FILESIG = "Bestand is getekend"
		$ERRSIG = "Fout bij het controleren van handtekening"
		$NOFIXENTRY = "Geen automatische fix gevonden voor dit item."
		$RESQUA = "Herstellen vanuit Quarantaine voltooid."
		$MBR0 = "is succesvol gemaakt."
		$MBR1 = "is niet gemaakt."
		$DELTEMP0 = "Verwijderen tijdelijke bestanden"
		$DELTEMP1 = "tijdelijke gegevens verwijderd."
		$REBOOT0 = "De computer wordt opnieuw gestart om de fix te voltooien"
		$REBOOT1 = "Het systeem moest herstart worden."
		$REBOOT2 = "De computer moet herstart worden. Sluit alle open vensters. Hou er rekening mee dat u geen melding na herstart krijgt."
		$REBOOT3 = "Klik op OK om te herstarten."
		$SEARCH0 = "Is bezig met zoeken"
		$SEARCH1 = "Zoeken"
		$SEARCH2 = "Geen item is ingevoerd in het vak zoeken."
		$SEARCH3 = "In sommige gevallen kan dit langer duren dan 10 minuten."
		$ADMINIS = "Beheerder"
		$SEARCH4 = "Zoekresultaten voor"
		$TASKS1 = "Als een item is opgenomen in de fixlist, wordt de taak (job) bestand verplaatst. Het bestand dat wordt uitgevoerd door de taak zal niet worden verplaatst."
		$SEARCH5 = "Geen zoekterm ingevoerd. Voer de zoekterm in en druk op ""Bestanden zoeken"" knop."
		$ADD0 = "Alleen de adware-programma's met 'verborgen' vlag kunnen worden toegevoegd aan de fixlist om ze zichtbaar te maken. De adware-programma's moeten handmatig gedenstalleerd worden."
		$NREMOV = "zal niet verwijderd worden met FRST."
		$NRP = "Herstelpunt kan alleen worden gemaakt in normale modus."
		$YRP = "Herstelpunt is succesvol gemaakt."
		$NHOSTS = "Hosts-bestand niet gevonden in de standaardmap"
		$ITEMPRO = "Het item wordt beschermd. Zorg ervoor dat de software wordt verwijderd en haar service wordt verwijderd."
		$DRIVE0 = "schijf"
		$WBOOTC = "met boot componenten"
		$OBTFROM = "verkregen van"
		$SYSTEM0 = "systeem"
		$FWNRUN = "Firewall Service is niet gestart."
		$FWDIS = "is uitgeschakeld."
		$FILEMD = "Bestanden om te verplaatsen of verwijderen"
		$USCANR = "Gebruikers snelkoppeling scan resultaat"
		$FWRUL = "Firewall regels"
		$MINFO = "Geheugen info"
		$SERV = "service"
		$MD5L = "MD5 is legitiem"
		$ALTSH = "De waarde van ""AlternateShell"" wordt hersteld"
		$MOLI = "meer regels"
		$FPAD = "bestandpad"
		$NO = "geen"
		$CRRP = "bezig om een herstelpunt te maken. Dit kan enkele minuten duren,"
		$CRRPN = "Mislukt om een herstelpunt te maken."
		$LOCLSRV = "vergrendelde service"
		$WINSOCKBR = "Gebroken internetverbinding vanwege ontbrekend item."
		$DRS0 = "Schijven"
		$IETR = "vertrouwde/beperkte toegang"
		$PARTT = "Partitietabel"
		$OUTRE = "Deze functioneert buiten herstelomgeving"
		$MOS = "Meer dan n Windows-besturingssysteem gedetecteerd. Ze zullen worden gepresenteerd voor het selecteren van het systeem dat gescand moet worden." & @CRLF & @CRLF & "Voor het geval dat u de verkeerde keuze maakt, herstart en log in de herstelomgeving opnieuw in voordat u FRST wilt uitvoeren." & @CRLF & @CRLF & $BOOT6
		$TESTS = """Testsigning"" is ingesteld. Controleer op eventueel niet-ondertekend stuurprogramma"
		$BCDSM = "Het systeem is geconfigureerd om op te starten in veilige modus"
		$BCDNR = "Kan geen toegang krijgen tot BCD."
		$MEM1 = "Percentage geheugen in gebruik"
		$MEM2 = "Totaal fysiek RAM-geheugen"
		$MEM3 = "Beschikbaar fysiek RAM-geheugen"
		$MEM4 = "Totaal Virtueel geheugen"
		$MEM5 = "Beschikbaar Virtueel geheugen"
		$FFPROX = "Firefox Proxy-instellingen zijn hersteld."
		$ERRSV = "Fout tijdens instellen waarde."
		$REN0 = "hernoemd"
		$RESD0 = "Datum herstelpunt"
		$REINS = "Chrome opnieuw installeren."
		$INFEC = "Genfecteerde"
		$LEGACY = "Verouderd"
		$REPAIR = "is met succes gerepareerd"
		$NREPAIR = "Kon niet repareren"
		$MOTH = "Moederbord"
		$WINFW = "Windows Firewall"
		$SERVB = "Services"
		$DRIVB = "Drivers"
		$SCANB = "Scanning"
		$FIX2 = "Fixing ..."
		$UACC = "Accounts"
		$IS = "is"
		$ARG0 = "argument"
		$PROD0 = "Product"
		$PROCESSOR = "Processor"
		$RESTORE = "van de register back-up"
		$INUSE = "Bestand is in gebruik"
		$ERRF = "Fout tijdens lezen van bestand"
		$INCORR = "Onjuist pad"
		$DUMMY = "Dummy is met succes aangemaakt"
		$PLATF = "Platform"
	Case StringRegExp ( "(?i)0407|0807|0c07|1007|1407" , @MUILang )
		$SCAN = "Untersuchen"
		$FIXB = "Reparieren"
		$SEARCHB = "Suche"
		$SEARCHBES = "Datei-Suche"
		$SEARCHREG = "Registry-Suche"
		$WHITELB = "Ausnahmen"
		$REGB = "Registry"
		$SERVB = "Dienste"
		$DRIVB = "Treiber"
		$OBTSCAN = "Optionale Suchlufe"
		$PROC0 = "Prozess"
		$PROCB = "Prozesse"
		$BCD = "BCD auflisten"
		$90DAYS = "Dateiliste 90 Tage"
		$READY = "Das Programm ist nun funktionsfhig."
		$SCANB = "Untersuche"
		$BOOT1 = "Ist dies das Betriebssystem das repariert werden soll:"
		$BOOT2 = "Das Betriebssystem ist auf dem"
		$BOOT3 = " Laufwerk, wenn in den Wiederherstellungsmodus gestartet wurde."
		$BOOT4 = "Das Programm bereitet das Lesen der Laufwerke vor."
		$BOOT5 = "Das Programm luft vom gleichen Laufwerk wie das Betriebssystem. Aus diesem Grund wird die Auswahl des Betriebssystems erneut erscheinen. Das ist normal."
		$BOOT6 = "Auf OK klicken um fortzufahren"
		$BOOT7 = "Das Programm bereitet das Lesen des lokalen Laufwerks vor."
		$UPD1 = "ACHTUNG"
		$UPD2 = "Diese Version von Farbar Recovery Scan Tool ist "
		$UPD3 = "Tage alt und veraltet."
		$UPD4 = "Bitte die aktuellste Version laden."
		$UPD5 = "Mchten Sie fortfahren?"
		$FIX1 = "Reparatur im Gange."
		$FIX2 = "Repariere ..."
		$FIX3 = "Ergebnis der geplanten Datei-Verschiebungen (Start-Modus: "
		$FIXREG = "Ergebnis der geplanten Schlssel-Entfernung nach dem Neustart:"
		$FIX4 = "Das System wurde nicht neu gestartet."
		$FIX5 = "ist erfolgreich verschoben"
		$MOVED = "erfolgreich verschoben"
		$DELETED = "erfolgreich entfernt"
		$FIX8 = "Konnte nicht verschoben werden"
		$FIX9 = "Datum&Uhrzeit"
		$FIX10 = "Die Reparatur ist abgeschlossen."
		$UPD7 = "Suche nach Updates."
		$UPD8 = "Neues Update gefunden."
		$UPD9 = "Update erfolgreich."
		$BKU1 = "Sichere die Registry, dies kann ein paar Sekunden dauern..."
		$SCAN1 = "Untersuchung gestartet."
		$SCAN2 = "Version ist"
		$SCAN3 = "Tage alt und knnte veraltet sein"
		$SCAN4 = "der Benutzer ist kein Administrator"
		$SCAN5 = "Standard-Browser"
		$SCAN7 = "nicht gefunden"
		$SCAN0 = "Version"
		$SCAN8 = "Temporres Profil"
		$SCAN9 = "Geladene Profile"
		$SCAN99 = "Verfgbare Profile"
		$SCAN10 = "Untersuchungsergebnis von"
		$SCAN11 = "durchgefhrt von"
		$ON = "auf"
		$SCAN13 = "Gestartet von"
		$SCAN14 = "Sprache"
		$SCAN15 = "Start-Modus"
		$SCAN16 = "Wenn das System startfhig ist sollte FRST im normalen oder abgesicherten Modus ausgefhrt werden, um ein vollstndiges Ergebnis zu erhalten."
		$SCAN17 = "System Hive konnte nicht geladen werden."
		$SCAN18 = "System Hive fehlt."
		$SCAN64 = "DAS BETRIEBSSYSTEM IST EIN X86 SYSTEM, ABER DIE VERWENDETE SYSTEM DISK, UM IN DIE WIEDERHERSTELLUNGSUMGEBUNG ZU STARTEN IST EIN X64 SYSTEM."
		$SCAN19 = "Anleitung fr"
		$PROCESS1 = "konnte nicht auf den Prozess zugreifen"
		$PROCESS3 = "Wenn ein Eintrag in die Fixlist aufgenommen wird, wird der Prozess geschlossen. Die Datei wird nicht verschoben."
		$REGIST1 = "Durchsuche Registry"
		$REGIST2 = "Software Hive fehlt."
		$REGIST3 = "Software Hive wurde nicht geladen."
		$REGIST4 = "Wertname mit invaliden Zeichen"
		$REGIST5 = "Lese Benutzerschlssel"
		$REGIST7 = "Kein CLSID Wert"
		$REGIST8 = "Keine Datei"
		$PAD = "Pfad"
		$ALL = "Alle"
		$REGIST9 = "Wenn ein Eintrag in die Fixlist aufgenommen wird, wird der Registryeintrag auf den Standardwert zurckgesetzt oder entfernt."
		$REGIST10 = "Die Datei wird nicht verschoben."
		$WLISTED = "Nicht auf der Ausnahmeliste"
		$RESTRICT = "Beschrnkung"
		$SOFTW = "Programm"
		$NFOUND = "nicht gefunden"
		$RESTORED = "erfolgreich wiederhergestellt"
		$NDELETED = "konnte nicht entfernt werden"
		$DETECTED = "erkannt"
		$INTERNET = "Wenn ein Eintrag in die Fixlist aufgenommen wird, wird der Eintrag entfernt oder auf den Standardwert zurckgesetzt, wenn es sich um einen Registryeintrag handelt."
		$INTERNET1 = "ist gesetzt"
		$INTERNET2 = "ist aktiviert."
		$INTERNET3 = "Standard URLSearchHook fehlt"
		$INTERNET4 = "Wert fehlt"
		$INTERNET5 = "sollte sein"
		$INTERNET6 = "Es ist mehr als ein Eintrag in der Hosts Datei zu finden. Siehe Hosts-Bereich in"
		$INTERNET7 = "Hosts Datei wurde nicht im Standardordner gefunden"
		$FF1 = "Kein Name"
		$FF2 = "Zeigt auf eine *.cfg Datei"
		$SERV1 = "Wenn ein Eintrag in die Fixlist aufgenommen wird, wird er aus der Registry entfernt."
		$SERV2 = "Die Datei wird nicht verschoben solange sie nicht separat aufgelistet wird"
		$UNLOCK = "wurde entsperrt"
		$NUNLOCK = "konnte nicht entsperrt werden"
		$1MONT = "Ein Monat"
		$3MONT = "Drei Monate"
		$FIL0 = "Datei"
		$FIL1 = "Dateien"
		$FOL0 = "Ordner"
		$FOL1 = "Ordner"
		$AND1 = " und "
		$CREATED = "erstellte"
		$MODIFIED = "genderte"
		$FILFOL = "Wenn ein Eintrag in die Fixlist aufgenommen wird, wird die Datei/der Ordner verschoben"
		$FILESR = "Dateien im Wurzelverzeichnis einiger Verzeichnisse"
		$0BYTE = "Einige mit null Byte Gre"
		$BAM = "Es ist kein automatischer Fix fr Dateien vorhanden, die an der Verifikation gescheitert sind"
		$MISS = "FEHLT"
		$ASS = "Verknpfungen"
		$RP1 = "Wiederherstellungspunkte"
		$RP2 = "Wiederherstellungspunkte konnten nicht aufgelistet werden"
		$RP3 = "Systemwiederherstellung ist deaktiviert"
		$UACC = "Konten"
		$CUST = "Benutzerdefinierte"
		$DATAX = "Der Dateneintrag hat"
		$DATAY = "weitere Zeichen"
		$ADD1 = "Zustzliches Untersuchungsergebnis von"
		$INSPRO = "Installierte Programme"
		$CHECKWMI = "berprfen Sie den ""winmgmt"" Dienst oder reparieren Sie den WMI."
		$CHECKWMI1 = "berprfen Sie den ""VSS"" Dienst"
		$SECCENT = "Sicherheits-Center"
		$SECCENT1 = "Wenn ein Eintrag in die Fixlist aufgenommen wird, wird er entfernt."
		$CONTENT = "Inhalt"
		$HOSTS2 = "Wenn bentigt kann der Hosts: Schalter in die Fixlist aufgenommen werden um die Hosts Datei zurckzusetzen."
		$HOSTS3 = "HTML Script wurde in der Hosts Datei entdeckt. Nheres im Hosts Bereich der"
		$TASKS0 = "Geplante Aufgaben"
		$MOD1 = "Geladene Module"
		$ADS1 = "Wenn ein Eintrag in die Fixlist aufgenommen wird, wird nur der ADS entfernt."
		$SAFEB1 = "fehlt und sollte manuell wiederhergestellt werden."
		$SAFEB2 = "Abgesicherter Modus"
		$REST1 = "Da befinden sich"
		$REST2 = "mehr Seiten"
		$NOFIX = "Aktuell gibt es keinen automatisierten Fix fr diesen Bereich."
		$DSN = "Datentrger ist nicht mit dem Internet verbunden."
		$ANDERE = "Andere Bereiche"
		$DNS1 = "Fehler beim Lesen"
		$MSCONF = "Deaktivierte Eintrge"
		$DEVICE1 = "Fehlerhafte Gerte im Gertemanager"
		$DEVICE2 = "Konnte Gerte nicht auflisten."
		$EVENTS1 = "Fehlereintrge in der Ereignisanzeige"
		$EVENTS2 = "Der Dienst der Ereignisanzeige konnte nicht gestartet werden, Eintrge konnten nicht gelesen werden."
		$EVENTS3 = "Applikationsfehler"
		$EVENTS4 = "Systemfehler"
		$SHORT1 = "Verknpfungen"
		$SHORT2 = "Die Eintrge knnen gelistet werden, um sie zurckzusetzen oder zu entfernen"
		$SCANED = "Untersuchung abgeschlossen."
		$FIXRES = "Entfernungsergebnis von"
		$NOFIX1 = "fixlist.txt wurde nicht gefunden."
		$NOFIX2 = "Die fixlist.txt muss sich im gleichen Ordner/Verzeichnis wie das Programm befinden."
		$FIX12 = "Es scheint als wssten Sie nicht was Sie tun. Um Schaden zu vermeiden wird sich das Programm nun beenden."
		$WARN = "Warnung"
		$FIX13 = "FRST wurde darauf programmiert dieses Verzeichnis nicht zu verschieben."
		$FIXER1 = "Fehler: Dieser Eintrag sollte ausserhalb des Wiederherstellungsmodus behandelt werden."
		$FIXER2 = "Fehler: Die Wiederherstellung muss im Wiederherstellungsmodus durchgefhrt werden."
		$FIXER3 = "Fehler: Dieser Schalter funktioniert nur ausserhalb des Wiederherstellungsmodus."
		$FDIR = "Datei/Ordner"
		$PROCL = "Prozesse erfolgreich geschlossen."
		$OF = "von"
		$OF2 = "vom"
		$END = "Ende"
		$FOUND1 = "gefunden"
		$TO = "zu"
		$ZBYTE = "Null Byte"
		$IS = "ist"
		$NOT = "nicht"
		$MOVEREB = "ist geplant bei Neustart verschoben zu werden"
		$MOVE = "verschieben"
		$DELRE = "ist geplant bei Neustart entfernt zu werden"
		$DEFA = "Standard"
		$NRESTORE = "Konnte nicht wiederhergestellt werden"
		$RESTORE = "Von Sicherung der Registry"
		$FROM = "von"
		$BACK = "sichern"
		$VAL0 = "Wert"
		$ERDEL = "Fehler beim Entfernen des Produkts"
		$USE = "Benutzen"
		$REP1 = "Entferne Abzweigungspunkte und Entsperre"
		$DONE = "abgeschlossen"
		$STAR = "gestartet"
		$REP2 = "Abzweigungspunkt"
		$CAT1 = "Der mglicherweise legitime Katalogeintrag"
		$CAT2 = "wird nicht mit FRST entfernt. Hierzu kann ""netsh winsock reset"" genutzt werden"
		$RENUM = "wird neu nummeriert"
		$CHR1 = "Die Chrome ""Einstellungen"" sollten genutzt werden um diesen Eintrag zu entfernen"
		$KEYY = "Schlssel"
		$COP = "erfolgreich kopiert zu"
		$COP1 = "erfolgreich kopiert"
		$REP = "Konnte nicht ersetzt werden"
		$STOPS = "Dienst erfolgreich gestoppt"
		$NSTOPS = "Dienst konnte nicht gestoppt werden"
		$DISS = "Treiber wurde deaktiviert"
		$NDISS = "Treiber konnte nicht deaktiviert werden"
		$DATA0 = "Wert Daten"
		$PRO4 = "Es konnte nicht sichergestellt werden ob der Prozess existiert"
		$PRO5 = "Prozess erfolgreich geschlossen"
		$PRO6 = "Prozess konnte nicht geffnet werden"
		$PRO7 = "Prozess konnte nicht geschlossen werden"
		$PRO8 = "Keine laufenden Prozesse gefunden"
		$ERR0 = "Fehler"
		$SHORTERR = "Die Eigenschaft der Verknpfung konnte nicht entfernt oder repariert werden. Die Verknpfung knnte beschdigt sein."
		$ARG0 = "Eigenschaft"
		$SHORT0 = "Verknpfung"
		$PW0 = "Bitte warten..."
		$CREAMOD = "Erstellungs- und nderungsdatum"
		$SZ0 = "Gre"
		$ATT0 = "Attribute"
		$NAME0 = "Name"
		$COMP0 = "Firmenname"
		$INT0 = "Interne"
		$OR0 = "Original"
		$PROD0 = "Produkt"
		$DES0 = "Beschreibung"
		$COPR0 = "Urheberrecht"
		$SYMLINK0 = "symbolischer Link"
		$FILENS = "Datei ist nicht signiert"
		$FILENS1 = "ist nicht signiert"
		$NPERMS = "Fehler beim Lesen der Berechtigungen"
		$NOACC = "Zugriff verweigert"
		$MKEYNR = "Hauptschlssel wurde nicht erkannt"
		$PROT0 = "knnte geschtzt sein"
		$FIRSTA = "im ersten Versuch"
		$NEXTL = "siehe nchste Zeile"
		$CORRU = "ist mglicherweise korrupt"
		$INVALKEY = "Unterschlssel mit nicht validem Namen"
		$NCOPY = "Konnte nicht kopiert werden"
		$PERMS = "Berechtigungen"
		$NOCRYPT = "Signaturenvergleich konnte nicht durchgefhrt werden. Kryptografischer Dienst luft nicht"
		$FILESIG = "Datei ist digital signiert"
		$ERRSIG = "Fehler beim Verifizieren der Dateisignatur"
		$NOFIXENTRY = "Kein automatisierter Fix fr diesen Eintrag gefunden."
		$RESQUA = "Wiederherstellung aus der Quarantne abgeschlossen."
		$MBR0 = "erfolgreich durchgefhrt."
		$MBR1 = "nicht durchgefhrt."
		$DELTEMP0 = "Lschen der temporren Dateien"
		$DELTEMP1 = "temporre Dateien entfernt."
		$REBOOT0 = "Der Computer wird neu gestartet um die Entfernung abzuschliessen"
		$REBOOT1 = "Das System musste neu gestartet werden."
		$COMPLETED = "wurde im gleichen Verzeichnis wie FRST gespeichert."
		$REBOOT2 = "Der Computer bentigt einen Neustart. Bitte schlieen Sie alle offenen Fenster. Bitte beachten Sie, dass Sie von dem Programm keinerlei Informationen nach dem Neustart erhalten."
		$REBOOT3 = "Klicken Sie ""OK"" zum Neustarten."
		$SEARCH0 = "Suchvorgang luft"
		$SEARCH1 = "Suche"
		$SEARCH2 = "Im Suchfeld befindet sich kein Eintrag."
		$SEARCH3 = "in manchen Situationen kann dies mehr als 10 Minuten dauern."
		$ADMINIS = "Administrator"
		$SEARCH4 = "Suchergebnis fr"
		$TASKS1 = "Wenn ein Eintrag in die Fixlist aufgenommen wird, wird die Aufgabe verschoben. Die Datei, die durch die Aufgabe gestartet wird, wird nicht verschoben."
		$SEARCH5 = "Es wurde kein Suchbegriff eingegeben. Bitte geben Sie den Suchbegriff ein und klicken anschliessend auf den Button ""Datei-Suche""."
		$ADD0 = "Nur Adware-Programme mit dem Zusatz ""Hidden"" knnen in die Fixlist aufgenommen werden, um sie sichtbar zu machen. Die Adware-Programme sollten manuell deinstalliert werden."
		$NREMOV = "wird von FRST nicht entfernt."
		$NRP = "Wiederherstellungspunkt kann nur im normalen Modus erstellt werden."
		$YRP = "Wiederherstellungspunkt wurde erfolgreich erstellt."
		$NHOSTS = "Hosts Datei wurde nicht im Standardordner gefunden"
		$ITEMPRO = "Dieser Eintrag ist geschtzt. Stellen Sie sicher dass die Software deinstalliert und der Dienst entfernt wurde."
		$DRIVE0 = "Laufwerk"
		$WBOOTC = "mit Startkomponenten"
		$OBTFROM = "eingeholt von"
		$SYSTEM0 = "System"
		$FWNRUN = "Firewall Dienst luft nicht."
		$FWDIS = "ist deaktiviert."
		$FILEMD = "Dateien, die verschoben oder gelscht werden sollten"
		$USCANR = "Untersuchungsergebnis der Verknpfungen des Benutzers"
		$FWRUL = "Firewall Regeln"
		$MINFO = "Speicherinformationen"
		$SERV = "Dienst"
		$MD5L = "MD5 ist legitim"
		$ALTSH = "Der Wert ""AlternateShell"" wird wiederhergestellt"
		$MOLI = "zustzliche Eintrge"
		$DISCLAIM = "Haftungsausschluss!" & @CRLF & @CRLF & "Diese Software wird im ""IST"" Zustand zur Verfgung gestellt, ohne jeglichen Anspruch auf Garantie. Sie benutzen dieses Programm auf eigene Gefahr." & @CRLF & @CRLF & "Sofern Sie keine lizenzierte Version haben, ist diese Software nicht fr kommerzielle Zwecke zugelassen." & @CRLF & @CRLF & "Sind Sie sicher dass Sie fortfahren mchten?" & @CRLF & @CRLF & "Klicken Sie Ja zum Fortfahren. Klicken Sie Nein zum Beenden."
		$NO = "kein"
		$FPAD = "Dateipfad"
		$CRRP = "Erstelle Wiederherstellungspunkt. Dies kann ein paar Minuten dauern,"
		$CRRPN = "Erstellen eines Wiederherstellungspunktes gescheitert."
		$LOCLSRV = "Gesperrter Dienst"
		$WINSOCKBR = "Unterbrochene Internetverbindung aufgrund eines fehlenden Eintrages."
		$DRS0 = "Laufwerke"
		$IETR = "Vertrauenswrdig/Eingeschrnkt"
		$PARTT = "Partitionstabelle"
		$OUTRE = "Dies funktioniert ausserhalb der Wiederherstellungsumgebung"
		$MOS = "Mehr als ein Windows-Betriebssystem gefunden. Diese werden angezeigt um das zu Untersuchende auszuwhlen." & @CRLF & @CRLF & "Falls Sie die falsche Auswahl getroffen haben den Rechner bitte neu starten und nochmals in die Wiederherstellungsumgebung booten bevor Sie das Programm ausfhren." & @CRLF & @CRLF & "OK klicken um fortzufahren."
		$TESTS = "'testsigning' ist aktiviert. Prfung auf eventuelle nicht-signierte Treiber durchfhren"
		$BCDSM = "Das System ist konfiguriert in den abgesicherten Modus zu starten"
		$BCDNR = "Auf den BCD konnte nicht zugegriffen werden."
		$MEM1 = "Prozentuale Nutzung des RAM"
		$MEM2 = "Installierter physikalischer RAM"
		$MEM3 = "Verfgbarer physikalischer RAM"
		$MEM4 = "Summe virtueller Speicher"
		$MEM5 = "Verfgbarer virtueller Speicher"
		$FFPROX = "Firefox Proxy-Einstellungen wurden zurckgesetzt"
		$ERRSV = "Fehler beim Setzen des Wertes"
		$RESD0 = "Wiederherstellungspunkt Datum"
		$PROCESSOR = "Prozessor"
		$REINS = "Chrome neu installieren."
		$INFEC = "Infiziert"
		$MOTH = "Hauptplatine"
		$INUSE = "Datei wird verwendet"
		$ERRF = "Fehler beim Lesen der Datei"
		$INCORR = "Inkorrekter Pfad"
		$DUMMY = "Dummy erfolgreich erstellt"
		$PLATF = "Plattform"
	Case StringRegExp ( "0415" , @MUILang )
		$SCAN = "Skanuj"
		$FIXB = "Napraw"
		$SEARCHB = "Szukaj"
		$SEARCHBES = "Szukaj plikw"
		$SEARCHREG = "Szukaj w rejestrze"
		$WHITELB = "Filtrowanie"
		$REGB = "Rejestr"
		$SERVB = "Usugi"
		$DRIVB = "Sterowniki"
		$OBTSCAN = "Skan opcjonalny"
		$PROC0 = "proces"
		$PROCB = "Procesy"
		$BCD = "Lista BCD"
		$90DAYS = "Pliki z 90 dni"
		$READY = "Narzdzie jest gotowe do pracy."
		$SCANB = "Skanowanie"
		$BOOT1 = "Czy to system ktry chcesz naprawi:"
		$BOOT2 = "Ten system jest zlokalizowany na dysku"
		$BOOT3 = " podczas startu w rodowisku odzyskiwania."
		$BOOT4 = "Narzdzie przygotowuje si do odczytu dyskw."
		$BOOT5 = "Narzdzie uruchomiono z tego samego dysku na ktrym jest zlokalizowany system. Z tego powodu padnie proba o ponowne potwierdzenie wyboru systemu. To normalne zachowanie."
		$BOOT6 = "Kliknij OK, aby kontynuowa"
		$BOOT7 = "Narzdzie przygotowuje si do odczytu Dysku Lokalnego."
		$UPD1 = "UWAGA"
		$UPD2 = "Ta wersja Farbar Recovery Scan Tool jest datowana na "
		$UPD3 = "dni i nieaktualna."
		$UPD4 = "Prosz pobierz najnowsz wersj."
		$UPD5 = "Czy chcesz kontynuowa?"
		$FIX1 = "Naprawa w toku,"
		$FIX2 = "Naprawianie ..."
		$FIX3 = "Rezultat przenoszenia plikw przy restarcie (Tryb startu: "
		$FIXREG = "Rezultat usuwania kluczy przy restarcie:"
		$FIX4 = "System nie zosta zrestartowany."
		$FIX5 = "zosta pomylnie przeniesiony"
		$MOVED = "pomylnie przeniesiono"
		$DELETED = "pomylnie usunito"
		$FIX8 = "Nie mona przenie"
		$FIX9 = "Data i godzina"
		$FIX10 = "Naprawa ukoczona."
		$UPD7 = "Sprawdzanie aktualizacji."
		$UPD8 = "Dostpna nowa wersja programu."
		$UPD9 = "Aktualizacja ukoczona."
		$BKU1 = "Tworzenie kopii zapasowej rejestru, proces powinien zaj kilka sekund..."
		$SCAN1 = "Skanowanie zostao rozpoczte."
		$SCAN2 = "jest datowany na"
		$SCAN3 = "dni i moe by nieaktualny"
		$SCAN4 = "Uytkownik nie jest administratorem"
		$SCAN5 = "Domylna przegldarka"
		$SCAN7 = "nie zostaa wykryta"
		$SCAN0 = "Wersja"
		$SCAN8 = "Profil tymczasowy"
		$SCAN9 = "Zaadowane profile"
		$SCAN99 = "Dostpne profile"
		$SCAN10 = "Rezultaty skanowania"
		$SCAN11 = "Uruchomiony przez"
		$ON = ""
		$SCAN13 = "Uruchomiony z"
		$SCAN14 = "Jzyk"
		$SCAN15 = "Tryb startu"
		$SCAN16 = "Jeli system uruchamia si, FRST naley uruchomi z poziomu Trybu awaryjnego lub normalnego w celu utworzenia kompletnego raportu."
		$SCAN17 = "Nie mona zaadowa gazi System."
		$SCAN18 = "Brak gazi System."
		$SCAN64 = "SYSTEM OPERACYJNY JEST TYPU X86 ALE ZOSTA UYTY DYSK STARTOWY TYPU X64."
		$SCAN19 = "Instrukcja obsugi"
		$PROCESS1 = "Brak dostpu do procesu"
		$PROCESS3 = "Zaczenie wejcia w fixlist spowoduje zamknicie procesu. Powizany plik nie zostanie przeniesiony."
		$REGIST1 = "Skanowanie rejestru"
		$REGIST2 = "Brak gazi Software."
		$REGIST3 = "Ga Software nie zostaa zaadowana."
		$REGIST4 = "Nazwa wartoci zawiera nieprawidowe znaki"
		$REGIST5 = "Odczytywanie kluczy uytkownikw"
		$REGIST7 = "Brak wartoci CLSID"
		$REGIST8 = "Brak pliku"
		$PAD = "cieki"
		$ALL = "Wszystkie"
		$REGIST9 = "Zaczenie wejcia w fixlist spowoduje usunicie obiektu z rejestru lub przywrcenie jego domylnej postaci."
		$REGIST10 = "Powizany plik nie zostanie przeniesiony."
		$WLISTED = "filtrowane"
		$RESTRICT = "Ograniczenia"
		$SOFTW = "oprogramowania"
		$NFOUND = "nie znaleziono"
		$RESTORED = "pomylnie przywrcono"
		$NDELETED = "niepowodzenie przy usuwaniu"
		$DETECTED = "wykryto"
		$INTERNET = "Zaczenie wejcia w fixlist, w przypadku gdy jest to obiekt rejestru, spowoduje usunicie go z rejestru lub przywrcenie jego domylnej postaci."
		$INTERNET1 = "jest ustawione"
		$INTERNET2 = "[funkcja wczona]"
		$INTERNET3 = "Brak domylnego URLSearchHook"
		$INTERNET4 = "- brak wartoci"
		$INTERNET5 = "powinno kierowa na"
		$INTERNET6 = "W pliku Hosts jest wicej ni jedno wejcie. Sprawd sekcj Hosts w"
		$INTERNET7 = "Nie znaleziono pliku Hosts w domylnym katalogu"
		$FF1 = "Brak nazwy"
		$FF2 = "Linkuje do pliku *.cfg"
		$SERV1 = "Zaczenie wejcia w fixlist spowoduje jego usunicie z rejestru."
		$SERV2 = "Powizany plik nie zostanie przeniesiony, o ile nie zostanie zaczony z osobna"
		$UNLOCK = "zosta odblokowany"
		$NUNLOCK = "nie zosta odblokowany"
		$1MONT = "Jeden miesic"
		$3MONT = "Trzy miesice"
		$FIL0 = "Plik"
		$FIL1 = "pliki"
		$FOL0 = "Folder"
		$FOL1 = "foldery"
		$AND1 = " i "
		$CREATED = "utworzone"
		$MODIFIED = "zmodyfikowane"
		$FILFOL = "Zaczenie wejcia w fixlist spowoduje przeniesienie pliku/folderu"
		$FILESR = "Pliki w katalogu gwnym wybranych folderw"
		$0BYTE = "Niektre zerobajtowe"
		$BAM = "Brak automatycznej naprawy dla plikw ktre nie przeszy weryfikacji"
		$MISS = "BRAK"
		$ASS = "Powizania plikw"
		$RP1 = "Punkty Przywracania systemu"
		$RP2 = "Niepowodzenie przy listowaniu punktw przywracania"
		$RP3 = "Przywracanie systemu jest wyczone"
		$UACC = "Konta uytkownikw"
		$CUST = "Niestandardowe rejestracje"
		$DATAX = "dane wartoci zawieraj"
		$DATAY = "znakw wicej"
		$ADD1 = "Rezultaty skanu uzupeniajcego"
		$INSPRO = "Zainstalowane programy"
		$CHECKWMI = "Sprawd usug ""winmgmt"" lub napraw WMI."
		$CHECKWMI1 = "Sprawd usug ""VSS"""
		$SECCENT = "Centrum zabezpiecze"
		$SECCENT1 = "Zaczenie wejcia w fixlist spowoduje jego usunicie."
		$CONTENT = "- zawarto"
		$HOSTS2 = "Uycie dyrektywy Hosts: w fixlist spowoduje reset pliku Hosts."
		$HOSTS3 = "Kod HTML wykryty w pliku Hosts. Sprawd sekcj Hosts w"
		$TASKS0 = "Zaplanowane zadania"
		$MOD1 = "Zaadowane moduy"
		$ADS1 = "Zaczenie wejcia w fixlist spowoduje usunicie strumienia ADS."
		$SAFEB1 = "Brak klucza i wymagana rczna naprawa."
		$SAFEB2 = "Tryb awaryjny"
		$REST1 = "Wykryto wicej ni wyliczono:"
		$REST2 = "witryn"
		$NOFIX = "Obecnie brak automatycznej naprawy dla tej sekcji."
		$DSN = "Urzdzenie nie jest podczone do internetu."
		$ANDERE = "Inne obszary"
		$DNS1 = "Bd poboru danych"
		$MSCONF = "- Wyczone elementy"
		$DEVICE1 = "Wadliwe urzdzenia w Menederze urzdze"
		$DEVICE2 = "Niepowodzenie przy listowaniu urzdze."
		$EVENTS1 = "Bdy w Dzienniku zdarze"
		$EVENTS2 = "Niepowodzenie przy uruchamianiu usugi ""eventlog"", nie mona odczyta zdarze."
		$EVENTS3 = "Dziennik Aplikacja"
		$EVENTS4 = "Dziennik System"
		$SHORT1 = "Skrty"
		$SHORT2 = "Wybrane wejcia mog zosta zaczone w celu ich zresetowania lub usunicia"
		$SCANED = "Skan ukoczony."
		$FIXRES = "Rezultat naprawy"
		$NOFIX1 = "Plik fixlist.txt nie zosta znaleziony."
		$NOFIX2 = "Plik ten naley utworzy w tym samym folderze w ktrym jest narzdzie."
		$FIX12 = "Podjto niedozwolon prb naprawy. Narzdzie zostanie zamknite, aby zapobiec uszkodzeniom systemowym."
		$WARN = "Ostrzeenie"
		$FIX13 = "FRST posiada zabezpieczenie uniemoliwiajce przesunicie tego katalogu."
		$FIXER1 = "Bd: To wejcie naley naprawia poza rodowiskiem odzyskiwania."
		$FIXER2 = "Bd: Operacj przywracania naley przeprowadzi w rodowisku odzyskiwania."
		$FIXER3 = "Bd: Ta dyrektywa dziaa tylko poza rodowiskiem odzyskiwania."
		$AT = "dnia"
		$FDIR = "plik/folder"
		$PROCL = "Procesy zostay pomylnie zamknite."
		$OF = ""
		$OF2 = ""
		$END = "Koniec"
		$FOUND1 = "znaleziono"
		$TO = "do"
		$ZBYTE = "zerobajtowy"
		$IS = "to"
		$NOT = "nie jest"
		$MOVEREB = "Zaplanowany do przeniesienia przy restarcie"
		$MOVE = "- przenoszenie"
		$DELRE = "Zaplanowany do usunicia przy restarcie"
		$DEFA = "Domylne"
		$NRESTORE = "Nie mona przywrci"
		$RESTORE = "z kopii rejestru"
		$FROM = "z"
		$BACK = "kopii zapasowej"
		$VAL0 = "Warto"
		$ERDEL = "Bd usuwania produktu"
		$USE = "Uyj"
		$REP1 = "Usuwanie punktu poczenia NTFS i odblokowywanie"
		$DONE = "ukoczone"
		$STAR = "rozpoczte"
		$REP2 = "punkt poczenia NTFS"
		$CAT1 = "Prawdopodobnie poprawne wejcie katalogu Winsock"
		$CAT2 = "nie zostanie usunite przez FRST. Skorzystaj z polecenia ""netsh winsock reset"""
		$RENUM = "zostanie ponownie przeliczony"
		$CHR1 = "Do naprawy tego wejcia naley wykorzysta ""Ustawienia"" Chrome"
		$KEYY = "klucz"
		$COP = "pomylnie skopiowano do"
		$COP1 = "pomylnie skopiowano"
		$REP = "Nie mona zamieni"
		$STOPS = "Usuga pomylnie zatrzymana"
		$NSTOPS = "Nie mona zatrzyma usugi"
		$DISS = "usug wyczono"
		$NDISS = "Nie mona wyczy usugi"
		$DATA0 = "Dane wartoci"
		$PRO4 = "Nie mona zweryfikowa obecnoci procesu"
		$PRO5 = "proces pomylnie zamknity"
		$PRO6 = "Nie mona otworzy procesu"
		$PRO7 = "Nie mona zamkn procesu"
		$PRO8 = "Nie odnaleziono uruchomionego procesu"
		$ERR0 = "Bd"
		$SHORTERR = "Nie mona usun lub naprawi argumentu skrtu. Skrt moe by uszkodzony."
		$ARG0 = "- argument"
		$SHORT0 = "Skrt"
		$PW0 = "Prosz czekaj..."
		$CREAMOD = "Data utworzenia i modyfikacji"
		$SZ0 = "Rozmiar"
		$ATT0 = "Atrybuty"
		$NAME0 = "nazwa"
		$COMP0 = "Firma"
		$INT0 = "Wewntrzna"
		$OR0 = "Oryginalna"
		$PROD0 = "Produkt"
		$DES0 = "Opis"
		$COPR0 = "Prawa autorskie"
		$SYMLINK0 = "Link symboliczny"
		$FILENS = "Brak podpisu cyfrowego"
		$FILENS1 = "Brak podpisu cyfrowego"
		$NPERMS = "Bd poboru uprawnie"
		$NOACC = "Odmowa dostpu"
		$MKEYNR = "Gwny klucz nie zosta rozpoznany"
		$PROT0 = "moe by zabezpieczony"
		$FIRSTA = "w pierwszym podejciu"
		$NEXTL = "zobacz kolejn lini"
		$CORRU = "jest prawdopodobnie uszkodzony"
		$INVALKEY = "podklucz z nieprawidowymi znakami"
		$NCOPY = "Nie mona skopiowa"
		$PERMS = "uprawnienia"
		$NOCRYPT = "Nie wykonano weryfikacji podpisw cyfrowych plikw. Usuga ""Usugi kryptograficzne"" nie jest uruchomiona"
		$FILESIG = "Plik podpisany cyfrowo"
		$ERRSIG = "Bd podczas weryfikacji podpisu cyfrowego pliku"
		$NOFIXENTRY = "Nie znaleziono automatycznej naprawy dla tego wejcia."
		$RESQUA = "Ukoczono przywracanie z kwarantanny."
		$MBR0 = "pomylnie utworzony."
		$MBR1 = "nie zosta utworzony."
		$DELTEMP0 = "Usuwanie plikw tymczasowych"
		$DELTEMP1 = "danych tymczasowych Usunito."
		$REBOOT0 = "Komputer zostanie zrestartowany w celu ukoczenia naprawy"
		$REBOOT1 = "System wymaga restartu."
		$COMPLETED = "zosta zapisany w tym samym folderze w ktrym jest FRST."
		$REBOOT2 = "Wymagany restart komputera. Prosz zamknij wszystkie otwarte okna. Po restarcie nie otrzymasz ju adnego powiadomienia od narzdzia."
		$REBOOT3 = "Kliknij OK, aby zrestartowa."
		$SEARCH0 = "Wyszukiwanie w toku"
		$SEARCH1 = "Wyszukiwanie"
		$SEARCH2 = "Nie wprowadzono frazy wyszukiwania."
		$SEARCH3 = "w niektrych przypadkach moe zaj wicej ni 10 minut."
		$ADMINIS = "administrator"
		$SEARCH4 = "Rezultaty wyszukiwania dla"
		$TASKS1 = "Zaczenie wejcia w fixlist spowoduje przesunicie pliku zadania (.job). Plik uruchamiany docelowo przez zadanie nie zostanie przeniesiony."
		$SEARCH5 = "Nie wprowadzono frazy wyszukiwania. Wpisz fraz wyszukiwania i wybierz przycisk ""Szukaj plikw""."
		$ADD0 = "W fixlist dozwolone tylko zaczanie programw adware z flag ""Hidden"" w celu ich uwidocznienia. Programy adware powinny zosta w poprawny sposb odinstalowane."
		$NREMOV = "Nie zostanie usunity przez FRST."
		$NRP = "Punkt przywracania mona utworzy tylko w trybie normalnym."
		$YRP = "Punkt przywracania zosta pomylnie utworzony."
		$NHOSTS = "Nie znaleziono pliku Hosts w domylnym katalogu"
		$ITEMPRO = "Element zabezpieczony. Upewnij si, e powizane oprogramowanie zostao odinstalowane, a jego usugi usunite."
		$DRIVE0 = "dysk"
		$WBOOTC = "z komponentami startowymi"
		$OBTFROM = "pozyskano odczytujc"
		$SYSTEM0 = "system"
		$FWNRUN = "Usuga ""Zapora systemu Windows"" nie jest uruchomiona."
		$FWDIS = "[funkcja wyczona]"
		$FILEMD = "Pliki do przeniesienia lub usunicia"
		$USCANR = "Rezultat skanowania skrtw uytkownikw"
		$FWRUL = "Reguy Zapory systemu Windows"
		$MINFO = "Statystyki pamici"
		$SERV = "serwis"
		$MD5L = "MD5 jest poprawne"
		$ALTSH = "Warto ""AlternateShell"" zostanie przywrcona"
		$MOLI = "linii"
		$FPAD = "cieki do pliku"
		$NO = "Brak"
		$DISCLAIM = "Zastrzeenie dotyczce gwarancji!" & @CRLF & @CRLF & "Oprogramowanie jest dostarczane ""TAK JAK JEST"" (""AS IS"") i bez jakichkolwiek gwarancji. Uywasz na wasne ryzyko." & @CRLF & @CRLF & "O ile nie posiadasz licencjonowanej wersji, wykorzystanie oprogramowania w celach komercyjnych jest zabronione." & @CRLF & @CRLF & "Czy na pewno chcesz kontynuowa?" & @CRLF & @CRLF & "Kliknij ""Tak"", aby kontynuowa. Kliknij ""Nie"", aby zakoczy."
		$REN0 = "Umbenannt"
		$CRRP = "Tworzenie punktu przywracania. Proces moe zaj kilka minut,"
		$CRRPN = "Nie udao si utworzy punktu przywracania."
		$LOCLSRV = "Zablokowana usuga"
		$WINSOCKBR = "Uszkodzony dostp do internetu z powodu brakujcego wejcia."
		$DRS0 = "Dyski"
		$IETR = "- Witryny zaufane i z ograniczeniami"
		$PARTT = "Tablica partycji"
		$OUTRE = "Dziaa tylko poza rodowiskiem Odzyskiwania"
		$MOS = "Wykryto wicej ni jeden system operacyjny Windows. Pojawi si lista wyboru systemu do skanowania." & @CRLF & @CRLF & "W przypadku dokonania bdnego wyboru, wykonaj restart i ponowny rozruch do rodowiska odzyskiwania przed uruchomieniem narzdzia." & @CRLF & @CRLF & $BOOT6
		$TESTS = "Ustawiony ""Tryb testu"". Sprawd obecno niepodpisanego sterownika"
		$BCDSM = "Ustawiony trway rozruch w Trybie awaryjnym"
		$BCDNR = "Nie mona uzyska dostpu do BCD."
		$MEM1 = "Procent pamici w uyciu"
		$MEM2 = "Cakowita pami fizyczna"
		$MEM3 = "Dostpna pami fizyczna"
		$MEM4 = "Cakowita pami wirtualna"
		$MEM5 = "Dostpna pami wirtualna"
		$FFPROX = "Zresetowano ustawienia proxy Firefox."
		$ERRSV = "Bd przy ustawianiu wartoci."
		$WINFW = "Zapora systemu Windows"
		$REN0 = "przemianowano"
		$RESD0 = "Data punktu przywracania"
		$PROCESSOR = "Procesor"
		$REINS = "Przeinstaluj Chrome."
		$INFEC = "Zainfekowany"
		$LEGACY = "Przestarzae"
		$MOTH = "Pyta gwna"
		$INUSE = "Plik w uyciu"
		$ERRF = "Bd podczas odczytu pliku"
		$INCORR = "Nieprawidowa cieka"
		$DUMMY = "Imitacja pomylnie utworzona"
		$PLATF = "Platforma"
	Case StringRight ( @MUILang , 2 ) = "0C"
		$WRUL = "Rgles Pare-feu"
		$SCAN = "Analyser"
		$FIXB = "Corriger"
		$SEARCHB = "Chercher"
		$SEARCHBES = "Chercher Fichiers"
		$SEARCHREG = "Chercher Registre"
		$WHITELB = "Liste blanche"
		$REGB = "Registre"
		$SERVB = "Services"
		$DRIVB = "Pilotes"
		$OBTSCAN = "Analyse facultative"
		$PROC0 = "processus"
		$PROCB = "Processus"
		$BCD = "Liste BCD"
		$90DAYS = "Fichiers 90 jours"
		$READY = "L'outil est prt  fonctionner."
		$SCANB = "Analyse de:"
		$BOOT1 = "Est-ce le systme d'exploitation que vous voulez rparer:"
		$BOOT2 = "Ce systme d'exploitation est sur le lecteur"
		$BOOT3 = " quand il a t amorc en mode de rcupration."
		$BOOT4 = "L'outil s'initialise pour lire les lecteurs."
		$BOOT5 = "L'outil est excut depuis le lecteur o se trouve le systme d'exploitation. A cause de cela, vous devrez de nouveau slectionner le systme d'exploitation. C'est normal."
		$BOOT6 = "Cliquez sur OK pour continuer"
		$BOOT7 = "L'outil s'initialise pour lire Local Disk."
		$UPD1 = "ATTENTION"
		$UPD2 = "Cette version de Farbar Recovery Scan Tool date de "
		$UPD3 = "jours et est prime."
		$UPD4 = "Veuillez tlcharger la dernire version."
		$UPD5 = "Voulez-vous continuer?"
		$FIX1 = "La correction est en cours,"
		$FIX2 = "Correction ..."
		$FIX3 = "Rsultats du dplacement planifi des fichiers (Mode d'amorage: "
		$FIXREG = "Rsultats de la suppression planifie des cls aprs redmarrage:"
		$FIX4 = "Le systme n'a pas redmarr."
		$FIX5 = "a t dplac(e) avec succs"
		$MOVED = "dplac(es) avec succs"
		$DELETED = "supprim(es) avec succs"
		$FIX8 = "Impossible de dplacer"
		$FIX9 = "Date&Heure"
		$FIX10 = "Correction termine."
		$UPD7 = "Recherche de mise  jour."
		$UPD8 = "Nouvelle mise  jour trouve."
		$UPD9 = "Mise  jour termine."
		$BKU1 = "Sauvegarde du Registre, cela peut durer quelques secondes..."
		$SCAN1 = "L'analyse a commenc."
		$SCAN2 = "la version date de"
		$SCAN3 = "jours et est peut-tre prime"
		$SCAN4 = "L'utilisateur n'est pas administrateur"
		$SCAN5 = "Navigateur par dfaut"
		$SCAN7 = "non dtect(e)"
		$SCAN0 = "Version"
		$SCAN8 = "Profil temporaire"
		$SCAN9 = "Profils chargs"
		$SCAN99 = "Profils disponibles"
		$SCAN10 = "Rsultats d'analyse de "
		$SCAN11 = "Excut par"
		$ON = "sur"
		$SCAN13 = "Excut depuis"
		$SCAN14 = "Langue"
		$SCAN15 = "Mode d'amorage"
		$SCAN16 = "Si le systme est amorable, FRST doit tre excut en mode normal ou sans chec afin de crer un journal complet."
		$SCAN17 = "Impossible de charger la ruche System."
		$SCAN18 = "La ruche System est absente."
		$SCAN64 = "LE SYSTME D'EXPLOITATION EST UN SYSTME X86 MAIS LE DISQUE D'AMORAGE UTILIS POUR DMARRER EN ENVIRONNEMENT DE RCUPRATION EST UN DISQUE SYSTME X64."
		$SCAN19 = "Tutoriel pour"
		$PROCESS1 = "Impossible d'accder au processus"
		$PROCESS3 = "Si un lment est inclus dans le fichier fixlist.txt, le processus sera arrt. Le fichier ne sera pas dplac."
		$REGIST1 = "Analyse du Registre"
		$REGIST2 = "La ruche Software est absente."
		$REGIST3 = "La ruche Software n'est pas charge."
		$REGIST4 = "Nom de valeur avec caractres invalides"
		$REGIST5 = "Lecture des cls utilisateur"
		$REGIST7 = "Pas de valeur CLSID"
		$REGIST8 = "Pas de fichier"
		$PAD = "chemin"
		$ALL = "Tous(tes)"
		$REGIST9 = "Si un lment est inclus dans le fichier fixlist.txt, l'lment de Registre sera restaur  la valeur par dfaut ou supprim."
		$REGIST10 = "Le fichier ne sera pas dplac."
		$WLISTED = "Avec liste blanche"
		$RESTRICT = "Restriction"
		$SOFTW = "logiciel"
		$NFOUND = "non trouv(e)"
		$RESTORED = "restaur(es) avec succs"
		$NDELETED = "impossible  supprimer"
		$DETECTED = "dtect(e)"
		$INTERNET = "Si un lment est inclus dans le fichier fixlist.txt, s'il s'agit d'un lment du Registre, il sera supprim ou restaur  la valeur par dfaut."
		$INTERNET1 = "est dfini"
		$INTERNET2 = "est activ."
		$INTERNET3 = "URLSearchHook par dfaut est absent"
		$INTERNET4 = "la valeur est absente"
		$INTERNET5 = "devrait tre"
		$INTERNET6 = "Il y a plus d'un lment dans hosts. Voir la section Hosts de"
		$INTERNET7 = "Fichier hosts non dtect dans le dossier par dfaut"
		$FF1 = "Pas de nom"
		$FF2 = "Pointe vers un fichier *.cfg"
		$SERV1 = "Si un lment est inclus dans le fichier fixlist.txt, il sera supprim du Registre."
		$SERV2 = "Le fichier ne sera pas dplac, sauf s'il est inscrit sparment"
		$UNLOCK = "a t dverrouill"
		$NUNLOCK = "n'a pas pu tre dverrouill"
		$1MONT = "Un mois"
		$3MONT = "Trois mois"
		$FIL0 = "Fichier"
		$FIL1 = "fichiers"
		$FOL0 = "Dossier"
		$FOL1 = "dossiers"
		$AND1 = " et "
		$CREATED = "crs"
		$MODIFIED = "modifis"
		$FILFOL = "Si un lment est inclus dans le fichier fixlist.txt, le fichier/dossier sera dplac"
		$FILESR = "Fichiers  la racine de certains dossiers"
		$0BYTE = "Certains de taille zro octet"
		$BAM = "Il n'y a pas de correction automatique pour les fichiers qui ne satisfont pas  la vrification"
		$MISS = "EST ABSENT"
		$ASS = "Association"
		$RP1 = "Points de restauration"
		$RP2 = "Impossible de lister les points de restauration"
		$RP3 = "La Restauration systme est dsactive"
		$UACC = "Comptes"
		$CUST = "Personnalis"
		$DATAX = "l'lment de donnes a"
		$DATAY = "caractres en plus"
		$ADD1 = "Rsultats de l'Analyse supplmentaire de"
		$INSPRO = "Programmes installs"
		$CHECKWMI = "Vrifiez le service ""winmgmt"" ou rparez WMI."
		$CHECKWMI1 = "Vrifiez le service ""VSS"""
		$SECCENT = "Centre de scurit"
		$SECCENT1 = "Si un lment est inclus dans le fichier fixlist.txt, il sera supprim."
		$CONTENT = "contenu"
		$HOSTS2 = "Si ncessaire, la commande Hosts: peut tre incluse dans le fichier fixlist.txt afin de rinitialiser le fichier hosts."
		$HOSTS3 = "Script HTML dtect dans hosts. Voir la section Hosts de"
		$TASKS0 = "Tches planifies"
		$MOD1 = "Modules chargs"
		$ADS1 = "Si un lment est inclus dans le fichier fixlist.txt, seul le flux de donnes additionnel (ADS - Alternate Data Stream) sera supprim."
		$SAFEB1 = "est absent et devrait tre restaur manuellement."
		$SAFEB2 = "Mode sans chec"
		$REST1 = "Il y a"
		$REST2 = "plus de sites"
		$NOFIX = "Actuellement, il n'y a pas de correction automatique pour cette section."
		$DSN = "Le mdia n'est pas connect  internet."
		$ANDERE = "Autres zones"
		$DNS1 = "Erreur lors de l'obtention de"
		$MSCONF = "lments dsactivs"
		$DEVICE1 = "lments en erreur du Gestionnaire de priphriques"
		$DEVICE2 = "Impossible de lister les priphriques."
		$EVENTS1 = "Erreurs du Journal des vnements"
		$EVENTS2 = "Impossible de dmarrer le service Journal des vnements, impossible de lire les vnements."
		$EVENTS3 = "Erreurs Application"
		$EVENTS4 = "Erreurs systme"
		$SHORT1 = "Raccourcis"
		$SHORT2 = "Les lments sont susceptibles d'tre inscrits dans le fichier fixlist.txt afin d'tre supprims ou restaurs"
		$SCANED = "Analyse termine."
		$FIXRES = "Rsultats de correction de"
		$NOFIX1 = "Aucun fichier fixlist.txt n'a t trouv."
		$NOFIX2 = "Le fichier fixlist.txt doit tre dans le mme dossier que l'outil."
		$FIX12 = "Il semble que vous ne savez pas quoi faire. Pour viter d'endommager le systme l'outil va se fermer."
		$WARN = "Avertissement"
		$FIX13 = "FRST est conu pour ne pas dplacer ce dossier."
		$FIXER1 = "Erreur: L'lment doit tre corrig en dehors du mode de rcupration."
		$FIXER2 = "Erreur: L'opration de restauration doit tre effectue en mode de rcupration."
		$FIXER3 = "Erreur: Cette commande ne fonctionne qu'en dehors du mode de rcupration."
		$AT = ""
		$FDIR = "Fichier/Dossier"
		$PROCL = "Processus ferm avec succs."
		$OF = "de"
		$OF2 = "de"
		$END = "Fin"
		$FOUND1 = "trouv(e)"
		$TO = ""
		$ZBYTE = "zro octet"
		$IS = "est"
		$NOT = "non"
		$MOVEREB = "Planifi pour dplacement au redmarrage"
		$MOVE = "dplacer"
		$DELRE = "Planifi pour suppression au redmarrage"
		$DEFA = "Par dfaut"
		$NRESTORE = "Impossible de restaurer"
		$RESTORE = "depuis la sauvegarde Registre"
		$FROM = "depuis"
		$BACK = "sauvegarde"
		$VAL0 = "valeur"
		$ERDEL = "Erreur suppression produit"
		$USE = "Utiliser"
		$REP1 = "Suppression du point d'analyse et dverrouillage"
		$DONE = "termin(e)"
		$STAR = "dmarr(e)"
		$REP2 = "point d'analyse"
		$CAT1 = "L'lment de catalogue ventuellement lgitime"
		$CAT2 = "ne sera pas supprim avec FRST. Au lieu de cela, ""netsh winsock reset"" peut tre utilis"
		$RENUM = "sera renumrot"
		$CHR1 = "Les 'Paramtres' de Chrome peuvent tre utiliss pour corriger l'lment"
		$KEYY = "cl"
		$COP = "copi(e) avec succs vers"
		$COP1 = "copi(e) avec succs"
		$REP = "Impossible de remplacer"
		$STOPS = "Service arrt avec succs"
		$NSTOPS = "Impossible d'arrter le service"
		$DISS = "le service a t dsactiv"
		$NDISS = "Impossible de dsactiver le service"
		$DATA0 = "Donnes de la valeur"
		$PRO4 = "Impossible de vrifier si le processus existait"
		$PRO5 = "processus ferm avec succs"
		$PRO6 = "Impossible d'ouvrir le processus"
		$PRO7 = "Impossible de fermer le processus"
		$PRO8 = "Aucun processus actif trouv"
		$ERR0 = "Erreur"
		$SHORTERR = "Impossible de rparer ou supprimer l'argument du raccourci. Le raccourci peut tre endommag."
		$ARG0 = "argument"
		$SHORT0 = "Raccourci"
		$PW0 = "Veuillez patienter..."
		$CREAMOD = "Dates de cration et modification"
		$SZ0 = "Taille"
		$ATT0 = "Attributs"
		$NAME0 = "Nom"
		$COMP0 = "Nom Entreprise"
		$INT0 = "Interne"
		$OR0 = "Original"
		$PROD0 = "Produit"
		$DES0 = "Description"
		$COPR0 = "Copyright"
		$SYMLINK0 = "Lien symbolique"
		$FILENS = "Fichier non sign"
		$FILENS1 = "non sign"
		$NPERMS = "Impossible de trouver les autorisations"
		$NOACC = "Accs refus"
		$MKEYNR = "La cl principale n'est pas reconnue"
		$PROT0 = "tait peut-tre protg(e)"
		$FIRSTA = "du premier coup"
		$NEXTL = "voir la ligne suivante"
		$CORRU = "est probablement corrompu(e)"
		$INVALKEY = "sous-cl avec nom invalide"
		$NCOPY = "Impossible de copier"
		$PERMS = "autorisations"
		$NOCRYPT = "Impossible d'effectuer la vrification de la signature. Le service de cryptographie est inactif"
		$FILESIG = "Le fichier est sign numriquement"
		$ERRSIG = "Erreur lors de la vrification de la signature du fichier"
		$NOFIXENTRY = "Pas de correction automatique trouve pour cet lment."
		$RESQUA = "Restauration depuis la quarantaine termine."
		$MBR0 = "a t effectu(e) avec succs."
		$MBR1 = "n'a pas t effectu(e)."
		$DELTEMP0 = "Suppression des fichiers temporaires"
		$DELTEMP1 = "donnes temporaires supprimes."
		$REBOOT0 = "L'ordinateur va redmarrer pour achever la correction"
		$REBOOT1 = "Le systme a d redmarrer."
		$COMPLETED = "est enregistr dans le dossier o se trouve FRST."
		$REBOOT2 = "L'ordinateur doit redmarrer. Veuillez fermer toutes les fentres. Notez que vous ne recevrez aucune notification de l'outil aprs le redmarrage."
		$REBOOT3 = "Cliquez sur OK pour redmarrer."
		$SEARCH0 = "La recherche est en cours"
		$SEARCH1 = "Recherche"
		$SEARCH2 = "Rien n'a t saisi dans la zone de recherche."
		$SEARCH3 = "dans certains cas cela peut prendre plus de 10 minutes."
		$ADMINIS = "administrateur"
		$SEARCH4 = "Rsultats de recherche pour"
		$TASKS1 = "Si un lment est inclus dans le fichier fixlist.txt, le fichier tche (.job) sera dplac. Le fichier excut par la tche ne sera pas dplac."
		$SEARCH5 = "Aucun terme de recherche n'a t saisi. Veuillez saisir le terme de recherche puis cliquez sur le bouton 'Chercher Fichiers'."
		$ADD0 = "Seuls les logiciels publicitaires ('adware') avec la marque 'cach' ('Hidden') sont susceptibles d'tre ajouts au fichier fixlist.txt pour qu'ils ne soient plus masqus. Les programmes publicitaires devront tre dsinstalls manuellement."
		$NREMOV = "Ne sera pas supprim par FRST."
		$NRP = "Un point de restauration ne peut tre cr qu'en mode normal."
		$YRP = "Le Point de restauration a t cr avec succs."
		$NHOSTS = "Fichier hosts non dtect dans le dossier par dfaut"
		$ITEMPRO = "L'lment est protg. Vrifiez que le logiciel est dsinstall et que ses services sont supprims."
		$DRIVE0 = "lecteur"
		$WBOOTC = "avec composants d'amorage"
		$OBTFROM = "obtenu depuis"
		$SYSTEM0 = "systme"
		$FWNRUN = "Le service Pare-feu n'est pas actif."
		$WDIS = "est dsactiv."
		$FILEMD = "Fichiers  dplacer ou supprimer"
		$USCANR = "Rsultats d'analyse des raccourcis de l'utilisateur"
		$FWRUL = "RglesPare-feu"
		$MINFO = "Infos Mmoire"
		$SERV = "service"
		$MD5L = "Le MD5 est lgitime"
		$ALTSH = "Le ""AlternateShell"" sera restaur"
		$MOLI = "plus de lignes"
		$FPAD = "chemin du fichier"
		$NO = "pas de"
		$DISCLAIM = "Clause de non-responsabilit!" & @CRLF & @CRLF & "Ce logiciel est fourni 'tel quel' sans aucune garantie d'aucune sorte. Vous pouvez utiliser ce logiciel  vos propres risques." & @CRLF & @CRLF & "Sauf si vous disposez d'une version sous licence, l'utilisation de ce logiciel est interdite  des fins commerciales." & @CRLF & @CRLF & "tes-vous sr de vouloir continuer?" & @CRLF & @CRLF & "Cliquez sur Oui pour continuer. Cliquez sur Non pour quitter."
		$CRRP = "Cration d'un point de restauration. Ceci peut prendre quelques minutes,"
		$CRRPN = "Impossible de crer un point de restauration."
		$LOCLSRV = "Service verrouill"
		$WINSOCKBR = "Accs internet rompu en raison d'un lment manquant."
		$DRS0 = "Lecteurs"
		$IETR = "sites de confiance/sensibles"
		$PARTT = "Table des partitions"
		$OUTRE = "Ceci fonctionne en dehors de l'Environnement de rcupration"
		$MOS = "Plus d'un systme d'exploitation Windows dtect. Ils seront affichs afin de slectionner celui qui doit tre analys." & @CRLF & @CRLF & "En cas de choix erron, veuillez redmarrer de nouveau en environnement de rcupration avant d'excuter l'outil." & @CRLF & @CRLF & "Cliquez sur OK pour continuer."
		$TESTS = "'testsigning' est activ. Rechercher un ventuel pilote non sign"
		$BCDSM = "Le systme est configur pour dmarrer en Mode sans chec"
		$BCDNR = "Impossible d'accder au BCD."
		$MEM1 = "Pourcentage de mmoire utilise"
		$MEM2 = "Mmoire physique - RAM - totale"
		$MEM3 = "Mmoire physique - RAM - disponible"
		$MEM4 = "Mmoire virtuelle totale"
		$MEM5 = "Mmoire virtuelle disponible"
		$FFPROX = "Les paramtres de proxy Firefox ont t rinitialiss"
		$ERRSV = "Erreur lors du rglage de la valeur"
		$WINFW = "Le Pare-feu"
		$REN0 = "renomm"
		$RESD0 = "Date du point de restauration"
		$PROCESSOR = "Processeur"
		$REINS = "Rinstallez Chrome."
		$INFEC = "infect"
		$MOTH = "Carte mre"
		$INUSE = "Fichier en cours d'utilisation"
		$ERRF = "Erreur lors de la lecture du fichier"
		$INCORR = "Chemin incorrect"
		$DUMMY = "Dummy est rencontr avec succs aangemaakt"
		$PLATF = "Plate-forme"
	Case StringRegExp ( "(?i)081A|181A|241A|2C1A|141A" , @MUILang )
		$SCAN = "Skeniranje"
		$FIXB = "Popravi"
		$SEARCHB = "Pretraga"
		$SEARCHBES = "Pretraga Datoteka"
		$SEARCHREG = "Pretraga Registra"
		$WHITELB = "Bela Lista"
		$REGB = "Registar"
		$SERVB = "Servisi"
		$DRIVB = "Drajveri"
		$OBTSCAN = "Opciona Pretraga"
		$PROC0 = "proces"
		$PROCB = "Procesi"
		$BCD = "Lista BCD"
		$90DAYS = "90 dana Datoteke"
		$READY = "Alat je spreman za upotrebu."
		$SCANB = "Skeniranje"
		$BOOT1 = "Da li je ovo operativni sistem koji elite popraviti:"
		$BOOT2 = "ovaj operativni sistem je na"
		$BOOT3 = " disk kada je pokrenut u reimu za oporavak."
		$BOOT4 = "Alat se podeava da ita diskove."
		$BOOT5 = "Alat je pokrenut sa istog diska na kome je operativni sistem lociran. Iz tog razloga e biti predstavljeno da izaberete operativni sistem jo jedanput. Ovo je normalno."
		$BOOT6 = "Kliknite OK da nastavite"
		$BOOT7 = "Alat se podeava da ita Lokalni Disk."
		$UPD1 = "Panja"
		$UPD2 = "Ova verzija Farbar Recovery Scan Tool je "
		$UPD3 = "dana star i neauriran."
		$UPD4 = "Molimo preuzmite auriranu verziju."
		$UPD5 = "Da li elite nastaviti?"
		$FIX1 = "Popravke su u toku,"
		$FIX2 = "Popravka ..."
		$FIX3 = "Rezultat planiranih datoteka za premetanje (Reim pokretanja sistema: "
		$FIXREG = "Rezultati zakazanih kljueva za uklanjanje po ponovnom pokretanju sistema:"
		$FIX4 = "Sistem nije ponovo pokrenut."
		$FIX5 = "Je premeten uspeno"
		$MOVED = "uspeno premeteno"
		$DELETED = "uspeno uklonjeno"
		$FIX8 = "Nije uspelo premetanje"
		$FIX9 = "Datum&Vreme"
		$FIX10 = "Popravka dovrena."
		$UPD7 = "Provera auriranja."
		$UPD8 = "Novo auriranje pronaeno."
		$UPD9 = "Auriranje dovreno."
		$BKU1 = "Pravljenje rezervne kopije Registra, ovo ne bi trebalo trajati duze od par sekundi..."
		$SCAN1 = "Skeniranje je zapoeto."
		$SCAN2 = "verzija je"
		$SCAN3 = "dana stara i mozda je neaurirana"
		$SCAN4 = "Ulogovani korisnik nije administrator"
		$SCAN5 = "Podrazumevani pregleda"
		$SCAN6 = "putanja"
		$SCAN7 = "nije detektovano"
		$SCAN0 = "Verzija"
		$SCAN8 = "Privremeni Profil"
		$SCAN9 = "Uitani Profili"
		$SCAN99 = "Dostupani Profili"
		$SCAN10 = "Izvetaj skeniranja od"
		$SCAN11 = "Pokrenuo"
		$ON = "na"
		$SCAN13 = "Pokrenuto sa"
		$SCAN14 = "Jezik"
		$SCAN15 = "Reim pokretanja sistema"
		$SCAN16 = "Ukoliko je sistem butabilan, FRST mora biti pokrenut iz normal ili safe moda da bi napravio kompletan izvetaj."
		$SCAN17 = "Nije mogue uitati system hive."
		$SCAN18 = "Sistemska konica nedostaje."
		$SCAN64 = "OPERATIVNI SISTEM JE X86 SISTEM ALI BOOT DISK KOJI JE KORIEN ZA PRISTUP REIMU ZA OPORAVAK JE X64 SISTEMSKI DISK."
		$SCAN19 = "Vodi za"
		$PROCESS1 = "Nije uspeo pristup procesu"
		$PROCESS3 = "Ukoliko je stavka uneena u fixlist, proces ce biti zatvoren. Datoteka nece biti premeten."
		$REGIST1 = "Skeniranje Registra"
		$REGIST2 = "Softverska konica nedostaje."
		$REGIST3 = "Softverska konica nije uitana."
		$REGIST4 = "Vrednost Imena sa nepravilnim karakterima"
		$REGIST5 = "itanje korisnikih kljueva"
		$REGIST7 = "Nema CLSID Vrednosti"
		$REGIST8 = "Nema Datoteke"
		$PAD = "pitanja"
		$ALL = "Sve"
		$REGIST9 = "Ukoliko je stavka uneena u fixlist, registru stavka ce biti vraena na podrazumevanu vrednost ili uklonjena."
		$REGIST10 = "Datoteka nee biti premetena."
		$WLISTED = "Na Beloj Listi"
		$RESTRICT = "Restrikcije"
		$SOFTW = "softver"
		$NFOUND = "nije pronaena"
		$RESTORED = "uspeno vraeno u predhodno stanje"
		$NDELETED = "nije mogue ukloniti"
		$DETECTED = "detektovano"
		$INTERNET = "Ukoliko je stavka uneena u fixlist, ako je to registru stavka, bie uklonjena ili vraena na podrazumevanu vrednost."
		$INTERNET1 = "je postavljen"
		$INTERNET2 = "je omoguen"
		$INTERNET3 = "Podrazumevani URLSearchHook nedostaje"
		$INTERNET4 = "nedostaje vrednost"
		$INTERNET5 = "trebao bi"
		$INTERNET6 = "Postoji vie od jednog unosa u Hosts. Pogledati Hosts sekciju iz"
		$INTERNET7 = "Hosts datoteka nije detektovana u podrazumevanom direktorijumu"
		$FF1 = "Nema Imena"
		$FF2 = "Ukazuje na .cfg datoteku"
		$SERV1 = "Ukoliko je stavka uneena u fixlist, bie uklonjena iz registra."
		$SERV2 = "Datoteka nee biti premetena ukoliko nije izlistana zasebno."
		$UNLOCK = "je otkljuan"
		$NUNLOCK = "ne moe biti otkljuato"
		$1MONT = "Mesec dana"
		$3MONT = "Tri meseca"
		$FIL0 = "Datoteka"
		$FIL1 = "Datoteke"
		$FOL0 = "Fascikla"
		$FOL1 = "Fascikli"
		$AND1 = " i "
		$CREATED = "kreirane"
		$MODIFIED = "modifikovane"
		$FILFOL = "Ukoliko je stavka uneena u fixlist, Datoteka/Fascikla e biti premetena"
		$FILESR = "Datoteke u korenu nekih direktorijuma"
		$0BYTE = "Neke nula bajt veliine"
		$BAM = "Ne postoji automatizovan popravak za datoteke koji nisu prole verifikaciju"
		$MISS = "NEDOSTAJE"
		$ASS = "Asocijacije"
		$RP1 = "Take Vraanja"
		$RP2 = "Nije moguce izlistati take vraanja"
		$RP3 = "Oporavak Sistema is iskljuen"
		$UACC = "Nalozi"
		$CUST = "Prilagoen"
		$DATAX = "unos podatka ima"
		$DATAY = "vie karaktera"
		$ADD1 = "Additional izvetaj od"
		$INSPRO = "Instalirani Programi"
		$CHECKWMI = "Proveri ""winmgmt"" servis ili popravi WMI."
		$CHECKWMI1 = "Proveri ""VSS"" servis"
		$SECCENT = "Bezbednosni Centar"
		$SECCENT1 = "Ukoliko je stavka uneena u fixlist, ona e biti uklonjena."
		$CONTENT = "sadraj"
		$HOSTS2 = "Ukoliko je potrebno, Hosts: direktiva moe biti ukljuena u fixlist da postavi poetnu Hosts vrednost."
		$HOSTS3 = "HTML skripta u Hosts detektovana. Pogledati Hosts sekciju od"
		$TASKS0 = "Planirani Zadaci"
		$MOD1 = "Uitani Moduli"
		$ADS1 = "Ukoliko je stavka uneena u fixlist, samo ce ADS biti uklonjen."
		$SAFEB1 = "nedostaje i trebalo bi biti vraeno runo."
		$SAFEB2 = "Bezbedni Reim"
		$REST1 = "Postoji"
		$REST2 = "vie lokacija"
		$NOFIX = "Trenutno ne postoji automatizovana popravka za ovu sekciju."
		$DSN = "Medija nije konektovana na internet."
		$ANDERE = "Ostale Oblasti"
		$DNS1 = "Greka dobijanja"
		$MSCONF = "iskljueni unosi"
		$DEVICE1 = "Neispravni Ureaji Upravlja Ureajima"
		$DEVICE2 = "Nije mogue izlistati Ureaje."
		$EVENTS1 = "Event log greke"
		$EVENTS2 = "Nije mogue startovati eventlog servis, nije mogue proitati events."
		$EVENTS3 = "Aplikacione greke"
		$EVENTS4 = "Systemske greke"
		$SHORT1 = "Preice"
		$SHORT2 = "Stavka moe biti navedena da bi bila vraena ili uklonjena"
		$SCANED = "Skeniranje dovreno."
		$FIXRES = "Izvetaj ispravaka od"
		$NOFIX1 = "Nije pronaen fixlist.txt."
		$NOFIX2 = "fixlist.txt treba da se nalazi u istoj fascikli/direktorijumu gde je i sam alat smeten."
		$FIX12 = "Izgleda da ne zna sta radis. Da bi se spreila steta sistemu, alat se sada zatvara."
		$WARN = "Upozorenje"
		$FIX13 = "FRST je skriptovan da ne premeta ovaj direktorijum."
		$FIXER1 = "Greka: Stavka bi trebala da bude popravljena izvan reima oporavka."
		$FIXER2 = "Greka: Operacija oporavka bi trebala biti odraena u reimu za oporavak."
		$FIXER3 = "Greka: Ova direktiva radi samo izvan reima oporavka."
		$AT = "u"
		$FDIR = "Datoteka/Fascikla"
		$PROCL = "Procesi su zatvoreni uspeno."
		$OF = "od"
		$OF2 = "od"
		$END = "Kraj"
		$FOUND1 = "naao"
		$TO = "na"
		$ZBYTE = "nula bajt"
		$IS = "je"
		$NOT = "ne"
		$MOVEREB = "Planirano za premetanje po ponovnom pokretanju"
		$MOVE = "premetanje"
		$DELRE = "Planirano za uklanjanje po ponovnom pokretanju"
		$DEFA = "Podrazumevano"
		$NRESTORE = "Nije mogue povratiti"
		$RESTORE = "od registra rezervna kopija"
		$FROM = "od"
		$BACK = "rezervna kopija"
		$VAL0 = "vrednost"
		$ERDEL = "Greka brisanja proizvoda"
		$USE = "Upotrebiti"
		$REP1 = "Brisanje reparse taaka i otkljuavanje"
		$DONE = "dovreno"
		$STAR = "zapoeto"
		$REP2 = "reparsepoint"
		$CAT1 = "Mogue legitiman Catalog unos"
		$CAT2 = "nee biti obrisan sa FRST. Umesto, ""netsh winsock reset"" moe biti korien."
		$RENUM = "e biti prenumerisano."
		$NOMOVE = "Ne bi trebalo biti premeteno"
		$CHR1 = "Chrome ""Settings"" mogu biti koriena za ovaj unos."
		$KEYY = "klju"
		$COP = "kopirano uspeno u"
		$COP1 = "kopirano uspeno"
		$REP = "Nije mogue premestiti"
		$STOPS = "Servis je uspeno zaustavljen"
		$NSTOPS = "Nije mogue zaustaviti servis"
		$DISS = "servis je onemoguen"
		$NDISS = "Nije mogue onemoguiti servis"
		$DATA0 = "podatak"
		$PRO4 = "Nije mogue verifikovati da li proces postoji"
		$PRO5 = "proces je uspeno zatvoren"
		$PRO6 = "nije mogue otvoriti proces"
		$PRO7 = "Nije mogue zatvoriti proces"
		$PRO8 = "Nema pokrenutih procesa"
		$ERR0 = "Greka"
		$SHORTERR = "Nije mogue ukloniti ili popraviti argument preice. Preica je mozda osteena."
		$ARG0 = "argument"
		$SHORT0 = "Preica"
		$PW0 = "Molim saekajte..."
		$CREAMOD = "Datum kreiranja i modifikovanja"
		$SZ0 = "Veliina"
		$ATT0 = "Atributi"
		$NAME0 = "Ime"
		$COMP0 = "Ime Kompanije"
		$INT0 = "Interno"
		$OR0 = "Originalno"
		$PROD0 = "Proizvod"
		$DES0 = "Opis"
		$COPR0 = "Sva prava zadrana"
		$SYMLINK0 = "Simbolika veza"
		$FILENS = "Datoteka nije potpisana"
		$FILENS1 = "nije potpisana"
		$NPERMS = "Dobijanje dozvola nije uspelo"
		$NOACC = "Pristup Odbijen"
		$MKEYNR = "Glavni klju nije prepoznat"
		$PROT0 = "moda je zastien"
		$FIRSTA = "po prvom pokuaju"
		$NEXTL = "pogledati sledeu liniju"
		$CORRU = "je mogue oteen"
		$INVALKEY = "podklju sa nevaeim imenom"
		$NCOPY = "Nije mogue kopirati"
		$PERMS = "dozvole"
		$NOCRYPT = "Nije mogue izvrsiti verifikaciju potpisa. Cryptographic servis nije pokrenut"
		$FILESIG = "Datoteka je digitalno potpisana"
		$ERRSIG = "Greka u verifikovanju datoteke potpisa"
		$NOFIXENTRY = "Ne postoji automacka popravka za ovu stavku."
		$RESQUA = "Vraanje iz Karantina dovreno."
		$MBR0 = "uspeno napravljena."
		$MBR1 = "nije napravljeno."
		$DELTEMP0 = "Brisanje privremenih datoteka"
		$DELTEMP1 = "privremeni podaci Uklonjeni."
		$REBOOT0 = "Raunar e biti ponovo pokrenut da bi dovrio popravke"
		$REBOOT1 = "Sistemu je potreban ponovno pokretanje."
		$COMPLETED = "je sauvan u isti direktorijum gde se i FRST alat nalazi."
		$REBOOT2 = "Raunaru je potrebno ponovno pokretanje. Molim, zatvorite sve pokrenute prozore. Imati na umu da neete dobiti nikakvo obavetenje od alata po ponovnom pokretanju."
		$REBOOT3 = "Kliknite U redu za ponovno pokretanje."
		$SEARCH0 = "Pretraga je u toku"
		$SEARCH1 = "Pretraga"
		$SEARCH2 = "Ni jedna stavka nije uneena u polje za pretraivanje."
		$SEARCH3 = "u nekim sluajevima ovo moe trajati i due od 10 minuta."
		$ADMINIS = "administrator"
		$SEARCH4 = "Rezultati pretrage za"
		$TASKS1 = "Ukoliko je stavka uneena u fixlist, planirani zadaci (.job) datoteke e biti premetene. Datoteka koju zadatak izvrava nee biti uklonjena."
		$SEARCH5 = "Pojam za pretragu nije uneen. Unesite termin pretrage a potom kliknite na ""Pretraga Datoteka"" dugme"
		$ADD0 = "Samo adware programi sa ""hidden"" simbolom mogu biti dodati u fixlist da bi bili prikazani. Adware programi bi trebali biti runo deinstalirani."
		$NREMOV = "Nee biti uklonjeno sa FRST."
		$NRP = "Taka vraanja moe biti kreirana jedino iz normalnog reima."
		$YRP = "Taka vraanja je uspeno kreirana."
		$NHOSTS = "Hosts datoteka nije detektovana u podrazumevanom direktorijumu"
		$ITEMPRO = "Unos je zatien. Postarajte se da je softver deinstaliran a njegov servis uklonjen."
		$DRIVE0 = "disk"
		$WBOOTC = "sa boot komponentama"
		$OBTFROM = "dobijeno od"
		$SYSTEM0 = "sistem"
		$FWNRUN = "Firewall servis nije pokrenut."
		$WDIS = "je onemogueno."
		$ILEMD = "Datoteke za premetanje ili brisanje"
		$USCANR = "Izvetaj skeniranja korisnikih preica"
		$WRUL = "FirewallRules"
		$MINFO = "Informacije o Memoriji"
		$SERV = "servis"
		$MD5L = "MD5 is legitiman"
		$ALTSH = """AlternateShell"" e biti vraen na podrazumevanu vrednost."
		$MOLI = "vie linija"
		$FPAD = "putanjadatoteke"
		$NO = "ne"
		$CRRP = "Pravljenje take vraanja. Ovo moze trajati par minuta,"
		$CRRPN = "Neuspelo pravljenje take vraanja."
		$LOCLSRV = "Zakljuani Servisi"
		$WINSOCKBR = "oteen pristup internetu usled nedostajuih unosa."
		$DRS0 = "Drajveri"
		$IETR = "pouzdano/ogranieno"
		$PARTT = "Particiona Tabela"
		$OUTRE = "Ovo funkcionie izvan okruenja za oporavak"
		$DISCLAIM = "Odricanje od garancija!" & @CRLF & @CRLF & "Ovaj softver je obezbeen ""TAKAV-KAKAV JE"" bez garancije bilo koje vrste. Mozete koristiti ovaj softver na sopstveni rizik." & @CRLF & @CRLF & "Osim ako nemate licenciranu verziju, ovaj softver nije dozvoljen u komercijalne svrhe." & @CRLF & @CRLF & "Da li ste sigurni da elite nastaviti?" & @CRLF & @CRLF & "Kliknite Yes da nastavite. Kliknite No da izaete iz programa."
		$MOS = "Vie od jednog Windows operativnog sistema je detektovano. Bie predstavljeno da izaberete jedan koji e biti skeniran." & @CRLF & @CRLF & "U sluaju da ste izabrali pogresno, molimo ponovo pokrenite racunar u okruenje za oporavak pre pokretanja alata." & @CRLF & @CRLF & $BOOT6
		$TESTS = "'testsigning' is postavljen. Proveriti na mogue nepotpisane drajvere"
		$BCDSM = "Sistem je konfigurisan da se pokree u Bezbedni reim"
		$BCDNR = "Nije mogu pristup BCD-u."
		$MEM1 = "Postotak memorije u upotrebi"
		$MEM2 = "Ukupno fizikog RAM-a"
		$MEM3 = "Dostupno fizikog RAM-a"
		$MEM4 = "Ukupno Virtualnog"
		$MEM5 = "Dostupno Virtualnog"
		$FFPROX = "Firefox Proxy podeavanja su vraena na poetnu vrednost."
		$ERRSV = "Greka postavljanja vrednosti."
		$LOG0 = "log"
		$WINFW = "Windows Firewall"
		$REN0 = "preimenovano"
		$RESD0 = "Datum take vraanja"
		$PROCESSOR = "Procesor"
		$REINS = "Ponovo instalirajte Chrome."
		$INFEC = "zaraena"
		$MOTH = "Maticna ploca"
		$INUSE = "Ova datoteka je u upotrebi"
		$ERRF = "Greka tokom itanja datoteke"
		$INCORR = "Netaan put"
		$DUMMY = "    "
		$PLATF = "Platform"
	Case StringRight ( @MUILang , 2 ) = "16"
		$SCAN = "Analizar"
		$FIXB = "Corrigir"
		$SEARCHB = "Pesquisar"
		$SEARCHBES = "Pesquisar Arquivos"
		$SEARCHREG = "Pesquisar Registro"
		$WHITELB = "Whitelist"
		$REGB = "Registro"
		$SERVB = "Servios"
		$DRIVB = "Drivers"
		$OBTSCAN = "Anlise Opcional"
		$PROC0 = "processo"
		$PROCB = "Processos"
		$BCD = "List BCD"
		$90DAYS = "Arquivos 90 Dias"
		$DISCLAIM = "Aviso Legal!" & @CRLF & @CRLF & "Este programa  fornecido ""NO ESTADO EM QUE SE ENCONTRA"" sem garantia de qualquer espcie. Voc pode usar este programa por sua prpria conta e risco." & @CRLF & @CRLF & "No  permitido o uso deste programa para fins comerciais." & @CRLF & @CRLF & "Voc tem certeza de que quer continuar?" & @CRLF & @CRLF & "Clique em Sim para continuar. Clique em No para sair."
		$READY = "A ferramenta est pronta para ser utilizada."
		$SCANB = "Analizando"
		$BOOT1 = "Este  o sistema operacional que voc deseja reparar:"
		$BOOT2 = "Este sistema operacional est no drive"
		$BOOT3 = " sendo inicializado no modo de recuperao."
		$BOOT4 = "A ferramenta est sendo configurada para ler os drives."
		$BOOT5 = "A ferramenta est sendo executada a partir do mesmo drive em que o sistema operacional est localizado. Por isso, ser pedido para selecionar o sistema operacional uma vez mais. Isto  normal."
		$BOOT6 = "Clique em OK para continuar"
		$BOOT7 = "A ferramenta est sendo configurada para ler o Disco Local."
		$UPD1 = "ATENO"
		$UPD2 = "Esta verso da Farbar Recovery Scan Tool tem "
		$UPD3 = "dias e est desatualizada."
		$UPD4 = "Por favor, baixe a verso mais recente."
		$UPD5 = "Voc deseja continuar?"
		$UPD7 = "Pesquisando por atualizaes."
		$FIX1 = "A Correo est em andamento"
		$FIX2 = "Corrigindo ..."
		$FIX3 = "Resultado dos arquivos que foram agendados para serem movidos (Modo de Inicializao: "
		$FIXREG = "Resultado dos registros marcados para excluir ser exibido aps a reinicializao:"
		$FIX4 = "O Sistema no reiniciou."
		$FIX5 = "foi movido com sucesso"
		$MOVED = "movido com sucesso"
		$DELETED = "removido (a) com sucesso."
		$FIX8 = "No pode ser movido"
		$FIX9 = "Data&Hora"
		$FIX10 = "Correo completada."
		$UPD8 = "Nova atualizao encontrada."
		$UPD9 = "Atualizao Completada."
		$BKU1 = "Fazendo Backup do Registro, isto deve levar alguns segundos..."
		$SCAN1 = "Anlise iniciada."
		$SCAN2 = "verso tem"
		$SCAN3 = "dias e pode estar desatualizada"
		$SCAN4 = "O usurio no  o administrador"
		$SCAN5 = "Navegador padro"
		$SCAN7 = "no detectado"
		$SCAN0 = "Verso"
		$SCAN8 = "Perfil Temporrio"
		$SCAN9 = "Perfis Carregados"
		$SCAN99 = "Perfis Disponveis"
		$SCAN10 = "Resultado do anlise da"
		$SCAN11 = "Executado por"
		$ON = "em"
		$SCAN13 = "Executando a partir de"
		$SCAN14 = "Idioma"
		$SCAN15 = "Modo da Inicializao"
		$SCAN16 = "Se o sistema for inicializvel, a FRST deve ser executada em modo Normal ou de Segurana, para que seja gerado um log completo."
		$SCAN17 = "No foi possvel carregar as chaves dos sistema."
		$SCAN18 = "A chave do sistema no foi encontrada."
		$SCAN19 = "Tutorial da"
		$PROCESS1 = "Falha ao acessar processo"
		$PROCESS3 = "Se uma entrada for includa na fixlist, o processo ser fechado. O arquivo no ser movido."
		$REGIST1 = "Analizando o Registro"
		$REGIST2 = "A chave programa no foi encontrada."
		$REGIST3 = "O ramo do programa no foi carregado."
		$REGIST4 = "Nome do Valor com caracteres invlidos"
		$REGIST5 = "Lendo chaves de usurios"
		$REGIST7 = "Nenhum Valor CLSID"
		$REGIST8 = "Nenhum Arquivo"
		$PAD = "caminho"
		$ALL = "Todos"
		$REGIST9 = "Se uma entrada for includa na fixlist, o tem no Registro ser restaurado para o padro ou removido."
		$REGIST10 = "O arquivo no ser movido."
		$WLISTED = "Whitelisted"
		$RESTRICT = "Restrio"
		$SOFTW = "programa"
		$NFOUND = "no encontrado (a)"
		$RESTORED = "restaurado com sucesso"
		$NDELETED = "No pode ser removido"
		$DETECTED = "detectado"
		$INTERNET = "Se um tem for includo na fixlist, sendo um tem do Registro, ser removido ou restaurado para o padro."
		$INTERNET1 = "est configurado"
		$INTERNET2 = "est habilitado."
		$INTERNET3 = "A URLSearchHook Padro est ausente"
		$INTERNET4 = "valor est ausente"
		$INTERNET5 = "deve ser"
		$INTERNET6 = "H mais de uma entrada no Hosts. Veja a seo Hosts do"
		$INTERNET7 = "O arquivo Hosts no foi detectado no seu diretrio padro"
		$FF1 = "Sem Nome"
		$FF2 = "Aponta para arquivo *.cfg"
		$SERV1 = "Se uma entrada for includa na fixlist, ser removida do Registro."
		$SERV2 = "O arquivo no ser movido, a menos que seja colocado separadamente"
		$UNLOCK = "foi desbloqueado"
		$NUNLOCK = "no pode ser desbloqueado"
		$1MONT = "Um ms"
		$3MONT = "Trs meses"
		$FIL0 = "Arquivo"
		$FIL1 = "arquivos"
		$FOL0 = "Pasta"
		$FOL1 = "pastas"
		$AND1 = " e "
		$CREATED = "criados"
		$MODIFIED = "modificados"
		$FILFOL = "Se uma entrada for includa na fixlist, o arquivo/pasta ser movido"
		$FILESR = "Arquivos na raiz de alguns diretrios"
		$0BYTE = "Alguns com tamanho de zero byte"
		$BAM = "No h correo automtica para arquivos que no passaram na verificao"
		$MISS = "EST AUSENTE"
		$ASS = "Associao"
		$RP1 = "Pontos de Restaurao"
		$RP2 = "No foi possvel listar os pontos de restaurao"
		$RP3 = "A Restaurao do Sistema est desabilitada"
		$UACC = "Contas"
		$CUST = "Anlise Personalizada"
		$DATAX = "a entrada de dados tem"
		$DATAY = "mais caracteres"
		$ADD1 = "Resultado da anlise adicional"
		$INSPRO = "Programas Instalados"
		$CHECKWMI = "Verifique o servio ""winmgmt"" ou repare o WMI."
		$CHECKWMI1 = "Verifique o servio ""VSS"""
		$SECCENT = "Central de Segurana"
		$SECCENT1 = "Se uma entrada for includa na fixlist, ser removida."
		$CONTENT = "Contedo"
		$HOSTS2 = "Se necessrio, a diretiva Hosts: pode ser includa na fixlist para redefinir o Hosts."
		$HOSTS3 = "Um script HTML foi detectado no Hosts. Veja a seo Hosts do"
		$TASKS0 = "Tarefas Agendadas"
		$MOD1 = "Mdulos Carregados"
		$ADS1 = "Se uma entrada for includa na fixlist, somente o ADS ser removido."
		$SAFEB1 = "est ausente e deve ser restaurado manualmente."
		$SAFEB2 = "Modo de Segurana"
		$REST1 = "Existem ainda"
		$REST2 = "sites a mais"
		$NOFIX = "Atualmente no h nenhuma correo automtica para esta seo."
		$DSN = "O Suporte no est conectado  internet."
		$ANDERE = "Outras reas"
		$DNS1 = "Erro ao obter"
		$MSCONF = "tens desabilitados"
		$DEVICE1 = "Dispositivos Apresentando Falhas No Gerenciador"
		$DEVICE2 = "No foi possvel listar os Dispositivos."
		$EVENTS1 = "Erros no Log de eventos"
		$EVENTS2 = "No foi possvel iniciar o servio Log de eventos, e por isso no foram lidos."
		$EVENTS3 = "Erros em Aplicativos"
		$EVENTS4 = "Erros de Sistema"
		$SHORT1 = "Atalhos"
		$SHORT2 = "As entradas podem ser listadas para serem restauradas ou removidas"
		$SCANED = "Anlise completada."
		$FIXRES = "Resultado da Correo pela"
		$NOFIX1 = "Nenhuma fixlist.txt foi encontrada."
		$NOFIX2 = "A fixlist.txt deve estar na mesma pasta/diretrio onde a ferramenta est localizada."
		$FIX12 = "Parece que voc no sabe o que fazer. Para evitar danos ao sistema, a ferramenta ser encerrada."
		$WARN = "Aviso"
		$FIX13 = "A FRST  programada para no mover este diretrio."
		$FIXER1 = "Erro: A entrada deve ser consertada fora do modo de recuperao."
		$FIXER2 = "Erro: A restaurao deve ser feita no modo de recuperao."
		$FIXER3 = "Erro: Esta diretiva s funciona fora do modo de recuperao."
		$FDIR = "Arquivo/Pasta"
		$PROCL = "Processos fechados com sucesso."
		$OF = "de"
		$OF2 = "de"
		$END = "Fim"
		$FOUND1 = "encontrado"
		$TO = "para"
		$ZBYTE = "zero byte"
		$IS = ""
		$NOT = "no"
		$MOVEREB = "Agendado para ser movido na reinicializao"
		$MOVE = "mover"
		$DELRE = "Agendado para ser removido na reinicializao"
		$DEFA = "Padro"
		$NRESTORE = "No foi possvel restaurar"
		$RESTORE = "a partir do backup do Registro"
		$FROM = "a partir de"
		$BACK = "back up"
		$VAL0 = "valor"
		$ERDEL = "Erro eliminando produto"
		$USE = "Uso"
		$REP1 = "Eliminando reparse point e desbloqueando"
		$DONE = "completado"
		$STAR = "comeado"
		$REP2 = "reparsepoint"
		$CAT1 = "A entrada do Catlogo possivelmente legtima"
		$CAT2 = "no ser deletada com a FRST. Em vez disso, o ""netsh winsock reset"" pode ser usado"
		$RENUM = "ser renumerado"
		$CHR1 = "As ""Configuraes"" do Chrome podem ser usadas para corrigir a entrada"
		$KEYY = "a chave"
		$COP = "copiado com sucesso para"
		$COP1 = "copiado com sucesso"
		$REP = "No foi possvel substituir"
		$STOPS = "Servio finalizado com sucesso"
		$NSTOPS = "No foi possvel finalizar o servio"
		$DISS = "o servio foi desabilitado"
		$NDISS = "No foi possvel desabilitar o servio"
		$DATA0 = "Dados do Valor"
		$PRO4 = "No foi verificado se existia o processo"
		$PRO5 = "processo fechado com sucesso"
		$PRO6 = "No foi possvel abrir o processo"
		$PRO7 = "No foi possvel fechar o processo"
		$PRO8 = "No foi encontrado em execuo o processo"
		$ERR0 = "Erro"
		$SHORTERR = "No foi possvel remover ou reparar o argumento do atalho. O atalho pode estar danificado."
		$ARG0 = "argumento"
		$SHORT0 = "Atalho"
		$PW0 = "Por favor, aguarde..."
		$CREAMOD = "Data de criao e modificao"
		$SZ0 = "Tamanho"
		$ATT0 = "Atributos"
		$NAME0 = "Nome"
		$COMP0 = "Nome Da Empresa"
		$INT0 = "Interno"
		$OR0 = "Original"
		$PROD0 = "Produto"
		$DES0 = "Descrio"
		$COPR0 = "Copyright"
		$SYMLINK0 = "Ligao Simblica"
		$FILENS = "Arquivo no assinado"
		$FILENS1 = "no assinado"
		$NPERMS = "Falha em obter permisses"
		$NOACC = "Acesso Negado"
		$MKEYNR = "Chave principal no foi reconhecida"
		$PROT0 = "pode estar protegida"
		$FIRSTA = "na primeira tentativa"
		$NEXTL = "ver a prxima linha"
		$CORRU = "est provavelmente corrompida"
		$INVALKEY = "subchave com o nome invlido"
		$NCOPY = "No foi possvel copiar"
		$PERMS = "permisses"
		$NOCRYPT = "No foi possvel executar a verificao da assinatura. O Servio de Criptografia no est sendo executado"
		$FILESIG = "O arquivo  assinado digitalmente"
		$ERRSIG = "Erro na verificao da assinatura do arquivo"
		$NOFIXENTRY = "Nenhuma correo automtica foi encontrada para esta entrada."
		$RESQUA = "Restaurao a partir da Quarentena concluda."
		$MBR0 = "foi realizada com sucesso."
		$MBR1 = "no foi realizada."
		$DELTEMP0 = "Eliminando arquivos temporrios"
		$DELTEMP1 = "de dados temporrios Removidos."
		$REBOOT0 = "O computador ser reiniciado para completar a correo"
		$REBOOT1 = "O sistema precisou ser reiniciado."
		$COMPLETED = " salvo no mesmo diretrio onde a FRST est localizada."
		$REBOOT2 = "O computador precisa ser reiniciado. Por favor, feche todas as janelas abertas. Tenha em ateno que voc no ir obter qualquer notificao da ferramenta aps a reinicializao."
		$REBOOT3 = "Clique em OK para reiniciar."
		$SEARCH0 = "A procura est em progresso"
		$SEARCH1 = "Procurando"
		$SEARCH2 = "Nenhuma entrada foi inserida na caixa de pesquisa."
		$SEARCH3 = "em alguns casos, isso pode levar mais de 10 minutos."
		$ADMINIS = "administrador"
		$SEARCH4 = "Resultado da procura por"
		$TASKS1 = "Se uma entrada for includa na fixlist, o arquivo da tarefa (.job) ser movido. O arquivo que est sendo executado pela tarefa no ser movido."
		$SEARCH5 = "Nenhum termo foi inserido na pesquisa. Por favor, digite o termo da pesquisa e clique no boto ""Pesquisar arquivos""."
		$ADD0 = "Somente os programas adwares com a indicao ""Oculto"" podem ser adicionados  fixlist para desocult-los. Os programas adwares devem ser desinstalados manualmente."
		$NREMOV = "No sero removidos com a FRST."
		$NRP = "Ponto de Restaurao somente pode ser criado em modo normal."
		$YRP = "Ponto de Restaurao criado com sucesso."
		$NHOSTS = "O arquivo Hosts no foi detectado no seu diretrio padro"
		$ITEMPRO = "O tem  protegido. Certifique-se de desinstalar o programa e remover os seus servios."
		$DRIVE0 = "drive"
		$WBOOTC = "com componentes de inicializao"
		$OBTFROM = "obtido atravs de"
		$SYSTEM0 = "sistema"
		$FWNRUN = "O Servio Firewall no est sendo executado."
		$FWDIS = "est desabilitado."
		$FILEMD = "Arquivos para serem movidos ou deletados"
		$USCANR = "Resultado da anlise no atalho de usurios"
		$FWRUL = "Regras do Firewall"
		$MINFO = "Informaes da Memria"
		$SERV = "o servio"
		$MD5L = "MD5  legtimo"
		$ALTSH = "O valor ""AlternateShell"" ser restaurado"
		$MOLI = "mais linhas"
		$FPAD = "caminho do arquivo"
		$NO = "no"
		$CRRP = "Criando Ponto de Restaurao. Isso pode levar alguns minutos,"
		$CRRPN = "Falha ao criar um ponto de restaurao."
		$LOCLSRV = "Servio Bloqueado"
		$WINSOCKBR = "acesso  internet interrompido devido  entrada ausente."
		$DRS0 = "Drives"
		$IETR = "confivel/restrito"
		$PARTT = "Tabela de Parties"
		$OUTRE = "Isto funciona fora do Ambiente de Recuperao"
		$MOS = "Mais de um sistema operacional Windows detectado. Ser pedido para selecionar um para ser examinado." & @CRLF & @CRLF & "No caso de voc ter feito a escolha errada, por favor, reinicie e inicialize no ambiente de recuperao novamente antes de executar a ferramenta." & @CRLF & @CRLF & $BOOT6
		$TESTS = "o 'modo de teste' est configurado. Verificao por possvel controlador no assinado"
		$BCDSM = "O sistema est configurado para inicializar no Modo de Segurana"
		$BCDNR = "No foi possvel acessar BCD."
		$MEM1 = "Percentagem de memria em uso"
		$MEM2 = "RAM fsica total"
		$MEM3 = "RAM fsica disponvel"
		$MEM4 = "Virtual Total"
		$MEM5 = "Virtual disponvel"
		$FFPROX = "As Configuraes de Proxy do Firefox foram redefinidas."
		$ERRSV = "Erro ao configurar valor."
		$WINFW = "Firewall do Windows"
		$REN0 = "renomeado"
		$RESD0 = "Data do Ponto de Restaurao"
		$PROCESSOR = "Processador"
		$SCAN64 = "O SISTEMA OPERACIONAL  UM X86 MAS O DISCO DE INICIALIZAO QUE EST SENDO USADO PARA INICIAR O AMBIENTE DE RECUPERAO  DE UM SISTEMA X64."
		$REINS = "Reinstalar Chrome."
		$INFEC = "Infectado"
		$MOTH = "placa-me"
		$INUSE = "O arquivo est em uso"
		$ERRF = "Erro ao ler arquivo"
		$INCORR = "Caminho incorreto"
		$DUMMY = "Dummy criado com sucesso."
		$PLATF = "Plataforma"
	Case StringRight ( @MUILang , 2 ) = "0A"
		$SCAN = "Analizar"
		$FIXB = "Corregir"
		$SEARCHB = "Buscar"
		$SEARCHBES = "Buscar Archivos"
		$SEARCHREG = "Buscar en Registro"
		$WHITELB = "Lista Blanca"
		$REGB = "Registro"
		$SERVB = "Servicios"
		$DRIVB = "Controladores"
		$OBTSCAN = "Anlisis Opcional"
		$PROC0 = "proceso"
		$PROCB = "Procesos"
		$BCD = "Listado BCD"
		$90DAYS = "Archivos 90 das"
		$DISCLAIM = "Descargo de responsabilidad!" & @CRLF & @CRLF & "Este software se proporciona ""TAL CUAL"" sin garanta de ningn tipo. Puede utilizar este software bajo su propio riesgo." & @CRLF & @CRLF & "Este software no est permitido para fines comerciales, a menos que disponga de una versin licenciada." & @CRLF & @CRLF & "Est seguro de querer continuar?" & @CRLF & @CRLF & "Haga clic en S para continuar. Haga clic en No para salir."
		$READY = "La herramienta est preparada para ser utilizada."
		$SCANB = "Analizando"
		$BOOT1 = "Es este el sistema operativo que quiere reparar?:"
		$BOOT2 = "Este sistema operativo est activo"
		$BOOT3 = " unidad cuando se inicia en el modo de recuperacin."
		$BOOT4 = "La herramienta est siendo configurada para leer las unidades."
		$BOOT5 = "La herramienta es ejecutada desde la misma unidad en la que se encuentra el sistema operativo. Por esta razn, se le ofrecer seleccionar el sistema operativo una vez ms. Esto es normal."
		$BOOT6 = "Clic en OK para continuar"
		$BOOT7 = "La herramienta est siendo configurada para leer el Disco Local."
		$UPD1 = "ATENCIN"
		$UPD2 = "Esta versin de Farbar Recovery Scan Tool tiene "
		$UPD3 = "das de antigedad y est desactualizada."
		$UPD4 = "Por favor, descargue la ltima versin."
		$UPD5 = "Desea continuar?"
		$FIX1 = "La correccin se encuentra en proceso,"
		$FIX2 = "Corrigiendo ..."
		$FIX3 = "Resultado de los archivos programados para mover (Modo de Inicio: "
		$FIXREG = "Resultado de las claves programadas para eliminar despus de reiniciar:"
		$FIX4 = "Sistema no es reiniciado."
		$FIX5 = "Se ha movido correctamente"
		$MOVED = "movido correctamente"
		$DELETED = "eliminado correctamente"
		$FIX8 = "No pudo ser movido"
		$FIX9 = "Fecha y Hora"
		$FIX10 = "Correccin completada."
		$UPD7 = "Comprobando actualizaciones existentes."
		$UPD8 = "Nueva actualizacin encontrada."
		$UPD9 = "Actualizacin Completada."
		$BKU1 = "Realizando una copia de seguridad del registro, Esto puede tomar unos segundos..."
		$SCAN1 = "Anlisis iniciado."
		$SCAN2 = "versin tiene"
		$SCAN3 = "das de antigedad y podra estar desactualizada"
		$SCAN4 = "El usuario no es administrador"
		$SCAN5 = "Navegador predeterminado"
		$SCAN7 = "no detectado"
		$SCAN0 = "Versin"
		$SCAN8 = "Perfil temporal"
		$SCAN9 = "Perfiles cargados"
		$SCAN99 = "Perfiles disponibles"
		$SCAN10 = "Resultado del anlisis realizado por"
		$SCAN11 = "Ejecutado por"
		$ON = "sobre"
		$SCAN13 = "Ejecutado desde"
		$SCAN14 = "Idioma"
		$SCAN15 = "Modo de Inicio"
		$SCAN16 = "Si el sistema inicia correctamente, FRST debe ejecutarse desde el modo normal o Seguro para crear un informe completo."
		$SCAN17 = "No se pudo cargar el subrbol del sistema."
		$SCAN18 = "Falta el subrbol del sistema."
		$SCAN19 = "Tutorial para"
		$PROCESS1 = "Error al acceder al proceso"
		$PROCESS3 = "Si una entrada es incluida en el fixlist, el proceso ser cerrado. El archivo no ser movido."
		$REGIST1 = "Analizando Registro"
		$REGIST2 = "Falta el subrbol de software."
		$REGIST3 = "El subrbol de software no ha sido cargado."
		$REGIST4 = "El nombre del valor contiene caracteres no vlidos"
		$REGIST5 = "Leyendo claves de usuario"
		$REGIST7 = "Sin valor CLSID"
		$REGIST8 = "Ningn archivo"
		$PAD = "ruta"
		$ALL = "Todos"
		$REGIST9 = "Si una entrada es incluida en el fixlist, el elemento del registro ser restaurado a su valor predeterminado o ser eliminado."
		$REGIST10 = "El archivo no ser movido."
		$WLISTED = "Lista blanca"
		$RESTRICT = "Restriccin"
		$SOFTW = "software"
		$NFOUND = "no encontrado"
		$RESTORED = "restaurado correctamente"
		$NDELETED = "no pudo ser eliminado"
		$DETECTED = "detectado"
		$INTERNET = "Si un elemento es incluido en el fixlist, y ste pertenece al registro, ser eliminado o restaurado a su valor predeterminado."
		$INTERNET1 = "est establecido"
		$INTERNET2 = "est habilitado."
		$INTERNET3 = "No se encuentra URLSearchHook predeterminado"
		$INTERNET4 = "no se encuentra el valor"
		$INTERNET5 = "debera ser"
		$INTERNET6 = "Hay ms de una entrada en Hosts. Consulte la seccin Hosts de"
		$INTERNET7 = "Archivo Hosts no detectado en el directorio predeterminado"
		$FF1 = "Sin Nombre"
		$FF2 = "Apunta a archivo *.cfg"
		$SERV1 = "Si una entrada es incluida en el fixlist, ser eliminada del registro."
		$SERV2 = "El archivo no se mover a menos que sea aadido al listado por separado"
		$UNLOCK = "fue desbloqueado"
		$NUNLOCK = "no pudo ser desbloqueado"
		$1MONT = "Un mes"
		$3MONT = "Tres meses"
		$FIL0 = "Archivo"
		$FIL1 = "archivos"
		$FOL0 = "Carpeta"
		$FOL1 = "carpetas"
		$AND1 = " y "
		$CREATED = "creado"
		$MODIFIED = "modificado"
		$FILFOL = "Si una entrada es incluida en el fixlist, el archivo/carpeta ser eliminado/a"
		$FILESR = "Archivos en la raz de algunos directorios"
		$0BYTE = "Algn tamao de cero bytes"
		$BAM = "No existe una correccin automtica para los archivos que no pasan la verificacin"
		$MISS = "FALTANTE"
		$ASS = "Asociacin"
		$RP1 = "Puntos de Restauracin"
		$RP2 = "No se pudieron listar los puntos de restauracin"
		$RP3 = "Restaurar Sistema est deshabilitado"
		$UACC = "Cuentas"
		$CUST = "Personalizado"
		$DATAX = "la entrada de datos tiene"
		$DATAY = "ms caracteres"
		$ADD1 = "Resultados del Anlisis Adicional de"
		$INSPRO = "Programas instalados"
		$CHECKWMI = "Comprobar el servicio ""winmgmt"" o reparar WMI."
		$SECCENT = "Centro de Seguridad"
		$SECCENT1 = "Si una entrada es incluida en el fixlist, ser eliminada."
		$CONTENT = "contenido"
		$HOSTS2 = "Si es necesario, la directiva Hosts: puede ser incluida en el fixlist para restablecer Hosts."
		$HOSTS3 = "Script HTML en Hosts detectado. Consulte la seccin Hosts de"
		$TASKS0 = "Tareas programadas"
		$MOD1 = "Mdulos cargados"
		$ADS1 = "Si una entrada es incluida en el fixlist, solamente los ADS sern eliminados."
		$SAFEB1 = "falta y se debe restaurar manualmente."
		$SAFEB2 = "Modo Seguro"
		$REST1 = "Hay"
		$REST2 = "ms sitios"
		$NOFIX = "Actualmente no existe una correccin automtica para esta seccin."
		$DSN = "El medio no est conectado a internet."
		$ANDERE = "Otras reas"
		$DNS1 = "Error obteniendo"
		$MSCONF = "elementos deshabilitados"
		$DEVICE1 = "Dispositivos defectuosos en el Administrador de dispositivos"
		$DEVICE2 = "No se pudieron listar los Dispositivos."
		$EVENTS1 = "Errores del registro de eventos"
		$EVENTS2 = "No se pudo iniciar el servicio de registro de eventos, no se pudieron leer los eventos."
		$EVENTS3 = "Errores de aplicacin"
		$EVENTS4 = "Errores del sistema"
		$SHORT1 = "Accesos directos"
		$SHORT2 = "Las entradas pueden ser listadas para ser restauradas o eliminadas"
		$SCANED = "Anlisis completado."
		$FIXRES = "Resultados de la correccin de"
		$NOFIX1 = "Ningn fixlist.txt encontrado."
		$NOFIX2 = "El fixlist.txt debe estar en la misma carpeta/directorio donde se encuentra la herramienta."
		$FIX12 = "Parece que no sabe qu hacer. Para prevenir daos en el sistema, la herramienta ser cerrada."
		$WARN = "Advertencia"
		$FIX13 = "FRST est programado para no mover este directorio."
		$FIXER1 = "Error: la entrada debe ser corregida fuera del modo de recuperacin."
		$FIXER2 = "Error: La operacin de restauracin debe ser realizada en el modo de recuperacin."
		$FIXER3 = "Error: Esta directiva solamente funciona fuera del modo de recuperacin."
		$FDIR = "Archivo/Carpeta"
		$PROCL = "Procesos cerrados correctamente."
		$OF = "de"
		$END = "Final"
		$FOUND1 = "encontrado"
		$TO = "a"
		$ZBYTE = "cero bytes"
		$IS = "tiene"
		$NOT = "no"
		$MOVEREB = "Programado para moverse al reiniciar"
		$MOVE = "mover"
		$DELRE = "Programado para eliminarse al reiniciar"
		$DEFA = "Predeterminado"
		$NRESTORE = "No se pudo restaurar"
		$RESTORE = "desde la copia de seguridad del registro"
		$FROM = "de"
		$BACK = "hacer una copia de seguridad"
		$VAL0 = "valor"
		$ERDEL = "Error al eliminar producto"
		$USE = "Utilizar"
		$REP1 = "Eliminando punto de repeticin de anlisis y desbloqueando"
		$DONE = "completado"
		$STAR = "iniciado"
		$REP2 = "punto de repeticin de anlisis"
		$CAT1 = "La posible entrada de Catlogo legtima"
		$CAT2 = "no ser eliminada con FRST. En su lugar, puede utilizar ""netsh winsock reset"""
		$RENUM = "ser enumerada de nuevo"
		$CHR1 = "La ""Configuracin"" Chrome puede ser utilizada para corregir la entrada"
		$KEYY = "clave"
		$COP = "copiado correctamente a"
		$COP1 = "copiado correctamente"
		$REP = "No se pudo reemplazar"
		$STOPS = "Servicio detenido correctamente"
		$NSTOPS = "No se puede detener el servicio"
		$DISS = "servicio fue deshabilitado"
		$NDISS = "No se puede deshabilitar el servicio"
		$DATA0 = "Informacin del valor"
		$PRO4 = "No se puede verificar si el proceso existe"
		$PRO5 = "proceso cerrado correctamente"
		$PRO6 = "No se pudo abrir el proceso"
		$PRO7 = "No se pudo cerrar el proceso"
		$PRO8 = "No se encontr ningn proceso en ejecucin"
		$ERR0 = "Error"
		$SHORTERR = "No se pudo eliminar ni reparar el argumento de acceso directo. El acceso directo podra estar daado."
		$ARG0 = "argumento"
		$SHORT0 = "Acceso directo"
		$PW0 = "Por favor, espere..."
		$CREAMOD = "Fecha de creacin y modificacin"
		$SZ0 = "Tamao"
		$ATT0 = "Atributos"
		$NAME0 = "Nombre"
		$COMP0 = "Nombre de la compaa"
		$INT0 = "Interno"
		$OR0 = "Original"
		$PROD0 = "Producto"
		$DES0 = "Descripcin"
		$COPR0 = "Copyright"
		$SYMLINK0 = "Vnculo simblico"
		$FILENS = "Archivo no firmado"
		$FILENS1 = "no firmado"
		$NPERMS = "Obteniendo permisos fallidos"
		$NOACC = "Acceso Denegado"
		$MKEYNR = "La clave principal no es reconocida"
		$PROT0 = "podra estar protegida"
		$FIRSTA = "en un primer intento"
		$NEXTL = "consultar la siguiente lnea"
		$CORRU = "puede que est daado"
		$INVALKEY = "subclave con nombre no vlido"
		$NCOPY = "No se pudo copiar"
		$PERMS = "permisos"
		$NOCRYPT = "No se pudo realizar la verificacin de firma. El Servicio criptogrfico no se est ejecutando"
		$FILESIG = "El archivo est firmado digitalmente"
		$ERRSIG = "Error al verificar la firma del archivo"
		$NOFIXENTRY = "Ninguna correccin automtica encontrada para esta entrada."
		$RESQUA = "Restauracin desde Quarantine completada."
		$MBR0 = "realizada correctamente."
		$MBR1 = "no realizada."
		$DELTEMP0 = "Eliminando archivos temporales"
		$DELTEMP1 = "datos temporales eliminados."
		$REBOOT0 = "La computadora ser reiniciada para completar la correccin"
		$REBOOT1 = "El sistema necesita reiniciarse."
		$COMPLETED = "se guarda en el mismo directorio donde se encuentra FRST."
		$REBOOT2 = "La computadora necesita reiniciarse. Por favor, cierre todas las ventanas abiertas. Tenga en cuenta que no recibir ninguna notificacin de la herramienta despus de reiniciar."
		$REBOOT3 = "Clic OK para reiniciar."
		$SEARCH0 = "La bsqueda est en progreso"
		$SEARCH1 = "Buscando"
		$SEARCH2 = "No ha introducido ninguna entrada en el cuadro de bsqueda."
		$SEARCH3 = "En algunos casos, esto puede tomar ms de 10 minutos."
		$ADMINIS = "administrador"
		$SEARCH4 = "Resultado de bsqueda para"
		$TASKS1 = "Si una entrada es incluida en el fixlist, el archivo de tarea (.job) ser movido. El archivo que est siendo ejecutado por la tarea no ser movido."
		$SEARCH5 = "No se ha introducido ningn trmino de bsqueda. Por favor, introduzca el trmino de bsqueda y haga clic en el botn ""Buscar archivos""."
		$ADD0 = "Solo los programas de adware con indicador ""Oculto"", pueden ser aadidos al fixlist para hacerlos visibles. Los programas adware deben ser desinstalados manualmente."
		$NREMOV = "No ser eliminado con FRST."
		$NRP = "El punto de restauracin solamente puede ser creado en modo normal."
		$YRP = "El punto de restauracin fue creado correctamente."
		$NHOSTS = "Archivo Hosts no detectado en el directorio predeterminado"
		$ITEMPRO = "El elemento est protegido. Asegrese de desinstalar el software y eliminar sus servicios."
		$DRIVE0 = "unidad"
		$WBOOTC = "con componentes de arranque"
		$OBTFROM = "obtenido de"
		$SYSTEM0 = "sistema"
		$FWNRUN = "El servicio de Firewall de Windows no se est ejecutando."
		$FWDIS = "est deshabilitado."
		$FILEMD = "Archivos a mover o eliminar"
		$USCANR = "Resultado del anlisis de Acceso directo de usuarios"
		$FWRUL = "Reglas de firewall"
		$MINFO = "Informacin de la memoria"
		$SERV = "servicio"
		$MD5L = "MD5 es legtimo"
		$ALTSH = "El ""AlternateShell"" ser restaurado"
		$MOLI = "ms lineas"
		$FPAD = "ruta de acceso de archivo"
		$NO = "no"
		$CRRP = "Creando Punto de Restauracin. Esto puede tomar unos minutos,"
		$CRRPN = "Error al crear un punto de restauracin."
		$LOCLSRV = "Servicio bloqueado"
		$WINSOCKBR = "Acceso a internet roto debido a falta de entrada."
		$DRS0 = "Unidades"
		$IETR = "sitios de confianza/restringidos"
		$PARTT = "Tabla de particiones"
		$OUTRE = "Esto funciona fuera del Entorno de Recuperacin"
		$MOS = "Ms de un sistema operativo Windows detectado. Sern presentados para que seleccione el que desea analizar." & @CRLF & @CRLF & "En caso de que haya tomado una decisin incorrecta, por favor, reinicie e inicie de nuevo el entorno de recuperacin antes de ejecutar la herramienta." & @CRLF & @CRLF & "Clic OK para continuar."
		$TESTS = "'testsigning' est establecido. Verifique para posible controlador no firmado"
		$BCDSM = "El sistema est configurado para iniciarse en Modo Seguro"
		$BCDNR = "No se pudo acceder al BCD."
		$MEM1 = "Porcentaje de memoria en uso"
		$MEM2 = "RAM fsica total"
		$MEM3 = "RAM fsica disponible"
		$MEM4 = "Virtual total"
		$MEM5 = "Virtual disponible"
		$FFPROX = "La configuracin proxy de Firefox fue restablecida."
		$ERRSV = "Error al establecer el valor."
		$WINFW = "Firewall de Windows"
		$REN0 = "renombrado"
		$RESD0 = "Fecha de punto de restauracin"
		$PROCESSOR = "Procesador"
		$REINS = "Reinstalar Chrome."
		$INFEC = "Infectado"
		$LEGACY = "Heredado"
		$REPAIR = "Reparado correctamente"
		$NREPAIR = "No se pudo reparar"
		$MOTH = "Placa base"
		$INUSE = "El archivo est en uso"
		$SCAN64 = "EL SISTEMA OPERATIVO ES UN SISTEMA X86, PERO EL DISCO DE ARRANQUE QUE SE UTILIZA PARA ARRANCAR EN EL ENTORNO DE RECUPERACIN ES UN DISCO DE SISTEMA X64."
		$ERRF = "Error al leer el archivo"
		$INCORR = "Camino incorrecto"
		$DUMMY = "Carpeta ficticia se cumple con xito aangemaakt"
		$PLATF = "Plataforma"
	Case StringRegExp ( "0419|0422|0423" , @MUILang )
		$SCAN = ""
		$FIXB = ""
		$SEARCHB = ""
		$SEARCHBES = " "
		$SEARCHREG = "  "
		$WHITELB = " "
		$REGB = " Windows"
		$SERVB = ""
		$DRIVB = ""
		$OBTSCAN = " "
		$PROC0 = ""
		$PROCB = ""
		$BCD = " BCD"
		$90DAYS = "  90 "
		$DISCLAIM = "  " & @CRLF & @CRLF & "    "" ""    .          ." & @CRLF & @CRLF & "     ,         ." & @CRLF & @CRLF & " ,   ?" & @CRLF & @CRLF & " ,  .  ,  ."
		$READY = "   ."
		$SCANB = ""
		$BOOT1 = "  ,    :"
		$BOOT2 = "    "
		$BOOT3 = "      ."
		$BOOT4 = "    "
		$BOOT5 = "     ,     .           .  ."
		$BOOT6 = "   "
		$BOOT7 = "     ."
		$UPD1 = ""
		$UPD2 = "      Farbar"
		$UPD3 = "    ."
		$UPD4 = ",   ."
		$UPD5 = "  ?"
		$FIX1 = " "
		$FIX2 = " ..."
		$FIX3 = "   ( :"
		$FIXREG = " ,     "
		$FIX4 = "  ."
		$FIX5 = " "
		$MOVED = " "
		$DELETED = " "
		$FIX8 = "   "
		$FIX9 = "  "
		$FIX10 = " "
		$UPD7 = " "
		$UPD8 = "  "
		$UPD9 = " "
		$BKU1 = "  ,      ..."
		$SCAN1 = " "
		$SCAN2 = ""
		$SCAN3 = "      "
		$SCAN4 = "   "
		$SCAN5 = "  "
		$SCAN7 = " "
		$SCAN0 = ""
		$SCAN8 = " "
		$SCAN9 = " "
		$SCAN99 = " "
		$SCAN10 = " "
		$SCAN11 = "  "
		$ON = ""
		$SCAN13 = " "
		$SCAN14 = ""
		$SCAN15 = " "
		$SCAN16 = "  ,  FRST            ."
		$SCAN17 = "    SYSTEM ."
		$SCAN18 = "  SYSTEM ."
		$SCAN19 = " "
		$PROCESS1 = "     "
		$PROCESS3 = "    fixlist,   .    ."
		$REGIST1 = "  Windows"
		$REGIST2 = "  SOFTWARE ."
		$REGIST3 = "  SOFTWARE  ."
		$REGIST4 = "  Name   ."
		$REGIST5 = "  "
		$REGIST7 = "  CLSID"
		$REGIST8 = " "
		$PAD = ""
		$ALL = ""
		$REGIST9 = "    fixlist,          ."
		$REGIST10 = "   ."
		$WLISTED = "  "
		$RESTRICT = ""
		$SOFTW = " "
		$NFOUND = " "
		$RESTORED = " "
		$NDELETED = " "
		$DETECTED = ""
		$INTERNET = "    fixlist,     ,         ."
		$INTERNET1 = ""
		$INTERNET2 = ""
		$INTERNET3 = " URLSearchHook "
		$INTERNET4 = " "
		$INTERNET5 = " "
		$INTERNET6 = " Hosts    .   Hosts"
		$INTERNET7 = " Hosts      "
		$FF1 = " "
		$FF2 = "  *.cfg "
		$SERV1 = "    fixlist,     ."
		$SERV2 = "   ,     "
		$UNLOCK = " "
		$NUNLOCK = "   "
		$1MONT = " "
		$3MONT = " "
		$FIL0 = ""
		$FIL1 = ""
		$FOL0 = ""
		$FOL1 = ""
		$AND1 = "  "
		$CREATED = ""
		$MODIFIED = ""
		$FILFOL = "     , /  "
		$FILESR = "   "
		$0BYTE = "   "
		$TEMP1 = "  "
		$BAM = "   ,    "
		$MISS = ""
		$ASS = ""
		$RP1 = " "
		$RP2 = "     "
		$RP3 = "  "
		$UACC = " "
		$CUST = ""
		$DATAX = "  "
		$DATAY = ""
		$ADD1 = "  "
		$INSPRO = " "
		$CHECKWMI = "  ""winmgmt""   WMI."
		$CHECKWMI1 = "  ""VSS"""
		$SECCENT = " "
		$SECCENT1 = "    fixlist,   "
		$CONTENT = ""
		$HOSTS2 = " ,  Hosts:     fixlist    Hosts"
		$HOSTS3 = " HTML-  Hosts .   Hosts"
		$TASKS0 = " "
		$MOD1 = " "
		$ADS1 = "    fixlist,    ADS (  )."
		$SAFEB1 = "     ."
		$SAFEB2 = " "
		$REST1 = " "
		$REST2 = ""
		$NOFIX = "        ."
		$DSN = "    "
		$ANDERE = " "
		$DNS1 = " "
		$MSCONF = " "
		$DEVICE1 = "    "
		$DEVICE2 = "    ."
		$EVENTS1 = "  "
		$EVENTS2 = "    eventlog,   ."
		$EVENTS3 = " "
		$EVENTS4 = " "
		$SHORT1 = ""
		$SHORT2 = "       "
		$SCANED = " ."
		$FIXRES = " "
		$NOFIX1 = "  filxlist.txt"
		$NOFIX2 = " fixlist.txt      ,    ."
		$FIX12 = ",    .    ,   ."
		$WARN = ""
		$FIX13 = "FRST   ,     "
		$FIXER1 = ":       . "
		$FIXER2 = ":       ."
		$FIXER3 = ":       ."
		$FDIR = "/"
		$PROCL = "  ."
		$OF = ""
		$OF2 = ""
		$END = ""
		$FOUND1 = ""
		$TO = ""
		$ZBYTE = " "
		$IS = ""
		$NOT = ""
		$MOVEREB = "    "
		$MOVE = ""
		$DELRE = "    "
		$DEFA = " "
		$NRESTORE = "  "
		$RESTORE = "   "
		$FROM = ""
		$BACK = " "
		$VAL0 = ""
		$ERDEL = "   "
		$USE = ""
		$REP1 = "     "
		$DONE = ""
		$STAR = ""
		$REP2 = "  "
		$CAT1 = "    "
		$CAT2 = "     FRST.      ""netsh winsock reset"""
		$RENUM = " "
		$CHR1 = """"" Chrome     "
		$KEYY = ""
		$COP = " "
		$COP1 = "  "
		$REP = "  "
		$STOPS = "  "
		$NSTOPS = "  "
		$DISS = "  "
		$NDISS = "  "
		$DATA0 = ""
		$PRO4 = "  ,   "
		$PRO5 = "  "
		$PRO6 = "   "
		$PRO7 = "   "
		$PRO8 = "   "
		$ERR0 = ""
		$SHORTERR = "      .    "
		$ARG0 = ""
		$SHORT0 = ""
		$PW0 = ", ..."
		$CREAMOD = "   "
		$SZ0 = ""
		$ATT0 = ""
		$NAME0 = ""
		$COMP0 = "  "
		$INT0 = ""
		$OR0 = ""
		$PROD0 = ""
		$DES0 = ""
		$COPR0 = " "
		$SYMLINK0 = " "
		$FILENS = "  "
		$FILENS1 = " "
		$NPERMS = "   "
		$NOACC = "  "
		$MKEYNR = "   "
		$PROT0 = "  "
		$FIRSTA = "  "
		$NEXTL = "  "
		$CORRU = ", "
		$INVALKEY = "   "
		$NCOPY = "  "
		$PERMS = ""
		$NOCRYPT = "    .    "
		$FILESIG = "  "
		$ERRSIG = "   "
		$NOFIXENTRY = "      ."
		$RESQUA = "   "
		$MBR0 = " "
		$MBR1 = " "
		$DELTEMP0 = "  "
		$DELTEMP1 = "  "
		$REBOOT0 = "     ."
		$REBOOT1 = "  ."
		$COMPLETED = "    ,   FRST"
		$REBOOT2 = " . ,    .  ,          ."
		$REBOOT3 = " ,  ."
		$SEARCH0 = " "
		$SEARCH1 = ""
		$SEARCH2 = "     ."
		$SEARCH3 = "       10 ."
		$ADMINIS = ""
		$SEARCH4 = "  "
		$TASKS1 = "    fixlist,   (.job)  . ,  ,   ."
		$SEARCH5 = "   . ,        ."
		$ADD0 = " fixlist        ,   ."
		$NREMOV = "     FRST."
		$NRP = "       ."
		$YRP = "    ."
		$NHOSTS = " Hosts      "
		$ITEMPRO = " . ,        ."
		$DRIVE0 = ""
		$WBOOTC = "  "
		$OBTFROM = " "
		$SYSTEM0 = ""
		$FWNRUN = "   ."
		$FWDIS = ""
		$FILEMD = "    ."
		$USCANR = "   "
		$FWRUL = " "
		$MINFO = "  "
		$SERV = ""
		$MD5L = "MD5 "
		$ALTSH = " ""AlternateShell""  "
		$MOLI = ""
		$FPAD = "  "
		$NO = ""
		$CRRP = "  .     ,"
		$CRRPN = "    ."
		$LOCLSRV = " "
		$WINSOCKBR = "    -  ."
		$DRS0 = ""
		$IETR = "/"
		$PARTT = " "
		$OUTRE = "     "
		$MOS = "     Windows.      ." & @CRLF & @CRLF & "    ,           ." & @CRLF & @CRLF & " ,  ."
		$TESTS = " ""testsigning"".     "
		$BCDSM = "      ."
		$BCDNR = "     BCD"
		$MEM1 = "  "
		$MEM2 = "   RAM"
		$MEM3 = "  RAM"
		$MEM4 = " "
		$MEM5 = " "
		$FFPROX = " - Firefox  ."
		$ERRSV = "  ."
		$WINFW = " Windows"
		$REN0 = ""
		$RESD0 = "  "
		$PROCESSOR = ""
		$REINS = " Chrome."
		$INFEC = ""
		$LEGACY = ""
		$REPAIR = " "
		$NREPAIR = "  "
		$MOTH = " "
		$INUSE = "  "
		$ERRF = "   "
		$INCORR = " "
		$SCAN64 = "   - 86,   ,     , - 64"
		$DUMMY = "   "
		$PLATF = ""
	Case StringRegExp ( "0804" , @MUILang )
		$SCAN = ""
		$FIXB = ""
		$SEARCHB = ""
		$SEARCHBES = ""
		$SEARCHREG = ""
		$WHITELB = ""
		$REGB = ""
		$SERVB = ""
		$DRIVB = ""
		$OBTSCAN = ""
		$PROC0 = ""
		$PROCB = ""
		$BCD = " BCD"
		$90DAYS = ""
		$DISCLAIM = "!" & @CRLF & @CRLF & "" & @CRLF & @CRLF & "" & @CRLF & @CRLF & "?" & @CRLF & @CRLF & "    "
		$READY = ""
		$SCANB = ""
		$BOOT1 = ":"
		$BOOT2 = ""
		$BOOT3 = ""
		$BOOT4 = ""
		$BOOT5 = ""
		$BOOT6 = " OK "
		$BOOT7 = ""
		$UPD1 = ""
		$UPD2 = " Farbar  "
		$UPD3 = ""
		$UPD4 = ""
		$UPD5 = "?"
		$FIX1 = ","
		$FIX2 = " ..."
		$FIX3 = " "
		$FIXREG = ":"
		$FIX4 = ""
		$FIX5 = ""
		$MOVED = ""
		$DELETED = ""
		$FIX8 = ""
		$FIX9 = ""
		$FIX10 = ""
		$UPD7 = ""
		$UPD8 = ""
		$UPD9 = ""
		$BKU1 = ", "
		$SCAN1 = ""
		$SCAN2 = ""
		$SCAN3 = ""
		$SCAN4 = ""
		$SCAN5 = ""
		$SCAN7 = ""
		$SCAN0 = ""
		$SCAN8 = ""
		$SCAN9 = ""
		$SCAN99 = ""
		$SCAN10 = "..."
		$SCAN11 = "..."
		$ON = ""
		$SCAN13 = ""
		$SCAN14 = ""
		$SCAN15 = ""
		$SCAN16 = "FRST"
		$SCAN17 = ""
		$SCAN18 = ""
		$SCAN19 = ""
		$PROCESS1 = ""
		$PROCESS3 = ""
		$REGIST1 = ""
		$REGIST2 = ""
		$REGIST3 = ""
		$REGIST4 = ""
		$REGIST5 = ""
		$REGIST7 = " CLSID "
		$REGIST8 = ""
		$PAD = ""
		$ALL = ""
		$REGIST9 = ""
		$REGIST10 = ""
		$WLISTED = ""
		$RESTRICT = ""
		$SOFTW = ""
		$NFOUND = ""
		$RESTORED = ""
		$NDELETED = ""
		$DETECTED = ""
		$INTERNET = ""
		$INTERNET1 = ""
		$INTERNET2 = ""
		$INTERNET3 = "URL"
		$INTERNET4 = ""
		$INTERNET5 = ""
		$INTERNET6 = ""
		$INTERNET7 = ""
		$FF1 = ""
		$FF2 = " *.cfg "
		$SERV1 = ""
		$SERV2 = ""
		$UNLOCK = ""
		$NUNLOCK = ""
		$1MONT = ""
		$3MONT = ""
		$FIL0 = ""
		$FIL1 = ""
		$FOL0 = ""
		$FOL1 = ""
		$AND1 = "  "
		$CREATED = ""
		$MODIFIED = ""
		$FILFOL = "/"
		$FILESR = ""
		$0BYTE = ""
		$BAM = ""
		$MISS = ""
		$ASS = ""
		$RP1 = ""
		$RP2 = ""
		$RP3 = ""
		$UACC = ""
		$CUST = ""
		$DATAX = ""
		$DATAY = ""
		$ADD1 = ""
		$INSPRO = ""
		$CHECKWMI = " ""winmgmt""    WMI."
		$CHECKWMI = " ""VSS"" ."
		$SECCENT = ""
		$SECCENT1 = ""
		$CONTENT = ""
		$HOSTS2 = ""
		$HOSTS3 = "HTML"
		$TASKS0 = ""
		$MOD1 = ""
		$ADS1 = "ADS"
		$SAFEB1 = ""
		$SAFEB2 = ""
		$REST1 = ""
		$REST2 = ""
		$NOFIX = ""
		$DSN = ""
		$ANDERE = ""
		$DNS1 = ""
		$MSCONF = ""
		$DEVICE1 = ""
		$DEVICE2 = ""
		$EVENTS1 = ""
		$EVENTS2 = ""
		$EVENTS3 = ""
		$EVENTS4 = ""
		$SHORT1 = ""
		$SHORT2 = ""
		$SCANED = ""
		$FIXRES = ""
		$NOFIX1 = ".txt"
		$NOFIX2 = ".txt/"
		$FIX12 = ""
		$WARN = ""
		$FIX13 = "FRST"
		$FIXER1 = ""
		$FIXER2 = ""
		$FIXER3 = ""
		$FDIR = ""
		$PROCL = ""
		$OF = ""
		$OF2 = ""
		$END = ""
		$FOUND1 = ""
		$TO = ""
		$ZBYTE = ""
		$IS = ""
		$NOT = ""
		$MOVEREB = ""
		$MOVE = ""
		$DELRE = ""
		$DEFA = ""
		$NRESTORE = ""
		$RESTORE = ""
		$FROM = ""
		$BACK = "b"
		$VAL0 = ""
		$ERDEL = ""
		$USE = ""
		$REP1 = ""
		$DONE = ""
		$STAR = ""
		$REP2 = ""
		$CAT1 = ""
		$CAT2 = "FRST ""Winsock"" "
		$RENUM = ""
		$CHR1 = "Chrome"""""
		$KEYY = ""
		$COP = ""
		$COP1 = ""
		$REP = ""
		$STOPS = ""
		$NSTOPS = ""
		$DISS = ""
		$NDISS = ""
		$DATA0 = ""
		$PRO4 = ""
		$PRO5 = ""
		$PRO6 = ""
		$PRO7 = ""
		$PRO8 = ""
		$ERR0 = ""
		$SHORTERR = ""
		$ARG0 = ""
		$SHORT0 = ""
		$PW0 = ""
		$CREAMOD = ""
		$SZ0 = ""
		$ATT0 = ""
		$NAME0 = ""
		$COMP0 = ""
		$INT0 = ""
		$OR0 = ""
		$PROD0 = ""
		$DES0 = ""
		$COPR0 = ""
		$SYMLINK0 = ""
		$FILENS = ""
		$FILENS1 = ""
		$NPERMS = ""
		$NOACC = ""
		$MKEYNR = ""
		$PROT0 = ""
		$FIRSTA = ""
		$NEXTL = ""
		$CORRU = ""
		$INVALKEY = ""
		$NCOPY = ""
		$PERMS = ""
		$NOCRYPT = ""
		$FILESIG = ""
		$ERRSIG = ""
		$NOFIXENTRY = ""
		$RESQUA = ""
		$MBR0 = ""
		$MBR1 = ""
		$DELTEMP0 = ""
		$DELTEMP1 = ""
		$REBOOT0 = ""
		$REBOOT1 = ""
		$COMPLETED = "FRST"
		$REBOOT2 = ""
		$REBOOT3 = ""
		$SEARCH0 = ""
		$SEARCH1 = ""
		$SEARCH2 = ""
		$SEARCH3 = ""
		$ADMINIS = ""
		$SEARCH4 = ""
		$TASKS1 = ".Cob"
		$SEARCH5 = """"""
		$ADD0 = """"""
		$NREMOV = "FRST"
		$NRP = ""
		$YRP = ""
		$NHOSTS = ""
		$ITEMPRO = ""
		$DRIVE0 = ""
		$WBOOTC = ""
		$OBTFROM = ""
		$SYSTEM0 = ""
		$FWNRUN = ""
		$FWDIS = ""
		$FILEMD = ""
		$USCANR = ""
		$FWRUL = ""
		$MINFO = ""
		$SERV = ""
		$MD5L = "MD5"
		$ALTSH = """AlternateShell"""
		$MOLI = ""
		$FPAD = ""
		$NO = ""
		$CRRP = ""
		$CRRPN = ""
		$LOCLSRV = ""
		$WINSOCKBR = ""
		$DRS0 = ""
		$IETR = "/"
		$PARTT = ""
		$OUTRE = ""
		$MOS = "Windows" & @CRLF & @CRLF & "" & @CRLF & @CRLF & ""
		$TESTS = "'"
		$BCDSM = ""
		$BCDNR = "BCD"
		$MEM1 = ""
		$MEM2 = ""
		$MEM3 = ""
		$MEM4 = ""
		$MEM5 = ""
		$FFPROX = ""
		$ERRSV = ""
		$WINFW = ""
		$REN0 = ""
		$RESD0 = ""
		$PROCESSOR = ""
		$REINS = "Chrome"
		$INFEC = ""
		$LEGACY = ""
		$REPAIR = ""
		$NREPAIR = ""
		$SCAN64 = "x86x64"
		$MOTH = ""
		$INUSE = ""
		$ERRF = ""
		$INCORR = ""
		$DUMMY = ""
		$PLATF = ""
Case Else
		__AAAALNG1 ( )
	EndSelect
EndFunc
Func __AAAALNG1 ( )
	$SCAN = "Scan"
	$FIXB = "Fix"
	$SEARCHB = "Search"
	$SEARCHBES = "Search Files"
	$SEARCHREG = "Search Registry"
	$WHITELB = "Whitelist"
	$REGB = "Registry"
	$SERVB = "Services"
	$DRIVB = "Drivers"
	$OBTSCAN = "Optional Scan"
	$PROC0 = "process"
	$PROCB = "Processes"
	$BCD = "List BCD"
	$90DAYS = "90 Days Files"
	$DISCLAIM = "Disclaimer of warranty!" & @CRLF & @CRLF & "This software is provided ""AS IS"" without warranty of any kind. You may use this software at your own risk." & @CRLF & @CRLF & "Unless you have a licensed version, this software is not permitted for commercial purposes." & @CRLF & @CRLF & "Are you sure you want to continue?" & @CRLF & @CRLF & "Click Yes to continue. Click No to exit."
	$READY = "The tool is ready to use."
	$SCANB = "Scanning"
	$BOOT1 = "Is this the operating system you want to repair:"
	$BOOT2 = "This operating system is on"
	$BOOT3 = " drive when booted to the recovery mode."
	$BOOT4 = "The tool is setting up itself to read the drives."
	$BOOT5 = "The tool is run from the same drive the operating system is located. For this reason you will be presented to select the operating system once more. This is normal."
	$BOOT6 = "Click OK to continue"
	$BOOT7 = "The tool is setting up itself to read Local Disk."
	$UPD1 = "ATTENTION"
	$UPD2 = "This version of Farbar Recovery Scan Tool is "
	$UPD3 = "days old and outdated."
	$UPD4 = "Please download the latest version."
	$UPD5 = "Do you want to continue?"
	$FIX1 = "Fixing is in progress,"
	$FIX2 = "Fixing ..."
	$FIX3 = "Result of scheduled files to move (Boot Mode: "
	$FIXREG = "Result of scheduled keys to remove after reboot:"
	$FIX4 = "System is not rebooted."
	$FIX5 = "Is moved successfully"
	$MOVED = "moved successfully"
	$DELETED = "removed successfully"
	$FIX8 = "Could not move"
	$FIX9 = "Date&Time"
	$FIX10 = "Fix completed."
	$UPD7 = "Checking for update."
	$UPD8 = "New update found."
	$UPD9 = "Update Completed."
	$BKU1 = "Backing up registry, this should take a few seconds..."
	$SCAN1 = "Scanning is started."
	$SCAN2 = "version is"
	$SCAN3 = "days old and could be outdated"
	$SCAN4 = "The user is not administrator"
	$SCAN5 = "Default browser"
	$SCAN7 = "not detected"
	$SCAN0 = "Version"
	$SCAN8 = "Temporary Profile"
	$SCAN9 = "Loaded Profiles"
	$SCAN99 = "Available Profiles"
	$SCAN10 = "Scan result of"
	$SCAN11 = "Ran by"
	$ON = "on"
	$SCAN13 = "Running from"
	$SCAN14 = "Language"
	$SCAN15 = "Boot Mode"
	$SCAN16 = "If the system is bootable FRST must be run from normal or Safe mode to create a complete log."
	$SCAN17 = "Could not load system hive."
	$SCAN18 = "System hive is missing."
	$SCAN19 = "Tutorial for"
	$PROCESS1 = "Failed to access process"
	$PROCESS3 = "If an entry is included in the fixlist, the process will be closed. The file will not be moved."
	$REGIST1 = "Scanning Registry"
	$REGIST2 = "Software hive is missing."
	$REGIST3 = "Software hive is not loaded."
	$REGIST4 = "Value Name with invalid characters"
	$REGIST5 = "Reading users keys"
	$REGIST7 = "No CLSID Value"
	$REGIST8 = "No File"
	$PAD = "path"
	$ALL = "All"
	$REGIST9 = "If an entry is included in the fixlist, the registry item will be restored to default or removed."
	$REGIST10 = "The file will not be moved."
	$WLISTED = "Whitelisted"
	$RESTRICT = "Restriction"
	$SOFTW = "software"
	$NFOUND = "not found"
	$RESTORED = "restored successfully"
	$NDELETED = "could not remove"
	$DETECTED = "detected"
	$INTERNET = "If an item is included in the fixlist, if it is a registry item it will be removed or restored to default."
	$INTERNET1 = "is set"
	$INTERNET2 = "is enabled."
	$INTERNET3 = "Default URLSearchHook is missing"
	$INTERNET4 = "value is missing"
	$INTERNET5 = "should be"
	$INTERNET6 = "There are more than one entry in Hosts. See Hosts section of"
	$INTERNET7 = "Hosts file not detected in the default directory"
	$FF1 = "No Name"
	$FF2 = "Points to *.cfg file"
	$SERV1 = "If an entry is included in the fixlist, it will be removed from the registry."
	$SERV2 = "The file will not be moved unless listed separately"
	$UNLOCK = "was unlocked"
	$NUNLOCK = "could not be unlocked"
	$1MONT = "One month"
	$3MONT = "Three months"
	$FIL0 = "File"
	$FIL1 = "files"
	$FOL0 = "Folder"
	$FOL1 = "folders"
	$AND1 = " and "
	$CREATED = "created"
	$MODIFIED = "modified"
	$FILFOL = "If an entry is included in the fixlist, the file/folder will be moved"
	$FILESR = "Files in the root of some directories"
	$0BYTE = "Some zero byte size"
	$BAM = "There is no automatic fix for files that do not pass verification"
	$MISS = "IS MISSING"
	$ASS = "Association"
	$RP1 = "Restore Points"
	$RP2 = "Could not list restore points"
	$RP3 = "System Restore is disabled"
	$UACC = "Accounts"
	$CUST = "Custom"
	$DATAX = "the data entry has"
	$DATAY = "more characters"
	$ADD1 = "Additional scan result of"
	$INSPRO = "Installed Programs"
	$CHECKWMI = "Check ""winmgmt"" service or repair WMI."
	$CHECKWMI1 = "Check ""VSS"" service"
	$SECCENT = "Security Center"
	$SECCENT1 = "If an entry is included in the fixlist, it will be removed."
	$CONTENT = "content"
	$HOSTS2 = "If needed Hosts: directive could be included in the fixlist to reset Hosts."
	$HOSTS3 = "HTML script in Hosts detected. See Hosts section of"
	$TASKS0 = "Scheduled Tasks"
	$MOD1 = "Loaded Modules"
	$ADS1 = "If an entry is included in the fixlist, only the ADS will be removed."
	$SAFEB1 = "is missing and should be manually restored."
	$SAFEB2 = "Safe Mode"
	$REST1 = "There are"
	$REST2 = "more sites"
	$NOFIX = "Currently there is no automatic fix for this section."
	$DSN = "Media is not connected to internet."
	$ANDERE = "Other Areas"
	$DNS1 = "Error getting"
	$MSCONF = "disabled items"
	$DEVICE1 = "Faulty Device Manager Devices"
	$DEVICE2 = "Could not list Devices."
	$EVENTS1 = "Event log errors"
	$EVENTS2 = "Could not start eventlog service, could not read events."
	$EVENTS3 = "Application errors"
	$EVENTS4 = "System errors"
	$SHORT1 = "Shortcuts"
	$SHORT2 = "The entries could be listed to be restored or removed"
	$SCANED = "Scan completed."
	$FIXRES = "Fix result of"
	$NOFIX1 = "No fixlist.txt found."
	$NOFIX2 = "The fixlist.txt should be in the same folder/directory the tool is located."
	$FIX12 = "Looks you don't know what to do. To prevent damage to the system the tool will exit."
	$WARN = "Warning"
	$FIX13 = "FRST is scripted not to move this directory."
	$FIXER1 = "Error: The entry should be fixed outside recovery mode."
	$FIXER2 = "Error: The restore operation should be done in the recovery mode."
	$FIXER3 = "Error: This directive works only outside recovery mode."
	$FDIR = "File/Folder"
	$PROCL = "Processes closed successfully."
	$OF = "of"
	$OF2 = "of"
	$END = "End"
	$FOUND1 = "found"
	$TO = "to"
	$ZBYTE = "zero byte"
	$IS = "is"
	$NOT = "not"
	$MOVEREB = "Scheduled to move on reboot"
	$MOVE = "move"
	$DELRE = "Scheduled to remove on reboot"
	$DEFA = "Default"
	$NRESTORE = "Could not restore"
	$RESTORE = "from registry back up"
	$FROM = "from"
	$BACK = "back up"
	$VAL0 = "value"
	$ERDEL = "Error deleting product"
	$USE = "Use"
	$REP1 = "Deleting reparse point and unlocking"
	$DONE = "completed"
	$STAR = "started"
	$REP2 = "reparsepoint"
	$CAT1 = "The possible legit Catalog entry"
	$CAT2 = "will not be deleted with FRST. Instead, ""netsh winsock reset"" can be used"
	$RENUM = "will be renumbered"
	$CHR1 = "The Chrome ""Settings"" can be used to fix the entry"
	$KEYY = "key"
	$COP = "copied successfully to"
	$COP1 = "copied successfully"
	$REP = "Could not replace"
	$STOPS = "Service stopped successfully"
	$NSTOPS = "Unable to stop service"
	$DISS = "service was disabled"
	$NDISS = "Unable to disable service"
	$DATA0 = "Value data"
	$PRO4 = "Can not verify if process existed"
	$PRO5 = "process closed successfully"
	$PRO6 = "Could not open process"
	$PRO7 = "Could not close process"
	$PRO8 = "No running process found"
	$ERR0 = "Error"
	$SHORTERR = "Could not remove or repair shortcut argument. The shortcut could be damaged."
	$ARG0 = "argument"
	$SHORT0 = "Shortcut"
	$PW0 = "Please wait..."
	$CREAMOD = "Creation and modification date"
	$SZ0 = "Size"
	$ATT0 = "Attributes"
	$NAME0 = "Name"
	$COMP0 = "Company Name"
	$INT0 = "Internal"
	$OR0 = "Original"
	$PROD0 = "Product"
	$DES0 = "Description"
	$COPR0 = "Copyright"
	$SYMLINK0 = "Symbolic link"
	$FILENS = "File not signed"
	$FILENS1 = "not signed"
	$NPERMS = "Getting permissions failed"
	$NOACC = "Access Denied"
	$MKEYNR = "Main key is not recognized"
	$PROT0 = "could be protected"
	$FIRSTA = "at first attempt"
	$NEXTL = "see next line"
	$CORRU = "is possibly corrupted"
	$INVALKEY = "subkey with invalid name"
	$NCOPY = "Could not copy"
	$PERMS = "permissions"
	$NOCRYPT = "Could not perform signature verification. Cryptographic Service is not running"
	$FILESIG = "File is digitally signed"
	$ERRSIG = "Error verifying file signature"
	$NOFIXENTRY = "No automatic fix found for this entry."
	$RESQUA = "Restoring from Quarantine completed."
	$MBR0 = "is made successfully."
	$MBR1 = "is not made."
	$DELTEMP0 = "Deleting temporary files"
	$DELTEMP1 = "temporary data Removed."
	$REBOOT0 = "The computer will be restarted to complete the fix"
	$REBOOT1 = "The system needed a reboot."
	$COMPLETED = "is saved in the same directory FRST is located."
	$REBOOT2 = "The computer needs a restart. Please close all open windows. Note that you will not get any notification from the tool after restart."
	$REBOOT3 = "Click OK to restart."
	$SEARCH0 = "Search is in progress"
	$SEARCH1 = "Searching"
	$SEARCH2 = "No entry is entered in the search box."
	$SEARCH3 = "in some cases this can take more than 10 minutes."
	$ADMINIS = "administrator"
	$SEARCH4 = "Search result for"
	$TASKS1 = "If an entry is included in the fixlist, the task (.job) file will be moved. The file which is running by the task will not be moved."
	$SEARCH5 = "No search term is entered. Please enter the search term and press ""Search files"" button."
	$ADD0 = "Only the adware programs with ""Hidden"" flag could be added to the fixlist to unhide them. The adware programs should be uninstalled manually."
	$NREMOV = "Will not be removed with FRST."
	$NRP = "Restore point can only be created in normal mode."
	$YRP = "Restore point was successfully created."
	$NHOSTS = "Hosts file not detected in the default directory"
	$ITEMPRO = "The item is protected. Make sure the software is uninstalled and its services is removed."
	$DRIVE0 = "drive"
	$WBOOTC = "with boot components"
	$OBTFROM = "obtained from"
	$SYSTEM0 = "system"
	$FWNRUN = "Firewall Service is not running."
	$FWDIS = "is disabled."
	$FILEMD = "Files to move or delete"
	$USCANR = "Users shortcut scan result"
	$FWRUL = "FirewallRules"
	$MINFO = "Memory info"
	$SERV = "service"
	$MD5L = "MD5 is legit"
	$ALTSH = "The ""AlternateShell"" will be restored"
	$MOLI = "more lines"
	$FPAD = "filepath"
	$NO = "no"
	$CRRP = "Creating Restore Point. This can take a few minutes,"
	$CRRPN = "Failed to create a restore point."
	$LOCLSRV = "Locked Service"
	$WINSOCKBR = "Broken internet access due to missing entry."
	$DRS0 = "Drives"
	$IETR = "trusted/restricted"
	$PARTT = "Partition Table"
	$OUTRE = "This functions outside Recovery Environment"
	$MOS = "More than one Windows operating system detected. They will be presented to select one to be scanned." & @CRLF & @CRLF & "In case you made the wrong choice please restart and boot to recovery environment again before running the tool." & @CRLF & @CRLF & "Click OK to continue."
	$TESTS = "'testsigning' is set. Check for possible unsigned driver"
	$BCDSM = "The system is configured to boot to Safe Mode"
	$BCDNR = "Could not access BCD."
	$MEM1 = "Percentage of memory in use"
	$MEM2 = "Total physical RAM"
	$MEM3 = "Available physical RAM"
	$MEM4 = "Total Virtual"
	$MEM5 = "Available Virtual"
	$FFPROX = "Firefox Proxy settings were reset."
	$ERRSV = "Error setting value."
	$WINFW = "Windows Firewall"
	$REN0 = "renamed"
	$RESD0 = "Restore point date"
	$PROCESSOR = "Processor"
	$REINS = "Reinstall Chrome."
	$INFEC = "Infected"
	$LEGACY = "Legacy"
	$REPAIR = "Repaired successfully"
	$NREPAIR = "Could not repair"
	$MOTH = "Motherboard"
	$INUSE = "File is in use"
	$ERRF = "Error Reading file"
	$INCORR = "Incorrect path"
	$DUMMY = "Dummy created successfully"
	$PLATF = "Platform"
	$SCAN64 = "THE OPERATING SYSTEM IS A X86 SYSTEM BUT THE BOOT DISK THAT IS USED TO BOOT TO RECOVERY ENVIRONMENT IS A X64 SYSTEM DISK."
EndFunc
Func __REGDELETE ( $KEY )
	Global $ARRENT [ 0 ]
	_REGDELETEENT2 ( $KEY )
	_ARRAYREVERSE ( $ARRENT )
	For $N = 0 To UBound ( $ARRENT ) + 4294967295
		$FULLKEY = _HKEYTRANS ( $ARRENT [ $N ] )
		$RET = _HKEYCREATE ( $FULLKEY )
		Switch $RET
		Case 1
			_INVALID ( _STARTKEY ( $ARRENT [ $N ] ) , $ARRENT [ $N ] )
		Case 2
			$HKEY = _HKEY ( $FULLKEY , 1 )
			If Not @error And IsPtr ( $HKEY ) Then _NTDELETEKEY ( $HKEY )
		Case + 3221225506
			_SETREGACE ( $ARRENT [ $N ] , 1 )
			$HKEY = _HKEY ( $FULLKEY , 1 )
			If Not @error And IsPtr ( $HKEY ) Then _NTDELETEKEY ( $HKEY )
	Case Else
			$HKEY = _HKEY ( $FULLKEY , 1 )
			If Not @error And IsPtr ( $HKEY ) Then _NTDELETEKEY ( $HKEY )
		EndSwitch
	Next
	$ARRENT = ""
EndFunc
Func __REGENUMKEY ( $HKEY , $IINDEX )
	$BUFFERSIZE = 256
	$ARET = DllCall ( "advapi32.dll" , "long" , "RegEnumKeyExW" , "handle" , $HKEY , "dword" , $IINDEX , "wstr" , "" , "dword*" , 256 , "dword" , 0 , "ptr" , 0 , "ptr" , 0 , "ptr" , 0 )
	While $ARET [ 0 ] = 234
		$BUFFERSIZE += 256
		$LPNAME = DllStructCreate ( "byte[" & $BUFFERSIZE & "]" )
		$CBDATA = DllStructGetSize ( $LPNAME )
		$ARET = DllCall ( "advapi32.dll" , "long" , "RegEnumKeyExW" , "handle" , $HKEY , "dword" , $IINDEX , "wstr" , "" , "dword*" , $CBDATA , "dword" , 0 , "ptr" , 0 , "ptr" , 0 , "ptr" , 0 )
	WEnd
	If @error Or $ARET [ 0 ] Then
		_REGCLOSE ( $HKEY )
		Return SetError ( 1 )
	EndIf
	Return $ARET [ 3 ]
EndFunc
Func _AAAABITS ( )
	Local $IEBACKGROUNDCOPYMANAGER , $PENUM , $COUNT
	$FUNCSIBACKGROUNDCOPYMANAGER = "CreateJob hresult(wstr;int;clsid*;ptr*);GetJob hresult(clsid;ptr*);EnumJobs hresult(dword;ptr*)"
	Local $BCM_CLSID [ ] = [ "{5FD42AD5-C04E-4D36-ADC7-E08FF15737AD}" , "{4575438F-A6C8-4976-B0FE-2F26B80D959E}" , "{4BD3E4E1-7BD4-4A2B-9964-496400DE5193}" , "{4D233817-B456-4E75-83D2-B17DEC544D12}" , "{1ECCA34C-E88A-44E3-8D6A-8921BDE9E452}" , "{BB6DF56B-CACE-11DC-9992-0019B93A3A84}" , "{659CDEA7-489E-11D9-A9CD-000D56965251}" , "{03CA98D6-FF5D-49B8-ABC6-03DD84127020}" , "{6D18AD12-BDE3-4393-B311-099C346E6DF9}" , "{F087771F-D74F-4C1A-BB8A-E16ACA9124EA}" , "{4991D34B-80A1-4291-83B6-3328366B9097}" ]
	For $I = 0 To UBound ( $BCM_CLSID ) + 4294967295
		$IEBACKGROUNDCOPYMANAGER = ObjCreateInterface ( $BCM_CLSID [ $I ] , "{5CE34C0D-0DC9-4C1F-897C-DAA1B78CEE7C}" , $FUNCSIBACKGROUNDCOPYMANAGER )
		If IsObj ( $IEBACKGROUNDCOPYMANAGER ) Then ExitLoop
	Next
	If Not IsObj ( $IEBACKGROUNDCOPYMANAGER ) Then Return
	$FUNCSIENUMBACKGROUNDCOPYJOBS = "Next hresult(ulong;struct*;ulong_ptr*);Skip hresult(ulong);Reset hresult();Clone hresult(ptr*);GetCount hresult(ulong_ptr*)"
	$DWFLAGS = 1
	$IEBACKGROUNDCOPYMANAGER .EnumJobs ( $DWFLAGS , $PENUM )
	$IENUMBACKGROUNDCOPYJOBS = ObjCreateInterface ( $PENUM , "{1AF4F612-3B71-466F-8F58-7B6F73AC57AD}" , $FUNCSIENUMBACKGROUNDCOPYJOBS )
	If Not IsObj ( $IENUMBACKGROUNDCOPYJOBS ) Then Return
	$IENUMBACKGROUNDCOPYJOBS .GetCount ( $COUNT )
	If $COUNT < 1 Then Return
	Local $PCELTFETCHED , $JOBS
	For $I = 1 To $COUNT
		$JOBS &= "ptr;"
	Next
	$FUNCSIBACKGROUNDCOPYJOB2 = "AddFileSet hresult(ulong;struct*);AddFile hresult(wstr;wstr);EnumFiles hresult(ptr*);Suspend hresult();Resume hresult();Cancel hresult();Complete hresult();GetId hresult(clsid*);GetType hresult(int_ptr*);GetProgress hresult(struct*);GetTimes hresult(struct*);GetState hresult(int_ptr*);GetError hresult(ptr*);GetOwner hresult(wstr*);SetDisplayName hresult(wstr);GetDisplayName hresult(wstr*);SetDescription hresult(wstr);GetDescription hresult(wstr*);SetPriority hresult(int);GetPriority hresult(int_ptr*);SetNotifyFlags hresult(ulong);GetNotifyFlags hresult(ulong_ptr*);SetNotifyInterface hresult(ptr);GetNotifyInterface hresult(ptr*);SetMinimumRetryDelay hresult(ulong);GetMinimumRetryDelay hresult(ulong_ptr*);SetNoProgressTimeout hresult(ulong);GetNoProgressTimeout hresult(ulong_ptr*);GetErrorCount hresult(ulong_ptr*);SetProxySettings hresult(int;struct*;struct*);GetProxySettings hresult(int_ptr*;wstr*;wstr*);TakeOwnership hresult();SetNotifyCmdLine hresult(wstr;wstr);GetNotifyCmdLine hresult(wstr*;wstr*);"
	$FUNCSIENUMBACKGROUNDCOPYFILES = "Next hresult(ulong;struct*;ulong_ptr*);Skip hresult(ulong);Reset hresult();Clone hresult(ptr*);GetCount hresult(ulong_ptr*)"
	$FUNCSIBACKGROUNDCOPYFILE = "GetRemoteName hresult(wstr*);GetLocalName hresult(wstr*)"
	$SJOBS = DllStructCreate ( $JOBS )
	$IENUMBACKGROUNDCOPYJOBS .Next ( $COUNT , $SJOBS , $PCELTFETCHED )
	For $I = 1 To $PCELTFETCHED
		$PJOB = DllStructGetData ( $SJOBS , $I )
		$IBACKGROUNDCOPYJOB2 = ObjCreateInterface ( $PJOB , "{54B50739-686F-45EB-9DFF-D6A9A0FAA9AF}" , $FUNCSIBACKGROUNDCOPYJOB2 )
		If Not IsObj ( $IBACKGROUNDCOPYJOB2 ) Then ContinueLoop
		Local $PROGRAM , $PARAM , $GUID , $DISPLAY , $PFILES , $COUNT
		$IBACKGROUNDCOPYJOB2 .GetNotifyCmdLine ( $PROGRAM , $PARAM )
		If Not $PROGRAM Then ContinueLoop
		$IBACKGROUNDCOPYJOB2 .GetId ( $GUID )
		$IBACKGROUNDCOPYJOB2 .GetDisplayName ( $DISPLAY )
		$IBACKGROUNDCOPYJOB2 .EnumFiles ( $PFILES )
		$IENUMBACKGROUNDCOPYFILES = ObjCreateInterface ( $PFILES , "{CA51E165-C365-424C-8D41-24AAA4FF3C40}" , $FUNCSIENUMBACKGROUNDCOPYFILES )
		If Not IsObj ( $IENUMBACKGROUNDCOPYFILES ) Then ContinueLoop
		$IENUMBACKGROUNDCOPYFILES .GetCount ( $COUNT )
		Local $FILES , $PCELTFETCHED2 , $FNAMES = $FIL1 & ":"
		For $S = 1 To $COUNT
			$FILES &= "ptr;"
		Next
		$SFILES = DllStructCreate ( $FILES )
		$IENUMBACKGROUNDCOPYFILES .Next ( $COUNT , $SFILES , $PCELTFETCHED2 )
		If $COUNT < 1 Then ContinueLoop
		For $F = 1 To $PCELTFETCHED2
			$PFILE = DllStructGetData ( $SFILES , $F )
			$IEBACKGROUNDCOPYFILE = ObjCreateInterface ( $PFILE , "{01B7BD23-FB88-4A77-8490-5891D3E4653A}" , $FUNCSIBACKGROUNDCOPYFILE )
			If Not IsObj ( $IEBACKGROUNDCOPYFILE ) Then ContinueLoop
			Local $REMOTENAME , $LOCALNAME
			$IEBACKGROUNDCOPYFILE .GetRemoteName ( $REMOTENAME )
			$IEBACKGROUNDCOPYFILE .GetLocalName ( $LOCALNAME )
			$FNAMES &= $REMOTENAME & " -> " & $LOCALNAME & " "
		Next
		$FNAMES = StringTrimRight ( $FNAMES , 1 )
		FileWrite ( $HADDITION , @CRLF & "BITS: " & $GUID & " - (" & $DISPLAY & ") -> [NotifyCmdLine: " & $PROGRAM & " " & $PARAM & "] [" & $FNAMES & "]" & @CRLF )
	Next
EndFunc
Func _AAAABKP ( )
	$PFRST = $C & "\FRST"
	$PQUARAN = $PFRST & "\Quarantine"
	$PLOGS = $PFRST & "\Logs"
	$BIN = $PFRST & "\bin"
	If FileExists ( $PFRST ) Then
		If _CREATEFILE ( $PFRST , 268435456 ) Then _UNLOCKALLCHILD ( $PFRST )
		If StringRegExp ( FileGetAttrib ( $PFRST ) , "(?i)S|R|H" ) Then FileSetAttrib ( $PFRST , "-RSH" )
	EndIf
	If Not FileExists ( $PLOGS ) Then DirCreate ( $PLOGS )
	If FileExists ( $PQUARAN ) Then
		If StringRegExp ( FileGetAttrib ( $PQUARAN ) , "(?i)S|R|H" ) Then FileSetAttrib ( $PQUARAN , "-RSH" )
	Else
		DirCreate ( $PQUARAN )
	EndIf
	If Not FileExists ( $BIN & "\sqlite3_x64.dll" ) Then
		If FileExists ( $BIN ) And StringRegExp ( FileGetAttrib ( $BIN ) , "(?i)S|R|H" ) Then FileSetAttrib ( $BIN , "-RSH" )
		DirCreate ( $PFRST & "\bin" )
		FileInstall ( "sqlite3_x64.dll" , $BIN & "\" )
	EndIf
	$DESTIN = $C & "\FRST\Hives"
	If Not FileExists ( $DESTIN ) Then DirCreate ( $DESTIN )
	If StringRegExp ( FileGetAttrib ( $DESTIN ) , "(?i)S|R|H" ) Then FileSetAttrib ( $DESTIN , "-RSH" )
	If Not FileExists ( $PLOGS & "\ct.ini" ) Then
		FileWrite ( $PLOGS & "\ct.ini" , "[Run]" & @CRLF & "ct=0" & @CRLF )
		FileSetAttrib ( $PLOGS & "\ct.ini" , "+SH" )
	EndIf
	Local $SOURCE [ 6 ]
	Local $ARR [ ] = [ "SOFTWARE" , "SYSTEM" , "SAM" , "DEFAULT" , "SECURITY" , "COMPONENTS" ]
	For $I = 0 To UBound ( $ARR ) + 4294967295
		$SOURCE [ $I ] = $C & "\Windows\System32\config\" & $ARR [ $I ]
	Next
	If $BOOTM = "Recovery" Then
		GUICtrlSetData ( $LABEL1 , $BKU1 )
		Local $DR [ ] = [ "Y" , "C" , "D" , "E" ]
		For $I = 0 To UBound ( $ARR ) + 4294967295
			If Not FileExists ( $DESTIN & "\" & $ARR [ $I ] ) Then FileCopy ( $SOURCE [ $I ] , $DESTIN )
		Next
		For $I = 0 To UBound ( $DR ) + 4294967295
			If DriveStatus ( $DR [ $I ] & ":\" ) <> "Ready" Then ContinueLoop
			If Not FileExists ( $DESTIN & "\bcd." & $DR [ $I ] ) And FileExists ( $DR [ $I ] & ":\boot\bcd" ) Then
				FileCopy ( $DR [ $I ] & ":\boot\bcd" , $DESTIN )
				FileMove ( $DESTIN & "\bcd" , $DESTIN & "\BCD." & $DR [ $I ] )
			EndIf
		Next
	Else
		If FileExists ( $DESTIN & "\" & $ARR [ 0 ] ) And FileExists ( $DESTIN & "\" & $ARR [ 1 ] ) And FileExists ( $DESTIN & "\" & @UserName & "\NTUSER.DAT" ) Then Return
		If Not FileExists ( $DESTIN & "\" & @UserName ) Then DirCreate ( $DESTIN & "\" & @UserName )
		GUICtrlSetData ( $LABEL1 , $BKU1 )
		$COM = @SystemDir & "\bcdedit /export " & $DESTIN & "\BCD"
		If $OSNUM > 5.2 And StringRegExpReplace ( CMDRUN ( "echo 2" ) , "\s+" , "" ) = 2 Then
			RunWait ( @ComSpec & " /c " & $COM , "" , @SW_HIDE )
			FileDelete ( $DESTIN & "\BCD.LOG*" )
		EndIf
		If $OSNUM < 6 Then
			_BKP1 ( $ARR )
		Else
			$FPATH = @UserProfileDir & "\NTUSER.DAT"
			If FileExists ( $FPATH ) Then _ARRAYADD ( $SOURCE , $FPATH )
			$FPATH = @LocalAppDataDir & "\Microsoft\Windows\UsrClass.dat"
			If FileExists ( $FPATH ) Then _ARRAYADD ( $SOURCE , $FPATH )
			_SBKP ( $SOURCE )
			If @error Then _BKP1 ( $ARR )
		EndIf
	EndIf
	GUICtrlSetData ( $LABEL1 , "" )
EndFunc
Func _AAAACOD ( )
	Local $ARRCOD [ 1 ]
	DRIVERS32 ( $ARRCOD )
	DRIVERS32 ( $ARRCOD , 1 )
	DRIVERS32U ( $ARRCOD )
	FileWrite ( $HADDITION , @CRLF & "==================== Codecs (" & $WLISTED & ") ====================" & @CRLF )
	If UBound ( $ARRCOD ) > 1 Then
		FileWrite ( $HADDITION , @CRLF & "(" & $REGIST9 & " " & $REGIST10 & ")" & @CRLF )
		_FILEWRITEFROMARRAY ( $HADDITION , $ARRCOD )
	EndIf
EndFunc
Func _AAAADL ( )
	Local $R , $VAR , $DT , $DRY
	GUICtrlSetData ( $LABEL1 , $BOOT7 & " " & $PW0 )
	$SCRIPTDIR0 = StringRegExpReplace ( @ScriptDir & "\" & @ScriptName , "\\\\" , "\\" )
	$SCRIPTDIR = StringRegExpReplace ( $SCRIPTDIR0 , "[^\\]+(.+)" , "$1" )
	$VAR = DriveGetDrive ( "all" )
	For $I = 1 To UBound ( $VAR ) + 4294967295
		$DT = DriveGetType ( $VAR [ $I ] & "\" )
		If $DT = "Fixed" And FileExists ( $VAR [ $I ] & "\windows\system32\config\COMPONENTS" ) And FileExists ( $VAR [ $I ] & "\Users" ) Then
			Local $RET = DllCall ( "Kernel32.dll" , "bool" , "GetVolumeNameForVolumeMountPointW" , "wstr" , $VAR [ $I ] & "\" , "wstr" , "" , "dword" , 255 )
			$CGUID = $RET [ 2 ]
			If DriveStatus ( "C:\" ) <> "Invalid" Then
				Local $RET = DllCall ( "Kernel32.dll" , "bool" , "GetVolumeNameForVolumeMountPointW" , "wstr" , "C:\" , "wstr" , "" , "dword" , 255 )
				$YGUID = $RET [ 2 ]
				Local $RET = DllCall ( "kernel32.dll" , "bool" , "DeleteVolumeMountPointW" , "wstr" , "C:\" )
				$DRY = "Y"
				If DriveStatus ( "Y:\" ) <> "Invalid" Then
					For $I = 68 To 90
						If DriveStatus ( Chr ( $I ) & ":\" ) = "Invalid" Then
							$DRY = Chr ( $I )
							ExitLoop
						EndIf
					Next
				EndIf
				Local $RET = DllCall ( "kernel32.dll" , "bool" , "SetVolumeMountPointW" , "wstr" , $DRY & ":\" , "wstr" , $YGUID )
			EndIf
			Local $RET = DllCall ( "kernel32.dll" , "bool" , "DeleteVolumeMountPointW" , "wstr" , $VAR [ $I ] & "\" )
			Local $RET = DllCall ( "kernel32.dll" , "bool" , "SetVolumeMountPointW" , "wstr" , "C:\" , "wstr" , $CGUID )
			ExitLoop
		EndIf
	Next
	If FileExists ( $SCRIPTDIR0 ) Then Return
	$VAR = DriveGetDrive ( "all" )
	For $I = 1 To UBound ( $VAR ) + 4294967295
		If FileExists ( $VAR [ $I ] & $SCRIPTDIR ) Then
			ShellExecute ( $VAR [ $I ] & $SCRIPTDIR )
			Exit
		EndIf
	Next
EndFunc
Func _AAAALOS ( )
	$N = 0
	$VAR = DriveGetDrive ( "all" )
	If Not @error Then
		For $I = 1 To UBound ( $VAR ) + 4294967295
			$DT = DriveGetType ( $VAR [ $I ] & "\" )
			If $DT = "Fixed" And Not StringInStr ( $VAR [ $I ] , "X" ) And FileExists ( $VAR [ $I ] & "\windows\system32\config\software" ) Then
				$N = $N + 1
			EndIf
		Next
	EndIf
	If $N > 1 Then
		MsgBox ( 262144 + 0 , $FRST , $MOS )
		_AAAASOS ( )
	EndIf
EndFunc
Func _AAAAO ( )
	$RET = False
	$K = 0
	While 1
		$USERC = __REGENUMKEY ( 2147483651 , $K )
		If @error Then ExitLoop
		If StringInStr ( $USERC , "_Classes" ) Then
			$VDATA = RegRead ( "HKU\" & $USERC & "\CLSID\{56FDF344-FD6D-11d0-958A-006097C9A090}\InprocServer32" , "" )
			If Not @error And StringInStr ( $VDATA , "AppData" ) Then $RET = StringRegExpReplace ( $VDATA , ".+\\(.+?)\\.+" , "$1" )
		EndIf
		$K += 1
	WEnd
	Return $RET
EndFunc
Func _AAAAP ( )
	Local $HPROG [ 1 ] , $CHROMEAPPS [ 1 ]
	GUICtrlSetData ( $LABEL1 , $SCANB & " " & $INSPRO & "..." )
	$UNINSTALL = "HKLM\Software\Microsoft\Windows\CurrentVersion\Uninstall"
	$HKEY = _REGOPENKEYEX3 ( $UNINSTALL )
	If Not @error And IsPtr ( $HKEY ) Then
		$I = + 4294967295
		While 1
			$I += 1
			$VAR1 = __REGENUMKEY ( $HKEY , $I )
			If @error Then ExitLoop
			If Not RegRead ( $UNINSTALL & "\" & $VAR1 , "UninstallString" ) Then ContinueLoop
			$VAR2 = RegRead ( $UNINSTALL & "\" & $VAR1 , "Displayname" )
			$VAR2 = StringRegExpReplace ( $VAR2 , "^\s+" , "" )
			If Not StringRegExp ( $VAR2 , "^$|(?i)(Security Update for|hotfix for|Update for Microsoft)" ) Then
				$PUB = RegRead ( $UNINSTALL & "\" & $VAR1 , "Publisher" )
				$VERS0 = RegRead ( $UNINSTALL & "\" & $VAR1 , "Displayversion" )
				$VARH = RegRead ( $UNINSTALL & "\" & $VAR1 , "SystemComponent" )
				$VARHH = ""
				If $VARH = 1 Then $VARHH = " Hidden"
				_ARRAYADD ( $HPROG , $VAR2 & " (HKLM\...\" & $VAR1 & ") (Version: " & $VERS0 & " - " & $PUB & ")" & $VARHH , 0 , "||||" )
			EndIf
		WEnd
	EndIf
	For $U = 1 To UBound ( $USERREG ) + 4294967295
		$UNINSTALL = "hku\" & $USERREG [ $U ] & "\Software\Microsoft\Windows\CurrentVersion\Uninstall"
		$HKEY = _REGOPENKEYEX3 ( $UNINSTALL )
		If @error Or Not IsPtr ( $HKEY ) Then ContinueLoop
		$I = + 4294967295
		While 1
			$I += 1
			$VAR1 = __REGENUMKEY ( $HKEY , $I )
			If @error Then ExitLoop
			If Not RegRead ( $UNINSTALL & "\" & $VAR1 , "UninstallString" ) Then ContinueLoop
			$VAR2 = RegRead ( $UNINSTALL & "\" & $VAR1 , "Displayname" )
			$VAR2 = StringRegExpReplace ( $VAR2 , "^\s+" , "" )
			If Not StringRegExp ( $VAR2 , "^$|(?i)(Security Update for|hotfix for|Update for Microsoft)" ) Then
				$PUB = RegRead ( $UNINSTALL & "\" & $VAR1 , "Publisher" )
				$VERS0 = RegRead ( $UNINSTALL & "\" & $VAR1 , "Displayversion" )
				$VARH = RegRead ( $UNINSTALL & "\" & $VAR1 , "SystemComponent" )
				$VARHH = ""
				If $VARH = 1 Then $VARHH = " Hidden"
				$ENTRY = $VAR2 & " (HKU\" & $USERREG [ $U ] & "\...\" & $VAR1 & ") (Version: " & $VERS0 & " - " & $PUB & ")" & $VARHH
				If StringInStr ( $PUB , "Google\Chrome" ) Then
					_ARRAYADD ( $CHROMEAPPS , $ENTRY , 0 , "||||" )
				Else
					_ARRAYADD ( $HPROG , $ENTRY , 0 , "||||" )
				EndIf
			EndIf
		WEnd
	Next
	$UNINSTALL = "HKLM\SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall"
	$HKEY = _REGOPENKEYEX3 ( $UNINSTALL )
	If Not @error And IsPtr ( $HKEY ) Then
		$I = + 4294967295
		While 1
			$I += 1
			$VAR1 = __REGENUMKEY ( $HKEY , $I )
			If @error Then ExitLoop
			If Not RegRead ( $UNINSTALL & "\" & $VAR1 , "UninstallString" ) Then ContinueLoop
			$VAR2 = RegRead ( $UNINSTALL & "\" & $VAR1 , "Displayname" )
			$VAR2 = StringRegExpReplace ( $VAR2 , "^\s+" , "" )
			If Not StringRegExp ( $VAR2 , "^$|(?i)(Security Update for|hotfix for|Update for Microsoft)" ) Then
				$PUB = RegRead ( $UNINSTALL & "\" & $VAR1 , "Publisher" )
				$VERS0 = RegRead ( $UNINSTALL & "\" & $VAR1 , "Displayversion" )
				$VARH = RegRead ( $UNINSTALL & "\" & $VAR1 , "SystemComponent" )
				$VARHH = ""
				If $VARH = 1 Then $VARHH = " Hidden"
				_ARRAYADD ( $HPROG , $VAR2 & " (HKLM-x32\...\" & $VAR1 & ") (Version: " & $VERS0 & " - " & $PUB & ")" & $VARHH , 0 , "||||" )
			EndIf
		WEnd
	EndIf
	If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
	_ARRAYDELETE ( $HPROG , 0 )
	$HPROG = _ARRAYUNIQUE ( $HPROG , 0 , 0 , 0 , 0 , 1 )
	_ARRAYSORT ( $HPROG , 0 )
	FileWrite ( $HADDITION , @CRLF & "==================== " & $INSPRO & " ======================" & @CRLF )
	FileWrite ( $HADDITION , @CRLF & "(" & $ADD0 & ")" & @CRLF & @CRLF )
	$MOTORS = _AAAAO ( )
	For $P = 0 To UBound ( $HPROG ) + 4294967295
		$LINE = $HPROG [ $P ]
		$ATTEN = ""
		$KW = ""
		$KW1 = ""
		If StringRegExp ( $LINE , "\\Steam App \d+\)" ) Then ContinueLoop
		If StringRegExp ( $LINE , "(?i)^[a-z]+\s*[a-z]*? \d\.\d+\.\d+\.\d+ \(" ) Then
			$KW = StringRegExpReplace ( $LINE , "(?i)(^[a-z]+\s*[a-z]*?) \d\.\d+\.\d+\.\d+ \(.+" , "\1" )
			$KW1 = StringRegExpReplace ( $KW , " " , "" )
		EndIf
		Select
		Case StringRegExp ( $LINE , "(?i)A92DAB39-4E2C-4304-9AB6-BC44E68B55E2" )
			If StringInStr ( RegRead ( "HKLM\SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\{A92DAB39-4E2C-4304-9AB6-BC44E68B55E2}" , "InstallSource" ) , "VLCStreamer" ) Then $ATTEN = " <==== " & $UPD1
		Case StringRegExp ( $LINE , "(?i)^(\w+) Updater version \d.\d.\d.\d \(.+\\\1 Updater_is1\) \(Version: \d.\d.\d.\d - \)" )
			$ATTEN = " <==== " & $UPD1
		Case $KW <> "" And StringRegExp ( $LINE , "^" & $KW & " \d\.\d+\.\d+\.\d+ \(HKLM(-x32|)\\...\\" & $KW1 & "_\d\.\d+\.\d+\.\d+\) \(Version: \d\.\d+\.\d+\.\d+ - " & "(" & $KW & "|" & $KW1 & ")" )
			$ATTEN = " <==== " & $UPD1
		Case $MOTORS And StringRegExp ( $LINE , "(?i)^" & $MOTORS )
			$ATTEN = " <==== " & $UPD1
		Case StringRegExp ( $LINE , "(^HP\S+?) \(HK.+\\\1\) \(Version:\s+-\s+\)" )
			$ATTEN = " <==== " & $UPD1
		Case StringRegExp ( $LINE , "(?i)(.+?) \(.+\\\1\) \(Version: \d\.\d\.\d{4}\.\d{2,} - (\1|)\)" )
			$ATTEN = " <==== " & $UPD1
		Case StringRegExp ( $LINE , "(?i)(.+?) 1.0 \(.+\\\1\) \(Version: 1.0 - \1\)" )
			$ATTEN = " <==== " & $UPD1
		Case StringRegExp ( $LINE , "(?i)HKU\\.+?Version: \d\.\d\.\d - .+?corp\)" )
			$ATTEN = " <==== " & $UPD1
		Case StringRegExp ( $LINE , "(^\w+) version 1\.0\.3\.1 \(HKU.+\1\)" )
			$ATTEN = " <==== " & $UPD1
		Case StringRegExp ( $LINE , "(?i)- Uninstall \(.+\\{\w{8}-\w{4}-\w{4}-\w{4}-\w{12}}\) \(Version:\s+-\s+\)" )
			$ATTEN = " <==== " & $UPD1
		Case StringRegExp ( $LINE , "(?i)^(searcharchiver|Altruistics |gotosrch |ProW File Compressor|SteamClient \d|Client Helper \d|Outbyte Driver Update|gt-launcher \d|Warcraft 3 |SteamUpdate \d|TorrentPro |Pinaview |Francezon \(|WTOOLS |BitCleaner|AweAPCP|A\w+Application \(.+Version: 1\.|CT0iuoBU Incorporated|WunderBAR|twengoo|Quick Driver Updater|Web Companion|Cookie A.Q|DigitalPulse)|Browser\s*Assistant|Bonanza\s*Deals|Host App Service|^(Massive|SEO) \(HKU|PriceWatch|RestMinder version|Honeygain|^2\.1\.2\.3" )
			$ATTEN = " <==== " & $UPD1
		Case StringRegExp ( $LINE , "(?i)^(Atruct|Browser Extension|BBWC \(|Web Search \(Yahoo|FLV Runner Toolbar|jZip \(|Advanced\s*System\s*Repair\s*Pro|Preispilot|Setup \d|Great Discover|Taskbar system version|DriverIdentifier|Restoro |Windows Manager|System Checkup|pricetaco|cr+a+c+o+n+|SearcherBar|Shopping Helper Smartbar|Decacopy Lite Clipboard|Bit Driver Updater|eSupport UndeletePlus|Updater \(|GoodGame|TotalAV|QScan System-Check|Ask Shopping Toolbar|VLC Plus Player|Torrent Streamer Plugin|PC Cleaner|WebExplorer|Desktopicon amazon|DreamTrips|StartHi uninstall|ScrSnap|Emoticons Mail|SAntivirus|DriverUpdate|Happy Lyrics|Malware Crusher|Web Updater version|PCKeeper Antivirus|PC Driver Kit|GIMP Updater|Segurazo |VLC Update|Secured Yahoo Powered|WhiteClick|Jetzt Konvertieren|SSOption|PC Privacy Protect|Up Pro version|cleanComputerNew|bestDownloader|TigerTrade Setup \d|publicHotsp version \d|Multitimer version \d|FastDataX \d|PrivDog|foldershare|Wondersoft - Wonderful Weather - Enhance|SavingsC\w+|CPUID CPU-Z(?!.+Inc\.)|NativeDesktopMediaService|Mp3tagApp3|Qweb Symbol|Main Services|My System Mechanic|OpenOffice Updater|Websuche |CCleaner.+n: 5.33 -|CpuzApp4|AnyDeskApp|Novo Optimizer|SearchAwesome|Screen Capture \d|pchandller|Driver Updater Plus|CloudNet |setupsk |Yahoo!? Powered|vSnapshot|Search the Web|YAC |MoneyFriend|SwytShop|AlphaGo|Video and Audio Plugin UBar|ScreenUp|CloudExtender|Amigo|PcRegBoost|Fix It|Vertech|WeatherBuddy|VAB Downloader|BeansPlayer|GlobalWeather|NotepadPlusPlusApp|deskapp |DragonBoost|s5m |MaxInternet)" )
			$ATTEN = " <==== " & $UPD1
		Case StringRegExp ( $LINE , "(?i)^(?:AdvancedModule|WindowsTM|isMiner|amulesw|ScreenMaker|BikaQ|VidsqaurE|MarvelSound |Zaxar Games Browser|WinSnare|Security Reviver|TablacusApp|Teoma Media Search|PPC-software|Video Box|WikiZ|MyMemory|InterStat |EZSearch|amuleC|cleaner \d\.|Screenshot Pro|Advanced.PC.Care|REOptimizer|Driver (Store|Support)|AppHelper|My Web Shield|SunnyDay|AppTrailers|SrpnFiles|Window Common Manager|System Broker version|SPCoptimizer |ns \(|PC Speed Up|Sale Calendar|PDF2HTML|nerta|BandwidthStat|BlazingFun|Get.?a.?Clip|2048 \d.00|SKuaiZip|StreamOptimizer|HDWallPaper|Itibiti RTC|Faster Web|AdVPN|HPSewil|GameLauncher \(|ContentPush|AdsToolBar|OtherSearch|mpck |EasyHotspot|NetStream|SSLOptimizer|wardmain|FastCompress|UmmyVideoDownloade|Booking.com version|Tv-Plug-In|Browser.Security|Translate Mgr|NotepadApp|MPC Cleaner|MaohaWiFi|Books Downloader version|iPumper|Host Service|Checkers|TTWiFi|AdSkip|anote|Compress \(|||Uncheckit|Sound\+|Max-Start|Hola |Weather.?Chickn|Social2Search|Popcorn Time|Buzzing Dhol|UC|WinZip Malware|mysites123|CleanBrowser|ByteFence|Amazon (1Button|Assistant)|System.?Healer|TomorrowGames|NowUSeeIt Player|Note-up |Network Secured DNS|groover|ArcadeTwist|QuickSearch |BrowserAir|vGrabber|I Want This|Sparta |yoursearching uninstall|Search Provided by Yahoo|MixVideoPlayer|RinoReader|One.?System.?Care|DarkEra \(HKU|DailyWiki|s5mark|save serp now|Search.?Module)" )
			$ATTEN = " <==== " & $UPD1
		Case StringRegExp ( $LINE , "(?i)- Vondos.+GmbH|Pokki|UCBrowser|Kometa( LCC|\))|503CA94E-0834-4CEE-AD92-BA17AF4E809A|d35e5e88-e5b8-447f-b6f4-66bc7aa638d1|1fd06d23-1810-464b-b9c5-b92c28776962|CrimeWatch|TidyNetwork|215 Apps\)|c8730ca5-3f82-41cc-65e2-01b87600cd89|1e578da5-a7c9-479c-c72b-3ddc74a54243|74f1e872-8d6f-4cc7-58d6-c60d8dfe43ed|Taiwan Shui Mu Chih Ching Technology Limited|\\{29007E8C-251B-4F61-A70E-635.*?_is\d|([a-z]{32}) \(HKU.+\\\1\) \(Version:\s+-\s+\)|Installer Technology|JiSuZip|YeaDesktop|Oasgames, Inc|376CA350-6C34-4F10-B8DC-586F8CA03009|A0275D4F-FFAB-4A42-9874-B871B1C4CA3D|CatalinaGroup|C87BD92A-FDDE-42C5-84F7-5159BEC08A01|WebOptimum|\\\wSPackage\)|ScreenShared|pccleanplus|MailRuUpdater|Systweak|startfenster|fd13f4a2-b0d8-4cad-9ccf-d4128eaf25ff|Microleaves|SimpleNotepad\d+|Malware Protection Live|KMPFaster|LuDaShi|AnonymizerGadget|Music.?Manager version| - Company Inc\.\)" )
			$ATTEN = " <==== " & $UPD1
		Case StringRegExp ( $LINE , "(?i)Gold Click Ltd|Itibiti|Freeze.com|USBBoxLite|\\PPTAssist|\(Version: 1.0.0.0 - "" ""\)|Uniblue Systems Limited|CMI Limited|Winzipper|A428B273-73B2-E11F-895C-669BA9344EE5|2AEF02C3-?5159-?4C81-?A688-?8D954F0DEE56|weatther|2F4B8122-4BD2-43A9-9F18-571BE0D29C7C|yessearches|iBryte|29633E53-BF13-41B5-9E10-19D7843BD9C3|^The Desktop Weather|61FFE1F9-137D-4c31-A181-3415FCAA5946|^SpaceSoundPro|\\5\)|\\WarThunder|^aion.+ - aion\)|\\zz\..+ - CSDI|^Fast.?Search|^SafeFinder|QQBrowser|IQIYI Video|\\GeePlayer|^oursurfing|6A128791-4857-4484-9BB2-71D4C1257200|D9BAB2C9-5236-48c3-AF02-67E799F09BBD|C09D747A-BD47-42A9-915E-CEB6B1BB7C11|^Max.?Driver.?Updater|^Friendly Error|\\SoftwareUpdater|\\PopupProduct|^Web.?Protector|^LiveUpdateWPP|^WordWizard|^MyBrowser|^jogotempo|7ADF667E-E14D-4D2C-827C-B0108F0D93BC|\\\w{3,}_[a-z]{2}_\d+_is1\) \(Version:\s+- ([a-z-\d]+|)\)|^eShield Browser Security|^SeeWords|^WordAnchor|6F6A5334-78E9-4D9B-8182-8B41EA8C39EF|^Boost \(|^I - Cinema|^Com Notification|^DesktopSearch|^Web Shield|^WinThruste|^PhraseProfesso|^omniboxes uninstall|^HQCinema Pro|^DNS Unlocker|^Cassiopesa|^free-4-pc bundle|^adblocker |^WordShark |^WindeskWinsearch|^shopperz|^RapidMediaConverter|^News Alert|^MaxComputerCleaner|^GUPlayer|^CPlus\.|Kromtech|F679D2F0-CE91-93C8-BD2D-062DF04DA0C1|214E251B-BF42-BF18-588C-42DA92658DB4|^BrowserV|^FlashGamesRockstar|^Games Bot|^Infonaut \d|06B99631-BFA2-3B7A-F58B-D067C2BA59B7|2395B860-45E4-42fd-96E6-50BA597C1C42|^Run_Dregol|4820778D-AB0D-6D18-C316-52A6A0E1D507|9D9BEFAE-9499-F52B-6CC4-94818CCC2AB5" )
			$ATTEN = " <==== " & $UPD1
		Case StringRegExp ( $LINE , "(?i)3112BDB8-7DB9-279D-EC5F-30BC1ABC266C|4F524A2D-5354-2D53-5045-A758B70C1C01|95AD5CB7-B9DA-C55D-9107-1B7B2346169F|36BA0E82-2B7D-79E6-9AC9-572294FDA2BB|D238A788-39B6-B97D-A5BA-13FE8E34E03C|53B21E29-3967-C332-57EB-C02631658584|F4D73F4A-21B8-E2D9-F41C-5588F0799B3C|E7AAE895-0690-E160-BAF2-2646BA3DE9F6|A5A8BEFB-ACE9-1A21-C178-51D86182FB16|CBD4D84E-ED1E-D519-C81F-8DE8E6E561DF|7BE66183-98C0-B71F-FF97-9E1CAABBF113|89182668-89F3-2E6B-C6ED-760879E0A25A|2349E803-9B10-7B83-C1CB-9C9F16739F60|C69321CD-CF34-49BD-576F-2CD9E1E03492|E599C983-3397-8338-16C0-A5C5B8C7D1FE|1C60D9BB-E5C5-3DEB-97E7-57505435E501|6EDB1653-9585-8A7A-8C61-F6D9ADC0491E|2F5E93AA-9D8C-AE4D-C794-7F0633216558|9B149088-3FB6-875E-C1A4-A25A6E9D278D|F04D4328-4631-1CBE-1907-201B33FAF2E8|D0DBE908-5DE8-3DF3-83C9-01620C65816F|65886F9B-214B-530F-E4EA-7565AFF6DE8D|B10BC31B-DBC6-56FE-DD3D-DD4E49A3E6CE|94851E46-5E5B-DD67-2593-709E8D27DC4C|F7FFE175-E3D6-2E86-0226-1D3AE4905E40|CC17A332-9555-AD95-3985-0BDD9BF0EC71|5F488658-35A7-2AB8-A756-560BA8F103C3|4C7D64C8-5315-C07C-FF38-7BE555411213|830DC6A6-5B68-828C-7633-B5C15EFA8BD6|9BC500CF-4965-341C-26BD-321A1C30BDD8|25AAE41B-C7A6-D04E-BABC-2D1B0D1DF4B0|E104A7D1-8E82-C1BE-AC54-71B85146658D|7D367FDF-8E9F-EE67-25C5-ECABBBAD5692|96CA71FF-122E-97A7-1D4F-F986889CA854|98275A18-3FCB-AD3A-81AC-E29858C2ED53|439763FF-59EC-FF1D-B0B5-CB9E213A7A5C|D5314663-3E59-BDB8-2150-E72C9107C551|7BCAC0EB-3993-2416-0531-848C39DF8B65|15BFA1EF-4B89-F075-6B00-0B4EAD6EFA43|EB0033B6-A734-7BFF-72E7-A3910B2566B5|8348C1F2-1FE8-EADF-5C76-34B0728A3FBC|CB59E2C0-06A6-D3B1-5C99-240E857075D2|558295F0-DEC2-66EC-3830-04777EF7DA33|E597EF89-D3DF-7708-E392-3D9C87CAB1AA" )
			$ATTEN = " <==== " & $UPD1
		Case StringRegExp ( $LINE , "(?i)^Pro PC Cleaner|^Search Module Plus|eeb86aef-4a5d-4b75-9d74-f16d438fc286|^SecurityUtility|^Dragon Branch|^SSN \(|^TermBlazer|^SanctionedMedia|\\QQPCMgr|\\Torrent Search|^Distributed Computing|^CurrencyShow|Cinema.?Plus|^System Optimizer|^ContinueToSave|^Lenovo Browser|^Glass Bottle|^boost.?web.?app|^YTDownloader|^globalupdate Helper|^Ge-Force \(|^Sale Charger|WajaInternetEnhance|3F7D597C-7512-F73C-B0F3-5D711BC91948|82E6757E-96A1-B10D-0D62-4AE87161572A|^Express Find|23497AFC-382C-417E-AC1F-42D98A5A8ADA|B696F285-F54E-2524-58B1-E06A70ABE6BE|3D0F43D9-C1D7-733C-01F8-4A3001BF8CC3|75F9BF4A-AF67-A478-A37B-31D73186D3F3|5081D2D4-1637-404c-B74F-50526718257D|7223EDAC-E091-B3C1-BD91-B66CE557800F|11F6D5AB-263F-388E-74DE-E3DECD390E3F|C637A71C-A4B2-4B47-1B2A-1042A8D525A3|8E8C2E2D-7F21-2CF5-0ADB-64935121ECF0|CA1838EF-A497-194E-3850-37A62CEE398B|A2616871-3463-BCEE-5AFA-73773317A381|594FD08C-0622-F9B8-CB02-7C1355D33CB8|478472F9-9E09-492A-BDAB-42EE595EF1AD|2D471A31-4FA7-95BA-1880-D441113ED736|78B72F2B-0468-A7AC-ECEE-02C79EC3EF0B|crrUnisntlDsply|DiscountFrenzy|^fR[aeio]+Delivery|^g+o+d+choice|681002C6-5019-81A2-7871-A43754F71E56|842C4394-47F7-60DE-480B-C09116B63559|6933C2BA-C67D-42C7-8C77-1FF4B364AF54|^XTab|C60D3D4E-3B20-5AB3-7F2C-9C946AD4080F|5CDF2354-26AF-2DBC-1012-44FEDFCC75BB|^Super Optimizer|^SuperPlusRadio|^PC Helper|^RewardsArcade|^Your Software Deals|730C1F02-ABB6-7601-60ED-659A59700742|66951628-3E5A-9C96-37EA-490E187974D5" )
			$ATTEN = " <==== " & $UPD1
		Case StringRegExp ( $LINE , "(?i)^(Dead Surf|TunesBarre|System Notifier|LolliScan|mintcas|OBRONA Cleaner|WikiBrowser|UpdateAdmin|NetMon |Tiny Download Manager|Quick Ref |Improved Search|HD Cinema.?Pro|HD.?Cinema|GoHDV|Genieo|BetterDeals|PC Speed Maximizer|Movie Mode|iRobinHood Partners|Context2pro|SkypeFall|Roll Around|CYF version|Doctor PC|do-search|Ace Stream Media|Software Management Module|BingProtect|UpdateAdmin|VK Downloader|Torrent Search|SpeedTray|ZenSearch|Webgameplay setup|SaferBrowser|tAkEshop|takesaVe|RegCure Pro|TheSettlersOnline |Smart File Advisor|Registry Dr|key.?find uninstall|Instant PC Optimizer|Web Bar \d|speed browser|Price.?Horse|PastaQuotes|Disasteroids|deal4real|Binkiland|WSE_Binkiland|WSE_Taplika|Taplika|StormWatch|StormFall|Pirates \(|MedPLyerV|MagnoPlayer|Gameo|ContextTrue|BubbleSound|RapidywebIE|Spyware Clear|Positive Finds|GoodGameEmpire|CinPl2|IGS |igsc |Health Alert|HDtubeV|FlashBeat|Vosteran|Strong Signal|PriceFountain|WorldofTanks|Shop to Win|getsav-in|allsearch|WebInternetSecurity|DiscountFrenzy|AppCloudUpdater|AppSafe|Pagealicious|Object Browser|Speedial|Rocket (?!Knight|League)|bSaving|WSE Rocket |SaveDailyDeals|WSE_Astromenda|Groovorio|UnknownFile|RocketTab|Term Tutor|Mezaa|LookThisUp|Radio Canyon|PennyBee|SimilarSites|OfferBoulevard|Techgile|Flowsurf|WSE_Lasaoren|Salus|HD-Quality-v4V01.10|WSE_Vosteran|InetStat|Internet program)" )
			$ATTEN = " <==== " & $UPD1
		Case StringRegExp ( $LINE , "(?i)\\WinCheck|^Social Privacy DNS|^BroAppVersion|^Zombie .+Solutions|4CEE92A3-9F0C-51AB-ADC0-34EC24AD7B7E|AD11DADE-C597-45D9-D8C5-1D2EB0B89613|^Superfish Inc. VisualDiscovery|^SpeedCheck|5B0CE14A-B9B6-4E25-A1BE-3EEC1998AC2C|C448EA30-BB7F-4D42-83BC-385EBA140AF2|^MaxiGet Software Manager|^Browsers\+|^Super Radio|^YouTube Accelerator|^VooUpdate|^foxydeal|^EpicScale Application|^Converter Free|^Consumer Input|^Softonic Assistant|^PriceLuess|^TornPlus|^sensePlus|^Games.?desktop|^Selection Tools|29633E53-BF13-41B5-9E10-19D7843BD9C3|^eDeals |^TextEdit .+Hesselberg Consulting|76DEE3DC-2B8B-E212-2126-D31D9E73DFE4|^Storm.?Alert|^PennyBee|^Fabulous discounts|^vi-view uninstall|^CinePlus|12DA0E6F-5543-440C-BAA2-28BF01070AFA|7E7FAE3D-3358-D280-8DBF-E8E2D94326D1|194FED75-9C74-BDB7-53F8-8CFFEF1AFEC9|5E03DFA7-51FC-7C12-CEE5-4D75FBB01E8F|D831E399-50FE-84AE-F5F7-0A63AC282464|12DA0E6F-5543-440C-BAA2-28BF01070AFA|3119AFD3-545C-0955-573A-494F62E61990|35E0D123-1F22-9AE6-F973-B7ECA46E8BFE|FE139F4C-CE5B-121A-8A2D-191FA2226094|^VeriBrowse|SqueakyChocolate|^CinPlus|^Browsers Apps|0B500125-92A7-40BF-ACF0-45A9221ADE21|Bitcoktail|CA8C94BE-9F47-1B2E-90F8-D8C07119BD96|VidPlaya " )
			$ATTEN = " <==== " & $UPD1
		Case StringRegExp ( $LINE , "(?i)A2616871-3463-BCEE-5AFA-73773317A381|594FD08C-0622-F9B8-CB02-7C1355D33CB8|779D1843-0043-65D2-D781-8614F17B6222|^OBRONA Bloc|^Freecorder .*(Applications|extension)|^WindApp |Internet Speed Checker|OpenCandy|^BuyNsave|^OfferBLVDUpdate|Think Tank Labs|^App Lid|80E8B0A0-117D-1402-7CDE-688156237115|0F44DC3A-6E62-4961-A14B-95323C512F9B|CloudGuard|^Better.?Surf|^Foxy Secure|^TotalPlus|70BD2558-27DA-8B02-02D0-D8704ECD2EDF|10A0E600-D246-BD63-F465-4C849C688998|532970A2-464B-73CB-BBC4-F209EAD3EEBE|AE9B04F2-E9E8-162C-829B-52C116B3EFCC|^Click.?Caption|^BoBrowser|HQ-VPro|^Reimage [PR]|^GetPrivate|^Word Proser|^Winner Download Manager|^SpeeditUp|^HD-V\d|^Cinemax|614925F9-841A-53FE-A28F-DC30FA07239B|^ALOT Appbar|^GoHD |al+t+[aeiou]+b+[aeiou]+n+[aeiou]+d+s+|Probit Software L|^FastPlayer|^omiga-plus|4F6D5E84-5826-4394-9F40-3A9A19165651|^BasicScan^|DownVision|FLVM Player|^Only.?search|LADY'S WOOD \d|^QuestBasic|^Softonic for Windows|Qwiklinx|^PCSpeedUp|^YTD Video Downloader|SiteRanker|4EF645BD-65B0-4F98-AD56-D0437B7045F6|^EZ YouTube|^Driver Pro|TheFreeHD|ask Toolbar" )
			$ATTEN = " <==== " & $UPD1
		Case StringRegExp ( $LINE , "(?i)(^Update for|Packages).+\(HKU" )
			$ATTEN = " <==== " & $UPD1
		EndSelect
		$LINE = StringRegExpReplace ( $LINE , "(?i)http(s|):" , "hxxp\1:" )
		FileWrite ( $HADDITION , $LINE & $ATTEN & @CRLF )
	Next
	If UBound ( $CHROMEAPPS ) > 1 Then
		FileWrite ( $HADDITION , @CRLF & "Chrome apps:" & @CRLF & "============" & @CRLF )
		_ARRAYDELETE ( $CHROMEAPPS , 0 )
		$CHROMEAPPS = _ARRAYUNIQUE ( $CHROMEAPPS , 0 , 0 , 0 , 0 , 1 )
		_ARRAYSORT ( $CHROMEAPPS , 0 )
		_FILEWRITEFROMARRAY ( $HADDITION , $CHROMEAPPS , 0 )
	EndIf
	_AAAAP1 ( )
EndFunc
Func _AAAAP1 ( )
	$KEY = "HKCR\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppModel\Repository\Packages"
	$HKEY = _REGOPENKEYEX3 ( $KEY )
	If @error Or Not IsPtr ( $HKEY ) Then Return
	Local $ARRPACK [ 1 ]
	$E = + 4294967295
	While 1
		$E += 1
		$SUB = __REGENUMKEY ( $HKEY , $E )
		If @error Then ExitLoop
		$PRF = RegRead ( $KEY & "\" & $SUB , "PackageRootFolder" )
		If Not FileExists ( $PRF ) Then ContinueLoop
		If FileExists ( $PRF & "\" & "AppxManifest.xml" ) Then
			$READ = FileRead ( $PRF & "\" & "AppxManifest.xml" )
		Else
			$ARRAY = _FILELISTTOARRAYREC ( $PRF , "*.msix" , 1 , 0 , 0 , 2 )
			$READ = ""
			If UBound ( $ARRAY ) > 1 Then
				$COUNT = Random ( 100 , 999 , 1 )
				$PATH = @TempDir & "\xml" & $COUNT & ".txt"
				$ZIP = @TempDir & "\" & $COUNT & "tmp.zip"
				$HXML = FileOpen ( $PATH , 2 + 256 )
				FileCopy ( $ARRAY [ 1 ] , $ZIP , 1 + 8 )
				$RET = UNZIP_SAVEFILETOFILEONCE ( $ZIP , "AppxManifest.xml" , "" )
				If $RET Then FileWrite ( $HXML , $RET )
				$READ = FileRead ( $PATH )
				FileClose ( $HXML )
				FileDelete ( $PATH )
				FileDelete ( $ZIP )
			EndIf
		EndIf
		$DEP = ""
		If StringRegExp ( $READ , "(?i)PackageDependency Name=""Microsoft.Advertising" ) Or FileExists ( $PRF & "\Microsoft.Advertising" ) Or FileExists ( $PRF & "\MSAdvertisingJS" ) Then $DEP = " [MS Ad]"
		If StringRegExp ( $READ , "(?i)(desktop|uap5):StartupTask" ) Then
			If StringRegExp ( $SUB , "(?i)^(MSTeams|Microsoft\.?(MicrosoftOfficeHub|PowerAutomateDesktop|StartExperiencesApp|Todos|Teams|WindowsTerminal|YourPhone|549981C3F5F10|GamingApp))_(\d+\.)+\d+(_x\d+)*(_neutral)*_+8wekyb3d8bbwe" ) Then ContinueLoop
			If StringRegExp ( $SUB , "(?i)^Microsoft.SkypeApp_(\d+\.)+\d+(_x\d+)*__kzf8qxf38zg5c" ) Then ContinueLoop
			If StringRegExp ( $SUB , "(?i)^MicrosoftWindows.CrossDevice_(\d+\.)+\d+(_x\d+)*_+cw5n1h2txyewy" ) Then ContinueLoop
			$DEP &= " [Startup Task]"
		EndIf
		If Not $DEP Then
			If StringRegExp ( $SUB , "(?i)^((WhatsNew|WebAuthBridgeIntranetSso|WebAuthBridgeInternetSso|WebAuthBridgeInternet|RoomAdjustment|Passthrough|MixedRealityLearning|EnvironmentsApp|DesktopLearning|HoloItemPlayerApp|HoloCamera|DesktopView|HoloShell|CortanaListenUIApp|winstore|SonicWALL.MobileConnect|JuniperNetworks.JunosPulseVpn|FileManager|f5.vpn.client|CheckPoint.VPN|InputApp|1527c705-839a-4832-9118-54d4Bd6a0c89|c5e2524a-ea46-4f67-841f-6a9465d9d515|E2A4F912-2574-4A75-9BB0-0D023378592B|F46D4000-FD22-4DB4-AC8E-4E1DDDE828FE|Microsoft.?(Windows.CrossDevice|Windows.LKG.(DesktopSpotlight|RulesEngine|SpeechRuntime|TwinSxS|AccountsService|IrisService)|Windows.Client.(Photon|OOBE|AIX|FileExp|CBS|WebExperience)|EdgeDevtoolsPlugin|XboxIdentityProvider|WindowsFeedback|MoCamera|PPIProjection|Win32WebViewHost|Windows.(UndockedDevKit|OOBENetwork(CaptivePortal|ConnectionFlow)|DevicesFlowHost|Search|Client.Core|PrintQueueActionCenter|StartMenuExperienceHost|CallingShellApp|WindowPicker|ModalSharePickerHost|HolographicFirstRun|SecondaryTileExperience|SecureAssessmentBrowser|ContentDeliveryManager|PeopleExperienceHost|XGpuEjectDialog|ParentalControls|ShellExperienceHost|AssignedAccessLockApp|CloudExperienceHost|Apprep.ChxApp|CapturePicker|Cortana)|AccountsControl|BioEnrollment|CredDialogHost|LockApp|AAD.BrokerPlugin|XboxGameCallableUI|Windows.PinningConfirmationDialog|Windows.SecHealthUI)|Windows.(PurchaseDialog|devicesflow|CBSPreview|immersivecontrolpanel|PrintDialog|MiracastView|ContactSupport))_(\d+\.)+\d+(.+)*(_neutral)*_+cw5n1h2txyewy)$" ) Then ContinueLoop
			If StringRegExp ( $SUB , "(?i)^(NcsiUwpApp|Microsoft.?(WidgetsPlatformRuntime|MPEG2VideoExtension|Copilot|BingSearch|AVCEncoderVideoExtension|AV1VideoExtension|ApplicationCompatibilityEnhancements|OutlookForWindows|549981C3F5F10|Winget.source|CorporationII.(QuickAssist|WindowsSubsystemForLinux)|RawImageExtension|Todos|SecHealthUI|PowerAutomateDesktop|OneDriveSync|GamingApp|WindowsNotepad|UI.Xaml.CBS|Paint|YourPhone|ZuneVideo|DirectXRuntime|GamingServices|Microsoft|BingNews|WindowsMixedRealityRuntimeApp|WindowsMixedReality.Runtime|360Viewer|MicrosoftSolitaireCollection|BingWeather|BingSports|BingFinance|XboxCompanion|TranslatorforMicrosoftEdge|XboxLIVEGames|Reader|Media.PlayReadyClient|HelpAndTips|BingFoodAndDrink|BingHealthAndFitness|BingTravel|BingMaps|LanguageExperiencePack\w+-\w+|ZuneMusic|XboxSpeechToTextOverlay|XboxIdentityProvider|XboxGamingOverlay|XboxGameOverlay|XboxApp|Xbox.TCUI|3DBuilder|MicrosoftEdgeDevToolsClient|Windows.NarratorQuickStart|Appconnector|AsyncTextService|HEIFImageExtension|HEVCVideoExtension|Messaging|MicrosoftEdge(|.stable)|MicrosoftOfficeHub|MicrosoftStickyNotes|ConnectivityStore|DesktopAppInstaller|ECApp|GetHelp|Getstarted|Microsoft3DViewer|MixedReality.Portal|MSPaint|NET.Native.Framework.\d.\d|NET.Native.Runtime.\d.\d|Office.OneNote|Office.Sway|OneConnect|People|Print3D|ScreenSketch|Services.Store.Engagement|StorePurchaseApp|UI.Xaml.\d.\d|VCLibs(.\d+)+.(UWPDesktop|Preview|Universal)*|WinJS.\d.\d|VP9VideoExtensions|Wallet|WebMediaExtensions|WebpImageExtension|Windows(.AugLoop.CBS|AppRuntime(|.CBS)|communicationsapps|ReadingList|Scan|.Photos|.SecHealthUI|Alarms|Calculator|Camera|FeedbackHub|Maps|SoundRecorder|Store|.Ai.Copilot.Provider|.DevHome)))(.\d)*_(\d+\.)+\d+(.+)*(_neutral)*_+8wekyb3d8bbwe$" ) Then ContinueLoop
			If StringRegExp ( $SUB , "(?i)^Clipchamp.Clipchamp_(\d+\.)+\d+_neutral__yxz26nhyzhsrt" ) Then ContinueLoop
		EndIf
		$DATECR = FILETIMECM ( $PRF )
		If Not $DATECR Then $DATECR = FILETIMECM ( $PRF & "\AppxManifest.xml" )
		$DN = RegRead ( $KEY & "\" & $SUB , "DisplayName" )
		$NAME = $DN
		If StringRegExp ( $DN , "^ms-resource:" ) Then
			If RegRead ( $KEY & "\" & $SUB & "\App\Capabilities" , "ApplicationName" ) Then $DN = RegRead ( $KEY & "\" & $SUB & "\App\Capabilities" , "ApplicationName" )
		EndIf
		$PUB = ""
		If StringRegExp ( $DN , "^@" ) Then
			$RETNAME = _AAAAP11 ( $DN )
			If $RETNAME Then $NAME = $RETNAME
			If StringRegExp ( $DN , "(?i)ms-resource.+/resources/" ) Then
				$RETPUB = _AAAAP11 ( $DN , 1 )
				If $RETPUB Then $PUB = " (" & $RETPUB & ")"
			EndIf
		Else
			If StringInStr ( $NAME , "ms-resource:" ) Then $NAME = StringRegExpReplace ( $READ , "(?is).+Identity\s+Name=""([^""]+)"".+" , "$1" )
		EndIf
		If Not $PUB Then $PUB = " (" & _AAAAP12 ( $READ ) & ")"
		_ARRAYADD ( $ARRPACK , $NAME & " -> " & $PRF & " [" & $DATECR & "]" & $PUB & $DEP , 0 , "|||" )
	WEnd
	If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
	$ARRPACK = _ARRAYUNIQUE ( $ARRPACK , 0 , 0 , 0 , 0 , 1 )
	_ARRAYSORT ( $ARRPACK )
	If UBound ( $ARRPACK ) > 1 Then
		FileWrite ( $HADDITION , @CRLF & "Packages:" & @CRLF & "=========" )
		_FILEWRITEFROMARRAY ( $HADDITION , $ARRPACK , 0 )
	EndIf
EndFunc
Func _AAAAP11 ( $STR , $PUB = 0 )
	If $PUB = 1 Then
		$STR = StringRegExpReplace ( $STR , "(?i)(.+/Resources/)(.+)" , "$1PublisherDisplayName}" )
	EndIf
	$STR = _WINAPI_LOADINDIRECTSTRING ( $STR )
	If Not @error Then Return $STR
EndFunc
Func _AAAAP12 ( $READ )
	$PUBL = ""
	If StringRegExp ( $READ , "(?i)<PublisherDisplayName>[^<]*<" ) Then
		$PUBL = StringRegExpReplace ( $READ , "(?is).+<PublisherDisplayName>([^<]*)</PublisherDisplayName.+" , "$1" )
		If StringInStr ( $PUBL , "ms-resource:" ) Then $PUBL = StringRegExpReplace ( $READ , "(?is).+Publisher=.+?O=(.+?), .+" , "$1" )
	EndIf
	Return $PUBL
EndFunc
Func _AAAASB ( )
	$SYSTEMDRIVE = EnvGet ( "SystemDrive" )
	If StringInStr ( $SYSTEMDRIVE , "X:" ) And ( FileExists ( "x:\windows" ) Or FileExists ( "x:\i386" ) ) Or StringInStr ( @ScriptName , "simulateRE" ) Then
		$BOOTM = "Recovery"
		$SOFTWARE = "888"
		$SYSTEM = "999"
		$BOOTSYSTEM = "\ControlSet0"
		$C = "C:"
		$PROGRAMFILES86 = "C:\Program Files (x86)"
		$WINDOWSDIR = "C:\Windows"
		$SYSTEMDIR = $WINDOWSDIR & "\System32"
		$PROGRAMFILES = "C:\Program Files"
	Else
		$DEF = ""
		$SOFTWARE = "Software"
		$SYSTEM = "System"
		$BOOTSYSTEM = "\CurrentControlSet"
		$C = EnvGet ( "SystemDrive" )
		$PROGRAMFILES86 = EnvGet ( "ProgramFiles(x86)" )
		$WINDOWSDIR = @WindowsDir
		$SYSTEMDIR = @SystemDir
		$PROGRAMFILES = @ProgramFilesDir
		$VAL = RegRead ( "HKLM\system\currentcontrolset\control\safeboot\option" , "OptionValue" )
		Select
		Case @error = 1
			$BOOTM = "Normal"
		Case @error = 0
			If $VAL = 1 Then
				$BOOTM = "Safe Mode (minimal)"
			ElseIf $VAL = 2 Then
				$BOOTM = "Safe Mode (with Networking)"
			Else
				$BOOTM = "Normal"
			EndIf
		EndSelect
	EndIf
	$WINDOWSDIR86 = $WINDOWSDIR & "\SysWOW64"
EndFunc
Func _AAAASHC ( )
	GUICtrlSetData ( $LABEL1 , $SCANB & " " & $SHORT1 & "... " )
	Global $ARRAYSHORTC [ 1 ] = [ @CRLF ]
	Global $ARRAYSHORTCU [ 1 ] = [ @CRLF ]
	Global $ARRAYSHORTCW [ 1 ] = [ @CRLF ]
	Global $ARRAYSHORTCWU [ 1 ] = [ @CRLF ]
	Global $ARRAYURL [ 1 ] = [ @CRLF ]
	Global $LAYOUT [ 1 ] = [ @CRLF ]
	For $P = 1 To UBound ( $ALLUSERS ) + 4294967295
		_AAAASHCLIST ( $ALLUSERS [ $P ] )
	Next
	$HLOG = FileOpen ( @ScriptDir & "\Shortcut.txt" , 2 + 256 )
	$CDATE = DATE ( )
	FileWrite ( $HLOG , $USCANR & $VERSION & @CRLF & $SCAN11 & " " & "" & @UserName & " (" & $CDATE & ")" & @CRLF & $SCAN13 & " " & @ScriptDir & @CRLF & $SCAN15 & ": " & $BOOTM & @CRLF & @CRLF & "==================== " & $SHORT1 & " =============================" & @CRLF & @CRLF & "(" & $SHORT2 & ".)" & @CRLF )
	If UBound ( $ARRAYSHORTCU ) > 1 Then _FILEWRITEFROMARRAY ( $HLOG , $ARRAYSHORTCU )
	If UBound ( $ARRAYSHORTC ) > 1 Then _FILEWRITEFROMARRAY ( $HLOG , $ARRAYSHORTC )
	If UBound ( $ARRAYSHORTCWU ) > 1 Then _FILEWRITEFROMARRAY ( $HLOG , $ARRAYSHORTCWU )
	If UBound ( $ARRAYSHORTCW ) > 1 Then _FILEWRITEFROMARRAY ( $HLOG , $ARRAYSHORTCW )
	If UBound ( $ARRAYURL ) > 1 Then _FILEWRITEFROMARRAY ( $HLOG , $ARRAYURL )
	If UBound ( $LAYOUT ) > 1 Then _FILEWRITEFROMARRAY ( $HLOG , $LAYOUT )
	FileWrite ( $HLOG , @CRLF & "==================== " & $END & " " & $OF2 & " Shortcut.txt" & " =============================" & @CRLF )
	FileClose ( $HLOG )
	$ARRAYSHORTC = ""
	$ARRAYSHORTCU = ""
	$ARRAYSHORTCW = ""
	$ARRAYSHORTCWU = ""
	$ARRAYURL = ""
	$LAYOUT = ""
EndFunc
Func _AAAASHCLIST ( $PATH1 )
	Local $ARGUMENT , $COMP , $ARR , $TARGET
	$ARR = _FILELISTTOARRAYREC ( $PATH1 , "*.lnk;*.url;*.website||*temp*;All Users;recent;*cache;Ostatnie;history" , 1 + 16 , 1 , 0 , 2 )
	For $S = 1 To UBound ( $ARR ) + 4294967295
		If StringRegExp ( $ARR [ $S ] , "(?i)\.(url|website)$" ) Then
			$ARGUMENT = _GETURL ( $ARR [ $S ] )
			$ARGUMENT = StringRegExpReplace ( $ARGUMENT , "(?i)http(s|):" , "hxxp\1:" )
			_ARRAYADD ( $ARRAYURL , "InternetURL: " & $ARR [ $S ] & " -> " & $ARGUMENT , 0 , "||||" )
		Else
			$SHORTC = FileGetShortcut ( $ARR [ $S ] )
			If IsArray ( $SHORTC ) Then
				$TARGET = ""
				$PATH = $SHORTC [ 0 ]
				If $SHORTC [ 2 ] <> "" Then
					$TARGET = " -> " & $SHORTC [ 2 ]
					$TARGET = StringRegExpReplace ( $TARGET , "(?i)http(s|):" , "hxxp\1:" )
				EndIf
				Select
				Case $PATH
				Case UBound ( $SHORTC ) > 4 And StringRegExp ( $SHORTC [ 4 ] , "(?i)(%[a-z]+%|[c-z]:)\\|\.exe|\.dll" )
					$PATH = $SHORTC [ 4 ]
					$PATH = _EXPAND ( $PATH )
			Case Else
					$HREAD = FileOpen ( $ARR [ $S ] , 16 )
					$PATH = FileRead ( $HREAD )
					FileClose ( $HREAD )
					$PATH = _AAAASHCLISTPATH ( $PATH , $ARR [ $S ] )
				EndSelect
				$PATH = FileGetLongName ( $PATH )
				If StringRegExp ( $PATH , ":\\Users\\" & $USERNAME & "\\" ) And StringRegExp ( $ARR [ $S ] , ":\\Users\\" ) And Not StringRegExp ( $ARR [ $S ] , ":\\Users\\" & $USERNAME & "\\" ) Then
					$AUSER = StringRegExpReplace ( $PATH1 , ".:\\[^\\]+\\(.+)" , "$1" )
					$SID = _SECURITY__LOOKUPACCOUNTNAME ( @ComputerName & "\" & $AUSER )
					If IsArray ( $SID ) Then $PATH = StringRegExpReplace ( $PATH , ":\\([^\\]+)\\[^\\]+\\" , ":\\$1\\" & $AUSER & "\\" )
				EndIf
				If FileExists ( $PATH ) Then
					$COMP = FileGetVersion ( $PATH , "CompanyName" )
					$COMP = StringRegExpReplace ( $COMP , "(?i)http(s|):" , "hxxp\1:" )
					If $TARGET = "" Then
						If StringRegExp ( $PATH , "(?i)\\\w+?\.bat|Program Files(| \(x86\))\\Firefox" ) Then
							_ARRAYADD ( $ARRAYSHORTCU , "Shortcut: " & $ARR [ $S ] & " -> " & $PATH & " (" & $COMP & ")" , 0 , "||||" )
						Else
							_ARRAYADD ( $ARRAYSHORTC , "Shortcut: " & $ARR [ $S ] & " -> " & $PATH & " (" & $COMP & ")" , 0 , "||||" )
						EndIf
					Else
						If StringRegExp ( $TARGET , "(?i)(hxxp:|www\.|\\\w+?\.bat|%sn(f|p)%)" ) Then
							_ARRAYADD ( $ARRAYSHORTCWU , "ShortcutWithArgument: " & $ARR [ $S ] & " -> " & $PATH & " (" & $COMP & ")" & $TARGET , 0 , "||||" )
						Else
							_ARRAYADD ( $ARRAYSHORTCW , "ShortcutWithArgument: " & $ARR [ $S ] & " -> " & $PATH & " (" & $COMP & ")" & $TARGET , 0 , "||||" )
						EndIf
					EndIf
				Else
					$NOF = ""
					If StringRegExp ( $PATH , "(?i)[c-z]:\\" ) And Not StringRegExp ( $PATH , "(?i)hxxp(|s):|explorer.exe,-" ) Then $NOF = " (" & $REGIST8 & ")"
					If StringRegExp ( $PATH , "(?i)\\\w+?\.bat|hxxp:|www\.|Program Files(| \(x86\))\\Firefox" ) Then
						_ARRAYADD ( $ARRAYSHORTCU , "Shortcut: " & $ARR [ $S ] & " -> " & $PATH & $NOF , 0 , "||||" )
					Else
						_ARRAYADD ( $ARRAYSHORTC , "Shortcut: " & $ARR [ $S ] & " -> " & $PATH & $NOF , 0 , "||||" )
					EndIf
				EndIf
			Else
				$HREAD = FileOpen ( $ARR [ $S ] , 16 )
				$PATH = FileRead ( $HREAD )
				FileClose ( $HREAD )
				$PATH = _AAAASHCLISTPATH ( $PATH , $ARR [ $S ] )
				_ARRAYADD ( $ARRAYSHORTC , "Shortcut: " & $ARR [ $S ] & " -> " & $PATH , 0 , "||||" )
			EndIf
		EndIf
	Next
	$PATH = $PATH1 & "\AppData\Local\Microsoft\Windows\Shell\LayoutModification.xml"
	$OLAY = FileOpen ( $PATH , 256 )
	$READ = FileRead ( $OLAY )
	FileClose ( $OLAY )
	If Not StringRegExp ( $READ , "<taskbar:TaskbarPinList>" ) Then Return
	$LINEARRAY = StringRegExp ( $READ , "(taskbar:(?:DesktopApp DesktopApplicationLinkPath|UWA AppUserModelID)=[^>]+)\s*/>" , 3 )
	If Not IsArray ( $LINEARRAY ) Then Return
	$LINEARRAY = _ARRAYUNIQUE ( $LINEARRAY , 0 , 0 , 0 , 0 , 1 )
	_ARRAYADD ( $LAYOUT , $PATH & ":" , 0 , "||||" )
	_ARRAYCONCATENATE ( $LAYOUT , $LINEARRAY )
	_ARRAYADD ( $LAYOUT , @CRLF )
EndFunc
Func _AAAASHCLISTPATH ( $PATH1 , $PATH2 )
	$PATHX = $PATH1
	If Not StringRegExp ( $PATHX , "^0x[A-Z0-9]+" ) Then
		$PATHX = StringToBinary ( $PATHX )
		$PATHX = StringRegExpReplace ( $PATHX , "[^x][^x]\K" , "00" )
	EndIf
	Select
	Case StringRegExp ( $PATHX , "00[46]800[57]400[57]400[57]0003A00" )
		$PATHX = StringRegExpReplace ( $PATHX , ".+([46]800[57]400[57]400[57]000(:?[57]300|)3A00(?:\w\w)+?)00[0189A-Z]\w00.*" , "$1" )
		$PATHX = _UNITOST ( $PATHX )
		$PATHX = StringRegExpReplace ( $PATHX , "(?i)http(s|):" , "hxxp\1:" )
		If Not StringRegExp ( $PATHX , "hxxps?:" ) Then $PATHX = StringRegExpReplace ( $PATHX , "\S(.:\\)" , " $1" )
		$PATHX = StringRegExpReplace ( $PATHX , "\\\($" , "\\" )
		Return $PATHX
	Case StringRegExp ( $PATHX , "002500([4567][0-9A-F]00)+2500" )
		$PATHX = StringRegExpReplace ( $PATHX , ".+(2500(?:[4567][0-9A-F]00)+2500(?:\w\w)+?)00[0189A-Z]\w00.*" , "$1" )
		$PATHX = _UNITOST ( $PATHX )
		$PATHX = _EXPAND ( $PATHX )
		Return $PATHX
	Case StringRegExp ( $PATHX , "4D006900630072006F0073006F00660074002E00570069006E0064006F00770073002E0048006F006D006500670072006F00750070" )
		$PATHX = "Microsoft.Windows.Homegroup"
		Return $PATHX
	Case StringRegExp ( $PATHX , "(410073007300650074007300|00[64]9006D00610067006500).+2E0070006E006700" )
		$PATHX = "Tile and icon assets"
		Return $PATHX
	Case StringRegExp ( $PATHX , "4D006900630072006F0073006F00660074002E00570069006E0064006F00770073002E004E006500740077006F0072006B" )
		$PATHX = "Microsoft.Windows.Network"
		Return $PATHX
	Case StringRegExp ( $PATHX , "430061006E006400790043007200750073006800" )
		$PATHX = "CandyCrushSodaSaga"
		Return $PATHX
	EndSelect
	$PATH1 = StringRegExpReplace ( $PATH1 , "\S(.:\\)" , " $1" )
	$HPATH2 = FileOpen ( $PATH2 , 256 )
	$READ = FileRead ( $HPATH2 )
	FileClose ( $HPATH2 )
	$PATH1 = _UNITOST2 ( _STRTOUN ( $READ ) )
	$SHORTC = FileGetShortcut ( $PATH2 )
	$PATH1 = StringRegExpReplace ( $PATH1 , ".*(::{22877A6D-37A1-461A-91B0-DBDA5AAEBC99}).*" , "\1" )
	Select
	Case UBound ( $SHORTC ) > 2 And $SHORTC [ 1 ]
		$PATH1 = $SHORTC [ 1 ]
		$PATH1 = StringRegExpReplace ( $PATH1 , "(?i)http(s|):" , "hxxp\1:" )
	Case StringRegExp ( $PATH1 , "(?i)System Folder|systeemmap|Folder system" )
		$PATH1 = "System Folder"
Case Else
		$PATH1 = StringRegExpReplace ( $PATH1 , ".*(::{22877A6D-37A1-461A-91B0-DBDA5AAEBC99}).*" , "\1" )
		If $PATH1 Then $PATH1 = "[" & $PATH1 & "]"
	EndSelect
	Return $PATH1
EndFunc
Func _AAAASHCLISTU ( $PATH1 , ByRef $SHORTCU , ByRef $SHORTCWU , $SUB = "" )
	If Not FileExists ( $PATH1 ) Then Return
	Local $ARGUMENT , $COMP , $ARR , $TARGET
	If StringRegExp ( $PATH1 , "(?i)(ProgramData|Desktop)" ) Then
		$ARR = _FILELISTTOARRAYREC ( $PATH1 , "*.lnk" , 1 + 16 , 0 , 0 , 2 )
	Else
		$EXCL = StringRegExpReplace ( @AppDataDir , ".+\\(.+)" , ";$1" )
		If $SUB Then $EXCL = ""
		$ARR = _FILELISTTOARRAYREC ( $PATH1 , "*.lnk||Office;*temp*;All Users;recent;Recente; ;*cache;Ostatnie;GameExplorer;Niedawny;history" & $EXCL , 1 + 16 , 1 , 0 , 2 )
	EndIf
	If Not IsArray ( $ARR ) Then Return
	For $S = 1 To UBound ( $ARR ) + 4294967295
		$SHORTC = FileGetShortcut ( $ARR [ $S ] )
		If Not IsArray ( $SHORTC ) Then ContinueLoop
		$TARGET = ""
		$PATH = $SHORTC [ 0 ]
		If $SHORTC [ 2 ] <> "" Then
			$TARGET = " -> " & $SHORTC [ 2 ]
			$TARGET = StringRegExpReplace ( $TARGET , "(?i)http(s|):" , "hxxp\1:" )
		EndIf
		If Not $PATH Then
			Select
			Case UBound ( $SHORTC ) > 4 And StringRegExp ( $SHORTC [ 4 ] , "(?i)(%[a-z]+%|[c-z]:)\\|\.exe|\.dll" )
				$PATH = $SHORTC [ 4 ]
				$PATHX = _EXPAND ( $PATH )
		Case Else
				$HREAD = FileOpen ( $ARR [ $S ] , 16 )
				$PATH = FileRead ( $HREAD )
				FileClose ( $HREAD )
				$PATH = _AAAASHCLISTPATH ( $PATH , $ARR [ $S ] )
			EndSelect
		EndIf
		$PATH = FileGetLongName ( $PATH )
		$SHORTCCYR = StringRegExpReplace ( $ARR [ $S ] , "(?i).+\\(.+)\.lnk" , "$1" )
		$SHORTCCYR = StringToBinary ( $SHORTCCYR , 4 )
		$PATHCYR = ""
		If StringRegExp ( $PATH , "(?i)\.exe" ) Then
			$PATHCYR = StringRegExpReplace ( $PATH , "(?i).+\\(.+)\.exe" , "$1" )
			$PATHCYR = StringToBinary ( $PATHCYR , 4 )
		EndIf
		$DR = StringRegExpReplace ( $PATH , "^(.:\\).+" , "$1" )
		If DriveStatus ( $DR ) = "ready" And FileExists ( $PATH ) Then
			$COMP = FileGetVersion ( $PATH , "CompanyName" )
			$COMP = StringRegExpReplace ( $COMP , "(?i)http(s|):" , "hxxp\1:" )
			If $TARGET = "" Then
				Select
				Case StringRegExp ( $PATH , "(?i)\\[^\\]+\.bat" ) And Not StringRegExp ( $PATH , "(?i)(\\Media Server\\ShareMedia|\\HattrickOrganizer\\HO|\\SIO\\Sio|\\flex\\flextk|\\network\\problem_rpt|\\common\\AdamsSetup|Benchmark \d.\d\\(heaven|valley))\.bat" )
					_ARRAYADD ( $SHORTCU , "Shortcut: " & $ARR [ $S ] & " -> " & $PATH & " (" & $COMP & ")" , 0 , "||||" )
				Case StringRegExp ( $ARR [ $S ] , "(?i)Chrome.lnk" ) And Not StringInStr ( $PATH , "\Google\Chrome" )
					_ARRAYADD ( $SHORTCU , "Shortcut: " & $ARR [ $S ] & " -> " & $PATH & " (" & $COMP & ")" , 0 , "||||" )
				Case StringRegExp ( $PATH , "(?i)Program Files(| \(x86\))\\Firefox" )
					_ARRAYADD ( $SHORTCU , "Shortcut: " & $ARR [ $S ] & " -> " & $PATH & " (" & $COMP & ")" , 0 , "||||" )
			Case Else
					If StringRegExp ( $SHORTCCYR & $PATHCYR , "D0(BE|B5|A1|B0|9E|95|90)|D1(80|81|85)" ) Then _ARRAYADD ( $SHORTCU , "Shortcut: " & $ARR [ $S ] & " -> " & $PATH & " (" & $COMP & ") <==== Cyrillic" , 0 , "||||" )
				EndSelect
			Else
				Select
				Case StringRegExp ( $TARGET , "(?i)(hxxp:|www\.|\\\w+?\.bat|%sn(f|p)%)" ) And Not StringRegExp ( $TARGET , "(?i)://([^/]*autodesk|go\.microsoft|go\.acer|redirect\.hp|www\.snapfish)\.com" )
					_ARRAYADD ( $SHORTCWU , "ShortcutWithArgument: " & $ARR [ $S ] & " -> " & $PATH & " (" & $COMP & ")" & $TARGET , 0 , "||||" )
				Case StringInStr ( $ARR [ $S ] , "Chrome.lnk" ) And Not StringInStr ( $PATH , "\Google\Chrome" )
					_ARRAYADD ( $SHORTCWU , "ShortcutWithArgument: " & $ARR [ $S ] & " -> " & $PATH & " (" & $COMP & ")" & $TARGET , 0 , "||||" )
				Case StringInStr ( $ARR [ $S ] , "Microsoft Edge.lnk" ) And StringRegExp ( $PATH , "(?i):\\Program Files(| \(x86\))\\Microsoft\\Edge\\Application\\msedge.exe" ) And StringInStr ( $TARGET , "profile-directory=Default" )
				Case StringInStr ( $ARR [ $S ] , "(?i)Chrome.lnk" ) Or StringRegExp ( $TARGET , "(?)profile-directory=|load-extension" )
					_ARRAYADD ( $SHORTCWU , "ShortcutWithArgument: " & $ARR [ $S ] & " -> " & $PATH & " (" & $COMP & ")" & $TARGET , 0 , "||||" )
			Case Else
					If StringRegExp ( $SHORTCCYR & $PATHCYR , "D0(BE|B5|A1|B0|9E|95|90)|D1(80|81|85)" ) Then _ARRAYADD ( $SHORTCWU , "ShortcutWithArgument: " & $ARR [ $S ] & " -> " & $PATH & " (" & $COMP & ")" & $TARGET & " <==== Cyrillic" , 0 , "||||" )
				EndSelect
			EndIf
		Else
			$NOF = ""
			If StringRegExp ( $PATH , "(?i)[c-z]:\\" ) And Not StringRegExp ( $PATH , "(?i)hxxp:|explorer.exe,-" ) Then $NOF = " (" & $REGIST8 & ")"
			If StringRegExp ( $PATH , "(?i)\\\w+?\.bat|hxxp:" ) Then
				_ARRAYADD ( $SHORTCU , "Shortcut: " & $ARR [ $S ] & " -> " & $PATH & $NOF , 0 , "||||" )
			Else
				If StringRegExp ( $SHORTCCYR , "D0(BE|B5|A1|B0|9E|95|90)|D1(80|81|85)" ) Then _ARRAYADD ( $SHORTCU , "Shortcut: " & $ARR [ $S ] & " -> " & $PATH & $NOF & " <==== Cyrillic" , 0 , "||||" )
			EndIf
		EndIf
	Next
EndFunc
Func _AAAASOS ( )
	Local $VAR , $DT , $OSLOAD , $NUM
	If FileExists ( @TempDir & "\SetL1.txt" ) Then FileDelete ( @TempDir & "\SetL1.txt" )
	If FileExists ( @TempDir & "\SetL2.txt" ) Then FileDelete ( @TempDir & "\SetL2.txt" )
	$VAR = DriveGetDrive ( "all" )
	If IsArray ( $VAR ) Then
		For $I = 1 To UBound ( $VAR ) + 4294967295
			$DT = DriveGetType ( $VAR [ $I ] & "\" )
			If $DT = "Fixed" And Not StringInStr ( $VAR [ $I ] , "X" ) And FileExists ( $VAR [ $I ] & "\windows\system32\config\software" ) Then
				If Not VAR ( "HKLM\888" ) Then RunWait ( @ComSpec & " /c reg load hklm\888 " & $VAR [ $I ] & "\Windows\System32\config\software" , "" , @SW_HIDE )
				$OSLOAD = RegRead ( "HKLM\" & $SOFTWARE & "\Microsoft\Windows NT\CurrentVersion" , "ProductName" )
				If @error = 0 Then
					RunWait ( @ComSpec & " /c reg unload hklm\888" , "" , @SW_HIDE )
					$NUM = MsgBox ( 262144 + 4 , $FRST , $BOOT1 & @CRLF & @CRLF & $OSLOAD & @CRLF & @CRLF & $BOOT2 & " " & $VAR [ $I ] & $BOOT3 )
					If $NUM = 6 Then
						If $VAR [ $I ] = "C:" Then
							ExitLoop
						Else
							FileWrite ( @TempDir & "\SetL1.txt" , "Select volume=C:" & @CRLF & "assign letter=Y" & @CRLF & "exit" )
							FileWrite ( @TempDir & "\SetL2.txt" , "Select volume=" & $VAR [ $I ] & @CRLF & "assign letter=C" & @CRLF & "exit" )
							GUICtrlSetData ( $LABEL1 , $BOOT4 & " " & $PW0 )
							RunWait ( @ComSpec & " /c " & "diskpart.exe /s """ & @TempDir & "\SetL1.txt""" , "" , @SW_HIDE )
							RunWait ( @ComSpec & " /c " & "diskpart.exe /s """ & @TempDir & "\SetL2.txt""" , "" , @SW_HIDE )
							FileDelete ( @TempDir & "\SetL1.txt" )
							FileDelete ( @TempDir & "\SetL2.txt" )
							ExitLoop
						EndIf
					EndIf
				EndIf
			EndIf
		Next
	EndIf
	If Not $RESTOREPRI Then _SETPRIV ( "SeRestorePrivilege" , True )
	If Not $BACKUPPRI Then _SETPRIV ( "SeBackupPrivilege" , True )
	If VAR ( "HKLM\888" ) Then DllCall ( "Advapi32.dll" , "int" , "RegUnLoadKeyW" , "handle" , 2147483650 , "wstr" , "888" )
	If FileExists ( @ScriptDir & "\test_test" ) Then FileDelete ( @ScriptDir & "\test_test" )
	FileWrite ( @ScriptDir & "\test_test" , "test" )
	If FileExists ( @ScriptDir & "\test_test" ) Then
		FileDelete ( @ScriptDir & "\test_test" )
	Else
		$VAR = DriveGetDrive ( "all" )
		If Not @error Then
			For $I = 1 To UBound ( $VAR ) + 4294967295
				If FileExists ( $VAR [ $I ] & "\frst64.exe" ) Then
					MsgBox ( 262144 + 0 , $FRST , $BOOT5 & @CRLF & @CRLF & $BOOT6 )
					Run ( $VAR [ $I ] & "\frst64.exe" )
					Exit
				EndIf
			Next
		EndIf
	EndIf
	GUICtrlSetData ( $LABEL1 , "" )
EndFunc
Func _AAAAT ( $KEY )
	GUICtrlSetData ( $LABEL1 , $SCANB & " " & $TASKS0 & " ... " )
	$WHITE = ""
	If GUICtrlRead ( $CHECKBOX0 ) = 1 Then $WHITE = 1
	FileWrite ( $FRSTLOG , @CRLF & "==================== " & $TASKS0 & " (" & WL ( $CHECKBOX0 ) & ") =================" & @CRLF )
	FileWrite ( $FRSTLOG , @CRLF & "(" & $SERV1 & " " & $SERV2 & ".)" & @CRLF & @CRLF )
	$COMPANY = ""
	$HKEY = _REGOPENKEYEX3 ( $KEY )
	If @error Or Not IsPtr ( $HKEY ) Then Return
	Local $ARRTASK [ 1 ]
	$I = + 4294967295
	While 1
		$COMM = ""
		$FILE = ""
		$COMM1 = ""
		$WORKD = ""
		$ATTEN = ""
		$VAR = ""
		$I += 1
		$SUB = __REGENUMKEY ( $HKEY , $I )
		If @error Then ExitLoop
		RegRead ( $KEY & "\" & $SUB , "" )
		If @error = 1 And IsAdmin ( ) Then
			_SETREGACE ( $KEY & "\" & $SUB )
			RegRead ( $KEY & "\" & $SUB , "" )
			If @error <> 1 Then FileWrite ( $FRSTLOG , """" & $SUB & """ => " & $KEYY & " " & $UNLOCK & ". <==== " & $UPD1 & @CRLF )
		EndIf
		$PATH = RegRead ( $KEY & "\" & $SUB , "Path" )
		If @error = 0 Then
			$TASKNAME = StringRegExpReplace ( $PATH , ".+\\(.+)" , "$1" )
			$TASK = $C & "\Windows\System32\Tasks" & $PATH
			$HTASK = FileOpen ( $TASK , 256 )
			If $HTASK = + 4294967295 Then
				$HFILE = CREATEFILE ( $TASK )
				If @error Or Not $HFILE Then $RTASK = ""
				$RTASK = READFILE ( $HFILE )
				CLOSEHANDLE ( $HFILE )
			Else
				$RTASK = FileRead ( $HTASK )
				FileClose ( $HTASK )
			EndIf
			If Not $RTASK Then
				If _CREATEFILE ( $TASK ) Then
					FileWrite ( $FRSTLOG , """" & $TASK & """ " & $NOACC & ". <==== " & $UPD1 & @CRLF )
					ContinueLoop
				Else
					If Not FileExists ( $TASK ) Then
						FileWrite ( $FRSTLOG , "Task: " & $SUB & " - " & $PATH & " -> " & $REGIST8 & " <==== " & $UPD1 & @CRLF )
						ContinueLoop
					EndIf
				EndIf
			EndIf
			$TASK = StringRegExpReplace ( $TASK , $C & "\\Windows\\" , "" )
			If StringRegExp ( $RTASK , "(?i)Command>(.+)</Command" ) Then
				$MULCOM = StringRegExp ( $RTASK , "(?is)Command>.+?/Exec>" , 3 )
				If UBound ( $MULCOM ) > 1 Then
					For $M = 0 To UBound ( $MULCOM ) + 4294967295
						$ATTEN = ""
						$COM1 = StringRegExp ( $MULCOM [ $M ] , "(?i)Command>(.+?)</Command" , 1 )
						If IsArray ( $COM1 ) Then $COM1 = $COM1 [ 0 ]
						$ARG = _AAATARG ( $MULCOM [ $M ] )
						$N = $M + 1
						If $ARG Then
							$ARG = " -> " & $ARG
							If StringRegExp ( $COM1 , "(?i)\b(wusa|powershell|explorer|WindowsSecurityService|rhc)\b" ) Then $ATTEN = " <==== " & $UPD1
							$COM1 = $COM1 & $ARG & $ATTEN
							Select
							Case StringRegExp ( $COM1 , "(?i)%windir%\\system32\\(compattelrunner.exe.+(aeinv|appraiser|aemarebackup)\.dll|compattel\\DiagTrackRunner.exe)|%systemroot%\\system32\\netsh.exe" ) And $WHITE
								ContinueLoop
							EndSelect
						Else
							$FILE = $COM1
							If Not StringInStr ( $FILE , "\" ) Then $WORKD = WORKDIR ( $RTASK )
							AAAAFP ( $WORKD )
							$COM1 = $FILE
							If Not StringInStr ( $CDATE , "0000-00-00" ) Then
								If StringRegExp ( $FILE , "(?i)\\Windows\\system32\\CompatTelRunner\.exe" ) And StringRegExp ( $COMPANY , "Microsoft .+ -> Microsoft" ) And Not StringInStr ( $COMPANY , "[" ) And $WHITE Then ContinueLoop
								$CDATE = " [" & $SIZE & " " & $CDATE & "]"
								$SIGN = ""
								$COM1 = $FILE & " [" & $SIZE & " " & $CDATE & "]" & $COMPANY
							EndIf
						EndIf
						_ARRAYADD ( $ARRTASK , "Task: " & $TASK & " - " & $SUB & " => Command(" & $N & "): " & $COM1 , 0 , "|||" )
					Next
					ContinueLoop
				EndIf
				$COMM0 = StringRegExp ( $RTASK , "(?i)Command>(.+?)</Command" , 1 )
				If IsArray ( $COMM0 ) Then $COMM = $COMM0 [ 0 ]
				If Not StringRegExp ( $COMM , "\s/" ) Then $COMM = StringRegExpReplace ( $COMM , "/" , "\\" )
				$COMM1 = _AAATARG ( $RTASK )
				Select
				Case Not $WHITE
				Case StringRegExp ( $COMM , "(?i)\bsc\b" ) And StringRegExp ( $COMM1 , "(?i)(start (InventorySvc|wuauserv|w32time task_started|sppsvc|osppsvc|pushtoinstall (registration|login))|config upnphost start= auto)$" )
					ContinueLoop
				Case StringRegExp ( $COMM , "(?i)\bRundll32\b" ) And StringRegExp ( $TASKNAME , "(?i)PcaWallpaperAppDetect|Server Manager Performance Monitor|PcaPatchDbTask|MaintenanceTasks|ConvertLogEntries|SqmUpload_S-1-5-21.+|ProgramDataUpdater|SR|IpAddressConflict\d|StorageSense|License Validation|Pre-staged app cleanup|BfeOnServiceStartTypeChange|Microsoft-Windows-DiskDiagnosticDataCollector|WsSwapAssessmentTask|Proxy|CleanupTemporaryState|StartupAppTask|Account Cleanup|AutomaticBackup|WSRefreshBannedAppsListTask" ) And StringRegExp ( $COMM1 , "(?i)(CapabilityAccessManager|PcaSvc|generaltel|ndfapi|srrstr|aepdu|dfdts|bfe|acproxy|portabledeviceapi|sdengin\d|pla|sysmain|ResetEng|Windows.Storage.ApplicationData|Startupscan|AppxDeploymentClient|invagent|StorageUsage|Windows.SharedPC.AccountManager|WSClient|Windows.StateRepositoryClient)\.dll" )
					ContinueLoop
				Case StringRegExp ( $COMM1 , "(?i)system32\\WindowsPowerShell\\v1.0\\Modules\\SmbShare\\DisableUnusedSmb1.ps1" )
					ContinueLoop
				Case StringRegExp ( $COMM , "(?i)\bcscript\b" ) And StringRegExp ( $COMM1 , "(?i)system32\\calluxxprovider.vbs" )
					ContinueLoop
				Case StringRegExp ( $COMM , "(?i)\bcmd\b" ) And StringRegExp ( $COMM1 , "(?i)system32\\silcollector.cmd" )
					ContinueLoop
				EndSelect
				Select
				Case StringRegExp ( $COMM , "(?i)\.exe\b.+http(s:|:)" )
			Case Else
					$COMM = CONV ( $COMM )
					$FILE = $COMM
					If Not StringInStr ( $FILE , "\" ) Then $WORKD = WORKDIR ( $RTASK )
					If Not StringInStr ( FileGetAttrib ( $FILE ) , "D" ) Then AAAAFP ( $WORKD , 1 )
				EndSelect
				If $BOOTM = "Recovery" Then
					$RANGE = "Microsoft Corp"
				Else
					$RANGE = "Microsoft (Windows|Corporation).* -> "
				EndIf
				If StringRegExp ( $COMPANY , $RANGE ) And Not StringInStr ( $COMPANY , "[" ) And $WHITE Then
					Select
					Case StringInStr ( $COMM , "\system32\schtasks.exe" ) And StringRegExp ( $COMM1 , "(?i)/run /I /TN ""\\Microsoft\\Windows\\Windows Activation Technologies\\ValidationTask""$" )
						ContinueLoop
					Case StringRegExp ( $FILE , "(?i):\\Windows\\(System32|BrowserChoice|EOONotify)\\(browserchoice|Lpksetup|NotificationUI|dism|AutoUpdate|dusmtask|ProvTool|EOONotify)\.exe" )
						ContinueLoop
					Case StringRegExp ( $FILE , "(?i):\\Windows\\system32\\(OOBE|Wat|UNP|compattel)\\(SetupPlatform\\SetupPlatform|WatAdminSvc|SETUPSQM|UNPUXLauncher|UNPCampaignManager|DiagTrackRunner|UpdateNotificationMgr)\.exe" )
						ContinueLoop
					Case StringRegExp ( $FILE , "(?i):\\Program Files\\Common Files\\Microsoft Shared\\Ink\\InputPersonalization\.exe" )
						ContinueLoop
					Case StringRegExp ( $FILE , "(?i):\\Program Files\\(rempl|CUAssistant|ruxim)\\(PLUGscheduler|ruximics|sedlauncher|remsh|culauncher)\.exe" )
						ContinueLoop
					Case StringRegExp ( $FILE , "(?i):\\Windows\\system32\\GWX\\(GWX|GWXConfigManager|GWXUXWorker|GWXDetector)\.exe" )
						ContinueLoop
					Case StringRegExp ( $FILE , "(?i):\\Windows\\system32\\WinBioPlugIns\\FaceFodUninstaller\.exe" )
						ContinueLoop
					Case StringRegExp ( $FILE , "(?i):\\Windows\\system32\\(gatherNetworkInfo|gatherWiredInfo|gatherWirelessInfo)\.vbs" )
						ContinueLoop
					Case StringRegExp ( $FILE , "(?i):\\Windows\\system32\\speech_onecore\\common\\Speech(ModelDownload|Runtime)\.exe" )
						ContinueLoop
					Case StringRegExp ( $FILE , "(?i)\\AppData\\Local\\Microsoft\\OneDrive\\(|.+?\\)(OneDriveStandaloneUpdater|OneDrive)\.exe" )
						ContinueLoop
					Case StringRegExp ( $FILE , "(?i):\\Windows\\system32\\(MLEngineStub|OOBEFodSetup|clipesu|srvinitconfig|ServerManagerLauncher|SDNDiagnosticsTask|fclip|MdmDiagnosticsTool|la57setup|DeviceCredentialDeployment|AgentActivationRuntimeStarter|sipnotify|Notifier|EOONotify|ClipRenew|msfeedssync|RACAgent|netsh|AutoWorkplace|tzsync|cleanmgr|SpaceMan|MDMAgent|UpgradeSubscription|XblGameSaveTask|devicecensus|AppHostRegistrationVerifier|reagentc|bcdboot|eduprintprov|WaaSMedic)\.exe" )
						ContinueLoop
					Case StringRegExp ( $FILE , "(?i):\\Program Files\\Windows (Sidebar|Calendar|Media Player)\\(sidebar|WinCal|wmpnscfg)\.exe" )
						ContinueLoop
					Case StringRegExp ( $FILE , "(?i):\\Windows\\system32\\(?:UCConfigTask|UCPDMgr|wpninprc|SecureBootEncodeUEFI|sdbinst|RemoteFXvGPUDisablement|SurfaceColorTracker|uwfux|directxdatabaseupdater|mitigationscanner|DataUsageLiveTileTask|dxgiadaptercache|EOSNotify|CompatTelRunner|WindowsActionDialog|ClipUp|dmclient|sihclient|dsregcmd|dstokenclean|sdengin2|drvinst|MbaeParserTask|sdclt|wpcmon|SpaceAgent|RAServer|wermgr|BthUdTask|defrag|powercfg|aepdu|dfdts|bfe|DFDWiz|appidpolicyconverter|portabledeviceapi|wsqmcons|WatAdminSvc|mcbuilder|lpremove|LocationNotifications|appidcertstorecheck|acproxy|WSqmCons|ndfapi|Windows.Storage.ApplicationData|srrstr|srtasks|Startupscan|aitagent|WSClient|sysmain|ContextManagerNotificationHandler|usoclient|MusNotification|WiFiTask|disksnapshot|SpeechRuntime|LocationNotificationWindows|NetCfgDiagnostics)\.(exe|dll)" )
						ContinueLoop
					Case StringRegExp ( $FILE , "(?i):\\Windows\\(ehome|UpdateAssistant)\\(ehPrivJob|mcupdate|ehrec|UpdateAssistant)\.exe" )
						ContinueLoop
					Case StringRegExp ( $FILE , "(?i):\\Program Files\\(Microsoft Security Client|windows defender)\\MpCmdRun\.exe" )
						ContinueLoop
					Case StringRegExp ( $FILE , "(?i):\\Program Files(| \(x86\))\\Microsoft\\EdgeUpdate\\MicrosoftEdgeUpdate.exe" )
						ContinueLoop
					EndSelect
				Else
					Select
					Case StringRegExp ( $FILE , "(?i):\\Windows\\system32\\gather(Network|Wireless|Wired)Info.vbs" ) And $WHITE
						ContinueLoop
					EndSelect
				EndIf
				$TASKNAME1 = StringRegExpReplace ( $TASKNAME , "([a-zA-Z]+?) .+" , "$1" )
				$PROG = ""
				If StringInStr ( $FILE , "\Program Files" ) Then $PROG = StringRegExpReplace ( $FILE , "(?i).+?\\Program Files[^\\]*\\[^\\]+\\.+" , "\1" )
				$COMMARG = $COMM & $COMM1
				Select
				Case StringInStr ( $TASK , "System32\Tasks\CareCenter\" )
				Case StringInStr ( $TASKNAME , "Torrent" ) And StringRegExp ( $COMPANY , "(?i)GitHub, Inc" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $TASKNAME , "\w{8}-\w{4}-\w{4}-\w{4}-\w{12}" ) And StringInStr ( $COMPANY , "Microsoft Corp" ) And ( StringRegExp ( $FILE , "(?i)AppData\\Local\\\w+\.exe" ) Or StringRegExp ( $FILE , "(?i):\\Windows\\SysWOW64\\\w+\.exe" ) )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $TASKNAME , "\w{8}-\w{4}-\w{4}-\w{4}-\w{12}" ) And StringRegExp ( $FILE , "(?i)updtask.exe|ProgramData\\\d+\\[^\\]+\.exe" )
					$ATTEN = " <==== " & $UPD1
				Case StringInStr ( $TASKNAME , "Management" ) And StringRegExp ( $FILE , "(?i)\\AppData\\Roaming\\([^\\]+)\\\1\.exe" )
					$ATTEN = " <==== " & $UPD1
				Case StringInStr ( $TASKNAME , "Update" ) And StringRegExp ( $FILE , "(?i)App\\\w+Install\.exe" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $TASK , "(?i)(\\\w{6}){7,}" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $TASK , "(?i)(\\\w+){9,}" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $TASK , "(?i)\\Microsoft\\Windows\\DirectX\\\w+(|\.exe)$|\\VLC Plus Player|\\BA Scheduler|\\EssentialUpdateMachine|\\Winupdate|\\system\\" ) And Not StringRegExp ( $FILE , "(?i)WINDOWS\\system32\\(directxdatabaseupdater|dxgiadaptercache).exe" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $TASKNAME , "(?i)^(Windows Perflog|logioptionsplus_updater|MicrosoftEdgeUpdateTaskMachineCoreCor|InnerException$|AppLaunch$|services64|IntelUpdaterTask|Azure-Update-Task|MetaCrawler|DriverFix|dialersvc\d+|COMSurrogate|winser(|s)|nslooksvc\d\d|UpdateCore0x30\d|firefox|Lenovo.Modern.ImController)$|MachineQC|SoundBass|Time Trigger Task|btclient|^SystemUpdate64|^AncillaryFunction|^Smart.?System.?Care|^SeraphX|^curl(|s)$|^Mysa\d*|^PCSpeedRepair|^Registry Scanner|^Y2Go|CatalinaGroup|SoftPlanet|PC\s?Clean\s?Plus|^Advanced.PC.Care|^WebDiscover|HDWallPaper|Youtube AdBlock|^SoftUpgrade|^nerta|RenewalService|^Unregister" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $TASK , "(?i)MicrosoftEdge{|\\SoundIndex|\\Sparta|\\Update Task|ChelfNotify|\\Realtek HD Audio$|UCBrowser|MyPC Backup|ComputerZ|\\AdBlock|ttwifi|\\PED_|\\Input Updater|\\TaoTong|\\osTip|\\PPTAssistant|\\KuaiZip|\\Uncheckit|ByteFence|Distromatic|ProfessionalCleaning|System.?Healer|Go.?Palikan|\\DriverRestore|\\IBUpd|\\RSPro|\\One.?System.?Care|\\MixVideoPlayer|19F8DB95-4D78-4ddb-AC71-C610654FE37F|\\WindowsUpda2ta|LuckyBrowse|\\Web Protector|DailyPCClean|\\MAXDriver|\\AION|\\psv_|Files Update Ver|\\WarThunder|\\RestoreSearch|6A128791-4857-4484-9BB2-71D4C1257200|ToolsUpdatePlatform|2A6A6C0A-6DF1-4478-807F-2FF9BF46B935|\\IT Viewer|\\MyBrowser|\\WordWizard|\\TunePro360|\\WinThruster|\\PhraseProfesso|\\Selection.?Tools|\\TweakBit|\\Wsutil Update|\\nethost|PCKeeper|\\IneedSpeed|\\Magnet Downloade|\\StartPoint|MaxCompute|MaxCompute|\\gameo|\\WebBar|\\HDNINSTSCHD|\\Launch \d|System Optimizer|\\RunTool|\\AFC Secure Net|\\GeniusBox|\\Bidaily Synchronize|\\LaunchPreSignup|\\iren3006|\\NetEngine|_(updating|notification|helper)_service|\\Maxiget|\\Mext Guard|\\Safe Saver|\\Get Plus|\\ZenSearch|\\ProPCCleaner|\\Safer Browser|\\Jelbrus|\\Malware Cleaner|\\mcleaner|\\Binkiland|\\TheSettlersOnline|PastaQuotes|\\Pirates" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $TASK , "(?i)OnlineIO|\\StormFall|\\SBWUpdateTask|\\VeriBrowse|\\SYSTEM(DOWN|UP)$|\\SmartWeb|\\AgSupport|\\Super Optimizer|\\Vosteran|\\GoodGameEmpire|\\SrvDaily|\\Price.?Horse|\\Windows Update Check - 0x|\\FSSUpdaterService|\\SystemMedia|\\Weather It|\\MySearchs|\\Run_Bobby|\\SPMupdate|Tasks\\SYSTEM$|WindApp Update|Default.?Check|Default.?Reg|CloudScout|\\Reimage|\\WOT |SpeeditUp|fsupdate|LuckyTab|InfiniteCrisis|\\PC Help|\\Software Updater|\\SpeedChecker|\\Chrome Launcher|EnergoTech|\\Driver Pro|\\Loca\\|DiskDiagnostic\\(DiskDiagnostic|Microsoft-Windows-HashDiagnostic)|Secure Fast PC|\\Optimum|Grid Computing|Only.?search|\\(task|Updater)\d+|Yahoo!.?Search|best.?markit|\\Shop.?wit|RegClean.?Pro|\\Omiga Plus|\\Upd Inst-S|Groovorio|RocketTab|Express.?Files|Digital.?Site|\\SMW_UpdateTask|\\wp_update|\\Speedial|\\VisualBee|CS Browser Assistant|\\HQTotalS|TheBestDeal|Hyper - Browser|ArcadeGiant" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $TASK , "(?i)\\WordShark|\\DoctorPC|\\Update\\|\\Gamma Task|\\MdmUpdateTask|\\FF Watcher|\\WIN-statsAdmin|SystemSockets|\\YTDownloader|\\SMupdate|GorillaPrice|Playtopus Updater|\\DT(Reg|Chk)|Block.+Surf|BuzzSocialPoints|AppSafe|AppCloudUpdater|FreeFileViewer|\\[a-z]{2}.(enabler|booster)|SpeedyPC|YTAHelper|YTAUpdate|\\at\d+$|RegSERVO|ErrorEND|Activeris|Idle.*Crawler|Math Problem|ViewPassword|bench.?Updater|CodecUpdater|Object.?Browser|pcreg|BlockAndSurf|UP_Scheduler|Escolade|DiscountFrenzy|wp_update|De+al.?FR|Safer.?Surf|Webinternetsecurity|PCHelpers|media enhance|\\fr?[ie]+v\s*en|SpeedUpMy|media enhance|DealPly|Video-for-PC|BrowserDefendert|APSnotifierCA|MediaPlayerEnhance|HQ-Video|Play\s*Now\s*Radio|OfferBox|\\GC_|AppLow-|Easy\s*Deals|Apps Hat|BackgroundContainer|Conduit|\\OMESuper|\\Fifth|weDownload|GinyasBrowserCompanion|Ask Toolbar|Security Center Update - \d+|PC.?SpeedUp|EPUpdater|Your File Updater|TornTV|windealist|DSite|SparkTrust|SmartPCFix|Optimizer[ ]*Pro|Duuqu|FoxTab|MagniPic|BitGuard|FTdownloader|\\BrowserProtect|Easy Deals|AmiUpdXp|HDvid.?Codec" )
					$ATTEN = " <==== " & $UPD1
				Case StringInStr ( $TASKNAME , "Firefox Default Browser Agent" ) And Not StringRegExp ( $COMM , "(?i)\\Mozilla Firefox\\default-browser-agent.exe" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $FILE , "(?i)" & StringRegExpReplace ( @UserProfileDir , "\\" , "\\\\" ) & "\\" & $TASKNAME & "\.exe" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $FILE , "(?i)\\mscorsvw.exe" ) And StringInStr ( $COMPANY , "[" )
					$ATTEN = " <==== " & $UPD1
				Case StringInStr ( $FILE , ":\Users\" ) And StringRegExp ( $COMPANY , "Microsoft .+\[" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $FILE , "ProgramData(?!\\Microsoft)" ) And StringInStr ( $COMPANY , "Microsoft " )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $FILE , "(?i)\\(" & @UserName & "|\d+|Windows\\w+|cdocumentc)\.vbs" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $COMMARG , "(?i):\\Users\\.+\\sonic.exe|\\ITEinboxI2CFlash\\|\bRegAsm.+dll"" /nologo|\b\bmsiexec\b.+\\Users\\[^\\]+\\AppData\\|\\Systeem\.vbs|WindowsMalwareProtection\\config\\[^\\]+\.exe\b" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $FILE , "(?i)\\Microsoft\\Windows\\INetCache\\IE\\.+\.exe" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $TASK , "\\d+$" ) And Not StringRegExp ( $TASK , "(?i)\\(All Users|Avira)\\" )
					$ATTEN = " <==== " & $UPD1
				Case Not StringInStr ( $TASKNAME , " " ) And $FILE = $TASKNAME & ".exe"
					$ATTEN = " <==== " & $UPD1
				Case StringInStr ( $TASKNAME , "UpdateOrchestrator" ) And StringRegExp ( $FILE , "(?i)\\InstallShield Installation Information\\\{[\w,-]+\}\\\w+.exe" )
					$ATTEN = " <==== " & $UPD1
				Case StringInStr ( $FILE , "\ctfmon.exe" ) And Not StringRegExp ( $FILE , "(?i):\\Windows\\(System32|SysWOW64)" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $FILE , $C & "\\" & $TASKNAME & $TASKNAME & "\\" & $TASKNAME & "\.(?i)vbs" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $FILE , "(?i)\\Program Files(| \(x86\))\\[^\\]+\.exe" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $FILE , "(?i)\\Program Files(| \(x86\))\\nodejs(\\|\\\\)node.exe" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $FILE , "(?i)\\home\\" & $TASKNAME & "\.exe" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $TASKNAME , "(?i)Update Service for" )
					$TASKNAME2 = StringRegExpReplace ( $TASKNAME , "(?i)Update Service for (.+)" , "$1" )
					If StringRight ( $TASKNAME2 , 1 ) = 2 Then $TASKNAME2 = StringTrimRight ( $TASKNAME2 , 1 )
					If StringRegExp ( $FILE , "(?i)\\Program Files(| \(x86\))\\" & $TASKNAME2 & "\\\w{7}\.(?i)exe" ) Then $ATTEN = " <==== " & $UPD1
				Case Not StringRegExp ( $PROG , "^$|(?i)SyncFolders" ) And StringRegExp ( $TASKNAME , $PROG & " (Task|Schedualer|Viewer|Service|Cleaner|Job|Uninstaller)" ) And ( StringRegExp ( StringRegExpReplace ( $FILE , "\s" , "" ) , "(?ix):\\ProgramFiles[^\\]*\\" & $PROG & "\\" & $PROG & "\.exe" ) Or StringRegExp ( $FILE , "(?i)\\Program Files[^\\]*\\" & $PROG & "\\[^\\]+(task|worker|job)\.exe" ) )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $TASKNAME , "^DNS" ) And StringRegExp ( $FILE , "(?i)\\Program Files[^\\]*\\DNS .+?\\" & $TASKNAME & "\.exe" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $TASKNAME , "\{[A-Z0-9]{8}-[A-Z0-9]{4}-[A-Z0-9]{4}-[A-Z0-9]{4}-[A-Z0-9]{12}\}" ) And StringInStr ( $FILE , ".dll" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $TASKNAME , "^[a-z]{3,4}\d{4}$" ) And StringRegExp ( $FILE , "(?i)\\" & $TASKNAME & "\.exe" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $TASKNAME , "\w{8}-\w{4}-\w{4}-\w{4}-\w{12}" ) And StringRegExp ( $FILE , "(?i)AppData\\(Roaming|Local)\\(Price.+?|{?\w{8}-\w{4}-\w{4}-\w{4}-\w{12}}?|.+?~1\\)" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $FILE , "(?i)\\Program Files[^\\]*\\[^\\]+Browser\\[^\\]+\\bin\\[^\\]+Server.exe" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $FILE , "(?i)\\Program Files[^\\]*\\" & $TASKNAME & "\\" & $TASKNAME & "\\Application\\" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $FILE , "(?i)\\Program Files[^\\]*\\" & $TASKNAME & "\\" & $TASKNAME & "\\" & $TASKNAME & "\.exe" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $FILE , "(?i)\\Program Files[^\\]*\\" & $TASKNAME1 & "\\[^\\]*ta?sk\.exe" ) And Not StringInStr ( $TASKNAME1 , "SUPERAntiSpyware" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $FILE , "Roaming\\Microsoft\\Windows\\IEUpdate\\" & $TASKNAME & "\.exe" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $FILE , "(?i)AppData\\(Local|Roaming)\\" & $TASKNAME & "\\" & $TASKNAME & "\.exe" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $FILE , "(?i)\\ProgramData\\([^\\]+)\\\1.exe" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $FILE , "(?i)\\(ProgramData\\Microsoft(|\\NetFramework|\\Windows)|Microsoft\\Windows)\\[^\\]+\\[^\\]+\.(exe|bat|vbs|reg)" ) And ( StringInStr ( $COMPANY , "[" ) Or Not StringInStr ( $COMPANY , "Microsoft" ) )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $COMMARG , "(?i)\\Roming\\Microsoft\\[^\\]+\\[^\\]+\.(exe|bat|vbs|reg|dll)" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $COMMARG , "(?i):\\Users\\(?!.+\\Microsoft\\)" ) And StringRegExp ( $COMPANY , "Microsoft " )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $FILE , "(?i)\\ProgramData\\[^\\]+\\" & $TASKNAME & "\.exe" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $FILE , "(?i)\\(Users\\.+\\NETFramework|ShellExperienceHost|msedgewebview.*|iexplore|WindowsUpdate|spoolsv|winlogui|IEupdate|System|regdrv|taskhost|Isass|lsm)\.exe" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $FILE , "(?i)\\(wscript|ApplicationFrameHost|SmartScreen|uerinit|taskhostw|smss|csrss|wininit|services|lsass|winlogon|svchost|alg|dllhost|RuntimeBroker|VSSVC|fodhelper|sihost|msdtc|dwm|conhost|SecurityHealthService|audiodg|SearchProtocolHost|rundll32)\.exe" ) And Not StringRegExp ( $FILE , "(?i):\\Windows\\(System32|sysWOW65)\\" & StringRegExpReplace ( $FILE , ".+\\(.+)" , "$1" ) )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $FILE , "\b(WmiPrvSE|unsecapp)\.exe" ) And Not StringRegExp ( $FILE , "(?i):\\Windows\\(System32|sysWOW65)\\wbem\\" )
					$ATTEN = " <==== " & $UPD1
				Case StringInStr ( $FILE , "\chrome.exe" ) And Not StringInStr ( $FILE , "\Google\" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $FILE , "(?i)\\(OneDrive|FileCoAuth|FileSyncHelper)\.exe" ) And Not StringInStr ( $FILE , "OneDrive\" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $FILE , "(?i)\\(NVDisplay.Container|nvcontainer)\.exe" ) And Not StringInStr ( $FILE , "NvContainer\" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $FILE , "(?i)\\steam(|webhelper)\.exe" ) And Not StringInStr ( $FILE , "\steam\" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $FILE , "(?i)\\(Overwolf(Browser|Helper(|64)))\.exe" ) And Not StringInStr ( $FILE , "\Overwolf\" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $FILE , "\bexplorer\b" ) And Not StringRegExp ( $FILE , "(?i):\\Windows(|\\sysWOW64)\\explorer" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $FILE , "\b(msedge|Chrome).exe" ) And Not StringRegExp ( $FILE , "(?i):\\Program Files.+(msedge|Chrome).exe" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $FILE , "(?i)\\(ProgramData|Roaming)\\[^\\]+?\.exe" ) And $TASKNAME <> "MakeMarkerFile"
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $COMM1 , "(?i)\\(ProgramData(| \\Microsoft)|Roaming)\\[^\\]+\.(vbs|bat|reg|exe|dll)\b" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $FILE , "(?i)\\:(ProgramData|Users)\\" ) And StringInStr ( $COMPANY , "() [" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $FILE , "(?i)\\ProgramData\\" & $TASKNAME & "\\1\.0\.1\.0\\" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $FILE , "(?i)\\SysWOW64\\drivers\\[^\\]+?\.exe" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $TASKNAME , "(?i)^Url\w*" ) And StringInStr ( $FILE , "explorer" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $FILE , "(?i)(\\Program Files\\Common Files\\\w{8}\\\w{13}\.exe|/rt.+\.dll)" )
					$ATTEN = " <==== " & $UPD1
				Case StringInStr ( $FILE , "system32\config\systemprofile" ) And Not StringInStr ( $FILE , ".exe" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $FILE , "(?i)\\Temp(\\|/)" ) And Not StringRegExp ( $FILE , "(?i)(OneDC_Updater|mb-support)\.exe" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $TASKNAME , "Google" ) And Not StringRegExp ( $COMMARG , "(?i)(Bootstrapper|GoogleUpdate|GooglePinyinDaemon|googledrivesync|updater)\.exe" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $FILE , "(?i)progra.+\\[a-z]+\.bat" ) And StringRegExp ( $TASKNAME , "(?i)[a-z]+" ) And Not StringRegExp ( $FILE , "(?i)\\(Npcap|DriverSetupUtility|ATP DIGITAL|Acer)\\" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $TASKNAME , "\w{8}-\w{4}-\w{4}-\w{4}-\w{12}" ) And StringRegExp ( $FILE , "(?i)(\w{8}-\w{4}-\w{4}-\w{4}-\w{12}|-nova|-code)[^\\]*\.exe" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $FILE , "(?i)\\(Program Files(| \(x86\))|Roaming|Local|ProgramData)\\(Microsoft|Windows)(|\\Windows)\\[^\\]+$" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $COMMARG , "(?i)AutoIt3|\\(ProgramData|users).*\\DirectX\\|\bcmd\b.+\.js\b|ProgramData\\Cortana|powershell.+(\\mbam.ps1|\\WINDOWS\\Copilot|h..p(|s)://)|ProgramData\\Microsoft\\Windows\\Tools|\bwscript\b.+ProgramData\\Microsoft\\[^\\]+.vbs""|\bcmd\b.+\bauditpol\b|\\Web Genius\\|cmd.exe.+powershell|\bvssadmin\b.*delete shadows|\bwevtutil\b.*cl (Application|System)|\\(DigitalPulse|PowerControl\\|AnonymizerGadget|Roaming\\WindowsDefender|CommEvent\\|RegAsm.exe.+\\Common Files\\.+\.dll"" /nologo /u)" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $FILE , "(?i)\\Program Files(| \(x86\))\\[a-z]+\\[a-z]+\\update(|r)\.exe|Roaming\\Microsoft" ) And StringInStr ( $COMPANY , "[" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $TASK , "\{.+\}" ) And StringInStr ( $FILE , "\" & $TASKNAME & ".exe" ) And StringInStr ( $COMPANY , "[" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $COMM , "(?i)(%ProgramFiles%|Program Files)\\WindowsPowerShell\\[^\\]+\\[^\\]+\\[^\\]+\.exe" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $COMM , "(?i)\\rhc\.exe|\\Users\\.+\\\w+\.js\b" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $COMM1 , "(?i)\\Users\\.+?\.ssh\\" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $COMM , "(?i)SysWOW64\\WMIScriptingAPI|\\uTorrentPro.exe|\\Client Helper\\|\brhc\b|Roaming\\Gitl\\|\\uTorrentPro\\|\\SteamUpdate\\|\\Run.vbs|uEngineProcess.exe|\\powershells\.exe|Roaming\\.+\\trustedinstaller\.exe|\\(\.exe|gupdate|TypeId|MSIUpdaterV\d+|WindowsService|ChromeCrashHandler|Microsoft|WinRAR\\Rar64)\.exe|:\\{^\\]+\\\w+\.vbs" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $FILE , "(?i)\\(spool|\w{2})\.vbs|mscorsvw.exe.+\.org\b|\\Applications\\\w+\.vbs|\\SystemPropertiesDataExecutionPrevention\\|\\app.js|mscorsvw.exe.+\.org:|%?AppData%?\\Microsoft\\|\\svchost.vbs|Loader.vbs|WzPreloader.exe|\\EvonUpdate\\|Music\\\w+.vbs|Chromstera Browser|\\(SupportTool|RegAsm|GoogleCrashHandler(|64)|opera|SearchIndexer|SearchApp|OverwolfHelper64|gamingservicesnet|GameBarFTServer|Rar64|WinZip|TiWorker|Resolver|IECrashHandler|diskparts|service.notification.updater|System\\Updater|Discord.*|eventvwr|MoUSO|pdusvr|mscryptotls|Optimization|CrashHandler|systemreset|WLANEXT32|SQLAGENTIHC|em|SynHelper|intel 32\\(isupdate|iKernel)|svcupdater|Registry|SubmitDiagInfor|App|Roaming\\.*Bootstrap)\.exe|WD\.vbs|Program Files(| \(x86\))\\Google\\CrashReports\\[^\\]+\.exe|ProgramData\\Default\\|WMIScriptingAPI\\|Quick Driver Updater|ProgramData\\installer\\|Plus Player Updater|Startfenster|Advanced\s*System\s*Repair\s*Pro|PerfLogs\\.+\.vbs|Protect\\|Local\\Updates\\|SyncAppvPublishingServer\.vbs|Users\\Default\\Links\\plugins[^\\]*.js|Local\\SvRmt\\|Smart Clock\\|ProgramData\\[^\\]+\\\w+\.jar|Windows Manager\\|Advance.System Care|DriverUpdate\\|PC Repair\\|VLCStreamer|easyxplore|Online Special Application|MyPc Doctor|KMPFaster|SearchGo\\|Uniblue\\|ClaraUpdater|WinZip Malware|MPC AdClean|PasswordBoss|ScreenSnapshot|WeatherTool|DNS.?Unlocker|UnicoBrowser|Cinema.?P" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $FILE , "(?i)Roaming\\\w+.cmd|Maintenance.vbs|\\pythonw?\.exe|mshandler.exe|ChromiumUpdate.exe|\\ProgramData\\Oracle\\Java\\java\.exe|\\AdvancedWindowsManager|sptools\.exe|\\PC Cleaner\\|ProgramData\\wow64|Service2WS|\\WinStartYou|\\MsCloud\\|\\Segurazo\\|TidyNetwork|\\Inno Setup\\Updater\\InnoUPD|\\Driver Support|\\BRTSvc\\|\\CPU Guardian|\\precomp\.exe|NativeDesktopMediaService|\\wget\\wget|\\Host App Service|\\Main Services\\|My System Mechanic|\\AppData\\.+\\jaureg.exe|ProgramData\\[^\\]+\.(exe|vbs|bat|scr|ps1)|\\(SyncTask|tools_update|winwb)\.exe|\\Mail.Ru|\\wintools\\|360bizhi\\ScreenUp|\\FilterStart|\\FixIt\\|\\Microleaves|\\YoutubeAdBlock|\\MIO\\MIO.exe|\\PrefsSecure\\|\\BikaQ|\\MarvelSound\\|\\GEN\\GEN.exe|\\updengine.exe|\\ParetoLogic\\|LuDaShi|\\UCBrowser\\|Roaming\\UPUpdata|\\WinFix|Right Backup|ElastiMotio68|QQBrowser|\\OtherSearch" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $FILE , "(?i)SeeWords|\\BoBrowser|\\CPlus\.|Portable Weather|\\Reg Pro Cleaner|\\SecurityUtility|\\user extensions|\\FlashBeat|iYogi|\\Runner\.exe|\\shopperz|\\GetPrivate|\\PrivateVPN|Pay-By-Ads|\\pennybee|\\Video.?Saver|\\TVWizard|\\SearchProtect|\\Flowsurf\\|\\trusted publisher\\|\\TotalPlus|\\GetPrivate|\\Total-\d|\\UpdateProc\\UpdateTask.exe|\\DownloadManager\\|\\videos.?Media.?Play|\\WinSTAT\\WinSTAT|TheFreeHD|plusapp.exe|Radio.?Canyon|Desktop\\Install|Browsers Apps|\\Information\\|\\HQ.?Pure|\\Ge.Force\\|\\SavePass|\\HomeTab\\|\\HQual2|\\Goobzo\\|gigglinggamesSA|\\[a-z]{2}.(enabler|booster)|gameflakeSA|pcdapp|\\HQVid|Webinternetsecurity|Optimizer Elite|\\fr?[ie]+v\s*en|media enhance|\\MyPC Backup|Roaming.+googleupd.exe|Shopper.?Pro|AnyProtect|FREEzeFrog|OfferBox|\\GCC\\|\\AppLow\\|\\DP\d+\\|VooMuu" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $COMM , "(?i)\b(shutdown|REGSVR32|rundll32|mshta|wscript|cmd|msiexec|powershell|conhost|curl)\b" )
					Select
					Case StringInStr ( $COMM1 , "(?i)\temp\" )
						$ATTEN = " <==== " & $UPD1
					Case StringRegExp ( $COMM , "(?i)\bconhost\b" ) And StringRegExp ( $COMM1 , "\bpowershell\b" )
						$ATTEN = " <==== " & $UPD1
					Case StringRegExp ( $COMM , "(?i)\bpowershell\b" ) And StringRegExp ( $TASKNAME , "^WC" )
						$ATTEN = " <==== " & $UPD1
					Case StringRegExp ( $COMM , "(?i)\bmshta\b" ) And StringInStr ( $COMM1 , "WScript" )
						$ATTEN = " <==== " & $UPD1
					Case StringRegExp ( $COMM , "(?i)\bpowershell\b" ) And ( StringRegExp ( $COMM1 , "(?i)Optimizer.ps1|-commAND.+icM.+sCRiptBloCk|(Windows|Users\\[^\\]+)\\\w+.ps1|\\updater.ps1|-w hidden -nop -enc|\.mp3\b|Browser\s*Assistant|Replace\(|Text.Encoding.+GetString|NvWinSearchOptimizer|\\Framework\\|GoogleCrashHandler(|64).exe|-NoProfile\s+-NoExit|ProgramData\\installer\\|tmp.ps1|(-\w+){2,}.ps1|(HKU|HKCU):|PrintWorkflowService|WindowsUpdater|function Local:|EncodedCommand|PrivacyBlockerWindows""|Roaming\\[^\\]+\\[^\\]+\.ps1" ) Or StringRegExp ( $TASKNAME , "_PR" ) )
						$ATTEN = " <==== " & $UPD1
					Case StringRegExp ( $COMM1 , "(?i)/quiet /i ""\\AppData\\Roaming\\[^\\]+\\[^\\]+.msi""" )
						$ATTEN = " <==== " & $UPD1
					Case StringRegExp ( $COMM1 , "(?i)h..p(|s)://.+scrobj.dll" )
						$ATTEN = " <==== " & $UPD1
					Case StringInStr ( $COMM , "wscript" ) And StringRegExp ( $COMM1 , "(?i)\\(RealtekUpdate|Edge).vbs|System.Text.Encoding|\.txt|:\\ProgramData\\\w{12,}\\\w+.\.wsf|\.js /b|nologo.+date.vbs|GEO-EN~1.JS|Geo-environmental Engineering.JS" & "|\\" & @UserName & ".vbs" )
						$ATTEN = " <==== " & $UPD1
					Case StringInStr ( $COMM , "wscript" ) And StringRegExp ( $COMM1 , "(?i)\\task\.vbs" ) And Not StringRegExp ( $COMM1 , "(?i)Program Files" )
						$ATTEN = " <==== " & $UPD1
					Case StringRegExp ( $COMM , "(?i)(\S|^)\b(explorer|msiexec)\b" ) And StringRegExp ( $COMM1 , "(?i)h..p(|s)://" )
						$ATTEN = " <==== " & $UPD1
					Case StringRegExp ( $COMM , "(?i)(\S|^)\b(cmd|curl)\b" ) And StringRegExp ( $COMM1 , "(?i)\bcmd\b|shutdown|h..p(|s)://|powershell|\\\w+\.bat\b|UpdateDeviceTask|%temp%|HKLM:" ) And Not StringRegExp ( $COMM1 , "(?i)silcollector" )
						$ATTEN = " <==== " & $UPD1
					Case StringRegExp ( $TASKNAME , "^[a-z 0-9]{32}$" ) And StringRegExp ( $COMM1 , $TASKNAME )
						$ATTEN = " <==== " & $UPD1
					Case StringRegExp ( $COMM1 , "(?i)\\SQLAGENTIHC.exe|ProgramData\\[^\\]+\.(ps1|dll)|cloudfront.net/|\\psgo.ps1|Program Files.+\\\w{6}.dll"",e62dc6c6547f46bda862da2d05af6862|Microsoft\\Internet Explorer\\[^\\]+\.dll|FindMeSavings|\\Temp(\\|/)|explorer(.exe|) ""?http:|-nologo -executionpolicy byp|-windowstyle hidden -noprofile|Shopper.?Pro|SearchProtect|TVWizard|omiga.?plus|webssearches|TheTorntv|WinZipper|AnyProtectEx|Softonic|SearchModule|PastaLeads|/s /n /i:""/rt""|\.ini""?$" )
						$ATTEN = " <==== " & $UPD1
					Case StringRegExpReplace ( $COMM1 , "\W" , "" ) = $TASKNAME
						$ATTEN = " <==== " & $UPD1
					Case StringRegExp ( $COMM1 , $TASKNAME & "(?i)\.ps1" )
						$ATTEN = " <==== " & $UPD1
					Case StringInStr ( $COMM , "Rundll32" )
						Select
						Case StringRegExp ( $COMM1 , "(?i)Program Files.+Program Files" ) And Not StringRegExp ( $COMM1 , "(?i)\\Stardock\\" )
							$ATTEN = " <==== " & $UPD1
						Case StringRegExp ( $COMM1 , "(?i)ProgramData\\.+\.dll\s*,?[a-zA-Z]+$|Common Files\\.+\.dll"",[a-zA-Z]+$" )
							$ATTEN = " <==== " & $UPD1
						Case StringRegExp ( $COMM1 , "(?i)\\Update_[^\\]+\.dll|\\windows\\debug\\|\\WindSync\\|dll"",#1$|\.dat\b" )
							$ATTEN = " <==== " & $UPD1
						Case StringRegExp ( $COMM1 , "(?i)ProgramData\\" & $TASKNAME & "\\" & $TASKNAME & "\.dll" )
							$ATTEN = " <==== " & $UPD1
						Case StringRegExp ( $COMM1 , "(?i)(winscomrssrv|StartupCheckLibrary)\.dll" )
							$ATTEN = " <==== " & $UPD1
						Case StringRegExp ( $TASKNAME , "(?i)Update Service for|\w{8}-\w{4}-\w{4}-\w{4}-\w{12}" ) And StringRegExp ( $COMM1 , "(?i)Program Files[^\\]*\\[^\\]+u\\\w+\.dll" )
							$ATTEN = " <==== " & $UPD1
						Case StringRegExp ( $COMM1 , "(?i)" & $TASKNAME & "\\\w?Bin\\" & StringRegExpReplace ( $TASKNAME , " " , "" ) & ".dll" )
							$ATTEN = " <==== " & $UPD1
						Case StringRegExp ( $COMM1 , "(?i)AppData\\Local\\" & StringRegExpReplace ( $TASKNAME , "2$" , "" ) & "\\{.+?}\\.+?,#1" )
							$ATTEN = " <==== " & $UPD1
						Case StringRegExp ( $TASKNAME , "V2" ) And StringRegExp ( $COMM1 , "dll,main 7 1" )
							$ATTEN = " <==== " & $UPD1
						Case StringRegExp ( $COMM1 , "(?i).+Program Files[^\\]*\\" & StringRegExpReplace ( $TASKNAME , "-(?i)dll" , "" ) & "\\.+\.dll" )
							$ATTEN = " <==== " & $UPD1
						Case StringRegExp ( $TASKNAME , StringRegExpReplace ( $COMM1 , "(?i).+Program Files\\(.+?)\\.+" , "$1" ) ) And StringRegExp ( $COMM1 , "(?i)\.dll"",w" )
							$ATTEN = " <==== " & $UPD1
						EndSelect
					Case StringInStr ( $COMM , "regsvr32" ) And StringRegExp ( $TASKNAME , "\w{8}-\w{4}-\w{4}-\w{4}-\w{12}" ) And StringRegExp ( $COMM1 , "(?i)/n /s /i:.+/q.+\\AppData" )
						$ATTEN = " <==== " & $UPD1
					Case StringInStr ( $COMM , "regsvr32" ) And StringInStr ( $COMM1 , "scrobj" )
						$ATTEN = " <==== " & $UPD1
					EndSelect
				EndSelect
				$COMM1 = StringRegExpReplace ( $COMM1 , "(?i)http(s|):" , "hxxp\1:" )
				If StringLen ( $COMM1 ) > 300 Then $COMM1 = StringTrimRight ( $COMM1 , StringLen ( $COMM1 ) + 4294966996 ) & " (" & $DATAX & " " & StringLen ( $COMM1 ) + 4294966996 & " " & $DATAY & ")."
				If FileExists ( $FILE ) Then
					$SIGN = ""
					$VAR = " [" & $SIZE & " " & $CDATE & "]" & $COMPANY
					If $SIZE > 629145600 Or StringRegExp ( $COMPANY , "(?i)SweetLabs|Pokki|\] \[" ) Then $ATTEN = " <==== " & $UPD1
				EndIf
				If Not $FILE Then $FILE = $COMM & " "
				If StringRegExp ( $COMM1 , "(?i):\\|%.+%|\bhxxp(|s):|\bwww\.|\.(dll|exe|bat|vbs)\b" ) Or StringRegExp ( $COMM , "(?i)\b(schtasks|shutdown|wevtutil|vssadmin|wmic|wusa|Regsvcs|RegAsm|REGSVR|REGSVR32|rundll32|sc|pcalua|cscript|mshta|regedt32|regedit|wscript|cmd|sllauncher|msiexec|powershell|launchwinapp|reg|conhost)\b" ) Then
					$VAR = $VAR & " -> " & $COMM1
				Else
					If Not FileExists ( $FILE ) And Not _CREATEFILE ( $FILE ) Then $VAR = $VAR & " " & $COMM1 & " (" & $REGIST8 & ")"
				EndIf
				If Not FileExists ( $FILE ) Then $FILE = $COMM & " "
				If _CREATEFILE ( $FILE ) Then $VAR = $VAR & " " & $COMM1 & " (" & $NOACC & ") <==== " & $UPD1
				If StringRegExp ( $VAR , "Roaming\\Service.*\\.+\.dat\b" ) Then $ATTEN = " <==== " & $UPD1
				If StringRegExp ( $FILE , "(?i)\.vbs\b" ) And StringRegExp ( $VAR , "(?i)\.lnk\b" ) Then $ATTEN = " <==== " & $UPD1
				If StringRegExp ( $VAR , "(?i)\.(chm|.txt)\b|:\\systemfile" ) Then $ATTEN = " <==== " & $UPD1
				_ARRAYADD ( $ARRTASK , "Task: " & $TASK & " - " & $SUB & " => " & $FILE & StringRegExpReplace ( $VAR , "\s{2}" , " " ) & $ATTEN , 0 , "|||" )
			Else
				$COMHAND = StringRegExp ( $RTASK , "(?is)ComHandler>(.+?)</ComHandler" , 1 )
				If IsArray ( $COMHAND ) Then
					$COMH = StringRegExp ( $COMHAND [ 0 ] , "(?i)ClassId>(.+?)</ClassId" , 1 )
					If IsArray ( $COMH ) Then
						$COMH = $COMH [ 0 ]
						$COMH = StringRegExpReplace ( $COMH , "^(A9A33436-678B-4c9c-A211-7CC38785E79D|752073A1-23F2-4396-85F0-8FDB879ED0ED)$" , "{$1}" )
						$KEY1 = "HKCR\CLSID\" & $COMH
						If $BOOTM = "Recovery" Then $KEY1 = "HKLM\" & $SOFTWARE & "\Classes\CLSID\" & $COMH
						$VDATA = RegRead ( $KEY1 & "\InprocServer32" , "" )
						If StringInStr ( $VDATA , "mscoree.dll" ) Then MSCOREE ( $KEY1 & "\InprocServer32" , $VDATA )
						$TYPELIB = ""
						If Not $VDATA Then $VDATA = RegRead ( $KEY1 & "\localserver32" , "" )
						If Not $VDATA Then
							$LOVALSR = ""
							$APPID = RegRead ( $KEY1 , "AppID" )
							If Not @error Then
								$LOVALSR = RegRead ( "HKCR\AppID\" & $APPID , "LocalService" )
								If @error Then
									$VDATA = RegRead ( "HKCR\AppID\" & $APPID , "DllSurrogate" )
								Else
									$VDATA = RegRead ( "hklm\" & $SYSTEM & $BOOTSYSTEM & $DEF & "\Services\" & $LOVALSR & "\Parameters" , "ServiceDll" )
									If @error Then $VDATA = RegRead ( "hklm\" & $SYSTEM & $BOOTSYSTEM & $DEF & "\Services\" & $LOVALSR , "ServiceDll" )
									If @error Then $VDATA = RegRead ( "hklm\" & $SYSTEM & $BOOTSYSTEM & $DEF & "\Services\" & $LOVALSR , "ImagePath" )
								EndIf
								$TL = RegRead ( $KEY1 & "\TypeLib" , "" )
								If Not @error Then
									$TYPELIB = RegRead ( "HKCR\TypeLib\" & $TL & "\1.0\0\Win32" , "" )
									If @error Then $TYPELIB = RegRead ( "HKCR\TypeLib\" & $TL & "\1.0\0\Win64" , "" )
								EndIf
							EndIf
						EndIf
						If $TYPELIB Then
							$FILE = $TYPELIB
							AAAAFP ( )
							If $BOOTM = "Recovery" Then
								$RANGE = "Microsoft Corp"
							Else
								$RANGE = "Microsoft (Windows|Corporation).* -> "
							EndIf
							If FileExists ( $FILE ) Then
								$VAR = $FILE & " [" & $SIZE & " " & $CDATE & "]" & $COMPANY
							Else
								$VAR = $VDATA & " (" & $REGIST8 & ")"
								If _CREATEFILE ( $FILE ) Then $VAR = $VDATA & " (" & $NOACC & ") <==== " & $UPD1
							EndIf
							If StringRegExp ( $COMPANY , $RANGE ) And Not StringInStr ( $COMPANY , "[" ) And $WHITE And StringRegExp ( $FILE , "(?i):\\Windows\\system32\\WaaSMedicPS\.dll" ) Then
							Else
								_ARRAYADD ( $ARRTASK , "Task: " & $TASK & " - " & $SUB & " => " & $COMH & " " & $VAR & $ATTEN , 0 , "|||" )
							EndIf
						EndIf
						If $VDATA Then
							$FILE = $VDATA
							AAAAFP ( )
							If $BOOTM = "Recovery" Then
								$RANGE = "Microsoft Corp"
							Else
								$RANGE = "Microsoft (Windows|Corporation).* -> "
							EndIf
							If StringRegExp ( $COMPANY , $RANGE ) And Not StringInStr ( $COMPANY , "[" ) And $WHITE Then
								Select
								Case StringRegExp ( $FILE , "(?i):\\Windows\\system32\\(IntelligentPwdlessTask|CmCleanup|EcoScoreTask|PowerGridForecastTask|Windows.SharedPC.AccountManager|PerformanceTraceHandler|WaaSMedicSvc|AppListBackupLauncher|wuaueng|LanguageOverlayServer|profsvc|UpdatePolicy|unifiedconsent|WlanMediaManager|netprofm|SettingsHandlers_Pen|CloudRestoreLauncher|Autopilot|PrinterCleanupTask|AppListBackupLauncher|Themes.SsfDownload.ScheduledTask|MitigationClient|CoreGlobConfig|InputCloudStore|MBMediaManager|Windows.UI.Immersive|RDXTaskFactory|wuautoappupdate|dsregtask|WpcWebSync|twinapi|WSService|BthSQM|pnpclean|msched|DfpCommon|apprepsync|netcfgx|TMM|QAgent|wpcumi|AuxiliaryDisplayServices|kernelceip|RacEngn|wpcmig|memdiag|perftrack|HotStartUserAgent|cscui|srmclient|ngctasks|InstallServiceTasks|wininet|DeviceDirectoryClient|WpcRefreshTask|DeviceSetupManagerAPI|discan|sysmain|edptask|dimsjob|SettingSyncCore|WorkFoldersShell|mapsupdatetask|energytask|TpmTasks|usbceip|rasmbmgr|sppcext|mapstoasttask|MitigationConfiguration|srchadmin|MsCtfMonitor|wdc|WofTasks|fcon|UsbTask|wdi|wosc|regidle|ReAgentTask|TempSignedLicenseExchangeTask|msdrm|mscms|pstask|MemoryDiagnostic|LanguageComponentsInstaller|pnpui|TimeSyncTask|pnppolicy|WinSATAPI|PlaySndSrv|sdiagschd|StorageUsage|fhtask|WiFiCloudStore|AppLockerCsp|BthTelemetry)\.dll" )
									ContinueLoop
								Case StringRegExp ( $FILE , "(?i):\\Windows\\system32\\(ReFsDedupSvc|CloudExperienceHostBroker|TieringEngineService|skydrive)\.exe" )
									ContinueLoop
								Case StringRegExp ( $FILE , "(?i):\\Windows\\Microsoft.NET\\Framework64\\[^\\]+\\ngentasklauncher\.dll" )
									ContinueLoop
								Case StringRegExp ( $FILE , "(?i):\\Windows\\System32\\IME\\shared\\imecfm\.dll" )
									ContinueLoop
								Case StringRegExp ( $FILE , "(?i):\\Windows\\winstore\\WinStoreUI\.dll" )
									ContinueLoop
								Case StringRegExp ( $FILE , "(?i):\\Windows\\servicing\\TrustedInstaller.exe" )
									ContinueLoop
								Case StringRegExp ( $FILE , "(?i):\\Windows\\system32\\oobe\\(UserOOBE|SetupCleanupTask)\.dll" )
									ContinueLoop
								EndSelect
							EndIf
							If FileExists ( $FILE ) Then
								If StringRegExp ( $FILE , "(?i)(shell32|shdocvw)\.dll" ) Then
									$DATA = SHELLTARGET ( $KEY1 & "\Instance\InitPropertyBag" )
									If $DATA Then
										$FILE = $FILE & " -> " & $DATA
									Else
										If StringRegExp ( $COMPANY , $RANGE ) And Not StringInStr ( $COMPANY , "[" ) And $WHITE Then ContinueLoop
									EndIf
								EndIf
								$VAR = $FILE & " [" & $SIZE & " " & $CDATE & "]" & $COMPANY
							Else
								$VAR = $VDATA & " (" & $REGIST8 & ")"
								If _CREATEFILE ( $FILE ) Then $VAR = $VDATA & " (" & $NOACC & ") <==== " & $UPD1
							EndIf
							_ARRAYADD ( $ARRTASK , "Task: " & $TASK & " - " & $SUB & " => " & $COMH & " " & $VAR & $ATTEN , 0 , "|||" )
							ContinueLoop
						Else
							If StringRegExp ( $TASKNAME , "(?i)^(?:SmartScreenSpecific|BgTaskRegistrationMaintenanceTask|(Enable|)ErrorDetailsUpdate|BindingWorkItemQueueHandler|Plug and Play Cleanup|FamilySafetyMonitorToastTask)$" ) And $WHITE Then ContinueLoop
							_ARRAYADD ( $ARRTASK , "Task: " & $TASK & " - " & $SUB & " => " & $COMH , 0 , "|||" )
							ContinueLoop
						EndIf
					EndIf
				EndIf
				$TASK = StringRegExpReplace ( $TASK , $C & "\\Windows\\" , "" )
				FileWrite ( $FRSTLOG , "Task: " & $SUB & " - " & $TASK & @CRLF )
			EndIf
		Else
			RegRead ( $KEY & "\" & $SUB , "" )
			If @error = 1 Then
				FileWrite ( $FRSTLOG , "Task: " & $SUB & " - " & $NOACC & ". <==== " & $UPD1 & @CRLF )
			Else
				FileWrite ( $FRSTLOG , "Task: " & $SUB & " - " & $NO & " " & $FPAD & ". <==== " & $UPD1 & @CRLF )
			EndIf
		EndIf
	WEnd
	_ARRAYSORT ( $ARRTASK , 0 , 1 )
	For $T = 1 To UBound ( $ARRTASK ) + 4294967295
		$TT = $ARRTASK [ $T ]
		$TT = StringRegExpReplace ( $TT , "(?i)Task: (System32\\Tasks.+?) - (\{[^}]+\})( =>.*)" , "Task: $2 - $1$3" )
		FileWrite ( $FRSTLOG , $TT & @CRLF )
	Next
	$ARRTASK = ""
	If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
EndFunc
Func _AAATARG ( $ARGU )
	$COMM1 = StringRegExp ( $ARGU , "(?is)<Arguments>(.+?)</Arguments" , 1 )
	If Not IsArray ( $COMM1 ) Then Return ""
	If StringRegExp ( $ARGU , "(?is)</Arguments>\R+\s*<WorkingDirectory>" ) Then
		$WD = StringRegExp ( $ARGU , "(?is)</Arguments>\R+\s*<WorkingDirectory>(.*)</WorkingDirectory>" , 1 )
		If IsArray ( $WD ) Then
			Return CONV ( $WD [ 0 ] & "\" & $COMM1 [ 0 ] )
		EndIf
	EndIf
	Return CONV ( $COMM1 [ 0 ] )
EndFunc
Func _AAAATJ ( )
	FileWrite ( $FRSTLOG , @CRLF & "(" & $TASKS1 & ")" & @CRLF & @CRLF )
	$FILEARRAY = _FILELISTTOARRAY ( $WINDOWSDIR & "\Tasks" , "*.job" , 1 , 1 )
	For $I = 1 To UBound ( $FILEARRAY ) + 4294967295
		$ATTEN = ""
		$TASK = $FILEARRAY [ $I ]
		If _REPARSEPOINT ( $TASK ) Then
			$FILE = "[" & $SYMLINK0 & " ->] " & _GETREPARSETARGET ( $TASK )
		Else
			$HTASK = FileOpen ( $TASK , 16 )
			$FILE = FileRead ( $HTASK )
			FileClose ( $HTASK )
			If StringLeft ( $FILE , 2 ) = "0x" Then $FILE = _UNITOST2 ( $FILE )
			$FILE = StringRegExpReplace ( $FILE , """" , "" )
			$FILE = StringRegExpReplace ( $FILE , "(?s).+?(.:\\.+)" , "$1" )
			If StringRegExp ( $FILE , "(?i)iexplore\.exe|firefox\.exe|opera\.exe|chrome\.exe" ) Then
				$FILE = StringRegExpReplace ( $FILE , "(?s).*?(.:\\.+/).+" , "$1" )
				$FILE = StringRegExpReplace ( $FILE , "(?s)<|\[" , " " )
				$FILE = StringRegExpReplace ( $FILE , "(?i).:\\program.+?\\Internet Explorer\\iexplore.exe" , "Iexplore.exe" )
			Else
				$FILE = StringRegExpReplace ( $FILE , "(?is).*?(.:\\.+\.[a-z]{2,3}).+" , "$1" )
				$FILE = StringRegExpReplace ( $FILE , "(?s)(.:\\.+?)(\W+)(.:\\.+)" , "$1 $3" )
			EndIf
			$FILE = StringRegExpReplace ( $FILE , "(?i)\wC:\\" , " C:\\" )
			$FILE = StringRegExpReplace ( $FILE , "(?i).:\\Windows\\system32\\rundll32.exe" , "rundll32.exe " )
			$FILE = StringRegExpReplace ( $FILE , "(?i).:\\Windows\\.+?wscript.exe" , "Wscript.exe " )
			$FILE = StringRegExpReplace ( $FILE , "(?i).:\\Windows\\system32\\reg.exe" , "reg.exe " )
			$FILE = StringRegExpReplace ( $FILE , "(?i).:\\Windows\\.+?\\WindowsPowerShell\\.+?powershell.exe" , "powershell.exe" )
			$FILE = StringRegExpReplace ( $FILE , "//" , "/" )
			If Not StringRegExp ( $FILE , ".:\\.+" ) Then
				$FILE = StringRegExpReplace ( $FILE , "[^\w\\/?]" , " " )
				$FILE = StringRegExpReplace ( $FILE , "(?<!/)\b[\d\D]\b" , " " )
				$FILE = StringRegExpReplace ( $FILE , "\s{2,}" , " " )
				$FILE = StringRegExpReplace ( $FILE , "^\s+|\s+$" , "" )
			EndIf
		EndIf
		$TASKNAME = StringRegExpReplace ( $TASK , "(?i).+\\Tasks\\(.+)\.job" , "$1" )
		$TASKNAME1 = StringRegExpReplace ( $TASKNAME , "([a-zA-Z]+?) .+" , "$1" )
		$PROG = ""
		If StringInStr ( $FILE , "\Program Files" ) Then $PROG = StringRegExpReplace ( $FILE , "(?i).+?\\Program Files[^\\]*\\(.+?)\\.+" , "\1" )
		Select
		Case StringRegExp ( $TASKNAME , "\w{8}-\w{4}-\w{4}-\w{4}-\w{12}" ) And StringInStr ( $FILE , "updtask.exe" )
			$ATTEN = " <==== " & $UPD1
		Case StringRegExp ( $TASKNAME , "(?i)Update Service for|\w{8}-\w{4}-\w{4}-\w{4}-\w{12}" ) And StringRegExp ( $FILE , "(?i)Program Files[^\\]*\\[^\\]+u\\\w+\.dll" )
			$ATTEN = " <==== " & $UPD1
		Case StringRegExp ( $FILE , $C & "\\" & $TASKNAME & $TASKNAME & "\\" & $TASKNAME & "\.(?i)vbs" )
			$ATTEN = " <==== " & $UPD1
		Case StringRegExp ( $FILE , "(?i)Rundll32.+ProgramData\\" & $TASKNAME & "\\" & $TASKNAME & "\.dll" )
			$ATTEN = " <==== " & $UPD1
		Case StringRegExp ( $FILE , "(?i)\\Program Files(| \(x86\))\\[^\\]+\.exe" )
			$ATTEN = " <==== " & $UPD1
		Case StringRegExp ( $FILE , "(?i)\\home\\" & $TASKNAME & "\.exe" )
			$ATTEN = " <==== " & $UPD1
		Case StringRegExp ( $TASKNAME , "(?i)Update Service for" )
			$TASKNAME2 = StringRegExpReplace ( $TASKNAME , "(?i)Update Service for (.+)" , "$1" )
			If StringRight ( $TASKNAME2 , 1 ) = 2 Then $TASKNAME2 = StringTrimRight ( $TASKNAME2 , 1 )
			If StringRegExp ( $FILE , "(?i)\\Program Files(| \(x86\))\\" & $TASKNAME2 & "\\\w{7}\.(?i)exe" ) Then $ATTEN = " <==== " & $UPD1
		Case Not StringRegExp ( $PROG , "^$|(?i)SyncFolders" ) And StringRegExp ( $TASKNAME , $PROG & " (Task|Schedualer|Viewer|Service|Cleaner|Job|Uninstaller)" ) And ( StringRegExp ( StringRegExpReplace ( $FILE , "\s" , "" ) , "(?ix):\\ProgramFiles.*?\\" & $PROG & "\\" & $PROG & "\.exe" ) Or StringRegExp ( $FILE , "(?i)\\Program Files[^\\]*\\" & $PROG & "\\[^\\]+(task|worker|job)\.exe" ) )
			$ATTEN = " <==== " & $UPD1
		Case StringRegExp ( $FILE , "(?i)Rundll32.+" & $TASKNAME & "\\\w?Bin\\" & StringRegExpReplace ( $TASKNAME , " " , "" ) & ".dll" )
			$ATTEN = " <==== " & $UPD1
		Case StringRegExp ( $TASKNAME , "^[a-z]{3,4}\d{4}$" ) And StringRegExp ( $FILE , "(?i)\\" & $TASKNAME & "\.exe" )
			$ATTEN = " <==== " & $UPD1
		Case StringRegExp ( $FILE , "Roaming\\Microsoft\\Windows\\IEUpdate\\" & $TASKNAME & "\.exe" )
			$ATTEN = " <==== " & $UPD1
		Case StringRegExp ( $FILE , "(?i)\\Program Files[^\\]*\\" & $TASKNAME & "\\" & $TASKNAME & "\\Application\\" )
			$ATTEN = " <==== " & $UPD1
		Case StringRegExp ( $FILE , "(?i).+Program Files[^\\]*\\" & $TASKNAME1 & "\\[^\\]*ta?sk\.exe" ) And Not StringInStr ( $TASKNAME1 , "SUPERAntiSpyware" )
			$ATTEN = " <==== " & $UPD1
		Case StringRegExp ( $TASKNAME , "\w{8}-\w{4}-\w{4}-\w{4}-\w{12}" ) And StringRegExp ( $FILE , "(?i)AppData\\(Roaming|Local)\\(Price.+?|{?\w{8}-\w{4}-\w{4}-\w{4}-\w{12}}?|.+?~1\\)" )
			$ATTEN = " <==== " & $UPD1
		Case StringRegExp ( $TASKNAME , "^DNS" ) And StringRegExp ( $FILE , "(?i)\\Program Files[^\\]*\\DNS .+?\\" & $TASKNAME & "\.exe" )
			$ATTEN = " <==== " & $UPD1
		Case StringRegExp ( $FILE , FileGetLongName ( EnvGet ( "AppData" ) ) & "\\Microsoft\\Windows\\IEUpdate\\" & $TASKNAME & "\.exe" )
			$ATTEN = " <==== " & $UPD1
		Case StringRegExp ( $FILE , FileGetLongName ( EnvGet ( "AppData" ) ) & "\\" & $TASKNAME & "\.exe" )
			$ATTEN = " <==== " & $UPD1
		Case StringRegExp ( $FILE , "(?i)\\ProgramData\\(.+?)\\\1.exe|\\temp\\" )
			$ATTEN = " <==== " & $UPD1
		Case StringRegExp ( $FILE , "(?i)\\(ProgramData|Roaming)\\[^\\]+?\.exe" ) And $TASKNAME <> "MakeMarkerFile"
			$ATTEN = " <==== " & $UPD1
		Case StringRegExp ( $FILE , "(?i)\\ProgramData\\" & $TASKNAME & "\\1\.0\.1\.0\\" )
			$ATTEN = " <==== " & $UPD1
		Case StringRegExp ( $FILE , "(?i)\\SysWOW64\\drivers\\[^\\]+?\.exe" )
			$ATTEN = " <==== " & $UPD1
		Case StringRegExp ( $FILE , "(?i)\\ProgramData\\\{.+?-.+?\}\\.+" )
			$ATTEN = " <==== " & $UPD1
		Case StringRegExp ( $FILE , "(?i)(\\Program Files\\Common Files\\\w{8}\\\w{13}\.exe|/rt.+\.dll)" )
			$ATTEN = " <==== " & $UPD1
		Case StringRegExp ( $FILE , "(?i)Wscript.exe.+\.ini" )
			$ATTEN = " <==== " & $UPD1
		Case StringRegExp ( $FILE , "(?i)\\Program Files[^\\]*\\(.+?)_\d+\.\d+\.\d+\.\d+\\Update\\\1AutoUpdateClient\.exe" )
			$ATTEN = " <==== " & $UPD1
		Case StringRegExp ( $FILE , "(?i)\\Program Files[^\\]*\\[^\\]+Browser\\[^\\]+\\bin\\[^\\]+Server.exe" )
			$ATTEN = " <==== " & $UPD1
		Case StringRegExp ( $TASKNAME , "(?i)Google" ) And Not StringRegExp ( $FILE , "(?i)(GoogleUpdate|GooglePinyinDaemon|googledrivesync)\.exe" )
			$ATTEN = " <==== " & $UPD1
		Case StringRegExp ( $FILE , "(?i)progra.+\\[a-z]+\.bat" ) And StringRegExp ( $TASKNAME , "(?i)[a-z]+" ) And Not StringRegExp ( $FILE , "(?i)\\(DriverSetupUtility|ATP DIGITAL)\\" )
			$ATTEN = " <==== " & $UPD1
		Case StringRegExp ( $TASKNAME , "\w{8}-\w{4}-\w{4}-\w{4}-\w{12}" ) And StringRegExp ( $FILE , "(?i)(\w{8}-\w{4}-\w{4}-\w{4}-\w{12}|-nova|-code)[^\\]*\.exe" )
			$ATTEN = " <==== " & $UPD1
		Case StringRegExp ( $TASKNAME , "(?i)MetaCrawler|nslooksvc\d\d|^Mysa\d*|^PCSpeedRepair|^Registry Scanner|^Y2Go|CatalinaGroup|SoftPlanet|PC\s?Clean\s?Plus|^Advanced.PC.Care|^WebDiscover|HDWallPaper|Youtube AdBlock|^SoftUpgrade|^nerta|RenewalService|^Unregister" )
			$ATTEN = " <==== " & $UPD1
		Case StringRegExp ( $TASK , "(?i)\\Sparta|\\Update Task|ChelfNotify|\\Realtek HD Audio$|UCBrowser|MyPC Backup|ComputerZ|\\AdBlock|ttwifi|\\PED_|\\Input Updater|\\TaoTong|\\osTip|\\PPTAssistant|\\KuaiZip|\\Uncheckit|ByteFence|Distromatic|ProfessionalCleaning|System.?Healer|Go.?Palikan|\\DriverRestore|\\IBUpd|\\RSPro|\\One.?System.?Care|\\MixVideoPlayer|19F8DB95-4D78-4ddb-AC71-C610654FE37F|\\WindowsUpda2ta|LuckyBrowse|\\Web Protector|DailyPCClean|\\MAXDriver|\\AION|\\psv_|Files Update Ver|\\WarThunder|\\RestoreSearch|6A128791-4857-4484-9BB2-71D4C1257200|ToolsUpdatePlatform|2A6A6C0A-6DF1-4478-807F-2FF9BF46B935|\\IT Viewer|\\MyBrowser|\\WordWizard|\\TunePro360|\\WinThruster|\\PhraseProfesso|\\TweakBit|\\EssentialUpdateMachine|\\Winupdate|\\Wsutil Update|\\nethost|PCKeeper|\\IneedSpeed|\\Magnet Downloade|\\StartPoint|MaxCompute|\\WinFix|Right Backup|MaxCompute|\\gameo|\\Selection.?Tool|\\WebBar|\\HDNINSTSCHD|\\Launch \d|\\DoctorPC|\\Update\\|\\Gamma Task|\\MdmUpdateTask|System Optimizer|\\RunTool|\\AFC Secure Net|\\GeniusBox|\\Bidaily Synchronize|\\LaunchPreSignup|\\iren3006|\\NetEngine|_(updating|notification|helper)_service|\\Maxiget|\\Mext Guard|\\Safe Saver|\\Get Plus|\\ZenSearch|\\ProPCCleaner|\\Safer Browser|\\Jelbrus|\\mcleaner|\\Malware Cleaner|\\Binkiland|\\TheSettlersOnline|PastaQuotes|\\Pirates|\\StormFall|\\SBWUpdateTask|\\VeriBrowse|\\SYSTEM(DOWN|UP)$|\\SmartWeb|\\AgSupport|Super Optimizer|\\Vosteran|\\GoodGameEmpire|\\SrvDaily|\\Price.?Horse|\\YTDownloader|\\SMupdate|\\Windows Update Check - 0x|\\FSSUpdaterService|AppCloudUpdater|\\SystemMedia|\\Weather It|\\MySearchs|Tasks\\SYSTEM\.job|WindApp Update|Default.?Check|Default.?Reg|CloudScout" )
			$ATTEN = " <==== " & $UPD1
		Case StringRegExp ( $TASK , "(?i)BrowserProtect|OnlineIO|\\WordShark|\\Run_Bobby|\\SPMupdate|\\Reimage|\\WOT |SpeeditUp|fsupdate|LuckyTab|InfiniteCrisis|EPUpdater|\\PC Help|\\Software Updater|\\SpeedChecker|\\Chrome Launcher|EnergoTech|SPBIW_UpdateTask|\\Driver Pro|\\Loca\\|DiskDiagnostic\\(DiskDiagnostic|Microsoft-Windows-HashDiagnostic)|Secure Fast PC|\\Optimum|Grid Computing|Only.?search|\\(task|Updater)\d+|Yahoo!.?Search|PC.?SpeedUp|best.?markit|\\Shop.?wit|RegClean.?Pro|Bonanza|\\Omiga Plus|\\Upd Inst-S|Groovorio|RocketTab|Express.?Files|\\FF Watcher|Digital.?Site|\\VisualBee|CS Browser Assistant|Idle.*Crawler|ArcadeGiant|\\FF Watcher \{|Playtopus Updater|\\[a-z]{2}.(enabler|booster)|\bBlock.+Surf|FreeFileViewer|SpeedyPC|AppSafe|ErrorEND|RegSERVO|bench.?Updater|VisualBeeRecovery|Speedial|AmiUpdXp|APSnotifier|CodecUpdater|Object.?Browser|pcreg|BlockAndSurf|APSnotifier|PCHelpers|\\DT(Reg|Chk)|Security Center Update - \d+|SystemSockets|Protected Search|Browser Updater|wp_update|De+al.?FR|Safer.?Surf|fr?[ie]+\s*ven|PCHelpers|Video-for-PC-|SpeedUpMy|media enhance|\\De+al_\w{2} |HQ-Video|MediaPlayerEnhance" )
			$ATTEN = " <==== " & $UPD1
		Case StringRegExp ( $FILE , "(?i)\\Microleaves\\|uEngineProcess.exe|Roaming\\Gitl\\" )
			$ATTEN = " <==== " & $UPD1
		EndSelect
		$FILE = StringRegExpReplace ( $FILE , "(?i)http(s|):" , "hxxp\1:" )
		FileWrite ( $FRSTLOG , "Task: " & $TASK & " => " & $FILE & $ATTEN & @CRLF )
	Next
EndFunc
Func _AAAAUS ( )
	If StringInStr ( @ScriptName , "beta" ) Or $CMD1 Then Return
	GUICtrlSetData ( $LABEL1 , $UPD7 & " " & $PW0 )
	$LPATH = $C & "\FRST\logs\"
	If FileExists ( $LPATH & "up64" ) Then FileDelete ( $LPATH & "up64" )
	$UP64 = InetGet ( "http://download.bleepingcomputer.com/farbar/up64" , $LPATH & "up64" , 1 , 0 )
	If Not $UP64 Or Not FileExists ( $LPATH & "up64" ) Then Return _AAAAUSF ( "1" )
	$VER1 = FileRead ( $LPATH & "up64" )
	FileDelete ( $LPATH & "up64" )
	$RET = _GETFILEPRO ( @ScriptDir & "\" & @ScriptName )
	If Not IsArray ( $RET ) Then Return _AAAAUSF ( "2" )
	$VER2 = $RET [ 1 ] [ 4 ]
	$SCNAME = @ScriptName
	If $VER1 And $VER2 And $VER1 <> $VER2 Then
		GUICtrlSetData ( $LABEL1 , $UPD8 & " " & $PW0 )
		FileDelete ( $LPATH & "FRSTupdate" )
		$RET = InetGet ( "http://www.bleepingcomputer.com/download/farbar-recovery-scan-tool/dl/82/" , $LPATH & "FRSTupdate" , 1 , 0 )
		If Not $RET Or Not FileExists ( $LPATH & "FRSTupdate" ) Then Return _AAAAUSF ( "3" )
		$PATH = FileRead ( $LPATH & "FRSTupdate" )
		$PATH = StringRegExp ( $PATH , "(?i)url=(https://download.bleepingcomputer.com/dl/.+/farbar-recovery-scan-tool/FRST64.exe)" , 1 )
		FileDelete ( $LPATH & "FRSTupdate" )
		If Not IsArray ( $PATH ) Then Return _AAAAUSF ( "4" )
		FileDelete ( $LPATH & "FRST64*.exe" )
		InetGet ( $PATH [ 0 ] , $LPATH & "FRST64.exe" , 1 , 0 )
		If Not FileExists ( $LPATH & "FRST64.exe" ) Then Return _AAAAUSF ( "5" )
		DirCreate ( @ScriptDir & "\FRST-OlderVersion" )
		FileMove ( @ScriptDir & "\" & $SCNAME , @ScriptDir & "\FRST-OlderVersion" , 1 )
		FileMove ( @ScriptDir & "\*FRST*.exe" , @ScriptDir & "\FRST-OlderVersion" , 1 )
		FileMove ( $LPATH & "FRST64.exe" , @ScriptDir & "\" & $SCNAME , 1 )
		FileDelete ( $LPATH & "FRST64.exe" )
		GUICtrlSetData ( $LABEL1 , $UPD9 )
		MsgBox ( 262144 + 0 , $FRST , $UPD9 & " " & $READY , 3 )
		ShellExecute ( @ScriptDir & "\" & $SCNAME )
		Exit
	EndIf
	GUICtrlSetData ( $LABEL1 , $READY )
EndFunc
Func _AAAAUSF ( $R )
	$FUPDATE = "Failed to update"
	If StringRegExp ( "0407|0807|0c07|1007|1407" , @MUILang ) Then $FUPDATE = "Fehler beim Aktualisieren"
	MsgBox ( 262144 + 0 , $FRST , $FUPDATE & " (" & $R & ")" )
	GUICtrlSetData ( $LABEL1 , $READY )
EndFunc
Func _AAAAOSV ( )
	If _SRVSTAT ( "winmgmt" ) <> "R" Then Return ""
	$OBJWMISERVICE = ObjGet ( "winmgmts:{impersonationLevel=impersonate}!\\.\root\cimv2" )
	If Not IsObj ( $OBJWMISERVICE ) Then Return ""
	$DEVCOLITEMS = $OBJWMISERVICE .ExecQuery ( "Select * from Win32_OperatingSystem" )
	If Not IsObj ( $DEVCOLITEMS ) Then Return ""
	For $OBJECT In $DEVCOLITEMS
		If ( $OBJECT .caption ) Then $SVERSION = $OBJECT .caption
	Next
EndFunc
Func _AAAAOSV2 ( )
	Switch @OSVersion
	Case "WIN_XP"
		$SVERSION = "Windows XP"
	Case "WIN_VISTA"
		$SVERSION = "Windows VISTA"
	Case "WIN_7"
		$SVERSION = "Windows 7"
	Case "WIN_8"
		$SVERSION = "Windows 8"
	Case "WIN_81"
		$SVERSION = "Windows 8.1"
	Case "WIN_10"
		$SVERSION = "Windows 10"
	Case "WIN_11"
		$SVERSION = "Windows 11"
	EndSwitch
EndFunc
Func _AAADNS ( )
	$ARESULT = DllCall ( "iphlpapi.dll" , "uint" , "GetNetworkParams" , "int*" , 0 , "uint*" , 4 )
	If $ARESULT [ 0 ] = 111 Then
		$TBUF = DllStructCreate ( "byte[" & $ARESULT [ 2 ] & "]" )
		$ARESULT = DllCall ( "iphlpapi.dll" , "uint" , "GetNetworkParams" , "ptr" , DllStructGetPtr ( $TBUF ) , "uint*" , $ARESULT [ 2 ] )
		If $ARESULT [ 0 ] Then Return SetError ( $ARESULT [ 0 ] , 0 , "" )
		$TDNSSERVERSLIST = DllStructCreate ( "ptr;char[16];char[16];uint;" , DllStructGetPtr ( $TBUF ) + 268 + 4 )
		$DNSPRIM = DllStructGetData ( $TDNSSERVERSLIST , 2 )
		$TDNSSERVERSLIST = DllStructCreate ( "ptr;char[16];char[16];uint;" , DllStructGetData ( $TDNSSERVERSLIST , 1 ) )
		$DNSSEC = DllStructGetData ( $TDNSSERVERSLIST , 2 )
		If $DNSSEC <> "0" Then $DNSPRIM &= " - " & $DNSSEC
		If $DNSPRIM = "" Then $DNSPRIM = $DSN
		Return $DNSPRIM
	Else
		Return SetError ( + 4294967295 , 0 , "" )
	EndIf
EndFunc
Func _AAAFW ( )
	GUICtrlSetData ( $LABEL1 , $SCANB & " " & $FWRUL & "..." )
	Local $ARRAYNAME
	FileWrite ( $HADDITION , @CRLF & "==================== " & $FWRUL & " (" & $WLISTED & ") ================" & @CRLF )
	FileWrite ( $HADDITION , @CRLF & "(" & $SERV1 & " " & $SERV2 & ".)" & @CRLF & @CRLF )
	$KEY = "HKLM\SYSTEM\CurrentControlSet\services\SharedAccess\Parameters\FirewallPolicy\FirewallRules"
	$HKEY = _REGOPENKEYEX3 ( $KEY )
	If Not @error And IsPtr ( $HKEY ) Then $ARRAYNAME = _LISTVAL ( $HKEY )
	If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
	For $V = 0 To UBound ( $ARRAYNAME ) + 4294967295
		$VALNAME = $ARRAYNAME [ $V ] [ 0 ]
		$VALDATA = $ARRAYNAME [ $V ] [ 1 ]
		Select
		Case StringRegExp ( $VALDATA , "(?i)Action=Allow.+(ehome|System32(\\OpenSSH|\\wbem|))\\(sshd|dfsfrsHost|mmc|snmp|tlntsvr|vmms|nfsclnt|deviceenroller|omadmclient|dmcertinst|mqsvc|sppextcomobj|svchost|wudfhost|netproj|mcrmgr|mcx2prov|ehshell|msra|raserver|msdtc|services|unsecapp|plasrv|lsass|p2phost|vdsldr|vds|spoolsv|snmptrap|wininit|proximityuxhost|dashost|NetEvtFwdr|RmtTpmVscMgrSvr|mdeserver|RdpSa|CastSrv)\.exe" )
			ContinueLoop
		Case StringRegExp ( $VALDATA , "(?i)Action=Allow.+%ProgramFiles(\(x86\)|)%\\(Windows Media Player|Windows MultiPoint Server)\\(WmsDashboard|WmsManager|Wmssvc|wmplayer|wmpnetwk)\.exe" )
			ContinueLoop
		Case StringRegExp ( $VALDATA , "(?i)Action=Allow.+:\\Windows\\Microsoft.NET\\Framework\d+\\[^\\]+\\SMSvcHost.exe" )
			ContinueLoop
		Case StringRegExp ( $VALDATA , "(?i)Action=Allow.+:\\Program Files( \(x86\)|)\\Microsoft Office\\Office\d+\\(outlook|GROOVE|ONENOTE)\.exe" )
			ContinueLoop
		Case StringRegExp ( $VALDATA , "(?i)Action=Allow.+:\\Program Files( \(x86\)|)\\Microsoft\\Edge\\Application\\msedge.exe" )
			ContinueLoop
		EndSelect
		$ALLOW = "(Allow) "
		If StringRegExp ( $VALDATA , "(?i)Action=Block" ) Then $ALLOW = "(Block) "
		Select
		Case StringRegExp ( $VALNAME , "(?i)vm-monitoring-nb-session|WCF-NetTcpActivator-In-TCP-64bit|HNS Container Networking" ) And StringRegExp ( $VALDATA , "(?i)Action=Allow.+LPort=(139|808|53)" )
		Case StringRegExp ( $VALDATA , "(?i)App=(?!System)" )
			$VALDATA = StringRegExpReplace ( $VALDATA , "(?i).+app=(.+?)\|.+" , "$1" )
			$FILE = $VALDATA
			$COMPANY = ""
			If StringInStr ( $FILE , "SysWOW64" ) Then
				AAAAFPWOW ( )
			Else
				AAAAFP ( )
			EndIf
			If Not FileExists ( $FILE ) Then
				$COMPANY = " => " & $REGIST8
				$FILE = $VALDATA
			EndIf
			FileWrite ( $HADDITION , "FirewallRules: [" & $VALNAME & "] => " & $ALLOW & $FILE & $COMPANY & @CRLF )
		Case StringRegExp ( $VALDATA , "(?i)LPort=(?!RPC-EPMap)" ) And Not StringInStr ( $VALDATA , "App=System" )
			$VALDATA = StringRegExpReplace ( $VALDATA , "(?i).+(LPort=.+?)\|.+" , "$1" )
			FileWrite ( $HADDITION , "FirewallRules: [" & $VALNAME & "] => " & $ALLOW & $VALDATA & @CRLF )
		EndSelect
	Next
	_AAAFWD ( "DomainProfile" , 1 )
	_AAAFWD ( "PublicProfile" , 1 )
	_AAAFWD ( "StandardProfile" , 1 )
	_AAAFWD ( "DomainProfile" )
	_AAAFWD ( "PublicProfile" )
	_AAAFWD ( "StandardProfile" )
EndFunc
Func _AAAFWD ( $DOMAIN , $AUTH = "" )
	Local $ARRAYNAME
	$SUBKEY = "\GloballyOpenPorts"
	If $AUTH Then $SUBKEY = "\AuthorizedApplications"
	$KEY = "HKLM\SYSTEM\CurrentControlSet\services\SharedAccess\Parameters\FirewallPolicy\" & $DOMAIN & $SUBKEY & "\List"
	$HKEY = _REGOPENKEYEX3 ( $KEY )
	If Not @error And IsPtr ( $HKEY ) Then $ARRAYNAME = _LISTVAL ( $HKEY )
	If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
	If UBound ( $ARRAYNAME ) < 1 Then Return
	For $V = 0 To UBound ( $ARRAYNAME ) + 4294967295
		$VALNAME = $ARRAYNAME [ $V ] [ 0 ]
		$VALDATA = $ARRAYNAME [ $V ] [ 1 ]
		If Not StringRegExp ( $VALNAME , "(?i)%windir%\\(system32|Network Diagnostic)\\(sessmgr|xpnetdiag)\.exe" ) Then
			$VALNAME1 = StringRegExpReplace ( $VALNAME , "\\" , "\\\\" )
			$VALNAME1 = StringRegExpReplace ( $VALNAME1 , "(\(|\))" , "\\$1" )
			$VALDATA = StringRegExpReplace ( $VALDATA , $VALNAME1 , "" )
			$VALDATA = StringRegExpReplace ( $VALDATA , "^:\*:" , "" )
			FileWrite ( $HADDITION , $DOMAIN & $SUBKEY & ": [" & $VALNAME & "] => " & $VALDATA & @CRLF )
		EndIf
	Next
	$ARRAYNAME = ""
EndFunc
Func _AAAFWFIX ( )
	$VAL1 = StringRegExpReplace ( $FIX , ".+?: \[(.+?)\] =>.*" , "$1" )
	$KEY1 = "HKLM\SYSTEM\CurrentControlSet\services\SharedAccess\Parameters\FirewallPolicy\"
	If StringRegExp ( $FIX , "FirewallRules:" ) Then
		$KEY = $KEY1 & "FirewallRules"
	Else
		$SUBKEY = "\GloballyOpenPorts"
		If StringInStr ( $FIX , "\AuthorizedApplications:" ) Then $SUBKEY = "\AuthorizedApplications"
		$DOMAIN = StringRegExpReplace ( $FIX , "(.+?)\\.+" , "$1" )
		$KEY = $KEY1 & $DOMAIN & $SUBKEY & "\List"
	EndIf
	DELVALUE ( $KEY , $VAL1 )
EndFunc
Func _ADS_LIST_NTQUERY ( $SFILE )
	Local $HFILE = CREATEFILE ( $SFILE )
	If @error Then Return SetError ( 1 , 0 , 0 )
	Local $TAGFILE_STREAM_INFORMATION = "ulong NextEntryOffset;" & "ulong StreamNameLength;" & "dword StreamSize[2];" & "dword StreamAllocationSize[2];"
	Local $TBYTE , $IALLOCSIZE = 512
	Local $IO_STATUS_BLOCK = DllStructCreate ( "long Status;ulong_ptr Information;" )
	While 1
		$TBYTE = DllStructCreate ( "byte[" & $IALLOCSIZE & "]" )
		Local $ACALL = DllCall ( "ntdll.dll" , "long" , "NtQueryInformationFile" , "handle" , $HFILE , "struct*" , $IO_STATUS_BLOCK , "struct*" , $TBYTE , "ulong" , DllStructGetSize ( $TBYTE ) , "ulong" , 22 )
		If @error Or $ACALL [ 0 ] = 3221225485 Then ExitLoop
		If DllStructGetData ( $IO_STATUS_BLOCK , "Information" ) <> 0 And DllStructGetData ( $IO_STATUS_BLOCK , "Status" ) = 0 Then ExitLoop
		If $IALLOCSIZE > 262144 Then ExitLoop
		$IALLOCSIZE *= 2
	WEnd
	Local $I = 1 , $AOUT [ 1 ]
	Local $TFILE_STREAM_INFORMATION , $ISTRINGSIZE
	Local $PPOINTER = DllStructGetPtr ( $TBYTE )
	While 1
		$TFILE_STREAM_INFORMATION = DllStructCreate ( $TAGFILE_STREAM_INFORMATION , $PPOINTER )
		$ISTRINGSIZE = DllStructGetData ( $TFILE_STREAM_INFORMATION , "StreamNameLength" )
		If $ISTRINGSIZE > 14 Then
			ReDim $AOUT [ $I ]
			$AOUT [ $I + 4294967295 ] = StringRegExpReplace ( DllStructGetData ( DllStructCreate ( "wchar[" & $ISTRINGSIZE / 2 & "]" , $PPOINTER + DllStructGetSize ( $TFILE_STREAM_INFORMATION ) ) , 1 ) , "(.*):.*" , "$1" )
			$I += 1
		EndIf
		If DllStructGetData ( $TFILE_STREAM_INFORMATION , "NextEntryOffset" ) = 0 Then ExitLoop
		$PPOINTER += DllStructGetData ( $TFILE_STREAM_INFORMATION , "NextEntryOffset" )
	WEnd
	CLOSEHANDLE ( $HFILE )
	If UBound ( $AOUT ) = 1 And Not $AOUT [ 0 ] Then Return 0
	Return $AOUT
EndFunc
Func _ARG ( $PATH = $FILE )
	If StringRegExp ( $PATH , "(?i)\b(shutdown|wevtutil|vssadmin|wmic|REGSVR|regsvr32|Regsvcs|RegAsm|regedt32|regedit|rundll32|wscript|cscript|javaw|cmd|powershell|reg)\b" ) Or StringRegExp ( $PATH , "(?i)java\.exe" ) Then Return 1
	If StringRegExp ( $PATH , "(?i)\b(userinit|dllhost|explorer)\b" ) Then Return 2
EndFunc
Func _BBBBCP ( )
	$ARRAYPRO = ProcessList ( )
	If IsArray ( $ARRAYPRO ) Then
		For $I = 1 To UBound ( $ARRAYPRO ) + 4294967295
			$PATH = _RUNPR ( $ARRAYPRO [ $I ] [ 1 ] )
			If $PATH Then
				If Not StringRegExp ( $PATH , "(?i)Windows\\System32\\(smss|csrss|wininit|csrss|services|lsass|lsm|winlogon|svchost|fontdrvhost|spoolsv|dwm|WUDFHost|msdtc|VSSVC|earchIndexer|SearchProtocolHost|SearchFilterHost|alg|sihost)\.exe" ) And Not StringRegExp ( $PATH , "(?i)Windows\\explorer.exe" ) And Not StringRegExp ( $PATH , "(?i)System32\\wbem\\WmiPrvSE\.exe" ) And Not StringRegExp ( $PATH , "(?i)Windows\\SystemApps\\.+\\(SearchUI|RemindersServer|ActionUriServer)\.exe" ) And Not StringInStr ( $PATH , @ScriptName ) Then
					If PROCRIT ( $ARRAYPRO [ $I ] [ 1 ] ) Then ProcessClose ( $ARRAYPRO [ $I ] [ 1 ] )
				EndIf
			EndIf
		Next
	EndIf
	FileWrite ( $C & "\FRST\re" , "R" & @CRLF )
	FileWrite ( $HFIXLOG , $PROCL & @CRLF )
EndFunc
Func _BBBBDF ( $PATH1 )
	If StringInStr ( FileGetAttrib ( "\\?\" & $PATH1 ) , "D" ) Then Return FileWrite ( $HFIXLOG , """" & $PATH1 & """ => " & $FOL0 & @CRLF )
	If _FILEDELETE ( $PATH1 ) Then Return DELETED ( $PATH1 )
	If StringRegExp ( $PATH1 , "(?i)\.exe" ) And $BOOTM <> "Recovery" Then
		$ARRAYPRO = ProcessList ( )
		For $I = 1 To UBound ( $ARRAYPRO ) + 4294967295
			If _RUNPR ( $ARRAYPRO [ $I ] [ 1 ] ) = $PATH1 Then
				If PROCRIT ( $ARRAYPRO [ $I ] [ 1 ] ) Then ProcessClose ( $ARRAYPRO [ $I ] [ 1 ] )
				ExitLoop
			EndIf
		Next
	EndIf
	If _FILEDELETE ( $PATH1 ) Then Return DELETED ( $PATH1 )
	If $BOOTM = "Recovery" Then Return NDELETED ( $PATH1 )
	FileWrite ( $HFIXLOG , $NDELETED & " """ & $PATH1 & """ => " & $DELRE & "." & @CRLF )
	MOVEFILEONREBOOT ( $PATH1 , "" )
	FileWrite ( $C & "\FRST\files" , $PATH1 & @CRLF )
	FileWrite ( $C & "\FRST\re" , "reboote?" & @CRLF )
EndFunc
Func _BBBBDR ( $PATH )
	If Not FileExists ( $PATH ) Then Return
	If StringLeft ( $PATH , 4 ) <> "\\?\" Then $PATH = "\\?\" & $PATH
	DllCall ( @SystemDir & "\kernel32.dll" , "none" , "RemoveDirectoryW" , "wstr" , $PATH )
EndFunc
Func _BBBBKP ( $PATH )
	$CHEK = ""
	$RUNPR = _FILELISTTOARRAYREC ( $PATH , "*.exe" , 1 + 16 , 1 , 0 , 2 )
	For $N = 1 To UBound ( $RUNPR ) + 4294967295
		$ARRAYPRO = ProcessList ( )
		For $I = 1 To UBound ( $ARRAYPRO ) + 4294967295
			$PATH1 = _RUNPR ( $ARRAYPRO [ $I ] [ 1 ] )
			If $RUNPR [ $N ] = $PATH1 Then
				If PROCRIT ( $ARRAYPRO [ $I ] [ 1 ] ) Then ProcessClose ( $ARRAYPRO [ $I ] [ 1 ] )
				$CHEK = 1
				ExitLoop
			EndIf
		Next
	Next
	Return $CHEK
EndFunc
Func _BBBBRBL ( )
	GUICtrlSetData ( $LABEL1 , $FIX1 & " " & $PW0 )
	GUICtrlSetData ( $BUTTONFIX , $FIX2 )
	GUICtrlSetState ( $BUTTONFIX , 128 )
	$CDATE = DATE ( )
	$HFIXLOG = FileOpen ( @ScriptDir & "\Fixlog.txt" , 256 + 1 )
	FileWrite ( $HFIXLOG , @CRLF & $FIX3 & $BOOTM & ") (" & $FIX9 & ": " & $CDATE & ")" & @CRLF & @CRLF )
	$I = 1
	While 1
		$FILE = FileReadLine ( $C & "\frst\files" , $I )
		If @error Then ExitLoop
		If $FILE <> "" Then
			$HOSTSP = "\Windows\System32\drivers\etc\hosts"
			$PATH = "\\?\" & $FILE
			If Not FileExists ( $PATH ) Then
				FileWrite ( $HFIXLOG , $FILE & " => " & $FIX5 & @CRLF )
				If StringInStr ( $FILE , $HOSTSP ) Then HOSTSFIX1 ( $FILE )
			Else
				$ATT = FileGetAttrib ( $PATH )
				If StringInStr ( $ATT , "D" ) Then
					$DES = DESTIN ( $FILE )
					_GRANTE ( $PATH , 1 , 0 )
					$DIRDONE = DirMove ( $PATH , $DES , 1 )
					Select
					Case $DIRDONE = 1 And Not FileExists ( $PATH )
						MOVED ( $FILE )
					Case $DIRDONE = 0 Or FileExists ( $PATH )
						_GRANTE ( $FILE , 1 , 0 )
						$DIRDONE1 = DirMove ( $FILE , $DES , 1 )
						Select
						Case $DIRDONE1 = 1 And Not FileExists ( $PATH )
							MOVED ( $FILE )
						Case $DIRDONE1 = 0 Or FileExists ( $PATH )
							If StringInStr ( $FILE , "\$Recycle.Bin\S-1-5-18" ) Or StringInStr ( $FILE , "\$Recycle.Bin\S-1-5-21" ) Or StringInStr ( $FILE , "\RECYCLER\S-1-5-21" ) Or StringInStr ( $FILE , "\RECYCLER\S-1-5-18" ) Then
								RunWait ( @ComSpec & " /c " & "rd /q/s """ & $FILE & """" , "" , @SW_HIDE )
							EndIf
							If Not FileExists ( $PATH ) Then
								DELETED ( $FILE )
							Else
								NMOVED ( $FILE )
							EndIf
						EndSelect
					EndSelect
				Else
					$DES = DESTIN ( $FILE , 1 )
					$DIRDONE = FileMove ( $PATH , $DES , 1 )
					Select
					Case $DIRDONE = 1
						MOVED ( $FILE )
						If StringInStr ( $FILE , $HOSTSP ) Then HOSTSFIX1 ( $FILE )
					Case $DIRDONE = 0
						_GRANTE ( $PATH , 1 , 0 )
						$DIRDONE1 = FileMove ( $PATH , $DES , 1 )
						Select
						Case $DIRDONE1 = 1
							MOVED ( $FILE )
							If StringInStr ( $FILE , $HOSTSP ) Then HOSTSFIX1 ( $FILE )
						Case $DIRDONE1 = 0
							NMOVED ( $FILE )
							If StringInStr ( $FILE , $HOSTSP ) Then FileWrite ( $HFIXLOG , $NRESTORE & " Hosts." & @CRLF )
						EndSelect
					EndSelect
				EndIf
			EndIf
		EndIf
		$I = $I + 1
	WEnd
	$II = 1
	While 1
		$FILE = FileReadLine ( $C & "\frst\filesRem" , $II )
		If @error Then ExitLoop
		If $FILE <> "" Then
			$PATH = "\\?\" & $FILE
			$PATH = StringRegExpReplace ( $PATH , "\\\\(?!\?\\)" , "\\" )
			If Not FileExists ( $PATH ) Then
				DELETED ( $FILE )
			Else
				If StringInStr ( FileGetAttrib ( $FILE ) , "D" ) Then
					_GRANTE ( $FILE , 1 , 1 )
					$DIRDONE = DirRemove ( $PATH , 1 )
					Select
					Case $DIRDONE = 1 And Not FileExists ( $PATH )
						DELETED ( $FILE )
					Case $DIRDONE = 0 Or FileExists ( $PATH )
						NMOVED ( $FILE )
					EndSelect
				Else
					_GRANTE ( $PATH , 1 , 0 )
					If StringRegExp ( FileGetAttrib ( $PATH ) , "(?i)S|R|H" ) Then FileSetAttrib ( $PATH , "-SRH" )
					$DIRDONE = FileDelete ( $PATH )
					Select
					Case $DIRDONE = 1
						DELETED ( $FILE )
					Case $DIRDONE = 0
						NMOVED ( $FILE )
					EndSelect
				EndIf
			EndIf
		EndIf
		$II = $II + 1
	WEnd
	If FileExists ( $C & "\frst\keysRem" ) Then
		If StringInStr ( $C & "\frst\keysRem" , "HKU\" ) Then LOAD ( )
		$REBOOTED = 1
		FileWrite ( $HFIXLOG , @CRLF & $FIXREG & @CRLF & @CRLF )
		$K = 1
		While 1
			$KEY = FileReadLine ( $C & "\frst\keysRem" , $K )
			If @error Then ExitLoop
			DELKEY ( $KEY , 1 )
			$K += 1
		WEnd
		If UBound ( $LOAD ) > 1 Then UNLOAD ( )
		FileDelete ( $C & "\frst\keysRem" )
		$REBOOTED = ""
	EndIf
	If FileExists ( $C & "\FRST\tempsize" ) Then READSIZE ( )
	FileWrite ( $HFIXLOG , @CRLF & "==== " & $END & " " & $OF2 & " Fixlog " & @HOUR & ":" & @MIN & ":" & @SEC & " ====" )
	FileDelete ( $C & "\frst\files" )
	FileDelete ( $C & "\frst\filesRem" )
	RegDelete ( "HKLM\Software\Microsoft\Windows\CurrentVersion\RunOnce" , "*FRST" )
	If FileExists ( $C & "\FRST\Hives\uac" ) Then
		Local $VALUAC
		$VALUAC = FileRead ( $C & "\FRST\Hives\uac" )
		RegWrite ( "HKLM\Software\Microsoft\Windows\CurrentVersion\Policies\System" , "ConsentPromptBehaviorAdmin" , "REG_DWORD" , $VALUAC )
		FileDelete ( $C & "\FRST\Hives\uac" )
	EndIf
	FileClose ( $HFIXLOG )
	$CDATE = @MDAY & "-" & @MON & "-" & @YEAR & " " & @HOUR & "." & @MIN & "." & @SEC
	FileCopy ( @ScriptDir & "\Fixlog.txt" , $C & "\FRST\Logs\Fixlog_" & $CDATE & ".txt" )
	GUICtrlSetData ( $LABEL1 , "" )
	MsgBox ( 262144 + 0 , $FRST , $FIX10 & " ""Fixlog.txt"" " & $COMPLETED )
	GUICtrlSetState ( $BUTTONFIX , 64 )
	Run ( "notepad """ & @ScriptDir & "\Fixlog.txt""" )
	Exit
EndFunc
Func _BBBBRD ( $PATH )
	Dim $PATH1 , $SUBFOLDERS , $AARRAYDIR
	If _BLACK ( $PATH ) Then Return FileWrite ( $HFIXLOG , $PATH & " => " & $NREMOV & @CRLF )
	If Not StringRegExp ( FileGetAttrib ( $PATH ) , "^$|(?i)D" ) Then Return FileWrite ( $HFIXLOG , """" & $PATH & """ => " & $FIL0 & @CRLF )
	$SUBFOLDERS = _GETALLSUBFOLDERSSHORT ( $PATH )
	If IsArray ( $SUBFOLDERS ) Then
		_ARRAYREVERSE ( $SUBFOLDERS , 1 )
		For $E = 1 To UBound ( $SUBFOLDERS ) + 4294967295
			DirRemove ( $SUBFOLDERS [ $E ] , 1 )
		Next
	EndIf
	$SUBFOLDERS = ""
	If DirRemove ( $PATH , 1 ) And Not FileExists ( $PATH ) Then Return DELETED ( $PATH )
	If _CREATEFILE ( $PATH , 268435456 ) Then _GRANTE ( $PATH , 1 , 0 )
	$SUBFOLDERS = _GETALLSUBFOLDERSSHORT ( $PATH )
	If IsArray ( $SUBFOLDERS ) Then
		_ARRAYREVERSE ( $SUBFOLDERS , 1 )
		For $E = 1 To UBound ( $SUBFOLDERS ) + 4294967295
			_DIRREMOVE ( $SUBFOLDERS [ $E ] )
			If FileExists ( $SUBFOLDERS [ $E ] ) And _BBBBKP ( $SUBFOLDERS [ $E ] ) Then _DIRREMOVE ( $SUBFOLDERS [ $E ] )
		Next
	EndIf
	$AARREST = _FILELISTTOARRAYREC ( $PATH , "*" , 1 + 16 , 1 , 1 , 2 )
	If UBound ( $AARREST ) > 1 Then
		For $E = 1 To UBound ( $AARREST ) + 4294967295
			If $PATH & "\" & StringRegExpReplace ( $AARREST [ $E ] , ".+\\" , "" ) = $AARREST [ $E ] Then _FILEDELETE ( $AARREST [ $E ] )
			If FileExists ( $AARREST [ $E ] ) Then
				If $BOOTM = "Recovery" Then
					NDELETED ( $AARREST [ $E ] )
				Else
					MOVEFILEONREBOOT ( $AARREST [ $E ] , "" )
					FileWrite ( $HFIXLOG , $NDELETED & " """ & $AARREST [ $E ] & """ => " & $DELRE & "." & @CRLF )
					$HFILEREM = FileOpen ( $C & "\FRST\filesRem" , 1 + 256 )
					FileWrite ( $HFILEREM , $AARREST [ $E ] & @CRLF )
					FileWrite ( $C & "\FRST\reb" , "reboote?" & @CRLF )
					FileClose ( $HFILEREM )
				EndIf
			EndIf
		Next
	EndIf
	$RET = DirRemove ( $PATH , 1 )
	If Not $RET Then _BBBBDR ( $PATH )
	If FileExists ( $PATH ) Then
		If $BOOTM = "Recovery" Then
			NDELETED ( $PATH )
		Else
			MOVEFILEONREBOOT ( $PATH , "" )
			FileWrite ( $HFIXLOG , $NDELETED & " """ & $PATH & """ => " & $DELRE & "." & @CRLF )
			$HFILEREM = FileOpen ( $C & "\FRST\filesRem" , 1 + 256 )
			FileWrite ( $HFILEREM , $PATH & @CRLF )
			FileWrite ( $C & "\FRST\re" , "reboote?" & @CRLF )
			FileClose ( $HFILEREM )
		EndIf
	Else
		DELETED ( $PATH )
	EndIf
EndFunc
Func _BBBBT ( )
	$SUBK = ""
	$IKEY = ""
	$KEY = ""
	$MKEY = "HKLM\" & $SOFTWARE & "\Microsoft\Windows NT\CurrentVersion\Schedule\"
	$KEY = StringRegExpReplace ( $FIX , "(?i)Task: (\{[^{]+\}) - .+" , "$1" )
	If $KEY <> "" Then
		$IKEY = $MKEY & "TaskCache\Boot\" & $KEY
		If VAR ( $IKEY ) Then DELKEY ( $IKEY )
		$IKEY = $MKEY & "TaskCache\Logon\" & $KEY
		If VAR ( $IKEY ) Then DELKEY ( $IKEY )
		$IKEY = $MKEY & "TaskCache\Plain\" & $KEY
		If VAR ( $IKEY ) Then DELKEY ( $IKEY )
		DELKEY ( $MKEY & "TaskCache\Tasks\" & $KEY )
	EndIf
	If StringInStr ( $FIX , " -> " ) Then $SUBK = StringRegExpReplace ( $FIX , "(?i)Task: \{[^}]+\} - (.+?) ->.+" , "$1" )
	If StringInStr ( $FIX , "- System32" ) And Not StringInStr ( $FIX , " => " ) Then
		$SUBK = StringRegExpReplace ( $FIX , "(?i)Task: \{[^}]+\} - System32\\Tasks(.*)" , "$1" )
		$FILEP = StringRegExpReplace ( $FIX , "(?i)Task: \{[^{]+\} - (.+)" , "$1" )
		$FILEP = $WINDOWSDIR & "\" & $FILEP
		If Not StringInStr ( FileGetAttrib ( $FILEP ) , "D" ) Then
			If $BOOTM = "Recovery" Then
				MOVEFILE ( $FILEP )
			Else
				MOVEFILENORMAL ( $FILEP )
			EndIf
		EndIf
	EndIf
	If StringInStr ( $FIX , "- System32" ) And StringInStr ( $FIX , " => " ) Then
		$SUBK = StringRegExpReplace ( $FIX , "(?i)Task: \{[^}]+\} - System32\\Tasks(.+?) =>.*" , "$1" )
		$FILEP = StringRegExpReplace ( $FIX , "(?i)Task: \{[^{]+\} - (.+?) =>.*" , "$1" )
		$FILEP = $WINDOWSDIR & "\" & $FILEP
		If Not StringInStr ( FileGetAttrib ( $FILEP ) , "D" ) Then
			If $BOOTM = "Recovery" Then
				MOVEFILE ( $FILEP )
			Else
				MOVEFILENORMAL ( $FILEP )
			EndIf
		EndIf
	EndIf
	If $SUBK <> "" Then DELKEY ( $MKEY & "TaskCache\Tree" & $SUBK )
EndFunc
Func _BKP ( $HIV1 , $HIV2 )
	$CH = ""
	If StringRegExp ( $HIV2 , "Y$" ) Then
		$HKEY = _REGOPENKEYEX3 ( $HIV1 & "\" & $HIV2 , 0 , 524288 )
	Else
		$HKEY = _REGOPENKEYEX3 ( $HIV1 & "\" & $HIV2 )
	EndIf
	If @error Or $HKEY = 0 Then Return
	$HIV2 = StringRegExpReplace ( $HIV2 , "^\." , "" )
	If StringInStr ( $HIV2 , "S-1-5-2" ) Then
		If StringInStr ( $HIV2 , "Classes" ) Then
			$SFILE = $C & "\FRST\Hives\" & @UserName & "\UsrClass.dat"
		Else
			$SFILE = $C & "\FRST\Hives\" & @UserName & "\NTUSER.DAT"
		EndIf
	Else
		$SFILE = $C & "\FRST\Hives\" & $HIV2
	EndIf
	$AVRSK = DllCall ( "Advapi32.dll" , "long" , "RegSaveKeyExW" , "hwnd" , $HKEY , "wstr" , $SFILE , "ptr" , 0 , "dword" , 4 )
	If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
EndFunc
Func _BKP1 ( $ARR )
	If Not $BACKUPPRI Then _SETPRIV ( "SeBackupPrivilege" )
	If Not $TAKEOWNPRI Then _SETPRIV ( "SeTakeOwnershipPrivilege" )
	For $I = 0 To UBound ( $ARR ) + 4294967295
		If StringRegExp ( $ARR [ $I ] , "T$" ) Then
			_BKP ( "HKU" , "." & $ARR [ 3 ] )
		Else
			_BKP ( "HKLM" , $ARR [ $I ] )
		EndIf
	Next
	$SID = _SECURITY__LOOKUPACCOUNTNAME ( @ComputerName & "\" & @UserName )
	If IsArray ( $SID ) Then
		_BKP ( "HKU" , $SID [ 0 ] )
		_BKP ( "HKU" , $SID [ 0 ] & "_Classes" )
	EndIf
EndFunc
Func _BKPS ( )
	GUICtrlSetData ( $LABEL1 , $SCANB & " " & $SERVB & ": " )
	$SFOL = _RAND ( )
	$PATH = $C & "\FRST\" & $SFOL
	DirCreate ( $PATH )
	FileSetAttrib ( $PATH , "HS" )
	If FileExists ( $PATH ) Then _SBKP ( $PATH )
	If Not FileExists ( $PATH & "\system" ) Then Return DirRemove ( $PATH , 1 )
EndFunc
Func _BLACK ( $PATH1 )
	$PATH1 = FileGetLongName ( $PATH1 )
	If StringRegExp ( $PATH1 , "(?i)" & $C & "\\(System Volume Information|Windows|Program Files|Program Files \(x86\)|Windows\\SysWOW64|Windows\\System32|Windows\\System32\\(Drivers|Tasks)|Windows\\System32\\config|Program Files\\(Microsoft Security Client|Windows Defender|WindowsApps)|Windows\\SystemApps(|\\Microsoft.MicrosoftEdge_8wekyb3d8bbwe(|\\Assets)))$" ) Then Return True
	Switch $PATH1
	Case FileGetLongName ( EnvGet ( "allusersprofile" ) ) , FileGetLongName ( @AppDataDir ) , FileGetLongName ( @AppDataCommonDir ) , FileGetLongName ( @MyDocumentsDir ) , FileGetLongName ( @DocumentsCommonDir ) , FileGetLongName ( @UserProfileDir ) , FileGetLongName ( @CommonFilesDir ) , FileGetLongName ( @DesktopCommonDir ) , FileGetLongName ( @DesktopDir ) , FileGetLongName ( @LocalAppDataDir ) , FileGetLongName ( @ProgramFilesDir ) , FileGetLongName ( @ProgramsDir ) , FileGetLongName ( @StartMenuDir ) , FileGetLongName ( @StartMenuCommonDir )
		Return True
	EndSwitch
EndFunc
Func _CF ( $SOURCE , $DEST )
	If StringLeft ( $SOURCE , 4 ) <> "\\?\" Then $SOURCE = "\\?\" & $SOURCE
	If StringLeft ( $DEST , 4 ) <> "\\?\" Then $DEST = "\\?\" & $DEST
	Local $ARET = DllCall ( "kernel32.dll" , "bool" , "CopyFileExW" , "wstr" , $SOURCE , "wstr" , $DEST , "ptr" , 0 , "struct*" , 0 , "bool*" , 0 , "dword" , BitOR ( 2048 , 4096 ) )
	If @error Or Not $ARET [ 0 ] Then SetError ( _WINAPI_GETLASTERROR ( ) )
	Return $ARET [ 0 ]
EndFunc
Func _CHECKKEYPERMS ( $KEY )
	If _CHECKKEYLOCKED ( $KEY ) Then _SETREGACE ( $KEY , 1 )
EndFunc
Func _CHECKKEYLOCKED ( $KEY )
	$RET = _GETSECDES ( $KEY , 4 )
	If StringInStr ( $RET , "(D;" ) Or Not StringRegExp ( $RET , "A;.*?;KA;;;BA" ) Then Return True
EndFunc
Func _CHECKSIG ( $FILEPATH , $INFO = "" )
	If _FILEGETSIZE ( $FILEPATH ) = 0 Or _CREATEFILE ( $FILEPATH ) Then Return
	If Not $INFO Then
		If _WINVERIFYTRUST ( $FILEPATH ) = 0 Then Return 11
	Else
		If $INFO = 1 Then
			$CERTINFO = _GETSIGNATUREINFO ( $FILEPATH )
			If $CERTINFO [ 1 ] Then Return $CERTINFO [ 1 ]
		EndIf
	EndIf
	Local $PCONTEXT
	$CONTEXT = DllCall ( "Wintrust.dll" , "BOOL" , "CryptCATAdminAcquireContext" , "ptr*" , $PCONTEXT , "ptr" , 0 , "DWORD" , 0 )
	If @error Or Not $CONTEXT [ 0 ] Then Return SetError ( 1 , 0 , "CryptCATAdminAcquireContext failed to return pContext" )
	$CONTEXT = $CONTEXT [ 1 ]
	$HFILE = CREATEFILE ( $FILEPATH )
	If @error Or Not $HFILE Then
		If $CONTEXT <> "" Then _RELEASECONTEXT ( $CONTEXT )
		Return SetError ( 2 , 0 , "Error1: CreateFileW function failed" )
	EndIf
	Local $CBHASH = 0
	$CRYPTH = "CryptCATAdminCalcHashFromFileHandle"
	$CBHASH = DllCall ( "Wintrust.dll" , "BOOL" , $CRYPTH , "handle" , $HFILE , "DWORD*" , $CBHASH , "ptr" , 0 , "dword" , 0 )
	If @error Or Not $CBHASH [ 0 ] Then
		If $CONTEXT <> "" Then _RELEASECONTEXT ( $CONTEXT )
		CLOSEHANDLE ( $HFILE )
		Return SetError ( 3 , 0 , "Error2: " & $CRYPTH & " failed to return cbHash #1" )
	EndIf
	$CBHASH = $CBHASH [ 2 ]
	Local $BUFFER = DllStructCreate ( "BYTE[" & $CBHASH & "]" )
	$PBHASH = DllStructGetPtr ( $BUFFER , 1 )
	$CBHASH = DllCall ( "Wintrust.dll" , "BOOL" , $CRYPTH , "handle" , $HFILE , "DWORD*" , $CBHASH , "ptr" , $PBHASH , "DWORD" , 0 )
	If @error Or Not $CBHASH [ 0 ] Then
		If $CONTEXT <> "" Then _RELEASECONTEXT ( $CONTEXT )
		CLOSEHANDLE ( $HFILE )
		If $INFO = 2 Then Return
		Return SetError ( 4 , 0 , "Error3: " & $CRYPTH & " failed to return cbHash, #2" )
	EndIf
	$CBHASH = $CBHASH [ 2 ]
	CLOSEHANDLE ( $HFILE )
	Local $CATALOGCONTEXT = DllCall ( "Wintrust.dll" , "handle" , "CryptCATAdminEnumCatalogFromHash" , "handle" , $CONTEXT , "ptr" , $PBHASH , "DWORD" , $CBHASH , "DWORD" , 0 , "handle" , 0 )
	If @error Or Not $CATALOGCONTEXT [ 0 ] Then
		If $CONTEXT <> "" Then _RELEASECONTEXT ( $CONTEXT )
		$CATALOGCONTEXT = 0
		$SIGNED = False
		$RET = _WINVERIFYTRUST ( $FILEPATH )
		If @error Then Return SetError ( 8 , 0 , "Error verfying file signature." )
		If $RET = 0 Then $SIGNED = 11
		If Not $INFO Then Return $SIGNED
	Else
		$CATALOGCONTEXT = $CATALOGCONTEXT [ 0 ]
		$TAGCATALOG_INFO = "DWORD cbStruct;" & "WCHAR wszCatalogFile[260];"
		Local $CATALOG_INFO = DllStructCreate ( $TAGCATALOG_INFO )
		DllStructSetData ( $CATALOG_INFO , "cbStruct" , DllStructGetSize ( $CATALOG_INFO ) )
		$PINFOSTRUCT = DllStructGetPtr ( $CATALOG_INFO )
		Local $RET = DllCall ( "Wintrust.dll" , "BOOL" , "CryptCATCatalogInfoFromContext" , "handle" , $CATALOGCONTEXT , "ptr" , $PINFOSTRUCT , "DWORD" , 0 )
		If @error Or Not $RET [ 0 ] Or Not DllStructGetData ( $CATALOG_INFO , 2 ) Then
			If $CATALOGCONTEXT <> "" Then _RELEASECONTEXT ( $CATALOGCONTEXT )
			If $CONTEXT <> "" Then _RELEASECONTEXT ( $CONTEXT )
			Return SetError ( 2 , 0 , "Failed to get Cataloginfo" )
		Else
			$CATPATH = DllStructGetData ( $CATALOG_INFO , 2 )
			If $INFO = 2 Then Return $CATPATH
			$CATMEMBERTAG = DllStructGetData ( $BUFFER , 1 )
			$CATMEMBERTAG = StringTrimLeft ( $CATMEMBERTAG , 2 )
			$SIGNED = False
			$RET = _WINVERIFYTRUST ( $FILEPATH , $CATPATH , $CATMEMBERTAG )
			If @error Then SetError ( 9 , 0 , "Error verfying file signature." )
			If $RET = 0 Then $SIGNED = 11
			If $CONTEXT <> "" Then _RELEASECONTEXT ( $CONTEXT )
			If Not $INFO Then Return $SIGNED
			$CERTINFO = _GETSIGNATUREINFO ( $CATPATH )
			If $CERTINFO [ 1 ] Then Return $CERTINFO [ 1 ]
		EndIf
	EndIf
EndFunc
Func _CHKINVAL ( $STR )
	Local $RETSTR , $CHK , $RET [ 2 ]
	$STR = StringRegExpReplace ( $STR , "^0x" , "" )
	$ARR = StringRegExp ( $STR , "\w{4}" , 3 )
	For $A = 0 To UBound ( $ARR ) + 4294967295
		$CHAR = StringRegExpReplace ( $ARR [ $A ] , "(\w{2})(\w{2})" , "$2$1" )
		$CHAR = StringRegExpReplace ( $CHAR , "00E0" , "0000" )
		If Dec ( $CHAR ) < 32 Then
			$CHAR = "002A"
			$CHK = 1
		EndIf
		$CHAR = ChrW ( Dec ( $CHAR ) )
		$RETSTR &= $CHAR
	Next
	$RET [ 0 ] = $CHK
	$RET [ 1 ] = $RETSTR
	Return $RET
EndFunc
Func _CLSIDCHR ( $USERC )
	$COMPANY = ""
	$VDATA = RegRead ( "HKU\" & $USERC & "\" & "ChromeHTML" & "\shell\open\command" , "" )
	$FILE = $VDATA
	$USER = StringRegExpReplace ( $USERC , "(.+?)_Classes" , "$1" )
	AAAAFPWOW ( )
	If FileExists ( $FILE ) Then
		$VDATA = $FILE
	EndIf
	If StringRegExp ( $VDATA , "(?i):\\(Program Files[^\\]*|Users\\[^\\]+\\AppData\\Local)\\Google\\Chrome\\Application\\chrome\.exe" ) And StringRegExp ( $COMPANY , "(?i)Google Inc" ) Then
		$ATT = ""
	Else
		$ATT = " <==== " & $UPD1
	EndIf
	_ARRAYADD ( $ARRCLSID , "HKU\" & $USER & "\...\ChromeHTML: -> " & $VDATA & $COMPANY & $ATT , 0 , "||||" )
EndFunc
Func _CLSIDCHRFIX ( )
	$USER = StringRegExpReplace ( $FIX , "(?i)HKU\\(.+?)\\.+" , "$1" )
	If StringInStr ( $FIX , "\StartMenuInternet\" ) Then Return DELKEY ( "HKU\" & $USER & "\SOFTWARE\Clients\StartMenuInternet\ChromeHTML" )
	DELKEY ( "HKU\" & $USER & "_Classes\ChromeHTML" )
EndFunc
Func _CLSID ( )
	$K = 0
	While 1
		$USERC = __REGENUMKEY ( 2147483651 , $K )
		If @error Then ExitLoop
		If StringInStr ( $USERC , "_Classes" ) Then
			$HKEY = _REGOPENKEYEX3 ( "HKU\" & $USERC , 1 )
			If @error Or $HKEY = 0 Then Return
			$L = 0
			While 1
				$CLSID = __REGENUMKEY ( $HKEY , $L )
				If @error Then ExitLoop
				If $CLSID = "CLSID" Then _CLSID2 ( $USERC )
				If $CLSID = "ChromeHTML" Then _CLSIDCHR ( $USERC )
				$L += 1
			WEnd
		EndIf
		$K += 1
	WEnd
	If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
	$HIVE = "SSODL: "
	SSODL ( "HKLM\Software\Microsoft\Windows\CurrentVersion\ShellServiceObjectDelayLoad" )
	$HIVE = "SSODL-x32: "
	SSODL ( "HKLM\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\ShellServiceObjectDelayLoad" )
	SSO ( )
	SSO ( 1 )
	$HIVE = "ShellExecuteHooks: "
	SEH ( "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\explorer\ShellExecuteHooks" )
	$HIVE = "ShellExecuteHooks-x32: "
	SEH ( "HKLM\SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\explorer\ShellExecuteHooks" )
EndFunc
Func _CLSID2 ( $USERC )
	GUICtrlSetData ( $LABEL1 , $SCANB & " CustomCLSID" )
	$KEY = "HKU\" & $USERC & "\" & "CLSID"
	$HKEY = _REGOPENKEYEX3 ( $KEY , 1 )
	If @error Or $HKEY = 0 Then Return
	$D = + 4294967295
	While 1
		$ATTEN = ""
		$COMPANY = ""
		$D += 1
		$CLSID = __REGENUMKEY ( $HKEY , $D )
		If @error Then ExitLoop
		$VDATA = RegRead ( $KEY & "\" & $CLSID & "\Shell\Open\Command" , "" )
		If Not @error Then
			If Not StringInStr ( $VDATA , "shell32" ) Then
				$FILE = $VDATA
				AAAAFP ( )
				If FileExists ( $FILE ) Then $VDATA = $FILE
			EndIf
			_ARRAYADD ( $ARRCLSID , "CustomCLSID: " & $KEY & "\" & $CLSID & "\Shell\Open\Command -> " & $VDATA & $COMPANY & $ATTEN , 0 , "||||" )
		EndIf
		$VDATA = RegRead ( $KEY & "\" & $CLSID & "\InprocServer32" , "" )
		Select
		Case Not @error And Not StringRegExp ( $VDATA , "(?i)\\Java\\jre-?1.8.*\\bin\\jp2iexp\.dll" )
			If StringInStr ( $VDATA , "mscoree.dll" ) Then MSCOREE ( $KEY & "\" & $CLSID & "\InprocServer32" , $VDATA )
			If StringRegExp ( $VDATA , "(?i)(shell32|shdocvw)\.dll" ) Then
				$NAME = RegRead ( $KEY & "\" & $CLSID , "" )
				$SKEY = $KEY & "\" & $CLSID & "\Instance\InitPropertyBag"
				$DATA = SHELLTARGET ( $SKEY )
				If $CLSID = "{018D5C66-4533-4307-9B53-224DE2ED1FE6}" And StringInStr ( $NAME , "OneDrive" ) And $DATA = "{a52bba46-e9e1-435f-b3d9-28daa648c0f6}" Then ContinueLoop
				$DATECR = FILETIME ( $DATA , 1 )
				If $DATECR Then $DATECR = " [" & $DATECR & "]"
				_ARRAYADD ( $ARRCLSID , "CustomCLSID: " & $KEY & "\" & $CLSID & " -> [" & $NAME & "] => " & $DATA & $DATECR , 0 , "||||" )
				ContinueLoop
			EndIf
			$FILE = $VDATA
			AAAAFP ( )
			If Not FileExists ( $FILE ) Then
				$FILEPATH = $VDATA
				If StringLen ( $FILEPATH ) > 200 Then $FILEPATH = StringTrimRight ( $FILEPATH , StringLen ( $FILEPATH ) + 4294967096 ) & " (" & $DATAX & " " & StringLen ( $FILEPATH ) + 4294967096 & " " & $DATAY & ")."
				$FILEPATH = $FILEPATH & " => " & $REGIST8
			Else
				$FILEPATH = $FILE
			EndIf
			If StringRegExp ( $CLSID , "(?i)(3050f406-98b5-11cf-bb82-00aa00bdce0b|33C53A50-F456-4884-B049-85FD643ECFED|56FDF344-FD6D-11d0-958A-006097C9A090|F28C2F70-47DE-4EA5-8F6D-7D1476CD1EF5|F6BF8414-962C-40FE-90F1-B80A7E72DB9A|2D349E57-23E4-4A67-9624-F1DC6B65AABF|56CBD3CF-BF99-4DF5-851F-F5B9B57496A1|5EC7C511-CD0F-42E6-830C-1BD9882F3458|61CED8F3-2CB2-4C3C-9484-7530E1127A58|D96C1D26-5CDF-4506-9244-57233C3984DF|F3D0D36F-23F8-4682-A195-74C92B03D4AF-NOT)" ) Then $ATTEN = " <==== " & $UPD1
			Select
			Case StringRegExp ( $COMPANY , "Mozilla Corporation ->" ) And StringRegExp ( $FILEPATH , "(?i):\\(Program Files(| \(x86\))|Users\\[^\\]+\\AppData\\Local)\\Mozilla Firefox\\notificationserver\.dll" )
			Case StringRegExp ( $COMPANY , "Microsoft" ) And StringRegExp ( $FILEPATH , "(?i):\\Users\\.+?\\AppData\\Local\\Microsoft\\OneDrive\\.+\\(FileSyncApi64|FileSyncShell64|FileCoAuth|FileCoAuthLib64)\.(dll|exe)" )
			Case StringRegExp ( $COMPANY , "(?i)Microsoft Corporation -> Microsoft.+:\\Program Files\\PowerToys\\.+\\PowerToys.PowerLauncher.exe" )
		Case Else
				_ARRAYADD ( $ARRCLSID , "CustomCLSID: " & $KEY & "\" & $CLSID & "\InprocServer32 -> " & $FILEPATH & $COMPANY & $ATTEN , 0 , "||||" )
			EndSelect
		Case @error = + 4294967295
			_ARRAYADD ( $ARRCLSID , "CustomCLSID: " & $KEY & "\" & $CLSID & "\InprocServer32 -> " & $NO & " " & $FPAD , 0 , "||||" )
		EndSelect
		$VDATA = RegRead ( $KEY & "\" & $CLSID & "\localserver32" , "" )
		Select
		Case Not @error
			If StringInStr ( $VDATA , "javascript" ) Then $ATTEN = " <==== Poweliks?"
			If StringInStr ( $VDATA , "\Chromium\" ) Then $ATTEN = " <==== " & $UPD1
			$FILE = $VDATA
			AAAAFP ( )
			If Not FileExists ( $FILE ) Then
				$FILEPATH = $VDATA
				If StringLen ( $FILEPATH ) > 200 Then $FILEPATH = StringTrimRight ( $FILEPATH , StringLen ( $FILEPATH ) + 4294967096 ) & " (" & $DATAX & " " & StringLen ( $FILEPATH ) + 4294967096 & " " & $DATAY & ")."
				$FILEPATH = $FILEPATH & " => " & $REGIST8
			Else
				$FILEPATH = $FILE
			EndIf
			If Not StringInStr ( $COMPANY , "[" ) And StringRegExp ( $COMPANY , "Microsoft" ) And StringRegExp ( $FILEPATH , "(?i):\\Users\\[^\\]+\\AppData\\Local\\Microsoft\\OneDrive(|.+?)\\(OneDrive|FileCoAuth|Microsoft.SharePoint)\.exe|\\Program Files\\WindowsApps\\Microsoft\.Paint.+8wekyb3d8bbwe\\PaintApp\\mspaint.exe" ) Then ContinueLoop
			_ARRAYADD ( $ARRCLSID , "CustomCLSID: " & $KEY & "\" & $CLSID & "\localserver32 -> " & $FILEPATH & $COMPANY & $ATTEN , 0 , "||||" )
		Case @error = + 4294967295
			_ARRAYADD ( $ARRCLSID , "CustomCLSID: " & $KEY & "\" & $CLSID & "\localserver32 -> " & $NO & " " & $FPAD , 0 , "||||" )
		EndSelect
	WEnd
	If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
EndFunc
Func _CLSIDFIX ( )
	If $BOOTM <> "Recovery" Then KILLDLL ( )
	If StringRegExp ( $FIX , "(?i)\\(InprocServer32|localserver32|Shell\\Open\\Command)" ) Then
		$KEY = StringRegExpReplace ( $FIX , "(?i)CustomCLSID: (.+)\\(InprocServer32|localserver32|Shell\\Open\\Command) ->.*" , "$1" )
	Else
		$KEY = StringRegExpReplace ( $FIX , "(?i)CustomCLSID: (.+?) ->.*" , "$1" )
	EndIf
	DELKEY ( $KEY )
EndFunc
Func _COPY ( )
	FileWrite ( $HFIXLOG , "================== """ & $FIX & """ ===================" & @CRLF & @CRLF )
	_COPY1 ( )
	FileWrite ( $HFIXLOG , @CRLF & "=== " & $END & " " & $OF & " Copy: ===" & @CRLF )
EndFunc
Func _COPY1 ( )
	$OSOURCE = StringRegExpReplace ( $FIX , "(?i)Copy:\s*(.+) [c-z]:.*" , "$1" )
	$DEST = StringRegExpReplace ( $FIX , "(?i)Copy:\s*.+ ([c-z]:.*)" , "$1" )
	$DEST = StringRegExpReplace ( $DEST , "\\$" , "" )
	$DEST = StringRegExpReplace ( $DEST , "\\\\(?!\?\\)" , "\\" )
	If Not FileExists ( "\\?\" & $OSOURCE ) Then Return NFOUND ( $OSOURCE )
	$DR = StringRegExp ( $DEST , ".:" , 1 )
	If Not IsArray ( $DR ) Then Return NFOUND ( $DEST & "\" )
	If Not FileExists ( $DR [ 0 ] ) Then Return NFOUND ( $DR [ 0 ] & "\" )
	If StringInStr ( FileGetAttrib ( "\\?\" & $OSOURCE ) , "D" ) Then Return _COPYD ( $OSOURCE , $DEST )
	_COPYF ( $OSOURCE , $DEST )
EndFunc
Func _COPYD ( $SOURCE , $DEST )
	$PDIR = StringRegExpReplace ( $SOURCE , "(.+)\\.+" , "$1" )
	$PDIR = StringRegExpReplace ( $PDIR , "\\" , "\\\\" )
	If Not FileExists ( "\\?\" & $DEST ) Then
		If Not DirCreate ( $DEST ) Then Return FileWrite ( $HFIXLOG , """" & $DEST & """ => Could not make directory" & @CRLF )
	EndIf
	$FP = StringRegExpReplace ( $SOURCE , $PDIR , "" )
	$DEST1 = $DEST & $FP
	If _REPARSEPOINT ( $SOURCE ) Then Return _COPYL ( $SOURCE , $DEST1 , _GETREPARSETARGET ( $SOURCE ) )
	$ARR = _FILELISTTOARRAYREC ( $SOURCE , "*" , 0 , 1 , 0 , 2 )
	For $I = 1 To UBound ( $ARR ) + 4294967295
		$FP = StringRegExpReplace ( $ARR [ $I ] , $PDIR , "" )
		$DEST1 = $DEST & $FP
		Select
		Case Not StringInStr ( FileGetAttrib ( $ARR [ $I ] ) , "D" )
			$DEST1 = StringRegExpReplace ( $DEST1 , "(.+)\\.+" , "$1" )
			_COPYF ( $ARR [ $I ] , $DEST1 )
		Case _REPARSEPOINT ( $ARR [ $I ] )
			_COPYL ( $ARR [ $I ] , $DEST1 , _GETREPARSETARGET ( $ARR [ $I ] ) )
	Case Else
			If Not FileExists ( $DEST1 ) Then DirCreate ( $DEST1 )
		EndSelect
	Next
EndFunc
Func _COPYF ( $SOURCE , $DEST )
	If Not FileExists ( $DEST ) Then
		If Not DirCreate ( $DEST ) Then Return FileWrite ( $HFIXLOG , """" & $DEST & """ => Could not make directory" & @CRLF )
	EndIf
	$DEST1 = $DEST & "\" & StringRegExpReplace ( $SOURCE , ".+\\" , "" )
	_CF ( $SOURCE , $DEST1 )
	$ERR = @error
	If $ERR = 5 Then $ERR = $NOACC
	If $ERR Then Return FileWrite ( $HFIXLOG , """" & $SOURCE & """ => Could not copy (" & $ERR0 & ":" & $ERR & ")" & @CRLF )
	$SOURCE1 = """" & $SOURCE & """ "
	If _REPARSEPOINT ( $SOURCE ) Then $SOURCE1 = """" & $SOURCE & """ (" & $SYMLINK0 & " -> " & _GETREPARSETARGET ( $SOURCE ) & ") "
	FileWrite ( $HFIXLOG , $SOURCE1 & $COP1 & @CRLF )
EndFunc
Func _COPYL ( $SOURCE , $DES , $TARGET )
	$RET = _WINAPI_CREATESYMBOLICLINK ( $DES , $TARGET , True )
	If Not $RET Then Return FileWrite ( $HFIXLOG , """" & $SOURCE & """ => Could not copy (" & $SYMLINK0 & " -> " & $TARGET & " <" & $ERR0 & ":" & _WINAPI_GETLASTERROR ( ) & ">)" & @CRLF )
	FileWrite ( $HFIXLOG , """" & $SOURCE & """ (" & $SYMLINK0 & " -> " & $TARGET & ") " & $COP1 & @CRLF )
EndFunc
Func _CREATEACL ( $ACCOUNT , $SE_OBJECT_TYPE = 1 , $ACCMODE = 2 )
	Local $INHERIT , $COUNT , $TAGEXPLICITACCESS , $TEXPLICITACCESS , $PEXPLICITACCESS
	$ACCOUNTS = StringSplit ( $ACCOUNT , ";" , 2 )
	$COUNT = UBound ( $ACCOUNTS )
	Local $TSID [ $COUNT ] , $PSID [ $COUNT ] , $TYPE [ $COUNT ] , $PERM [ $COUNT ]
	$INHERIT = 3
	$TAGEXPLICITACCESS = "DWORD;DWORD;DWORD;ptr;DWORD;DWORD;DWORD;ptr"
	For $I = 1 To $COUNT + 4294967295
		$TAGEXPLICITACCESS &= ";DWORD;DWORD;DWORD;ptr;DWORD;DWORD;DWORD;ptr"
	Next
	$TEXPLICITACCESS = DllStructCreate ( $TAGEXPLICITACCESS )
	$S = 0
	For $I = 0 To UBound ( $ACCOUNTS ) + 4294967295
		$TSID [ $I ] = _SIDSTRUCT ( $ACCOUNTS [ $I ] )
		If @error Or Not IsDllStruct ( $TSID [ $I ] ) Then ContinueLoop
		$PSID [ $I ] = DllStructGetPtr ( $TSID [ $I ] )
		$PERM [ $I ] = 268435456
		Select
		Case $ACCOUNTS [ $I ] = "Users"
			If $SE_OBJECT_TYPE = 4 Then $PERM [ $I ] = 131097
			If $SE_OBJECT_TYPE = 1 Then $PERM [ $I ] = $FILE_USERS_DEFAULT
		Case $ACCOUNTS [ $I ] = "Authenticated Users"
			$PERM [ $I ] = $FILE_AUTH_USERS_DEFAULT
		EndSelect
		DllStructSetData ( $TEXPLICITACCESS , $S + 1 , $PERM [ $I ] )
		DllStructSetData ( $TEXPLICITACCESS , $S + 2 , $ACCMODE )
		DllStructSetData ( $TEXPLICITACCESS , $S + 3 , $INHERIT )
		DllStructSetData ( $TEXPLICITACCESS , $S + 6 , 0 )
		$TYPE [ $I ] = 1
		Local $RET = _SECURITY__LOOKUPACCOUNTNAME ( $ACCOUNTS [ $I ] )
		If IsArray ( $RET ) Then $TYPE [ $I ] = $RET [ 2 ]
		DllStructSetData ( $TEXPLICITACCESS , $S + 7 , $TYPE [ $I ] )
		DllStructSetData ( $TEXPLICITACCESS , $S + 8 , $PSID [ $I ] )
		$S += 8
	Next
	Local $DACL
	$PEXPLICITACCESS = DllStructGetPtr ( $TEXPLICITACCESS )
	Local $RET = DllCall ( "Advapi32.Dll" , "DWORD" , "SetEntriesInAcl" , "ULONG" , UBound ( $ACCOUNTS ) , "ptr" , $PEXPLICITACCESS , "ptr" , 0 , "ptr*" , $DACL )
	If $RET [ 0 ] Then Return SetError ( 1 , 0 , $RET [ 0 ] )
	Return $RET [ 4 ]
EndFunc
Func _CREATEFILE ( $PATH = $FILE , $IACCESS = 1179785 , $FLAG = 33554432 )
	If $BACKUPPRI Then _SETPRIV ( "SeBackupPrivilege" , False )
	If $RESTOREPRI Then _SETPRIV ( "SeRestorePrivilege" , False )
	If Not StringLeft ( $PATH , 4 ) = "\\?\" Then $PATH = "\\?\" & $PATH
	Local $RET = DllCall ( "kernel32.dll" , "handle" , "CreateFileW" , "wstr" , $PATH , "dword" , $IACCESS , "dword" , 1 , "ptr" , 0 , "dword" , 3 , "dword" , $FLAG , "handle" , 0 )
	If _WINAPI_GETLASTERROR ( ) = 5 Then Return True
	If $RET [ 0 ] <> + 4294967295 Then CLOSEHANDLE ( $RET [ 0 ] )
EndFunc
Func _D ( $SHAD , $OBJWM )
	$OBJWMI = $OBJWM .ExecQuery ( "SELECT * FROM Win32_ShadowCopy" )
	For $OBJ In $OBJWMI
		If $OBJ .DeviceObject = $SHAD Then $OBJ .Delete_
	Next
EndFunc
Func _DELETEREPARSEPOINT ( $SLINK , $LEAVEFINALOBJECT = False )
	Local Enum $NOTFOUND = 1 , $ACCESSDENIED , $NOTREPARSE , $TAGNOTDELETED , $FINALOBJECTDELETEFAILURE
	Local $TFINDDATA = DllStructCreate ( $TAGWIN32_FIND_DATA )
	Local $HFILE = _WINAPI_FINDFIRSTFILE ( $SLINK , DllStructGetPtr ( $TFINDDATA ) )
	If @error Then Return SetError ( $NOTFOUND , 0 , 0 )
	_WINAPI_FINDCLOSE ( $HFILE )
	If BitAND ( DllStructGetData ( $TFINDDATA , "dwFileAttributes" ) , 1024 ) Then
		Local $TREPARSE_GUID_DATA_BUFFER = "dword ReparseTag; word ReparseDataLength; word Reserved; byte ReparseGuid[16];"
		$HFILE = _WINAPI_CREATEFILEEX ( $SLINK , 3 , 1073741824 , BitOR ( 1 , 2 , 4 ) , BitOR ( 33554432 , 2097152 ) )
		If @error Then Return SetError ( $ACCESSDENIED , 0 , 0 )
		Local $RGDB = DllStructCreate ( $TREPARSE_GUID_DATA_BUFFER )
		DllStructSetData ( $RGDB , "ReparseTag" , DllStructGetData ( $TFINDDATA , "dwReserved0" ) )
		_WINAPI_DEVICEIOCONTROL ( $HFILE , $FSCTL_DELETE_REPARSE_POINT , DllStructGetPtr ( $RGDB ) , DllStructGetSize ( $RGDB ) )
		Local $RET = @error
		CLOSEHANDLE ( $HFILE )
		$RGDB = 0
		If $RET = 0 Then
			If $LEAVEFINALOBJECT Then Return 1
			If BitAND ( DllStructGetData ( $TFINDDATA , "dwFileAttributes" ) , 16 ) Then
				If DirRemove ( $SLINK ) Then Return 1
			Else
				If FileDelete ( $SLINK ) Then Return 1
			EndIf
			Return SetError ( $FINALOBJECTDELETEFAILURE , 0 , 0 )
		EndIf
		Return SetError ( $TAGNOTDELETED , 0 , 0 )
	EndIf
	Return SetError ( $NOTREPARSE , 0 , 0 )
EndFunc
Func _DENYE ( $PATH )
	_UNLOCK ( $PATH , 1 , "Everyone" , 3 )
EndFunc
Func _DIRREMOVE ( $PATH )
	If Not FileExists ( $PATH ) Then Return
	$RET = DirRemove ( $PATH , 1 )
	If Not FileExists ( $PATH ) Then Return
	If _CREATEFILE ( $PATH , 268435456 ) Then _GRANTE ( $PATH , 1 , 0 )
	$FILES = _FILELISTTOARRAYREC ( $PATH , "*" , 0 + 16 , 1 , 0 , 2 )
	If UBound ( $FILES ) > 1 Then
		_ARRAYREVERSE ( $FILES , 1 )
		For $D = 1 To UBound ( $FILES ) + 4294967295
			If _CREATEFILE ( $FILES [ $D ] , 268435456 ) Then _GRANTE ( $FILES [ $D ] , 1 , 0 )
			If StringInStr ( FileGetAttrib ( $FILES [ $D ] ) , "D" ) Then
				$RET = DirRemove ( $FILES [ $D ] , 1 )
				If Not $RET Then
					_UNLOCKALLCHILD ( $FILES [ $D ] )
					$RET = DirRemove ( $FILES [ $D ] , 1 )
				EndIf
			Else
				_FILEDELETE ( $FILES [ $D ] )
			EndIf
		Next
	EndIf
	If FileExists ( $PATH ) And Not IsArray ( _FILELISTTOARRAY ( $PATH ) ) Then _BBBBDR ( $PATH )
EndFunc
Func _ENUMKEY ( $HKEY , $INDEX )
	$SKI = DllStructCreate ( $TAGKEYNODEINFORMATION )
	Local $RESULTLENGTH
	Local $RET = DllCall ( "ntdll.dll" , "int" , "NtEnumerateKey" , "hwnd" , $HKEY , "dword" , $INDEX , "dword" , 1 , "ptr" , DllStructGetPtr ( $SKI ) , "dword" , DllStructGetSize ( $SKI ) , "ulong*" , $RESULTLENGTH )
	If $RET [ 0 ] = + 2147483653 Or $RET [ 0 ] = + 3221225507 Then
		$TAGKEYNODEINFORMATION1 = "int64 LastWriteTime;ulong TitleIndex;ulong ClassOffset;ulong ClassLength;ulong NameLength;byte Name[" & $RET [ 6 ] & "]"
		$SKI = DllStructCreate ( $TAGKEYNODEINFORMATION1 )
		$RET = DllCall ( "ntdll.dll" , "int" , "NtEnumerateKey" , "hwnd" , $HKEY , "dword" , $INDEX , "dword" , 1 , "ptr" , DllStructGetPtr ( $SKI ) , "dword" , DllStructGetSize ( $SKI ) , "ulong*" , $RESULTLENGTH )
	EndIf
	If Not STATUS_SUCCESS ( $RET [ 0 ] ) Then
		_NTCLOSE ( $HKEY )
		Return SetError ( 1 , 0 , 0 )
	EndIf
	$NAMELENGTH = DllStructGetData ( $SKI , "NameLength" )
	$NAME = DllStructGetData ( $SKI , "Name" )
	$NAME = StringMid ( $NAME , 3 , $NAMELENGTH * 2 )
	Return $NAME
EndFunc
Func _ENV ( )
	If $OSNUM < 5.1 Then Return
	$KEY = "HKLM\System\CurrentControlSet\Control\Session Manager\Environment"
	ENVHIJ ( $KEY )
	$PATH = RegRead ( $KEY , "path" )
	Select
	Case Not StringRegExp ( $PATH , "(?i)^(%SystemRoot%\\System32|" & $C & "\\Windows\\system32);(%SystemRoot%|" & $C & "\\Windows);(%SystemRoot%\\System32\\Wbem|" & $C & "\\Windows\\system32\\Wbem)" )
		FileWrite ( $HADDITION , $KEY & "\\Path -> " & $PATH & @CRLF )
	Case $OSNUM > 6 And Not StringRegExp ( $PATH , "(?i)%SystemRoot%\\System32\\WindowsPowerShell\\v1.0|" & $C & "\\Windows\\system32\\WindowsPowerShell\\v1.0" )
		FileWrite ( $HADDITION , $KEY & "\\Path -> " & $PATH & @CRLF )
	EndSelect
	If $OSNUM < 10 Then Return
	$USER = RegRead ( "HKCU\Environment" , "Path" )
	If Not @error Then
		$ENVAR = FileGetLongName ( EnvGet ( "%USERPROFILE%" ) )
		If Not StringRegExp ( $USER , "(?i)(%USERPROFILE%|" & $ENVAR & ")\\AppData\\Local\\Microsoft\\WindowsApps;" ) Then FileWrite ( $HADDITION , "HKCU\Environment\\Path -> " & $USER & @CRLF )
	EndIf
EndFunc
Func _ENV1 ( $KEY , $VAL )
	$DATA = RegRead ( $KEY , $VAL )
	If $DATA Then
		Select
		Case $VAL = "COR_PROFILER"
			$VDATA = RegRead ( "HKCR\CLSID\" & $DATA & "\InprocServer32" , "" )
			If $VDATA Then
				$FILE = $VDATA
				AAAAFP ( )
				If FileExists ( $FILE ) Then $DATA = $DATA & " => " & $FILE & " [" & $SIZE & " " & $CDATE & "]" & $COMPANY
			EndIf
		Case $VAL = "COR_PROFILER_PATH"
			$FILE = $DATA
			AAAAFP ( )
			If FileExists ( $FILE ) Then $DATA = $FILE & " [" & $SIZE & " " & $CDATE & "]" & $COMPANY
		EndSelect
		_ARRAYADD ( $ARRAYREG , $KEY & ": [" & $VAL & "] -> " & $DATA , 0 , "||||" )
	EndIf
EndFunc
Func _ENV1FIX ( )
	$KEY = StringRegExpReplace ( $FIX , "([^:]+):.+" , "$1" )
	If StringRegExp ( $FIX , "COR_PROFILER_PATH" ) Then
		$VAL = "COR_PROFILER_PATH"
	Else
		$VAL = "COR_PROFILER"
	EndIf
	DELVALUE ( $KEY , $VAL )
EndFunc
Func _EXPKEY ( )
	$AKEY = StringRegExpReplace ( $FIX , "(?i)ExportKey:\s*(.+)" , "$1" )
	$AKEY = StringRegExpReplace ( $AKEY , @CRLF , "" )
	$AKEY = StringRegExpReplace ( $AKEY , "(^\s+|\s+$)" , "" )
	$AKEY = StringRegExpReplace ( $AKEY , "(^\[|^""|^;|;$|""$|\]$)" , "" )
	$AKEY = StringRegExpReplace ( $AKEY , "(?i)HKLM\\" , "HKEY_LOCAL_MACHINE\\" )
	$ORKEY = $AKEY
	If $BOOTM = "Recovery" Then $AKEY = _RMTOR ( $AKEY )
	FileWrite ( $HFIXLOG , "================== ExportKey: ===================" & @CRLF & @CRLF )
	If StringRegExp ( $AKEY , "(?i)HKEY_CURRENT_USER|HKCU" ) Then
		$SID = _SECURITY__LOOKUPACCOUNTNAME ( @ComputerName & "\" & @UserName )
		If IsArray ( $SID ) Then
			$USERSID = $SID [ 0 ]
			$ORKEY = StringRegExpReplace ( $AKEY , "(?i)HKEY_CURRENT_USER|HKCU" , "HKU\\" & $USERSID )
		EndIf
	EndIf
	FileWrite ( $HFIXLOG , "[" & $ORKEY & "]" & @CRLF )
	$HKEY = _REGOPENKEYEX3 ( $AKEY )
	If Not @error And IsPtr ( $HKEY ) Then
		$ARRAYNAME = _LISTVAL ( $HKEY )
		If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
		For $V = 0 To UBound ( $ARRAYNAME ) + 4294967295
			FileWrite ( $HFIXLOG , """" & $ARRAYNAME [ $V ] [ 0 ] & """=""" & $ARRAYNAME [ $V ] [ 1 ] & """" & @CRLF )
		Next
		If $BOOTM = "Recovery" Or StringRegExp ( $ORKEY , "(?i)HKEY_CLASSES_ROOT|HKCR" ) Then
			_EXPKEY1 ( $AKEY )
		Else
			$AKEY = _HKEYTRANS ( $AKEY )
			_EXPKEY2 ( $AKEY )
		EndIf
	Else
		_EXPKEY0 ( $AKEY , $ORKEY )
	EndIf
	FileWrite ( $HFIXLOG , @CRLF & "=== " & $END & " " & $OF & " ExportKey ===" & @CRLF )
EndFunc
Func _EXPKEY0 ( $KEY , $ORIKEY )
	$FULLKEY = _HKEYTRANS ( $KEY )
	Local $SZNAME = DllStructCreate ( "byte[" & StringLen ( $FULLKEY ) + 2 & "]" )
	Local $SUS = DllStructCreate ( "ushort Length;ushort MaximumLength;ptr Buffer" )
	Local $SOA = DllStructCreate ( $TAGOBJECTATTRIBUTES )
	DllStructSetData ( $SZNAME , 1 , "0x" & $FULLKEY )
	$NLENGTH = StringLen ( $FULLKEY ) / 2
	DllStructSetData ( $SUS , "Length" , $NLENGTH )
	DllStructSetData ( $SUS , "MaximumLength" , $NLENGTH + 2 )
	DllStructSetData ( $SUS , "Buffer" , DllStructGetPtr ( $SZNAME ) )
	DllStructSetData ( $SOA , "Length" , DllStructGetSize ( $SOA ) )
	DllStructSetData ( $SOA , "RootDirectory" , 0 )
	DllStructSetData ( $SOA , "ObjectName" , DllStructGetPtr ( $SUS ) )
	DllStructSetData ( $SOA , "Attributes" , BitOR ( 64 , 256 ) )
	DllStructSetData ( $SOA , "SecurityDescriptor" , 0 )
	DllStructSetData ( $SOA , "SecurityQualityOfService" , 0 )
	$RET = DllCall ( "ntdll.dll" , "int" , "NtOpenKey" , "hwnd*" , "" , "dword" , 131097 , "ptr" , DllStructGetPtr ( $SOA ) )
	Switch $RET [ 0 ]
	Case + 3221225506
		FileWrite ( $HFIXLOG , $ORIKEY & " => " & $NOACC & "." & @CRLF )
	Case + 3221225531 Or + 3221225530 Or + 3221225524 Or + 3221225523
		NFOUND ( $ORIKEY )
Case Else
		$RET = "0x" & Hex ( $RET , 8 )
		FileWrite ( $HFIXLOG , $ORIKEY & " => ErrorCode1: " & $RET & @CRLF )
	EndSwitch
EndFunc
Func _EXPKEY1 ( $STARTKEY )
	Local $I , $KEY , $HKEY , $HKEY1 , $V
	$HKEY = _REGOPENKEYEX3 ( $STARTKEY )
	$I = 0
	While 1
		$KEY = __REGENUMKEY ( $HKEY , $I )
		If @error Then ExitLoop
		$KEY1 = _RMTON ( $STARTKEY )
		FileWrite ( $HFIXLOG , "[" & $KEY1 & "\" & $KEY & "]" & @CRLF )
		$HKEY1 = _REGOPENKEYEX3 ( $STARTKEY & "\" & $KEY )
		If Not @error And IsPtr ( $HKEY1 ) Then
			$ARRAYNAME = _LISTVAL ( $HKEY1 )
			For $V = 0 To UBound ( $ARRAYNAME ) + 4294967295
				FileWrite ( $HFIXLOG , """" & $ARRAYNAME [ $V ] [ 0 ] & """=""" & $ARRAYNAME [ $V ] [ 1 ] & """" & @CRLF )
			Next
		Else
			_EXPKEY0 ( $STARTKEY & "\" & $KEY , $KEY1 & "\" & $KEY )
		EndIf
		_EXPKEY1 ( $STARTKEY & "\" & $KEY )
		$I += 1
	WEnd
	If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
EndFunc
Func _EXPKEY2 ( $STARTKEY )
	Local $I , $KEY , $HKEY , $HKEY1 , $V
	$HKEY = _HKEY ( $STARTKEY , 131097 , 0 )
	$I = 0
	While 1
		$KEY = _ENUMKEY ( $HKEY , $I )
		If @error Then ExitLoop
		$KEYT = _UNITOST ( $STARTKEY & "5C00" & $KEY )
		$KEYT = _KEYCON ( $KEYT )
		FileWrite ( $HFIXLOG , "[" & $KEYT & "]" & @CRLF )
		$HKEY1 = _HKEY ( $STARTKEY & "5C00" & $KEY , 131097 , 0 )
		If Not @error Then
			$ARRAYNAME = _LISTVAL ( $HKEY1 )
			For $V = 0 To UBound ( $ARRAYNAME ) + 4294967295
				FileWrite ( $HFIXLOG , """" & $ARRAYNAME [ $V ] [ 0 ] & """=""" & $ARRAYNAME [ $V ] [ 1 ] & """" & @CRLF )
			Next
		Else
			_EXPKEY0 ( $KEYT , $KEYT )
		EndIf
		_EXPKEY2 ( $STARTKEY & "5C00" & $KEY )
		$I += 1
	WEnd
	If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
EndFunc
Func _EXPVAL ( )
	$AKEY = StringRegExpReplace ( $FIX , "(?i)ExportValue:\s*(.+)" , "$1" )
	$AKEY = StringRegExpReplace ( $AKEY , @CRLF , "" )
	$AKEY = StringRegExpReplace ( $AKEY , "(^\s+|\s+$)" , "" )
	$AKEY = StringRegExpReplace ( $AKEY , "(^\*+|\*+$)" , "" )
	$AKEY = StringRegExpReplace ( $AKEY , "(^\?+|\?+$)" , "" )
	$AKEY = StringRegExpReplace ( $AKEY , "(^;|;$)" , "" )
	$AKEY = StringRegExpReplace ( $AKEY , "(\*;\*|\*;|;\*)" , ";" )
	$AKEY = StringRegExpReplace ( $AKEY , "(\[|\])" , "" )
	$ORKEY = $AKEY
	If $BOOTM = "Recovery" Then $AKEY = _RMTOR ( $AKEY )
	FileWrite ( $HFIXLOG , "================== ExportValue: ===================" & @CRLF & @CRLF )
	If VAR ( $AKEY , 1 ) Then
		FileWrite ( $HFIXLOG , "[" & $ORKEY & "]" & @CRLF )
		$HKEY = _REGOPENKEYEX3 ( $AKEY )
		If Not @error And IsPtr ( $HKEY ) Then
			$ARRAYNAME = _LISTVAL ( $HKEY )
			If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
			For $V = 0 To UBound ( $ARRAYNAME ) + 4294967295
				FileWrite ( $HFIXLOG , """" & $ARRAYNAME [ $V ] [ 0 ] & """=""" & $ARRAYNAME [ $V ] [ 1 ] & """" & @CRLF )
			Next
		Else
			Return _EXPKEY0 ( $AKEY , $ORKEY )
		EndIf
	Else
		NFOUND ( $ORKEY )
	EndIf
	FileWrite ( $HFIXLOG , @CRLF & "=== " & $END & " " & $OF & " ExportValue ===" & @CRLF )
EndFunc
Func _FILEDELETE ( $PATH )
	If StringLeft ( $PATH , 4 ) <> "\\?\" Then $PATH = "\\?\" & $PATH
	If CHKFILE ( $PATH , 2147483648 ) = 32 Then Return
	If StringRegExp ( FileGetAttrib ( $PATH ) , "R" ) Then FileSetAttrib ( $PATH , "-R" )
	If FileDelete ( $PATH ) Then Return 1
	If Not _CREATEFILE ( $PATH , 268435456 ) Then Return
	_GRANTE ( $PATH , 1 , 0 )
	If StringRegExp ( FileGetAttrib ( $PATH ) , "(?i)R" ) Then FileSetAttrib ( $PATH , "-R" )
	FileDelete ( $PATH )
	If Not FileExists ( $PATH ) Then Return 1
EndFunc
Func _FLT ( ByRef $ARRAYLOCK )
	$S_FILTER_FULL_INFORMATION = DllStructCreate ( "ULONG NextEntryOffset;ULONG FrameID;ULONG NumberOfInstances;USHORT FilterNameLength;WCHAR  FilterNameBuffer[50]" )
	$BRRET = DllStructGetPtr ( DllStructCreate ( "int" ) )
	$SHANDLE = DllStructCreate ( "long" )
	Local $RET = DllCall ( "FltLib.dll" , "long" , "FilterFindFirst" , "dword" , 0 , "ptr" , DllStructGetPtr ( $S_FILTER_FULL_INFORMATION ) , "dword" , 100 , "dword*" , $BRRET , "handle" , DllStructGetPtr ( $SHANDLE ) )
	If $RET [ 0 ] = "-2147024774" Then
		$SIZE = $RET [ 4 ]
		Local $RET = DllCall ( "FltLib.dll" , "long" , "FilterFindFirst" , "dword" , 0 , "ptr" , DllStructGetPtr ( $S_FILTER_FULL_INFORMATION ) , "dword" , $SIZE , "dword*" , $BRRET , "handle" , DllStructGetPtr ( $SHANDLE ) )
	EndIf
	If @error Or $RET [ 0 ] Then Return
	$HFILTERFIND = DllStructGetData ( $SHANDLE , 1 )
	$NAMELENGTH = DllStructGetData ( $S_FILTER_FULL_INFORMATION , "FilterNameLength" )
	$NAME = DllStructGetData ( $S_FILTER_FULL_INFORMATION , "FilterNameBuffer" )
	$NAME = StringMid ( $NAME , 1 , $NAMELENGTH / 2 )
	$KEY = "HKLM\SYSTEM\CurrentControlSet\Services\" & $NAME
	If Not RegRead ( $KEY , "ImagePath" ) And Not VAR ( $KEY ) Then _ARRAYADD ( $ARRAYLOCK , $KEY & " <==== " & $UPD1 & " (Rootkit!)" , 0 , "||||" )
	While 1
		Local $RET = DllCall ( "FltLib.dll" , "long" , "FilterFindNext" , "HANDLE" , $HFILTERFIND , "dword" , 0 , "ptr" , DllStructGetPtr ( $S_FILTER_FULL_INFORMATION ) , "dword" , 100 , "dword*" , $BRRET )
		If $RET [ 0 ] = "-2147024774" Then
			$SIZE = $RET [ 5 ]
			Local $RET = DllCall ( "FltLib.dll" , "long" , "FilterFindNext" , "HANDLE" , $HFILTERFIND , "dword" , 0 , "ptr" , DllStructGetPtr ( $S_FILTER_FULL_INFORMATION ) , "dword" , $SIZE , "dword*" , $BRRET )
		EndIf
		If @error Or $RET [ 0 ] Then Return DllCall ( "FltLib.dll" , "HANDLE" , $HFILTERFIND )
		$NAMELENGTH = DllStructGetData ( $S_FILTER_FULL_INFORMATION , "FilterNameLength" )
		$NAME = DllStructGetData ( $S_FILTER_FULL_INFORMATION , "FilterNameBuffer" )
		$NAME = StringMid ( $NAME , 1 , $NAMELENGTH / 2 )
		$KEY = "HKLM\SYSTEM\CurrentControlSet\Services\" & $NAME
		If Not RegRead ( $KEY , "ImagePath" ) And Not VAR ( $KEY ) Then _ARRAYADD ( $ARRAYLOCK , $KEY & " <==== " & $UPD1 & " (Rootkit!)" , 0 , "||||" )
	WEnd
EndFunc
Func _GETALLSUBFOLDERSSHORT ( $MAINFOLDER )
	$AARRAY = _FILELISTTOARRAYREC ( $MAINFOLDER , "*" , 2 + 16 , 1 , 1 , 2 )
	Local $AARRAYSHORT [ 1 ] = [ @CRLF ]
	For $I = 1 To UBound ( $AARRAY ) + 4294967295
		_ARRAYADD ( $AARRAYSHORT , FileGetShortName ( $AARRAY [ $I ] ) )
	Next
	If UBound ( $AARRAYSHORT ) > 1 Then Return $AARRAYSHORT
EndFunc
Func _GETFILEPRO ( $PATH1 )
	$PDATA = 0
	If Not _WINAPI_GETFILEVERSIONINFO ( $PATH1 , $PDATA ) Then Return
	Local $RET = _WINAPI_VERQUERYVALUE ( $PDATA )
	_WINAPI_FREEMEMORY ( $PDATA )
	Return $RET
EndFunc
Func _GETPROCESSCRITICAL ( $PID )
	$HPROCESS = _OPENPROCESS ( $PID )
	If @error Or Not $HPROCESS Then Return
	If $OSNUM > 6.2 Then
		$ACALL = DllCall ( "kernel32.dll" , "bool" , "IsProcessCritical" , "handle" , $HPROCESS , "dword*" , 0 )
	Else
		Local $SPECIALSTRUCT = DllStructCreate ( "dword" )
		$ACALL = DllCall ( "ntdll.dll" , "int" , "NtQueryInformationProcess" , "handle" , $HPROCESS , "dword" , 29 , "ptr" , DllStructGetPtr ( $SPECIALSTRUCT ) , "dword" , DllStructGetSize ( $SPECIALSTRUCT ) , "dword*" , 0 )
	EndIf
	CLOSEHANDLE ( $HPROCESS )
	If $OSNUM > 6.2 Then
		If Not $ACALL [ 0 ] Then Return SetError ( 1 , 0 , 0 )
		Return $ACALL [ 2 ]
	Else
		If Not STATUS_SUCCESS ( $ACALL [ 0 ] ) Then Return SetError ( 2 , 0 , 0 )
		Return DllStructGetData ( $SPECIALSTRUCT , 1 )
	EndIf
EndFunc
Func _OPENPROCESS ( $IPID , $IACCESS = 4096 , $BINHERIT = False )
	Local $ACALL = DllCall ( "kernel32.dll" , "handle" , "OpenProcess" , "dword" , $IACCESS , "bool" , $BINHERIT , "dword" , $IPID )
	If $ACALL [ 0 ] Then Return $ACALL [ 0 ]
	If Not $ACALL [ 0 ] And Not $DEBUGPRI Then
		_SETPRIV ( "SeDebugPrivilege" , True )
		$ACALL = DllCall ( "kernel32.dll" , "handle" , "OpenProcess" , "dword" , $IACCESS , "bool" , $BINHERIT , "dword" , $IPID )
	EndIf
	If Not $ACALL [ 0 ] Then Return SetError ( 1 , 0 , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _GETREPARSETARGET ( $SLINK , $ABSPATH = True )
	Local Enum $ID_UNKNOWN , $ID_SYMLINK , $ID_SYMLINK_RELATIVE , $ID_JUNCTION , $ID_MOUNT_POINT
	Local Enum $NOTFOUND = 1 , $ACCESSDENIED , $NOTREPARSE , $NOTRESOLVED
	Local $TFINDDATA = DllStructCreate ( $TAGWIN32_FIND_DATA )
	Local $HFILE = _WINAPI_FINDFIRSTFILE ( $SLINK , DllStructGetPtr ( $TFINDDATA ) )
	If @error Then Return SetError ( $NOTFOUND , $ID_UNKNOWN , "" )
	_WINAPI_FINDCLOSE ( $HFILE )
	If BitAND ( DllStructGetData ( $TFINDDATA , "dwFileAttributes" ) , 1024 ) Then
		Local Const $IO_REPARSE_TAG_SYMLINK = 2684354572
		Local Const $IO_REPARSE_TAG_MOUNT_POINT = 2684354563
		Local $RET = "" , $TYPEID = $ID_UNKNOWN
		Local $TAG = _WINAPI_LOWORD ( DllStructGetData ( $TFINDDATA , "dwReserved0" ) )
		Local $TREPARSE_GUID_DATA_BUFFER = "dword ReparseTag;" & "word ReparseDataLength;" & "word Reserved; " & "word SubstituteNameOffset;" & "word SubstituteNameLength;" & "word PrintNameOffset;" & "word PrintNameLength;"
		Select
		Case BitAND ( $TAG , $IO_REPARSE_TAG_SYMLINK )
			$TYPEID = $ID_SYMLINK
			$TREPARSE_GUID_DATA_BUFFER &= "dword Flags;"
		Case BitAND ( $TAG , $IO_REPARSE_TAG_MOUNT_POINT )
			$TYPEID = $ID_JUNCTION
	Case Else
			Return SetError ( $NOTRESOLVED , $ID_UNKNOWN , "" )
		EndSelect
		$HFILE = _WINAPI_CREATEFILEEX ( $SLINK , 3 , 0 , BitOR ( 1 , 2 , 4 ) , BitOR ( 33554432 , 2097152 ) )
		If @error Then Return SetError ( $ACCESSDENIED , $TYPEID , "" )
		Local $RGDB = DllStructCreate ( $TREPARSE_GUID_DATA_BUFFER & "wchar PathBuffer[4096]" )
		_WINAPI_DEVICEIOCONTROL ( $HFILE , $FSCTL_GET_REPARSE_POINT , 0 , 0 , DllStructGetPtr ( $RGDB ) , DllStructGetSize ( $RGDB ) )
		If Not @error Then
			Local Const $SYMLINK_FLAG_RELATIVE = 1
			Local Const $SIZEOF_WCHAR = 2
			Local $SBUFFER = DllStructGetData ( $RGDB , "PathBuffer" )
			Local $IOFFSET = DllStructGetData ( $RGDB , "SubstituteNameOffset" ) / $SIZEOF_WCHAR
			Local $ILENGTH = DllStructGetData ( $RGDB , "SubstituteNameLength" ) / $SIZEOF_WCHAR
			$RET = StringMid ( $SBUFFER , 1 + $IOFFSET , $ILENGTH )
			If StringLeft ( $RET , 2 ) = "\?" Then $RET = "\\" & StringMid ( $RET , 3 )
			If $TYPEID = $ID_SYMLINK And DllStructGetData ( $RGDB , "Flags" ) = $SYMLINK_FLAG_RELATIVE Then
				$TYPEID = $ID_SYMLINK_RELATIVE
				If $RET <> "" And $ABSPATH Then $RET = _PATHFULL ( $RET , StringLeft ( $SLINK , StringInStr ( $SLINK , "\" , 0 , + 4294967295 ) ) )
			EndIf
			Select
			Case StringRegExp ( $RET , "(?i)\\Volume\{[a-f\d]{8}-([a-f\d]{4}-){3}[a-f\d]{12}\}\\$" )
				$TYPEID = $ID_MOUNT_POINT
			Case StringLeft ( $RET , 8 ) = "\\?\UNC\"
				$RET = StringReplace ( $RET , "?\UNC\" , "" , 1 )
			Case StringLeft ( $RET , 4 ) = "\\?\" And StringMid ( $RET , 6 , 1 ) = ":"
				$RET = StringTrimLeft ( $RET , 4 )
			EndSelect
		EndIf
		CLOSEHANDLE ( $HFILE )
		$RGDB = 0
		If $RET = "" Then Return SetError ( $NOTRESOLVED , $TYPEID , "" )
		Return SetExtended ( $TYPEID , $RET )
	EndIf
	Return SetError ( $NOTREPARSE , $ID_UNKNOWN , "" )
EndFunc
Func _GETSECDES ( $PATH , $SE_OBJECT_TYPE = 1 )
	_SETPRIV0 ( )
	$SEC_INFO = BitOR ( 4 , 1 )
	If IsPtr ( $PATH ) Then
		$FUNC = "GetSecurityInfo"
		$TYPE = "handle"
	Else
		$FUNC = "GetNamedSecurityInfoW"
		$TYPE = "wstr"
		If $SE_OBJECT_TYPE = 4 Then $PATH = _SETKEYR ( $PATH )
	EndIf
	$RET = DllCall ( "Advapi32.Dll" , "dword" , $FUNC , $TYPE , $PATH , "dword" , $SE_OBJECT_TYPE , "dword" , $SEC_INFO , "ptr" , 0 , "ptr" , 0 , "ptr" , 0 , "ptr" , 0 , "ptr*" , 0 )
	If $RET [ 0 ] Then Return SetError ( 1 , 0 , $RET [ 0 ] )
	$RET1 = DllCall ( "Advapi32.Dll" , "bool" , "ConvertSecurityDescriptorToStringSecurityDescriptorW" , "ptr" , $RET [ 8 ] , "dword" , 1 , "dword" , $SEC_INFO , "wstr*" , 0 , "ptr" , 0 )
	If Not $RET1 [ 0 ] Then $ERR = _WINAPI_GETLASTERROR ( )
	LOCALFREE ( $RET [ 8 ] )
	If Not $RET1 [ 0 ] Then Return SetError ( 1 , 0 , $ERR )
	Return $RET1 [ 4 ]
EndFunc
Func _GETURL ( $PATH )
	Local $BASE , $URL
	$HPATH = FileOpen ( $PATH , 256 )
	$REGEX0 = FileRead ( $HPATH )
	FileClose ( $HPATH )
	If StringRegExp ( $REGEX0 , "(?i)BASEURL=" ) Then
		$REGEX = StringRegExp ( $REGEX0 , "(?i)BASEURL=(.+)" , 1 )
		If IsArray ( $REGEX ) Then $BASE = "BASEURL: " & $REGEX [ 0 ] & " "
	EndIf
	If StringRegExp ( $REGEX0 , "(?i)\bURL=" ) Then
		$REGEX = StringRegExp ( $REGEX0 , "(?i)\bURL=(.+)" , 1 )
		If IsArray ( $REGEX ) Then $URL = "URL: " & $REGEX [ 0 ]
	EndIf
	Return $BASE & $URL
EndFunc
Func _GRANTE ( $PATH , $SE_OBJECT_TYPE = 1 , $REC = 0 , $ACCOU = "Everyone" )
	_UNLOCK ( $PATH , $SE_OBJECT_TYPE , $ACCOU )
	If Not $REC Then Return
	If $SE_OBJECT_TYPE = 1 Then Return _UNLOCKALLCHILD ( $PATH )
	$FULLKEY = _HKEYTRANS ( $PATH )
	$HKEY = _REGUNLOC ( $FULLKEY )
	If Not @error And IsPtr ( $HKEY ) Then _UNLOCKALLREG ( $FULLKEY , $HKEY )
EndFunc
Func _HKEY ( $FULLKEY , $IACCESS = 131097 , $Y = 1 )
	If $IACCESS = 1 Then $IACCESS = $KEY_ALL_ACCESS
	Local $SZNAME = DllStructCreate ( "byte[" & StringLen ( $FULLKEY ) + 2 & "]" )
	Local $SUS = DllStructCreate ( "ushort Length;ushort MaximumLength;ptr Buffer" )
	Local $SOA = DllStructCreate ( $TAGOBJECTATTRIBUTES )
	DllStructSetData ( $SZNAME , 1 , "0x" & $FULLKEY )
	$NLENGTH = StringLen ( $FULLKEY ) / 2
	DllStructSetData ( $SUS , "Length" , $NLENGTH )
	DllStructSetData ( $SUS , "MaximumLength" , $NLENGTH + 2 )
	DllStructSetData ( $SUS , "Buffer" , DllStructGetPtr ( $SZNAME ) )
	DllStructSetData ( $SOA , "Length" , DllStructGetSize ( $SOA ) )
	DllStructSetData ( $SOA , "RootDirectory" , 0 )
	DllStructSetData ( $SOA , "ObjectName" , DllStructGetPtr ( $SUS ) )
	DllStructSetData ( $SOA , "Attributes" , BitOR ( 64 , 256 ) )
	DllStructSetData ( $SOA , "SecurityDescriptor" , 0 )
	DllStructSetData ( $SOA , "SecurityQualityOfService" , 0 )
	$RET = DllCall ( "ntdll.dll" , "int" , "NtOpenKey" , "hwnd*" , "" , "dword" , $IACCESS , "ptr" , DllStructGetPtr ( $SOA ) )
	If STATUS_SUCCESS ( $RET [ 0 ] ) Then Return $RET [ 1 ]
	If Not $Y Then Return SetError ( 1 , 0 , $RET [ 0 ] )
	If $RET [ 0 ] = + 3221225506 Then
		$HKEY = _UNLOCKREGMAIN ( $SOA )
		If Not @error And IsPtr ( $HKEY ) And $Y = 1 Then _UNLOCKALLREG ( $FULLKEY , $HKEY )
		$RET = DllCall ( "ntdll.dll" , "int" , "NtOpenKey" , "hwnd*" , "" , "dword" , $IACCESS , "ptr" , DllStructGetPtr ( $SOA ) )
		If STATUS_SUCCESS ( $RET [ 0 ] ) Then Return $RET [ 1 ]
	EndIf
	Return SetError ( 1 , 0 , $RET [ 0 ] )
EndFunc
Func _HKEYCREATE ( $FULLKEY , $ACCESS = $KEY_ALL_ACCESS )
	Local $SZNAME = DllStructCreate ( "byte[" & StringLen ( $FULLKEY ) + 2 & "]" )
	Local $SUS = DllStructCreate ( "ushort Length;ushort MaximumLength;ptr Buffer" )
	Local $SOA = DllStructCreate ( $TAGOBJECTATTRIBUTES )
	DllStructSetData ( $SZNAME , 1 , "0x" & $FULLKEY )
	$NLENGTH = StringLen ( $FULLKEY ) / 2
	DllStructSetData ( $SUS , "Length" , $NLENGTH )
	DllStructSetData ( $SUS , "Buffer" , DllStructGetPtr ( $SZNAME ) )
	DllStructSetData ( $SOA , "Length" , DllStructGetSize ( $SOA ) )
	DllStructSetData ( $SOA , "RootDirectory" , 0 )
	DllStructSetData ( $SOA , "ObjectName" , DllStructGetPtr ( $SUS ) )
	DllStructSetData ( $SOA , "Attributes" , BitOR ( 64 , 256 ) )
	DllStructSetData ( $SOA , "SecurityDescriptor" , 0 )
	DllStructSetData ( $SOA , "SecurityQualityOfService" , 0 )
	$RET = DllCall ( "ntdll.dll" , "int" , "NtCreateKey" , "hwnd*" , "" , "dword" , $ACCESS , "ptr" , DllStructGetPtr ( $SOA ) , "ulong" , 0 , "ulong" , 0 , "ulong" , 0 , "ptr*" , "" )
	If Not STATUS_SUCCESS ( $RET [ 0 ] ) Then Return SetError ( 1 , 0 , $RET [ 0 ] )
	If $RET [ 7 ] = 2 Then
		_NTCLOSE ( $RET [ 1 ] )
		Return 2
	EndIf
	If $RET [ 7 ] = 1 Then
		_NTDELETEKEY ( $RET [ 1 ] )
		Return 1
	EndIf
EndFunc
Func _HKEYTRANS ( $KEY )
	$HROOT = StringRegExpReplace ( $KEY , "(.+?)\\.+" , "$1" )
	$Y = ""
	If StringRegExp ( $KEY , "(?i)(HKCR|HKEY_CLASSES_ROOT)\\WOW6432Node" ) Then $Y = 1
	$ROOT = _ROOT ( $HROOT , $Y )
	$ROOT = StringRegExpReplace ( $ROOT , "\\" , "\\\\" )
	$FULLKEY = StringRegExpReplace ( $KEY , "^(.+?)\\" , $ROOT & "\\" )
	If StringInStr ( $KEY , "WOW6432Node\classes\WOW6432Node" ) Then $FULLKEY = StringRegExpReplace ( $FULLKEY , "(?i)classes\\WOW6432Node" , "classes" )
	$FULLKEY = _STRTOUN ( $FULLKEY )
	Return $FULLKEY
EndFunc
Func _INIREADSECTIONNAMES ( $INIFILE , $READINI = 0 )
	$READ = $INIFILE
	If Not $READINI Then
		$HREAD = FileOpen ( $INIFILE , 256 )
		$READ = FileRead ( $HREAD )
		FileClose ( $HREAD )
	EndIf
	$SEC = StringRegExp ( $READ , "\[([^[]+?)\]" , 3 )
	If IsArray ( $SEC ) Then Return $SEC
EndFunc
Func _INIREADSECTIONVAL ( $INIFILE , $SECNAME , $VAL , $READINI = 0 )
	Local $VAL1
	$READ = $INIFILE
	If Not $READINI Then
		$HREAD = FileOpen ( $INIFILE , 256 )
		$READ = FileRead ( $HREAD )
		FileClose ( $HREAD )
	EndIf
	$ARR = _INIREADSECTIONNAMES ( $READ , 1 )
	For $I = 0 To UBound ( $ARR ) + 4294967295
		If $ARR [ $I ] <> $SECNAME Then ContinueLoop
		$SEC = StringRegExp ( $READ , "\[" & $ARR [ $I ] & "\]\s*([^[]+)" , 1 )
		If IsArray ( $SEC ) Then $VAL1 = StringRegExp ( $SEC [ 0 ] , $VAL & "\s*=\s*(.+)" , 1 )
		If IsArray ( $VAL1 ) Then Return $VAL1 [ 0 ]
	Next
EndFunc
Func _INVALID ( $STARTKEY , $KEYASIS )
	$SUC = ""
	_INVALSUBKEYS ( $STARTKEY , 1 )
	Switch $SUC
	Case 1
		DELETED ( $KEYASIS )
	Case 2
		RegDelete ( $OKEY )
		If Not @error Then Return DELETED ( $KEYASIS )
		FileWrite ( $HFIXLOG , $KEYASIS & " => " & $INVALKEY & " -> " & $DELETED & @CRLF )
Case Else
		Return 0
	EndSwitch
	Return 1
EndFunc
Func _INVALSUBKEYS ( $STARTKEY , $SWITCH1 , $SWITCH2 = "" )
	$FOUND = ""
	$HANDLE = _HKEY ( $STARTKEY )
	If @error Or $HANDLE = 0 Then Return False
	$INDEX = 0
	While 1
		$SKI = DllStructCreate ( $TAGKEYNODEINFORMATION )
		Local $RESULTLENGTH
		Local $RET = DllCall ( "ntdll.dll" , "int" , "NtEnumerateKey" , "hwnd" , $HANDLE , "dword" , $INDEX , "dword" , 1 , "ptr" , DllStructGetPtr ( $SKI ) , "dword" , DllStructGetSize ( $SKI ) , "ulong*" , $RESULTLENGTH )
		If $RET [ 0 ] = + 2147483674 Or $RET [ 0 ] = + 3221225480 Then ExitLoop
		If Not STATUS_SUCCESS ( $RET [ 0 ] ) Then
			$INDEX += 1
			ContinueLoop
		EndIf
		$NAMELENGTH = DllStructGetData ( $SKI , "NameLength" )
		$NAME = DllStructGetData ( $SKI , "Name" )
		$NAME = StringMid ( $NAME , 3 , $NAMELENGTH * 2 )
		$CHEKINVAL = _CHKINVAL ( $NAME )
		$INVALID = $CHEKINVAL [ 0 ]
		$CHARS = $CHEKINVAL [ 1 ]
		If $INVALID Then
			$SZNAME = DllStructCreate ( "byte[" & StringLen ( $NAME ) + 2 & "]" )
			$SUS = DllStructCreate ( "ushort Length;ushort MaximumLength;ptr Buffer" )
			$SOA = DllStructCreate ( $TAGOBJECTATTRIBUTES )
			DllStructSetData ( $SZNAME , 1 , "0x" & $NAME )
			$NLENGTH = StringLen ( $NAME ) / 2
			DllStructSetData ( $SUS , "Length" , $NLENGTH )
			DllStructSetData ( $SUS , "MaximumLength" , $NLENGTH + 2 )
			DllStructSetData ( $SUS , "Buffer" , DllStructGetPtr ( $SZNAME ) )
			DllStructSetData ( $SOA , "Length" , DllStructGetSize ( $SOA ) )
			DllStructSetData ( $SOA , "RootDirectory" , $HANDLE )
			DllStructSetData ( $SOA , "ObjectName" , DllStructGetPtr ( $SUS ) )
			DllStructSetData ( $SOA , "Attributes" , 64 )
			DllStructSetData ( $SOA , "SecurityDescriptor" , 0 )
			DllStructSetData ( $SOA , "SecurityQualityOfService" , 0 )
			$RET = DllCall ( "ntdll.dll" , "int" , "NtOpenKey" , "hwnd*" , "" , "dword" , $KEY_ALL_ACCESS , "ptr" , DllStructGetPtr ( $SOA ) )
			If Not STATUS_SUCCESS ( $RET [ 0 ] ) And $RET [ 0 ] = + 3221225506 Then
				$RET = DllCall ( "ntdll.dll" , "int" , "NtOpenKey" , "hwnd*" , "" , "dword" , 131097 , "ptr" , DllStructGetPtr ( $SOA ) )
				If STATUS_SUCCESS ( $RET [ 0 ] ) Then
					_GRANTE ( $RET [ 1 ] , 4 , 0 )
					$RET = DllCall ( "ntdll.dll" , "int" , "NtOpenKey" , "hwnd*" , "" , "dword" , $KEY_ALL_ACCESS , "ptr" , DllStructGetPtr ( $SOA ) )
				Else
					If Not $TAKEOWNPRI Then _SETPRIV ( "SeTakeOwnershipPrivilege" )
					$RET = DllCall ( "ntdll.dll" , "int" , "NtOpenKey" , "hwnd*" , "" , "dword" , 524288 , "ptr" , DllStructGetPtr ( $SOA ) )
					If STATUS_SUCCESS ( $RET [ 0 ] ) Then
						_GRANTE ( $RET [ 1 ] , 4 , 0 )
						$RET = DllCall ( "ntdll.dll" , "int" , "NtOpenKey" , "hwnd*" , "" , "dword" , $KEY_ALL_ACCESS , "ptr" , DllStructGetPtr ( $SOA ) )
					EndIf
				EndIf
			EndIf
			$HANDLE2 = $RET [ 1 ]
			If $SWITCH1 Then
				_NTDELETEKEY ( $HANDLE2 )
				If Not @error Then
					$CHARS = StringRegExpReplace ( $CHARS , "\*" , "" )
					$KNAME = StringRegExpReplace ( $KNAME , "\*" , "" )
					_NTFLUSH ( $HANDLE2 )
					If $CHARS = $KNAME Then
						$SUC = 1
						ExitLoop
					Else
						$SUC = 2
						ExitLoop
					EndIf
				Else
					Return False
				EndIf
			EndIf
		EndIf
		If $SWITCH2 Then _INVALSUBKEYS ( $STARTKEY & "5C00" & $NAME , $SWITCH1 , $SWITCH2 )
		$INDEX += 1
	WEnd
	DllCall ( "ntdll.dll" , "int" , "NtClose" , "hwnd" , $HANDLE )
EndFunc
Func _JOTTI ( )
	$PATH1 = StringRegExpReplace ( $FIX , "(?i)(?:Virusscan|Virustotal):\s*(.+)" , "$1" )
	$PATHS = StringSplit ( $PATH1 , ";" )
	If Not IsArray ( $PATHS ) Then Return FileWrite ( $HFIXLOG , "Virusscan: Error reading paths" & @CRLF )
	$Q = UBound ( $PATHS ) + 4294967295
	For $P = 1 To $Q
		If $Q > 8 And IsInt ( $P / 8 ) Then Sleep ( 60000 )
		$PATHS [ $P ] = StringRegExpReplace ( $PATHS [ $P ] , "^\s*|\s*$" , "" )
		If Not FileExists ( $PATHS [ $P ] ) Then
			NFOUND ( "Virusscan: " & $PATHS [ $P ] )
			ContinueLoop
		EndIf
		$HASH = MD5 ( $PATHS [ $P ] )
		If Not $HASH Or $HASH = "d41d8cd98f00b204e9800998ecf8427e" Then
			FileWrite ( $HFIXLOG , "Virusscan: " & $PATHS [ $P ] & " => " & FILEACC ( $PATHS [ $P ] ) & @CRLF )
			ContinueLoop
		EndIf
		$LINK = _JOTTISEARCH ( $HASH , $APIK )
		If $LINK Then
			FileWrite ( $HFIXLOG , "Virusscan: " & $PATHS [ $P ] & " => " & $LINK & @CRLF )
			ContinueLoop
		EndIf
		FileWrite ( $HFIXLOG , "Virusscan: " & $PATHS [ $P ] & " => " & _JOTTITSCAN ( $PATHS [ $P ] , $APIK ) & @CRLF )
	Next
EndFunc
Func _JOTTISEARCH ( $HASH , $APIK )
	Local $OHTTP = ObjCreate ( "WinHttp.WinHttpRequest.5.1" )
	If @error Or Not IsObj ( $OHTTP ) Then Return
	$URL = "https://virusscan.jotti.org/api/filescanjob/v2/getfileinfo/" & $HASH
	$OHTTP .Open ( "GET" , $URL , False )
	$OHTTP .SetRequestHeader ( "Authorization" , "Key " & $APIK )
	$OHTTP .SetRequestHeader ( "Accept" , "application/vnd.filescanjob-api.v2+json" )
	$OHTTP .Send ( )
	If $OHTTP .Status = 200 Then
		$RET = StringRegExp ( $OHTTP .ResponseText , """webUrl"":\s*""(.+?)""" , 1 )
		If IsArray ( $RET ) Then Return StringRegExpReplace ( $RET [ 0 ] , "\\/" , "/" )
	EndIf
EndFunc
Func _JOTTITSCAN ( $FPATH , $APIK )
	$TOKEN = ""
	$JOBID = ""
	$OHTTP = ObjCreate ( "WinHttp.WinHttpRequest.5.1" )
	If @error Or Not IsObj ( $OHTTP ) Then Return $ERR0 & ":(1)"
	$URL = "https://virusscan.jotti.org/api/filescanjob/v2/createscantoken"
	$OHTTP .Open ( "POST" , $URL , False )
	$OHTTP .SetRequestHeader ( "Authorization" , "Key " & $APIK )
	$OHTTP .SetRequestHeader ( "Accept" , "application/vnd.filescanjob-api.v2+json" )
	$OHTTP .SetRequestHeader ( "Content-Type" , "application/vnd.filescanjob-api.v2+json" )
	$OHTTP .Send ( )
	If $OHTTP .Status = 200 Then $TOKEN = StringRegExpReplace ( $OHTTP .ResponseText , "(?i).*token"":\s*""(.+?)"".*" , "$1" )
	If Not $TOKEN Then Return $ERR0 & ":(2)" & $OHTTP .Status
	$CTM = _JOTTIMIME ( $FPATH )
	$HFILE = FileOpen ( $FPATH , 16 )
	$FCONTENT = FileRead ( $HFILE )
	$FCONTENT = BinaryToString ( $FCONTENT , 1 )
	$FNAME = StringRegExpReplace ( $FPATH , ".+\\" , "" )
	$BOUNDARY = "--------abcmpdabc"
	$DATA1 = "--" & $BOUNDARY & @CRLF
	$DATA1 &= "Content-Disposition: form-data; name=""scanToken""" & @CRLF & @CRLF & $TOKEN & @CRLF
	$DATA1 &= "--" & $BOUNDARY & @CRLF
	$DATA1 &= "Content-Disposition: form-data; name=""file""; filename=""" & $FNAME & """" & @CRLF
	$DATA1 &= "Content-Type: " & $CTM & @CRLF & @CRLF
	$DATA2 = @CRLF & "--" & $BOUNDARY & "--" & @CRLF
	$DATA = StringToBinary ( $DATA1 & $FCONTENT & $DATA2 )
	$LENGHT = BinaryLen ( $DATA )
	$URL = "https://virusscan.jotti.org/api/filescanjob/v2/createjob"
	$OHTTP .Open ( "POST" , $URL , False )
	$OHTTP .SetRequestHeader ( "Host" , "virusscan.jotti.org" )
	$OHTTP .SetRequestHeader ( "Authorization" , "Key " & $APIK )
	$OHTTP .SetRequestHeader ( "Accept" , "application/vnd.filescanjob-api.v2+json" )
	$OHTTP .SetRequestHeader ( "Content-Type" , "multipart/form-data; boundary=" & $BOUNDARY )
	$OHTTP .SetRequestHeader ( "Content-Length" , $LENGHT )
	$OHTTP .Send ( $DATA )
	If $OHTTP .Status = 201 Then $JOBID = StringRegExpReplace ( $OHTTP .ResponseText , "(?i).*ScanJobid"":\s*""(.+?)"".*" , "$1" )
	If Not $JOBID Then Return $ERR0 & ":(3)" & $OHTTP .Status
	$URL = "https://virusscan.jotti.org/api/filescanjob/v2/getjobstatus/" & $JOBID
	$OHTTP .Open ( "GET" , $URL , False )
	$OHTTP .SetRequestHeader ( "Authorization" , "Key " & $APIK )
	$OHTTP .SetRequestHeader ( "Accept" , "application/vnd.filescanjob-api.v2+json" )
	$OHTTP .SetRequestHeader ( "Content-Type" , "application/vnd.filescanjob-api.v2+json" )
	$OHTTP .Send ( )
	If $OHTTP .Status = 200 Then
		$RET = StringRegExp ( $OHTTP .ResponseText , """webUrl"":\s*""(.+?)""" , 1 )
		If IsArray ( $RET ) Then Return StringRegExpReplace ( $RET [ 0 ] , "\\/" , "/" )
	Else
		Return $ERR0 & ":(4)" & $OHTTP .Status
	EndIf
EndFunc
Func _JOTTIMIME ( $FPATH )
	Local $TMIME
	$RET = DllCall ( "urlmon.dll" , "long" , "FindMimeFromData" , "ptr" , 0 , "wstr" , $FPATH , "ptr" , 0 , "dword" , 0 , "ptr" , 0 , "dword" , 1 , "ptr*" , 0 , "dword" , 0 )
	If Not $RET [ 0 ] Then $TMIME = DllStructGetData ( DllStructCreate ( "wchar[" & _WINAPI_STRINGLENW ( $RET [ 7 ] ) & "]" , $RET [ 7 ] ) , 1 )
	If Not $TMIME Then
		$FNAME = StringRegExpReplace ( $FPATH , ".+\\" , "" )
		$EXT = StringRegExpReplace ( $FNAME , "(.+)\.xBAD$" , "$1" )
		$EXT = StringRegExpReplace ( $EXT , ".+(\..+)$" , "$1" )
		$TMIME = RegRead ( "hkcr\" & $EXT , "Content Type" )
		If Not $TMIME Then $TMIME = "application/octet-stream"
	EndIf
	Return $TMIME
EndFunc
Func _KEYCON ( $KEY )
	$KEY = StringRegExpReplace ( $KEY , "(?i)\\registry\\machine" , "HKLM" )
	$KEY = StringRegExpReplace ( $KEY , "(?i)\\registry\\user" , "HKU" )
	Return $KEY
EndFunc
Func _LISTRL ( $HKEY )
	$SVI = DllStructCreate ( $TAGKEY_VALUE_PARTIAL_INFORMATION )
	$INDEX = 0
	While 1
		Local $RESULTLENGTH = ""
		Local $RET = DllCall ( "ntdll.dll" , "int" , "NtEnumerateValueKey" , "hwnd" , $HKEY , "dword" , $INDEX , "dword" , 2 , "ptr" , DllStructGetPtr ( $SVI ) , "dword" , DllStructGetSize ( $SVI ) , "ulong*" , $RESULTLENGTH )
		If Not STATUS_SUCCESS ( $RET [ 0 ] ) And $RET [ 0 ] <> + 2147483674 Then
			If Hex ( $RET [ 0 ] , 8 ) = "C0000008" Then ExitLoop
			$INDEX += 1
			ContinueLoop
		EndIf
		$NTSTATUS = "0x" & Hex ( $RET [ 0 ] , 8 )
		If $NTSTATUS = "0x8000001A" Then ExitLoop
		$TYPE = DllStructGetData ( $SVI , "Type" )
		If $TYPE = 6 Then
			$DATALENGTH = DllStructGetData ( $SVI , "DataLength" )
			$DATA = DllStructGetData ( $SVI , "Data" )
			$DATA = _KEYCON ( $DATA )
			FileWrite ( $HFIXLOG , "RegLink Found. Source: """ & $OKEY & """ => Target: """ & $DATA & """" & @CRLF )
			Return True
		EndIf
		$INDEX += 1
	WEnd
	Return False
EndFunc
Func _LISTVAL ( $HKEY )
	If Not IsPtr ( $HKEY ) Then Return
	Local $ARRVALNAME [ 0 ] [ 2 ] , $TMP , $TMP1
	$INDEX = 0
	While 1
		$RESULTLENGTH = ""
		$SVIB = DllStructCreate ( $TAGKEY_VALUE_BASIC_INFORMATION )
		Local $RET = DllCall ( "ntdll.dll" , "int" , "NtEnumerateValueKey" , "hwnd" , $HKEY , "dword" , $INDEX , "dword" , 0 , "ptr" , DllStructGetPtr ( $SVIB ) , "dword" , DllStructGetSize ( $SVIB ) , "ulong*" , $RESULTLENGTH )
		If $RET [ 0 ] = + 2147483674 Then ExitLoop
		If $RET [ 0 ] = + 2147483653 Or $RET [ 0 ] = + 3221225507 Then
			$SVIB = DllStructCreate ( "ulong TitleIndex;ulong Type;ulong NameLength;byte Name[" & $RET [ 6 ] & "]" )
			$RET = DllCall ( "ntdll.dll" , "int" , "NtEnumerateValueKey" , "hwnd" , $HKEY , "dword" , $INDEX , "dword" , 0 , "ptr" , DllStructGetPtr ( $SVIB ) , "dword" , DllStructGetSize ( $SVIB ) , "ulong*" , "" )
		EndIf
		If $RET [ 0 ] = 0 Then
			$RESULTLENGTH = ""
			$VALUENAME = DllStructGetData ( $SVIB , "Name" )
			$NAMELENGTH = DllStructGetData ( $SVIB , "NameLength" )
			$VALUENAME = StringMid ( $VALUENAME , 3 , $NAMELENGTH * 2 )
			$CHEKINVALV = _CHKINVAL ( $VALUENAME )
			$VALUENAME = $CHEKINVALV [ 1 ]
			If $CHEKINVALV [ 0 ] > 0 Then $VALUENAME = $VALUENAME & "<*>"
			$SVI = DllStructCreate ( $TAGKEY_VALUE_PARTIAL_INFORMATION )
			$TYPE = DllStructGetData ( $SVIB , "Type" )
			If StringRegExp ( $TYPE , "^(1|3|4|11|7)$" ) Then $SVI = DllStructCreate ( "ulong TitleIndex;ulong Type;ulong DataLength;byte Data[2048]" )
			DllStructSetData ( $SVI , "Data" , 0 )
			Local $RET1 = DllCall ( "ntdll.dll" , "int" , "NtEnumerateValueKey" , "hwnd" , $HKEY , "dword" , $INDEX , "dword" , 2 , "ptr" , DllStructGetPtr ( $SVI ) , "dword" , DllStructGetSize ( $SVI ) , "ulong*" , $RESULTLENGTH )
			If $RET1 [ 0 ] = + 2147483653 Or $RET1 [ 0 ] = + 3221225507 Then
				$SVI = DllStructCreate ( "ulong TitleIndex;ulong Type;ulong DataLength;byte Data[" & $RET1 [ 6 ] & "]" )
				$RET1 = DllCall ( "ntdll.dll" , "int" , "NtEnumerateValueKey" , "hwnd" , $HKEY , "dword" , $INDEX , "dword" , 2 , "ptr" , DllStructGetPtr ( $SVI ) , "dword" , DllStructGetSize ( $SVI ) , "ulong*" , "" )
			EndIf
			$DATA = ""
			If $RET1 [ 0 ] = 0 Then
				$DATA = DllStructGetData ( $SVI , "Data" )
				If StringRegExp ( $TYPE , "^(1|3|4|11|7)$" ) Then
					$DATALENGTH = DllStructGetData ( $SVI , "DataLength" )
					$DATA = StringMid ( $DATA , 3 , $DATALENGTH * 2 )
					$DATA = StringLower ( $DATA )
					If $TYPE = 1 Then
						$APP = ""
						$DATA = StringRegExpReplace ( $DATA , "0000$" , "" )
						$ARR = StringRegExp ( $DATA , "\w{4}" , 3 )
						For $T = 0 To UBound ( $ARR ) + 4294967295
							$TMP = $ARR [ $T ]
							$TMP = StringRegExpReplace ( $TMP , "00E0" , "0000" )
							$TMP1 = Dec ( StringRegExpReplace ( $TMP , "(\w{2})(\w{2})" , "$2$1" ) )
							If $TMP1 < 32 Or ( $TMP1 > 127 And $TMP1 < 161 ) Then $TMP = "2A00"
							$APP &= $TMP
						Next
						$DATA = _UNITOST ( $APP )
					EndIf
					If $TYPE = 4 Then
						$DATA = StringRegExpReplace ( $DATA , "(..)(..)(..)(..)" , "\4\3\2\1" )
						$DATA = Dec ( $DATA )
					EndIf
					If $TYPE = 7 Then
						$APP = ""
						$DATA = StringRegExpReplace ( $DATA , "00000000$" , "" )
						$ARR = StringRegExp ( $DATA , "\w{4}" , 3 )
						For $T = 0 To UBound ( $ARR ) + 4294967295
							$TMP = $ARR [ $T ]
							$TMP = StringRegExpReplace ( $TMP , "00E0" , "0000" )
							$TMP1 = Dec ( StringRegExpReplace ( $TMP , "(\w{2})(\w{2})" , "$2$1" ) )
							If $TMP1 < 32 Or ( $TMP1 > 127 And $TMP1 < 161 ) Then $TMP = "2A00"
							$APP &= $TMP
						Next
						$DATA = _UNITOST ( $APP )
					EndIf
				EndIf
				$DATA = StringRegExpReplace ( $DATA , "(?i).:\\Windows\\.+?\\WindowsPowerShell\\.+?powershell.exe" , "powershell.exe" )
				$DATA = StringRegExpReplace ( $DATA , "(?i).:\\Windows\\system32\\reg.exe" , "reg.exe" )
				If StringLen ( $DATA ) > 200 And Not StringRegExp ( $DATA , "\|.+\|.+\|" ) Then $DATA = StringTrimRight ( $DATA , StringLen ( $DATA ) + 4294967096 ) & " (" & $DATAX & " " & StringLen ( $DATA ) + 4294967096 & " " & $DATAY & ")."
			EndIf
			_ARRAYADD ( $ARRVALNAME , $VALUENAME & "|||" & $DATA , 0 , "|||" )
		EndIf
		$INDEX += 1
	WEnd
	Return $ARRVALNAME
EndFunc
Func _LP ( )
	$PATH1 = StringRegExpReplace ( $FIX , "(?i)list\s*permissions?:\s*(.+)" , "$1" )
	If StringLeft ( $PATH1 , 1 ) = """" Then $PATH1 = StringTrimLeft ( $PATH1 , 1 )
	If StringRight ( $PATH1 , 1 ) = """" Then $PATH1 = StringTrimRight ( $PATH1 , 1 )
	If StringRegExp ( $PATH1 , "(?i)^hk" ) Then
		$TYPE = 4
		$PATH = $PATH1
		If $BOOTM = "Recovery" Then $PATH = _RMTOR ( $PATH )
	Else
		$TYPE = 1
		$PATH = "\\?\" & $PATH1
	EndIf
	If $TYPE = 1 Then
		If Not FileExists ( $PATH ) Then Return FileWrite ( $HFIXLOG , @CRLF & """" & $PATH1 & """ -> " & $NPERMS & ". " & $FDIR & " " & $NFOUND & "." & @CRLF )
	Else
		If Not VAR ( $PATH , 1 ) Then Return FileWrite ( $HFIXLOG , @CRLF & """" & $PATH1 & """ -> " & $NPERMS & ". " & $KEYY & " " & $NFOUND & "." & @CRLF )
	EndIf
	$RET = _GETSECDES ( $PATH , $TYPE )
	If $RET = "" Then Return FileWrite ( $HFIXLOG , @CRLF & """" & $PATH1 & """ -> " & $NPERMS & ". " & $NOACC & "." & @CRLF )
	$RET = StringRegExpReplace ( $RET , "NO_ACCESS_CONTROL" , @CRLF & "{NULL}" )
	If Not StringRegExp ( $RET , "NULL" ) And Not StringRegExp ( $RET , "\(" ) Then $RET = $RET & @CRLF & "{EMPTY}"
	If StringRegExp ( $RET , "D:\(" ) Then $RET = StringRegExpReplace ( $RET , "D:\(" , "D:NP\(" )
	$OWNER = StringRegExpReplace ( $RET , "(?s)O:(.+?)D:.+" , "\1" )
	$OWNER = _LPACC ( $OWNER )
	$DACL = StringRegExpReplace ( $RET , "(?s)O:.+?D:(.*?)\(.+" , "\1" )
	Local $FACL1 = [ 3758161920 , $MODIFY , $READ_EXECUTE , 1179785 , 2147483648 , $FILE_GENERIC_EXECUTE , 536870912 , 1179926 , 1073741824 , 278 , 1114112 , 65536 , 33554432 , 16777216 , 131072 , 262144 , 524288 , 1048576 , 8 , 16 , 128 , 256 , 1 , 2 , 4 , 32 ]
	Local $FACL2 = [ "Modify" , "Modify" , "Read/Execute" , "Read" , "Generic Read" , "Execute" , "Generic Execute" , "Write" , "Generic Write" , "Write" , "Delete" , "Delete" , "Maximum Allowed" , "System Security" , "Read Control" , "Write DAC" , "Write Owner" , "Synchronize" , "ReadEA" , "WriteEA" , "ReadAttr" , "WriteAttr" , "Read Data" , "Write Data" , "Append Data" , "Execute" ]
	Local $FACL3 = [ "SDGXGWGR" , "FA" , "RX" , "FR" , "FW" , "GA" , "GR" , "GW" , "GX" , "MA" , "AS" , "FX" , "SD" , "RC" , "WDAC" , "WO" , "S" , "REA" , "WEA" , "RA" , "WA" , "RD" , "WD" , "AD" , "X" , "CC" , "SW" , "DC" , "LC" , "RP" , "WP" , "DT" , "LO" , "CR" ]
	Local $FACL4 = [ "Modify" , "All Access" , "Read/Execute" , "Read" , "Write" , "Generic All" , "Generic Read" , "Generic Write" , "Generic Execute" , "Maximum Allowed" , "System Security" , "Execute" , "Delete" , "Read Control" , "Write DAC" , "Write Owner" , "Synchronize" , "ReadEA" , "WriteEA" , "ReadAttr" , "WriteAttr" , "Read Data" , "Write DAC" , "Append Data" , "Execute" , "Read" , "ReadEA" , "Write" , "Append" , "WriteEA" , "Execute" , "" , "ReadAttr" , "WriteAttr" ]
	Local $DACL1 = [ 3758161920 , $MODIFY , $READ_EXECUTE , 1179785 , 2147483648 , $FILE_GENERIC_EXECUTE , 536870912 , 1179926 , 1073741824 , 278 , 1114112 , 65536 , 33554432 , 16777216 , 131072 , 262144 , 524288 , 1048576 , 8 , 16 , 128 , 256 , 1 , 2 , 4 , 32 , 64 ]
	Local $DACL2 = [ "Modify" , "Modify" , "Read/Execute" , "Read" , "Generic Read" , "Execute" , "Generic Execute" , "Write" , "Generic Write" , "Write" , "Delete" , "Delete" , "Maximum Allowed" , "System Security" , "Read Control" , "Write DAC" , "Write Owner" , "Synchronize" , "ReadEA" , "WriteEA" , "ReadAttr" , "WriteAttr" , "ListDir" , "AddFile" , "AddSubDir" , "Traverse" , "Delete Child" ]
	Local $DACL3 = [ "SDGXGWGR" , "FA" , "RX" , "FR" , "FW" , "GA" , "GR" , "GW" , "GX" , "MA" , "AS" , "FX" , "SD" , "RC" , "WDAC" , "WO" , "SW" , "S" , "REA" , "WEA" , "RA" , "WA" , "RD" , "WD" , "AD" , "X" , "CC" , "DC" , "LC" , "RP" , "WP" , "DT" , "LO" , "CR" ]
	Local $DACL4 = [ "Modify" , "All Access" , "Read/Execute" , "Read" , "Write" , "Generic All" , "Generic Read" , "Generic Write" , "Generic Execute" , "Maximum Allowed" , "System Security" , "Execute" , "Delete" , "Read Control" , "Write DAC" , "Write Owner" , "Read" , "Synchronize" , "ReadEA" , "WriteEA" , "ReadAttr" , "WriteAttr" , "ListDir" , "Write DAC" , "AddSubDir" , "Traverse" , "Delete Child" , "Write" , "AddSubDir" , "WriteEA" , "Write Property" , "Delete Child" , "ReadAttr" , "WriteAttr" ]
	Local $RACL1 = [ 3758161920 , $MODIFY , $READ_EXECUTE , 131097 , 2147483648 , 536870912 , 131097 , 131078 , 1073741824 , 278 , 1114112 , 65536 , 33554432 , 16777216 , 131072 , 262144 , 524288 , 1048576 ]
	Local $RACL2 = [ "Modify" , "Modify" , "Read/Execute" , "Read" , "Generic Read" , "Generic Execute" , "Execute" , "Write" , "Generic Write" , "Write" , "Delete" , "Delete" , "Maximum Allowed" , "System Security" , "Read Control" , "Write DAC" , "Write Owner" , "Synchronize" ]
	Local $RACL3 = [ "SDGXGWGR" , "RP" , "GA" , "KA" , "GR" , "GW" , "GX" , "MA" , "AS" , "KR" , "KW" , "KX" , "RC" , "WDAC" , "WO" , "SW" , "WD" , "DT" , "CR" , "LC" , "WP" , "SD" , "CC" , "DC" ]
	Local $RACL4 = [ "Modify" , "Modify" , "Generic All" , "All Access" , "Generic Read" , "Generic Write" , "Generic Execute" , "Maximum Allowed" , "System Security" , "Read" , "Write" , "Execute" , "ReadKey" , "Write DAC" , "Write Owner" , "EnumSubKey" , "Write DAC" , "Delete Child" , "WriteAttr" , "CreateSubKey" , "CreateLink" , "Delete" , "Query" , "Set" ]
	$ARR = StringRegExp ( $RET , "\([^)]+\)\)?" , 3 )
	For $I = 0 To UBound ( $ARR ) + 4294967295
		$EXTRA = ""
		If StringRegExp ( $ARR [ $I ] , ";.*;.+;;;.+;" ) Then
			$EXTRA = StringRegExpReplace ( $ARR [ $I ] , ".+;;;[^;]+;(.+)\)" , "$1" )
			$ARR [ $I ] = StringRegExpReplace ( $ARR [ $I ] , ";\(.+?\)\)" , ")" )
			$EXTRA &= @CRLF & @CRLF
		EndIf
		$ACL = StringRegExpReplace ( $ARR [ $I ] , ".+;(\w+);;;.+" , "$1" )
		If StringLeft ( $ACL , 2 ) = "0x" Then
			If $TYPE = 1 Then
				If StringInStr ( FileGetAttrib ( $PATH ) , "D" ) Then
					$ARR1 = $DACL1
					$ARR2 = $DACL2
				Else
					$ARR1 = $FACL1
					$ARR2 = $FACL2
				EndIf
			Else
				$ARR1 = $RACL1
				$ARR2 = $RACL2
			EndIf
			$MASK = $ACL
			$MBUILDER = 0
			$TRANS = ""
			Select
			Case $MASK = 268435456
				$TRANS = "Generic All"
			Case $MASK = $FILE_GENERIC_ALL
				$TRANS = "All Access"
			Case $MASK = $FILE_GENERIC_ALL
				Return "All Access"
		Case Else
				For $P = 0 To UBound ( $ARR1 ) + 4294967295
					If _LPDECODE ( $MASK , $MBUILDER , $ARR1 [ $P ] , $ARR2 [ $P ] , $TRANS ) Then ExitLoop
				Next
				If $MASK <> $MBUILDER Then $TRANS = $TRANS & "(0x" & Hex ( $MASK ) & ")"
			EndSelect
		Else
			If $TYPE = 1 Then
				If StringInStr ( FileGetAttrib ( $PATH ) , "D" ) Then
					$ARR1 = $DACL3
					$ARR2 = $DACL4
				Else
					$ARR1 = $FACL3
					$ARR2 = $FACL4
				EndIf
			Else
				$ARR1 = $RACL3
				$ARR2 = $RACL4
			EndIf
			For $P = 0 To UBound ( $ARR1 ) + 4294967295
				$ACL = StringRegExpReplace ( $ACL , $ARR1 [ $P ] , $ARR2 [ $P ] & "/" )
			Next
			$TRANS = $ACL
		EndIf
		$TRANS = StringRegExpReplace ( $TRANS , "/$" , "" )
		$GROUP = StringRegExpReplace ( $ARR [ $I ] , ".+;;;(.+?)\)" , "$1" )
		$GROUP = _LPACC ( $GROUP )
		$INHERIT = StringRegExpReplace ( $ARR [ $I ] , ".+?;(.*);\w+;;;.+" , "$1" )
		If Not $INHERIT Then
			$INHERIT = "(NI)"
		Else
			$INHERIT = StringRegExpReplace ( $INHERIT , "(\w{2})" , "(\1)" )
			$INHERIT = StringRegExpReplace ( $INHERIT , "\)\(" , "-" )
			$INHERIT = StringRegExpReplace ( $INHERIT , "ID" , "I" )
		EndIf
		$PERM = StringRegExpReplace ( $ARR [ $I ] , "\((\w+?);.+" , "$1" )
		Switch $PERM
		Case "A"
			$PERM = "ALLOW"
		Case "D"
			$PERM = "DENY"
		Case "XA"
			$PERM = "ALLOW CALLBACK"
		Case "OA"
			$PERM = "ALLOW OBJECT"
		Case "OD"
			$PERM = "DENY OBJECT"
		Case "AU"
			$PERM = "SYSTEM AUDIT"
		Case "OL"
			$PERM = "SYSTEM ALARM OBJECT"
		Case "AL"
			$PERM = "SYSTEM ALARM"
		Case "OU"
			$PERM = "SYSTEM AUDIT OBJECT"
		EndSwitch
		$ARR [ $I ] = $EXTRA & $GROUP & @TAB & $PERM & @TAB & $TRANS & @TAB & $INHERIT
	Next
	FileWrite ( $HFIXLOG , "===================================" & @CRLF & $PERMS & " " & $OF & " """ & $PATH1 & """:" & @CRLF & @CRLF & "Owner: " & $OWNER & @CRLF & @CRLF & "DACL:" & $DACL & @CRLF & @CRLF )
	_FILEWRITEFROMARRAY ( $HFIXLOG , $ARR )
	FileWrite ( $HFIXLOG , @CRLF & @CRLF & "===================================" & @CRLF )
EndFunc
Func _LPDECODE ( $MASK , ByRef $MBUILDER , $TESTMASK , $MASKTRANS , ByRef $TRANS )
	If BitAND ( $MASK , $TESTMASK ) = $TESTMASK Then
		$CHECK = $MBUILDER
		$MBUILDER = BitOR ( $MBUILDER , $TESTMASK )
		If $CHECK <> $MBUILDER Then $TRANS &= $MASKTRANS & "/"
		If $MBUILDER = $MASK Then Return 1
	EndIf
EndFunc
Func _LPACC ( $ACC )
	If StringRegExp ( $ACC , "S-1-\d+-\d+" ) Then
		$ACCOUNTNAME = _SECURITY__LOOKUPACCOUNTSID ( $ACC )
		If IsArray ( $ACCOUNTNAME ) Then $ACC = $ACCOUNTNAME [ 1 ] & "\" & $ACCOUNTNAME [ 0 ]
	Else
		Switch $ACC
		Case "BA"
			$ACC = "BUILTIN\Administrators"
		Case "BU"
			$ACC = "BUILTIN\Users"
		Case "SU"
			$ACC = "NT AUTHORITY\SERVICE"
		Case "WD"
			$ACC = "EVERYONE"
		Case "BG"
			$ACC = "BUILTIN\Guests"
		Case "LA"
			$ACC = "LOCAL\Administrator"
		Case "SY"
			$ACC = "NT AUTHORITY\SYSTEM"
		Case "LS"
			$ACC = "NT AUTHORITY\LOCAL SERVICE"
		Case "RC"
			$ACC = "NT AUTHORITY\RESTRICTED"
		Case "LG"
			$ACC = "LOCAL\Guest"
		Case "AU"
			$ACC = "NT AUTHORITY\Authenticated Users"
		Case "PS"
			$ACC = "PERSONAL SELF"
		Case "CO"
			$ACC = "CREATOR OWNER"
		Case "RE"
			$ACC = "REOLICATOR"
		Case "IU"
			$ACC = "NT AUTHORITY\INTERACTIVE"
		Case "SO"
			$ACC = "SERVER OPERATORS"
		Case "AO"
			$ACC = "ACCOUNT OPERATORS"
		Case "BO"
			$ACC = "BACKUP OPERATORS"
		Case "PO"
			$ACC = "PRINTER OPERATORS"
		Case "SO"
			$ACC = "SERVER OPERATORS"
		Case "NS"
			$ACC = "NT AUTHORITY\NETWORK SERVICE"
		Case "NO"
			$ACC = "BUILTIN\Network Configuration Operators"
		Case "AC"
			$ACC = "APPLICATION PACKAGE AUTHORITY\ALL APPLICATION PACKAGES"
		Case "CG"
			$ACC = "CREATOR GROUP"
		Case "PU"
			$ACC = "NETWORK LOGON USERS"
		Case "NU"
			$ACC = "POWER USERS"
		Case "SU"
			$ACC = "SERVICE LOGON USERS"
		Case "WR"
			$ACC = "WRITE RESTRICTED CODE"
		Case "AN"
			$ACC = "Ananymous Logon"
		Case "SA"
			$ACC = "SCHEMA ADMINISTRATORS"
		Case "CA"
			$ACC = "CERTIFICATE SERVER ADMINISTRATORS"
		Case "PA"
			$ACC = "GROUP POLICY ADMINISTRATORS"
		Case "EA"
			$ACC = "ENTERPRISE ADMINISTRATORS"
		Case "RD"
			$ACC = "REMOTE DESKTOP USERS"
		Case "MU"
			$ACC = "PERFORMANCE MONITOR USERS"
		Case "LU"
			$ACC = "BUILTIN\Performance Log Users"
		Case "IS"
			$ACC = "Ananymous Internet Users"
		Case "CY"
			$ACC = "Crypto Operators"
		Case "OW"
			$ACC = "Owner Rights"
		Case "RM"
			$ACC = "RMS Service"
		Case "DA"
			$ACC = "DOMAIN ADMINS"
		Case "DG"
			$ACC = "DOMAIN GUESTS"
		Case "DU"
			$ACC = "DOMAIN USERS"
		Case "ED"
			$ACC = "ENTERPRISE DOMAIN CONTROLLERS"
		Case "DD"
			$ACC = "DOMAIN CONTROLLERS"
		Case "DC"
			$ACC = "DOMAIN CONPUTERS"
		Case "RS"
			$ACC = "RAS SERVERS"
		EndSwitch
	EndIf
	Return $ACC
EndFunc
Func _NETUSERGROUP ( $NUM )
	Switch $NUM
	Case 2
		Return "Administrator"
Case Else
		Return "Limited"
	EndSwitch
EndFunc
Func _NTCLOSE ( $HKEY )
	DllCall ( "ntdll.dll" , "int" , "NtClose" , "hwnd" , $HKEY )
EndFunc
Func _NTDELETEKEY ( $HKEY )
	Local $RET = DllCall ( "ntdll.dll" , "int" , "NtDeleteKey" , "hwnd" , $HKEY )
	If Not STATUS_SUCCESS ( $RET [ 0 ] ) Then SetError ( 1 , 0 , $RET [ 0 ] )
EndFunc
Func _NTFLUSH ( $HKEY )
	DllCall ( "ntdll.dll" , "int" , "NtFlushKey" , "hwnd" , $HKEY )
EndFunc
Func _PROCESSGETLOADEDMODULES ( $IPID )
	Local Const $PROCESS_QUERY_INFORMATION = 1024
	Local Const $PROCESS_VM_READ = 16
	Local $HPSAPI = DllOpen ( "Psapi.dll" )
	Local $HPROCESS , $TMODULESSTRUCT
	$TMODULESSTRUCT = DllStructCreate ( "hwnd [200]" )
	Local $SIZEOFHWND = DllStructGetSize ( $TMODULESSTRUCT ) / 200
	$HPROCESS = _WINAPI_OPENPROCESS ( BitOR ( $PROCESS_QUERY_INFORMATION , $PROCESS_VM_READ ) , False , $IPID )
	If Not $HPROCESS Then Return SetError ( 1 , 0 , + 4294967295 )
	Local $ACALL = DllCall ( $HPSAPI , "int" , "EnumProcessModulesEx" , "ptr" , $HPROCESS , "ptr" , DllStructGetPtr ( $TMODULESSTRUCT ) , "dword" , DllStructGetSize ( $TMODULESSTRUCT ) , "dword*" , "" , "dword" , 3 )
	If Not $ACALL [ 4 ] Then Return SetError ( 1 , 0 , + 4294967295 )
	If $ACALL [ 4 ] > DllStructGetSize ( $TMODULESSTRUCT ) Then
		$TMODULESSTRUCT = DllStructCreate ( "hwnd [" & $ACALL [ 4 ] / $SIZEOFHWND & "]" )
		$ACALL = DllCall ( $HPSAPI , "int" , "EnumProcessModulesEx" , "ptr" , $HPROCESS , "ptr" , DllStructGetPtr ( $TMODULESSTRUCT ) , "dword" , $ACALL [ 4 ] , "dword*" , "" , "dword" , 3 )
	EndIf
	If Not $ACALL [ 4 ] Then Return SetError ( 1 , 0 , + 4294967295 )
	Local $ARETURN [ $ACALL [ 4 ] / $SIZEOFHWND ]
	For $I = 0 To UBound ( $ARETURN ) + 4294967295
		$ACALL = DllCall ( $HPSAPI , "dword" , "GetModuleFileNameExW" , "ptr" , $HPROCESS , "ptr" , DllStructGetData ( $TMODULESSTRUCT , 1 , $I + 1 ) , "wstr" , "" , "dword" , 65536 )
		$ARETURN [ $I ] = $ACALL [ 3 ]
	Next
	CLOSEHANDLE ( $HPROCESS )
	DllClose ( $HPSAPI )
	Return $ARETURN
EndFunc
Func _PROF ( $SID )
	$KEY = "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList"
	$HKEY = _REGOPENKEYEX3 ( $KEY )
	If @error Or Not $HKEY Then Return
	$L = 0
	While 1
		$SUB = __REGENUMKEY ( $HKEY , $L )
		If @error Then ExitLoop
		If StringRegExp ( $SID , "S-\d-\d-\d" ) Then
			If $SUB = $SID Then Return RegRead ( $KEY & "\" & $SUB , "ProfileImagePath" )
		Else
			$RET = RegRead ( $KEY & "\" & $SUB , "ProfileImagePath" )
			If $SID = StringRegExpReplace ( $RET , ".+\\(.+)" , "$1" ) Then Return $SUB & "|" & $RET
		EndIf
		$L += 1
	WEnd
	If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
EndFunc
Func _RAND ( $NR = 4 )
	Local $ST
	For $I = 1 To $NR
		$ST = $ST & Chr ( Random ( 97 , 122 , 1 ) ) & Chr ( Random ( 48 , 57 , 1 ) ) & Chr ( Random ( 65 , 90 , 1 ) )
	Next
	$ST = StringTrimRight ( $ST , Random ( 0 , 4 , 1 ) )
	Return $ST
EndFunc
Func _REGCLOSE ( ByRef $HKEY )
	If IsPtr ( $HKEY ) Then DllCall ( "advapi32.dll" , "long" , "RegCloseKey" , "handle" , $HKEY )
	$HKEY = ""
EndFunc
Func _REGDELETEENT2 ( $KEY )
	$HKEY = _HKEY ( _HKEYTRANS ( $KEY ) )
	$E = 0
	While 1
		$SUB = __REGENUMKEY ( $HKEY , $E )
		If @error Then ExitLoop
		If _HKEYCREATE ( _HKEYTRANS ( $KEY & "\" & $SUB ) ) = + 3221225506 Then _UNLOCK ( $KEY & "\" & $SUB , 4 )
		_ARRAYADD ( $ARRENT , $KEY & "\" & $SUB , 0 , "||||" )
		_REGDELETEENT2 ( $KEY & "\" & $SUB )
		$E += 1
	WEnd
EndFunc
Func _REGOPENKEYEX3 ( $KEY , $Y = 0 , $IACCESS = 131097 )
	$HKEY = _ROOTHK ( $KEY )
	If Not StringInStr ( $KEY , "\" ) Then Return $HKEY
	$SUB = StringRegExpReplace ( $KEY , ".+?\\(.+)" , "$1" )
	$ARET = DllCall ( "advapi32.dll" , "long" , "RegOpenKeyExW" , "hwnd" , $HKEY , "wstr" , $SUB , "dword" , 0 , "dword" , $IACCESS , "hwnd*" , "" )
	If $ARET [ 0 ] = 5 And IsAdmin ( ) And $Y Then
		If Not $TAKEOWNPRI Then _SETPRIV ( "SeTakeOwnershipPrivilege" )
		$ARET = DllCall ( "advapi32.dll" , "long" , "RegOpenKeyExW" , "hwnd" , $HKEY , "wstr" , $SUB , "dword" , 0 , "dword" , 524288 , "hwnd*" , "" )
		If $ARET [ 0 ] = 0 Then
			$FULLKEY = _HKEYTRANS ( $KEY )
			$HKEY = _REGUNLOC ( $FULLKEY )
			_UNLOCKALLREG ( $FULLKEY , $HKEY )
			$ARET = DllCall ( "advapi32.dll" , "long" , "RegOpenKeyExW" , "hwnd" , $HKEY , "wstr" , $SUB , "dword" , 0 , "dword" , $IACCESS , "hwnd*" , "" )
		EndIf
	EndIf
	If $ARET [ 0 ] <> 0 Then Return SetError ( 1 , 0 , $ARET [ 0 ] )
	Return $ARET [ 5 ]
EndFunc
Func _REGUNLOC ( $FULLKEY )
	Local $HANDLE
	Local $SZNAME = DllStructCreate ( "byte[" & StringLen ( $FULLKEY ) + 2 & "]" )
	Local $SUS = DllStructCreate ( "ushort Length;ushort MaximumLength;ptr Buffer" )
	Local $SOA = DllStructCreate ( $TAGOBJECTATTRIBUTES )
	DllStructSetData ( $SZNAME , 1 , "0x" & $FULLKEY )
	$NLENGTH = StringLen ( $FULLKEY ) / 2
	DllStructSetData ( $SUS , "Length" , $NLENGTH )
	DllStructSetData ( $SUS , "MaximumLength" , $NLENGTH + 2 )
	DllStructSetData ( $SUS , "Buffer" , DllStructGetPtr ( $SZNAME ) )
	DllStructSetData ( $SOA , "Length" , DllStructGetSize ( $SOA ) )
	DllStructSetData ( $SOA , "RootDirectory" , 0 )
	DllStructSetData ( $SOA , "ObjectName" , DllStructGetPtr ( $SUS ) )
	DllStructSetData ( $SOA , "Attributes" , BitOR ( 64 , 256 ) )
	DllStructSetData ( $SOA , "SecurityDescriptor" , 0 )
	DllStructSetData ( $SOA , "SecurityQualityOfService" , 0 )
	$RET = DllCall ( "ntdll.dll" , "int" , "NtOpenKey" , "hwnd*" , "" , "dword" , $KEY_ALL_ACCESS , "ptr" , DllStructGetPtr ( $SOA ) )
	If Not STATUS_SUCCESS ( $RET [ 0 ] ) And $RET [ 0 ] = + 3221225506 Then
		$HANDLE = _UNLOCKREGMAIN ( $SOA )
		If @error Or Not $HANDLE Then Return SetError ( 1 , 0 , 0 )
		Return $HANDLE
	EndIf
	If Not STATUS_SUCCESS ( $RET [ 0 ] ) Then Return SetError ( 1 , 0 , 0 )
	Return $RET [ 1 ]
EndFunc
Func _RELEASECONTEXT ( $CON )
	DllCall ( "Wintrust.dll" , "BOOL" , "CryptCATAdminReleaseContext" , "HANDLE" , $CON , "DWORD" , 0 )
EndFunc
Func _REM ( $DRV , $PATH )
	$RET = DllCall ( "kernel32.dll" , "bool" , "DefineDosDeviceW" , "dword" , BitOR ( 2 , 4 ) , "wstr" , $DRV , "wstr" , $PATH )
EndFunc
Func _REPARSEPOINT ( $FOLDER )
	If Not FileExists ( $FOLDER ) Then Return
	If StringLeft ( $FOLDER , 4 ) <> "\\?\" Then $FOLDER = "\\?\" & $FOLDER
	$RC = DllCall ( "kernel32.dll" , "Int" , "GetFileAttributesW" , "wstr" , $FOLDER )
	If IsArray ( $RC ) And $RC [ 0 ] <> + 4294967295 And BitAND ( $RC [ 0 ] , 1024 ) = 1024 Then Return True
EndFunc
Func _RKS ( ByRef $ARRAYLOCK )
	$PATH = $C & "\FRST\" & $SFOL
	$KN = _RAND ( )
	RunWait ( @ComSpec & " /c reg load hklm\" & $KN & " " & $PATH & "\system" , "" , @SW_HIDE )
	If Not VAR ( "HKLM\" & $KN ) Then
		If Not $RESTOREPRI Then _SETPRIV ( "SeRestorePrivilege" , True )
		If Not $BACKUPPRI Then _SETPRIV ( "SeBackupPrivilege" , True )
		$RET = DllCall ( "Advapi32.dll" , "int" , "RegLoadKeyW" , "handle" , 2147483650 , "wstr" , $KN , "wstr" , $PATH & "\system" )
		If @error Or $RET [ 0 ] Then
			DirRemove ( $PATH , 1 )
			Return SetError ( 2 )
		EndIf
	EndIf
	$DCS = RegRead ( "HKLM\" & $KN & "\Select" , "Default" )
	If $DCS < 10 Then
		$DCS = "0" & $DCS
	Else
		$DCS = $DCS
	EndIf
	$KEY = "HKLM\" & $KN & "\ControlSet0" & $DCS & "\Services"
	$FULLKEY = _HKEYTRANS ( $KEY )
	$HKEY = _HKEY ( $FULLKEY )
	If @error Or Not $HKEY Then
		DirRemove ( $PATH , 1 )
		Return SetError ( 3 )
	EndIf
	$I = + 4294967295
	While 1
		$I = $I + 1
		$SNAME = __REGENUMKEY ( $HKEY , $I )
		If @error Then ExitLoop
		$SYSR = "HKLM\SYSTEM\CurrentControlSet\Services\" & $SNAME
		RegRead ( $SYSR , "" )
		If @error <> 1 Then ContinueLoop
		$KEY1 = $KEY & "\" & $SNAME
		$HKEY1 = _REGOPENKEYEX3 ( $KEY1 )
		If Not @error And IsPtr ( $HKEY1 ) Then
			_REGCLOSE ( $HKEY1 )
			ContinueLoop
		EndIf
		If $HKEY1 = 5 Then
			_SETREGACE ( $KEY1 , 1 )
		EndIf
		$SD = RegRead ( $KEY1 , "ServiceDll" )
		If @error Then $SD = RegRead ( $KEY1 & "\Parameters" , "ServiceDll" )
		If @error Then $SD = RegRead ( $KEY1 , "ImagePath" )
		If $SD Then
			$FILE = $SD
			$ATTEN = ""
			AAAAFP ( )
			If FileExists ( $FILE ) Then
				$FILE = $FILE & " [" & $SIZE & " " & $CDATE & "]" & $COMPANY & $ATTEN
			Else
				$FILE = $SD
			EndIf
		Else
			$FILE = ""
		EndIf
		_ARRAYADD ( $ARRAYLOCK , "HKLM\SYSTEM\ControlSet0" & $DCS & "\Services\" & $SNAME & " => " & $FILE & " <==== " & $UPD1 & " (Rootkit!" & "/" & $LOCLSRV & ")" , 0 , "||||" )
	WEnd
	_NTCLOSE ( $HKEY )
	$RET = DllCall ( "Advapi32.dll" , "int" , "RegUnLoadKeyW" , "handle" , 2147483650 , "wstr" , $KN )
	DirRemove ( $PATH , 1 )
EndFunc
Func LOAD ( )
	_SETPRIV0 ( )
	$ARR = _NETUSERENUM ( 1 )
	For $Y = 1 To UBound ( $ARR ) + 4294967295
		If Not VAR ( "HKU\" & $ARR [ $Y ] [ 0 ] , 1 ) Then
			If Not FileExists ( $ARR [ $Y ] [ 1 ] & "\ntuser.dat" ) Then ContinueLoop
			$RET = DllCall ( "Advapi32.dll" , "int" , "RegLoadKeyW" , "handle" , 2147483651 , "wstr" , $ARR [ $Y ] [ 0 ] , "wstr" , $ARR [ $Y ] [ 1 ] & "\ntuser.dat" )
			If Not @error And $RET [ 0 ] = 0 Then _ARRAYADD ( $LOAD , $ARR [ $Y ] [ 0 ] )
		EndIf
	Next
EndFunc
Func UNLOAD ( )
	_SETPRIV0 ( )
	For $Y = 1 To UBound ( $LOAD ) + 4294967295
		If VAR ( "HKU\" & $LOAD [ $Y ] , 1 ) Then DllCall ( "Advapi32.dll" , "int" , "RegUnLoadKeyW" , "handle" , 2147483651 , "wstr" , $LOAD [ $Y ] )
	Next
EndFunc
Func _OSVERSION ( )
	$OSV = _WINAPI_GETVERSION ( )
	Switch @OSVersion
	Case "WIN_XP"
		$OSV = 5.1
	Case "WIN_VISTA"
		$OSV = 6
	Case "WIN_7"
		$OSV = 6.1
	Case "WIN_8"
		$OSV = 6.2
	Case "WIN_81"
		$OSV = 6.3
	Case "WIN_10"
		$OSV = 10
	Case "WIN_11"
		$OSV = 10
	EndSwitch
	Return $OSV
EndFunc
Func _NETUSERENUM ( $ACC = "" )
	$SSERVER = ""
	Local $TBUFPTR = DllStructCreate ( "ptr" )
	Local $TENTRIESREAD = DllStructCreate ( "dword" )
	Local $TTOTALENTRIES = DllStructCreate ( "dword" )
	Local $ARET = DllCall ( "Netapi32.dll" , "int" , "NetUserEnum" , "wstr" , $SSERVER , "dword" , 1 , "dword" , 2 , "ptr" , DllStructGetPtr ( $TBUFPTR ) , "dword" , + 4294967295 , "ptr" , DllStructGetPtr ( $TENTRIESREAD ) , "ptr" , DllStructGetPtr ( $TTOTALENTRIES ) , "ptr" , 0 )
	If $ARET [ 0 ] Then Return SetError ( 1 , $ARET [ 0 ] , False )
	Local Const $UF_ACCOUNTDISABLE = 2
	Local $IENTRIESREAD = DllStructGetData ( $TENTRIESREAD , 1 )
	Local $PBUF = DllStructGetData ( $TBUFPTR , 1 )
	Local $SUSERINFO1 = "ptr;ptr;dword;dword;ptr;ptr;dword;ptr"
	Local $TUSERINFO1 = DllStructCreate ( $SUSERINFO1 )
	Local $ZUSERINFO1 = DllStructGetSize ( $TUSERINFO1 )
	If $ACC Then Local $ARRSN [ 1 ] [ 2 ] = [ [ "" , "" ] ]
	For $I = 1 To $IENTRIESREAD
		$TUSERINFO1 = DllStructCreate ( $SUSERINFO1 , $PBUF + ( $I + 4294967295 ) * $ZUSERINFO1 )
		Local $TNAME = DllStructCreate ( "wchar[256]" , DllStructGetData ( $TUSERINFO1 , 1 ) )
		Local $TFLAG = DllStructGetData ( $TUSERINFO1 , 7 )
		Local $TPRIV = DllStructGetData ( $TUSERINFO1 , 4 )
		If BitAND ( $TFLAG , $UF_ACCOUNTDISABLE ) = 0 Then
			$DISABLE = "Enabled"
		Else
			$DISABLE = "Disabled"
		EndIf
		$NAME = DllStructGetData ( $TNAME , 1 )
		If Not $ACC Then $TPRIV = _NETUSERGROUP ( $TPRIV )
		Local $SID = _SECURITY__LOOKUPACCOUNTNAME ( @ComputerName & "\" & $NAME )
		$DIR = ""
		If IsArray ( $SID ) Then
			$SID = $SID [ 0 ]
			$UFOLDER = _PROF ( $SID )
			If $UFOLDER Then $DIR = $UFOLDER
		Else
			$UFOLDER = _PROF ( $NAME )
			If $UFOLDER Then
				$DIR = StringRegExpReplace ( $UFOLDER , ".+\|(.*)" , "$1" )
				$SID = StringRegExpReplace ( $UFOLDER , "(.+)\|.+" , "$1" )
			EndIf
		EndIf
		If Not $ACC Then
			$ATT = ""
			If StringRegExp ( $NAME , "(?i)^(WgaUtilAcc|John)$" ) And Not $DIR Then $ATT = " <==== " & $UPD1
			If $DIR Then $DIR = " => " & $DIR
			If StringRegExp ( $SID , "S-\d-\d-\d" ) Then FileWrite ( $HADDITION , $NAME & " (" & $SID & " - " & $TPRIV & " - " & $DISABLE & ")" & $DIR & $ATT & @CRLF )
		Else
			If $DIR And StringRegExp ( $SID , "S-\d-\d-\d" ) Then _ARRAYADD ( $ARRSN , $SID & "|" & $DIR )
		EndIf
	Next
	DllCall ( "Netapi32.dll" , "int" , "NetApiBufferFree" , "ptr" , $PBUF )
	If $ACC Then Return $ARRSN
EndFunc
Func _RMTON ( $KEY )
	$KEY = StringRegExpReplace ( $KEY , "(?i)(hk.+?)\\888\\" , "$1\\Software\\" )
	$KEY = StringRegExpReplace ( $KEY , "(?i)(hk.+?)\\999\\" , "$1\\System\\" )
	Return $KEY
EndFunc
Func _RMTOR ( $KEY )
	$KEY = StringRegExpReplace ( $KEY , "(?i)(hk.+?)\\Software\\" , "$1\\888\\" )
	$KEY = StringRegExpReplace ( $KEY , "(?i)(hk.+?)\\System\\" , "$1\\999\\" )
	Return $KEY
EndFunc
Func _ROOT ( $RKEY , $Y = "" )
	Local $HROOT , $USERSID
	Switch StringUpper ( $RKEY )
	Case "HKEY_LOCAL_MACHINE" , "HKLM"
		$HROOT = "\registry\machine"
	Case "HKEY_USERS" , "HKU"
		$HROOT = "\registry\user"
	Case "HKEY_CURRENT_USER" , "HKCU"
		$SID = _SECURITY__LOOKUPACCOUNTNAME ( @ComputerName & "\" & @UserName )
		If IsArray ( $SID ) Then $USERSID = $SID [ 0 ]
		$HROOT = "\registry\user\" & $USERSID
	Case "HKEY_CLASSES_ROOT" , "HKCR"
		$HROOT = "\registry\machine\software\classes"
		If $Y Then $HROOT = "\registry\machine\software\Wow6432Node\classes"
Case Else
		$HROOT = ""
	EndSwitch
	Return $HROOT
EndFunc
Func _ROOTHK ( $KEY )
	Local $HROOT = StringLeft ( $KEY , StringInStr ( $KEY , "\" ) + 4294967295 )
	If $HROOT = "" Then $HROOT = $KEY
	Switch $HROOT
	Case "HKEY_LOCAL_MACHINE" , "HKLM"
		$HROOT = 2147483650
	Case "HKEY_USERS" , "HKU"
		$HROOT = 2147483651
	Case "HKEY_CURRENT_USER" , "HKCU"
		$HROOT = 2147483649
	Case "HKEY_CLASSES_ROOT" , "HKCR"
		$HROOT = 2147483648
	Case "HKEY_CURRENT_CONFIG" , "HKCC"
		$HROOT = 2147483653
Case Else
		Return SetError ( 1 , 0 , 0 )
	EndSwitch
	Return $HROOT
EndFunc
Func _RUNPR ( $PID )
	If Not ProcessExists ( $PID ) Or $PID = 4 Or $PID = 0 Then Return
	$IACCESS = $OSNUM < 6.0 ? 1024 : 4096
	If Not $DEBUGPRI Then _SETPRIV ( "SeDebugPrivilege" )
	Local $ACALL = DllCall ( "kernel32.dll" , "handle" , "OpenProcess" , "dword" , $IACCESS , "bool" , False , "dword" , $PID )
	If Not $ACALL [ 0 ] Then Return ""
	Local $RET = DllCall ( @SystemDir & "\kernel32.dll" , "bool" , "QueryFullProcessImageNameW" , "handle" , $ACALL [ 0 ] , "dword" , 0 , "wstr" , "" , "dword*" , 65535 )
	CLOSEHANDLE ( $ACALL [ 0 ] )
	If Not $RET [ 0 ] Then Return ""
	$PATH = $RET [ 3 ]
	If StringInStr ( $PATH , "SystemRoot" ) Then $PATH = StringRegExpReplace ( $PATH , "(?i)[\\]?SystemRoot" , StringRegExpReplace ( $WINDOWSDIR , "\\" , "\\\\" ) )
	If StringRegExp ( $PATH , "\\\w{6}~\d\\" ) Then $PATH = FileGetLongName ( $PATH )
	If StringRegExp ( $PATH , "\\\?" ) Then $PATH = StringRegExpReplace ( $PATH , "(?i).+([c-z]:.+)" , "$1" )
	Return $PATH
EndFunc
Func _SBKP ( $SOURCE )
	Local $SHAD1 , $SHAD2 , $OBJWMI , $SDRIVE
	$OBJWMI = ObjGet ( "winmgmts:{impersonationLevel=impersonate}!\\.\root\cimv2" )
	If Not IsObj ( $OBJWMI ) Then Return SetError ( 2 )
	$SHAD1 = DEVOBJ ( $OBJWMI )
	Local $OBJWMISERVICE = ObjGet ( "winmgmts:{impersonationLevel=impersonate}!\\.\root\cimv2:Win32_ShadowCopy" )
	If Not IsObj ( $OBJWMISERVICE ) Then Return SetError ( 2 )
	$OBJWMISERVICE .Create ( $C & "\" , "ClientAccessible" )
	$SHAD2 = DEVOBJ ( $OBJWMI )
	If Not $SHAD2 Then Return SetError ( 2 )
	If $SHAD2 = $SHAD1 Then Return SetError ( 3 )
	For $I = 67 To 90
		If DriveStatus ( Chr ( $I ) & ":\" ) = "Invalid" Then
			$SDRIVE = Chr ( $I ) & ":"
			ExitLoop
		EndIf
	Next
	Local $RET = DllCall ( "kernel32.dll" , "bool" , "DefineDosDeviceW" , "dword" , 8 , "wstr" , $SDRIVE , "wstr" , $SHAD2 )
	If @error Or Not $RET [ 0 ] Or DriveStatus ( $SDRIVE & "\" ) <> "Ready" Then
		_REM ( $SDRIVE , $SHAD2 )
		_D ( $SHAD2 , $OBJWMI )
		Return SetError ( 4 )
	EndIf
	$TMPF = $C & "\FRST\" & _RAND ( )
	DirCreate ( $TMPF )
	FileSetAttrib ( $TMPF , "HS" )
	$KN = _RAND ( )
	If Not $RESTOREPRI Then _SETPRIV ( "SeRestorePrivilege" , True )
	If Not $BACKUPPRI Then _SETPRIV ( "SeBackupPrivilege" , True )
	If IsArray ( $SOURCE ) Then
		For $I = 0 To UBound ( $SOURCE ) + 4294967295
			$PATH = StringMid ( $SOURCE [ $I ] , 3 )
			$FILE = StringRegExpReplace ( $PATH , ".+(\\.+)" , "$1" )
			$DESTIN = $C & "\FRST\Hives"
			If StringInStr ( $SOURCE [ $I ] , "\Users\" ) Then
				$DESTIN = $C & "\FRST\Hives\" & @UserName
				DirCreate ( $DESTIN )
			EndIf
			$RET = FileCopy ( $SDRIVE & $PATH , $TMPF , 1 )
			$RET = FileCopy ( $SDRIVE & $PATH & ".LOG*" , $TMPF , 1 )
			If $OSNUM > 6.1 Then
				RunWait ( @ComSpec & " /c reg load hklm\" & $KN & " " & $TMPF & $FILE , "" , @SW_HIDE )
				If Not VAR ( "HKLM\" & $KN ) Then
					$RET = DllCall ( "Advapi32.dll" , "int" , "RegLoadKeyW" , "handle" , 2147483650 , "wstr" , $KN , "wstr" , $TMPF & $FILE )
					If @error Or $RET [ 0 ] Then
						DirRemove ( $TMPF , 1 )
						_REM ( $SDRIVE , $SHAD2 )
						_D ( $SHAD2 , $OBJWMI )
						Return SetError ( 5 )
					EndIf
				EndIf
				$RET = DllCall ( "Advapi32.dll" , "int" , "RegUnLoadKeyW" , "handle" , 2147483650 , "wstr" , $KN )
				If VAR ( "HKLM\" & $KN ) Then RunWait ( @ComSpec & " /c reg unload hklm\" & $KN , "" , @SW_HIDE )
			EndIf
			$RET = FileCopy ( $TMPF & $FILE , $DESTIN , 1 )
			If StringRegExp ( $SOURCE [ $I ] , "(?i)(NTUSER|UsrClass).DAT" ) Then FileSetAttrib ( $DESTIN & $FILE , "-SH" )
			If Not $RET Then ExitLoop
		Next
	Else
		$PATH = StringMid ( @SystemDir & "\config\system" , 3 )
		$RET = FileCopy ( $SDRIVE & $PATH & ".LOG*" , $SOURCE , 1 )
		$RET = FileCopy ( $SDRIVE & $PATH , $SOURCE , 1 )
	EndIf
	DirRemove ( $TMPF , 1 )
	_REM ( $SDRIVE , $SHAD2 )
	_D ( $SHAD2 , $OBJWMI )
	If Not $RET Then Return SetError ( 8 )
EndFunc
Func _SETDEFAULTFILEACCESS ( $PATH )
	If Not FileExists ( $PATH ) Then Return SetError ( 1 , 0 , @error )
	If StringRegExp ( $PATH , "(?i)\\" & @UserName & "(\\|$)" ) Then
		$ACCOU = "Administrators;System;Users;" & @UserName
	Else
		$ACCOU = "Administrators;System;Users;Authenticated Users"
		If _WINAPI_GETVERSION ( ) > 5.2 And ( StringInStr ( $PATH , $WINDOWSDIR ) Or StringInStr ( $PATH , @ProgramFilesDir ) Or StringInStr ( $PATH , $PROGRAMFILES86 ) ) Then $ACCOU &= ";TrustedInstaller"
	EndIf
	_UNLOCK ( $PATH , 1 , $ACCOU )
	If @error Then Return SetError ( 2 , 0 , @error )
EndFunc
Func _SETDEFAULTFILEPERMS ( )
	$PATH = StringRegExpReplace ( $FIX , "(?i)SetDefaultFilePermissions:\s*(.+)" , "$1" )
	$PATH = StringRegExpReplace ( $PATH , """" , "" )
	$PATH = StringRegExpReplace ( $PATH , "\s+$" , "" )
	_SETDEFAULTFILEACCESS ( $PATH )
	$ERR = @error
	If $ERR Then
		If $ERR = 1 Then Return NFOUND ( $PATH )
		If $ERR = 2 Then Return FileWrite ( $HFIXLOG , """" & $PATH & """" & " => " & $DEFA & " " & $PERMS & " " & $NRESTORE & "." & @CRLF )
	EndIf
	FileWrite ( $HFIXLOG , """" & $PATH & """" & " => " & $DEFA & " " & $PERMS & " " & $RESTORED & "." & @CRLF )
EndFunc
Func _SETKEYR ( $KEY )
	$KEY = StringRegExpReplace ( $KEY , "(?i)^(HKEY_CLASSES_ROOT|HKCR)" , "CLASSES_ROOT" )
	$KEY = StringRegExpReplace ( $KEY , "(?i)^(HKEY_CURRENT_USER|HKCU)" , "CURRENT_USER" )
	$KEY = StringRegExpReplace ( $KEY , "(?i)^(HKEY_LOCAL_MACHINE|HKLM)" , "MACHINE" )
	$KEY = StringRegExpReplace ( $KEY , "(?i)^(HKEY_USERS|HKU)" , "USERS" )
	Return $KEY
EndFunc
Func _OWNERSET ( $PATH , $OWNER , $SE_OBJECT_TYPE = 1 )
	Local $TSID
	$TSID = _SIDSTRUCT ( $OWNER )
	If @error Then Return SetError ( 1 )
	_SETPRIV0 ( )
	If IsPtr ( $PATH ) Then
		$FUNC = "SetSecurityInfo"
		$TYPE = "handle"
	Else
		$FUNC = "SetNamedSecurityInfoW"
		$TYPE = "wstr"
		If $SE_OBJECT_TYPE = 4 Then $PATH = _SETKEYR ( $PATH )
	EndIf
	$RET = DllCall ( "Advapi32.Dll" , "dword" , $FUNC , $TYPE , $PATH , "dword" , $SE_OBJECT_TYPE , "dword" , 1 , "ptr" , DllStructGetPtr ( $TSID ) , "ptr" , 0 , "ptr" , 0 , "ptr" , 0 )
	If $RET [ 0 ] Then Return SetError ( 2 , 0 , $RET [ 0 ] )
EndFunc
Func _SETPRIV ( $SPRIVILEGE , $TURN = True )
	Local $HTOK = DllCall ( "advapi32.dll" , "bool" , "OpenProcessToken" , "handle" , _WINAPI_GETCURRENTPROCESS ( ) , "dword" , BitOR ( 32 , 8 ) , "handle*" , 0 )
	If Not $HTOK [ 0 ] Then Return SetError ( 0 )
	$RET = _SECURITY__SETPRIVILEGE ( $HTOK [ 3 ] , $SPRIVILEGE , $TURN )
	DllCall ( "kernel32.dll" , "int" , "CloseHandle" , "ptr" , $HTOK [ 3 ] )
	If $RET Then
		Switch $SPRIVILEGE
		Case "SeDebugPrivilege"
			If $TURN Then
				$DEBUGPRI = 1
			Else
				$DEBUGPRI = 0
			EndIf
		Case "SeSecurityPrivilege"
			If $TURN Then
				$SECPRI = 1
			Else
				$SECPRI = 0
			EndIf
		Case "SeRestorePrivilege"
			If $TURN Then
				$RESTOREPRI = 1
			Else
				$RESTOREPRI = 0
			EndIf
		Case "SeTakeOwnershipPrivilege"
			If $TURN Then
				$TAKEOWNPRI = 1
			Else
				$TAKEOWNPRI = 0
			EndIf
		Case "SeBackupPrivilege"
			If $TURN Then
				$BACKUPPRI = 1
			Else
				$BACKUPPRI = 0
			EndIf
		EndSwitch
	EndIf
	Return $RET
EndFunc
Func _SETPRIV0 ( )
	If Not $DEBUGPRI Then _SETPRIV ( "SeDebugPrivilege" , True )
	If Not $SECPRI Then _SETPRIV ( "SeSecurityPrivilege" , True )
	If Not $RESTOREPRI Then _SETPRIV ( "SeRestorePrivilege" , True )
	If Not $TAKEOWNPRI Then _SETPRIV ( "SeTakeOwnershipPrivilege" , True )
	If Not $BACKUPPRI Then _SETPRIV ( "SeBackupPrivilege" , True )
EndFunc
Func _SETPROCESSCRITICAL ( $PID , $FLAG = 0 )
	$HPROCESS = _OPENPROCESS ( $PID , 512 )
	If @error Or Not $HPROCESS Then Return SetError ( 1 , 0 , 0 )
	If Not $DEBUGPRI Then _SETPRIV ( "SeDebugPrivilege" , True )
	Local $SPECIALSTRUCT = DllStructCreate ( "dword" )
	DllStructSetData ( $SPECIALSTRUCT , 1 , $FLAG )
	$ACALL = DllCall ( "ntdll.dll" , "int" , "NtSetInformationProcess" , "handle" , $HPROCESS , "dword" , 29 , "ptr" , DllStructGetPtr ( $SPECIALSTRUCT ) , "dword" , DllStructGetSize ( $SPECIALSTRUCT ) )
	CLOSEHANDLE ( $HPROCESS )
	If Not STATUS_SUCCESS ( $ACALL [ 0 ] ) Then Return SetError ( 2 , 0 , 0 )
	Return True
EndFunc
Func _SETREGACE ( $KEY , $REC = 0 )
	$FULLKEY = _HKEYTRANS ( $KEY )
	$HKEY = _REGUNLOC ( $FULLKEY )
	If Not @error And $REC And IsPtr ( $HKEY ) Then _UNLOCKALLREG ( $FULLKEY , $HKEY )
EndFunc
Func _SIDSTRUCT ( $USER )
	Select
	Case StringRegExp ( $USER , "^S-1-\d" )
		$SID = $USER
	Case $USER = "Administrators"
		$SID = "S-1-5-32-544"
	Case $USER = "System"
		$SID = "S-1-5-18"
	Case $USER = "Everyone"
		$SID = "S-1-1-0"
	Case $USER = "Authenticated Users"
		$SID = "S-1-5-11"
	Case $USER = "Users"
		$SID = "S-1-5-32-545"
	Case $USER = "TrustedInstaller"
		$SID = "S-1-5-80-956008885-3418522649-1831038044-1853292631-2271478464"
	Case StringRegExp ( $USER , "^(S-1-\d+(-\d+){0,5})$" )
		$SID = $USER
Case Else
		$SID = _SECURITY__LOOKUPACCOUNTNAME ( @ComputerName & "\" & $USER )
		If IsArray ( $SID ) Then $SID = $SID [ 0 ]
	EndSelect
	$RET = _SIDSTRUCT0 ( $SID )
	If @error Then Return SetError ( 1 , 0 , 0 )
	Return $RET
EndFunc
Func _SIDSTRUCT0 ( $SID )
	$RET = DllCall ( "Advapi32.Dll" , "bool" , "ConvertStringSidToSidW" , "wstr" , $SID , "ptr*" , 0 )
	If Not $RET [ 0 ] Then Return SetError ( 1 , 0 , _WINAPI_GETLASTERROR ( ) )
	$PSID = $RET [ 2 ]
	$RET = DllCall ( "Advapi32.Dll" , "bool" , "IsValidSid" , "ptr" , $PSID )
	If Not $RET [ 0 ] Then Return SetError ( 1 , 0 , 0 )
	$RET = DllCall ( "Advapi32.Dll" , "dword" , "GetLengthSid" , "ptr" , $PSID )
	If Not $RET [ 0 ] Then Return SetError ( 1 , 0 , 0 )
	$BUFFER = DllStructCreate ( "byte Data[" & $RET [ 0 ] & "]" , $PSID )
	$TSID = DllStructCreate ( "byte Data[" & $RET [ 0 ] & "]" )
	DllStructSetData ( $TSID , "Data" , DllStructGetData ( $BUFFER , "Data" ) )
	LOCALFREE ( $PSID )
	Return $TSID
EndFunc
Func _SQLITECL ( $HSQ )
	_SQLITE_CLOSE ( $HSQ )
	_SQLITE_SHUTDOWN ( )
EndFunc
Func _SQLITEGT ( $SQ )
	Local $ARESULT , $IROWS , $ICOLUMNS , $ITEMS
	$_HSQ = _SQLITEO ( $SQ )
	If @error Or Not $_HSQ Then Return
	If _SQLITE_GETTABLE2D ( $_HSQ , "Select * From moz_perms;" , $ARESULT , $IROWS , $ICOLUMNS ) = 0 Then
		For $I = 1 To $IROWS
			If StringInStr ( $ARESULT [ $I ] [ 2 ] , "notification" ) And $ARESULT [ $I ] [ 3 ] = 1 Then $ITEMS &= $ARESULT [ $I ] [ 1 ] & "; "
		Next
		If $ITEMS Then $ITEMS = StringTrimRight ( $ITEMS , 2 )
	EndIf
	_SQLITECL ( $_HSQ )
	Return $ITEMS
EndFunc
Func _SQLITEO ( $SQ )
	$RET = _SQLITE_STARTUP ( $C & "\FRST\bin\sqlite3_x64.dll" , False , 1 )
	If @error Then Return SetError ( 1 )
	$HSQ = _SQLITE_OPEN ( $SQ )
	If $HSQ = 0 Then
		_SQLITE_SHUTDOWN ( )
		Return SetError ( 2 )
	EndIf
	Return $HSQ
EndFunc
Func _SR ( )
	$COM = StringRegExpReplace ( $FIX , "(?i)SystemRestore:\s*(\w+)" , "$1" )
	If $BOOTM = "recovery" Then Return _SR1 ( $COM )
	If $COM = "On" Then
		$DSPT = DriveSpaceTotal ( $C & "\" ) / 1024
		$DSPT = Round ( $DSPT , 2 )
		$DSPACE = DriveSpaceFree ( $C & "\" ) / 1024
		$DSPACE = Round ( $DSPACE , 2 )
		$PER = Round ( $DSPACE / $DSPT , 2 ) * 100
		If $PER < 10 Then Return FileWrite ( $HFIXLOG , "SystemRestore: On => " & $ERR0 & " -> " & $PER & "%" & @CRLF )
		If $DSPACE < 10 Then Return FileWrite ( $HFIXLOG , "SystemRestore: On => " & $ERR0 & " -> " & $DSPACE & " GB" & @CRLF )
		$KEY = "HKLM\SOFTWARE\Policies\Microsoft\Windows NT\SystemRestore"
		If VAR ( $KEY ) Then DELKEY ( $KEY )
	EndIf
	$OBJ = ObjGet ( "winmgmts:{impersonationLevel=impersonate}!root/default:SystemRestore" )
	If Not IsObj ( $OBJ ) Then Return _SR1 ( $COM )
	If $COM = "Off" Then
		$ENDIS = $OBJ .Disable ( $C & "\" )
	Else
		$ENDIS = $OBJ .Enable ( $C & "\" )
	EndIf
	If $ENDIS = 0 Then
		FileWrite ( $HFIXLOG , "SystemRestore: " & $COM & " => " & $DONE & @CRLF )
	Else
		_SR1 ( $COM )
	EndIf
EndFunc
Func _SR1 ( $DIR )
	FileWrite ( $HFIXLOG , "SystemRestore: " & $DIR & " => " & $ERR0 & @CRLF )
EndFunc
Func _SRVSTAT ( $SNAME )
	$ST = _SERVICE_QUERYSTATUS ( $SNAME )
	If IsArray ( $ST ) Then
		Switch $ST [ 1 ]
		Case 1
			Return "S"
		Case 4
			Return "R"
	Case Else
			Return "U"
		EndSwitch
	EndIf
EndFunc
Func _STARTKEY ( $KEY )
	$HROOT = StringRegExpReplace ( $KEY , "(.+?)\\.+" , "$1" )
	$Y = ""
	If StringRegExp ( $KEY , "(?i)(HKCR|HKEY_CLASSES_ROOT)\\WOW6432Node" ) Then $Y = 1
	$HROOT = _ROOT ( $HROOT , $Y )
	If StringRegExp ( $KEY , "\\.+\\" ) Then
		$SUBK2 = StringRegExpReplace ( $KEY , ".+?\\(.+)\\.+" , "$1" )
		If StringInStr ( $KEY , "WOW6432Node\classes\WOW6432Node" ) Then $SUBK2 = StringRegExpReplace ( $SUBK2 , "(?i)classes\\WOW6432Node" , "classes" )
		$STARTKEY = $HROOT & "\" & $SUBK2
	Else
		$STARTKEY = $HROOT
	EndIf
	Return _STRTOUN ( $STARTKEY )
EndFunc
Func _STOPSERVICE ( $SSERVICENAME )
	$OSCM = DllCall ( "advapi32.dll" , "handle" , "OpenSCManagerW" , "wstr" , "" , "wstr" , $SERVICES_ACTIVE_DATABASE , "dword" , 1 )
	If $OSCM [ 0 ] = 0 Then Return SetError ( 1 , 0 , 0 )
	$OS = DllCall ( "advapi32.dll" , "handle" , "OpenServiceW" , "handle" , $OSCM [ 0 ] , "wstr" , $SSERVICENAME , "dword" , 32 )
	CLOSESERVICEHANDLE ( $OSCM [ 0 ] )
	If $OS [ 0 ] = 0 Then Return SetError ( 2 , 0 , 0 )
	$CS = DllCall ( "advapi32.dll" , "int" , "ControlService" , "handle" , $OS [ 0 ] , "dword" , 1 , "str" , "" )
	CLOSESERVICEHANDLE ( $OS [ 0 ] )
	If $CS [ 0 ] = 0 Then Return SetError ( 3 , 0 , 0 )
EndFunc
Func _STRTOUN ( $STR )
	$RETSTR = ""
	$LENTH = StringLen ( $STR )
	For $I = 1 To $LENTH
		$CHAR = Hex ( AscW ( StringMid ( $STR , $I , 1 ) ) , 4 )
		$CHAR = StringRegExpReplace ( $CHAR , "(\w{2})(\w{2})" , "$2$1" )
		$RETSTR &= $CHAR
	Next
	Return $RETSTR
EndFunc
Func _TASKGETFOLDERS ( ByRef $AFOLDERS , $SFOLDER = "\" , $BRECURSE = True , $IDEPTH = 0 )
	If Not IsBool ( $BRECURSE ) Then Return SetError ( 4 , 0 , 0 )
	If Not IsInt ( $IDEPTH ) Then Return SetError ( 5 , 0 , 0 )
	Local $OSERVICE , $OFOLDER , $OFOLDERS , $OSUBFOLDERS
	$OSERVICE = ObjCreate ( "Schedule.Service" )
	If Not IsObj ( $OSERVICE ) Then Return SetError ( 1 , 0 , 0 )
	$OSERVICE .Connect ( )
	$OFOLDER = $OSERVICE .GetFolder ( $SFOLDER )
	If Not IsObj ( $OFOLDER ) Then Return SetError ( 2 , 0 , 0 )
	$OFOLDERS = $OFOLDER .GetFolders ( 0 )
	If Not IsObj ( $OFOLDER ) Then Return SetError ( 3 , 0 , 0 )
	If $IDEPTH = 0 Then
		Dim $AFOLDERS [ 2 ]
		$AFOLDERS [ 0 ] = 1
		$AFOLDERS [ 1 ] = $SFOLDER
	EndIf
	For $OITEM In $OFOLDERS
		With $OITEM
		ReDim $AFOLDERS [ $AFOLDERS [ 0 ] + 2 ]
		$AFOLDERS [ 0 ] += 1
		$AFOLDERS [ $AFOLDERS [ 0 ] ] = .Path
		If $BRECURSE Then _TASKGETFOLDERS ( $AFOLDERS , .Path , True , $IDEPTH + 1 )
		EndWith
	Next
	Return $AFOLDERS
EndFunc
Func _TASKLISTD ( $SFOLDER = "\" , $BHIDDEN = 1 , $BRECURSE = True )
	FileWrite ( $HFIXLOG , @CRLF & "========================= TasksDetails: ========================" & @CRLF & @CRLF )
	If Not IsBool ( $BRECURSE ) Then Return SetError ( 4 , 0 , 0 )
	If Not IsInt ( $BHIDDEN ) Then Return SetError ( 5 , 0 , 0 )
	Local $OSERVICE , $OFOLDER , $OTASKS , $OTASKDEFINITION , $COLTASKTRIGGERS , $AFOLDERS
	If $BRECURSE Then
		_TASKGETFOLDERS ( $AFOLDERS , $SFOLDER )
		If @error Then Return SetError ( 6 , @error , 0 )
	Else
		Dim $AFOLDERS [ 2 ]
		$AFOLDERS [ 0 ] = 1
		$AFOLDERS [ 1 ] = $SFOLDER
	EndIf
	$OSERVICE = ObjCreate ( "Schedule.Service" )
	If Not IsObj ( $OSERVICE ) Then Return SetError ( 1 , 0 , 0 )
	$OSERVICE .Connect ( )
	For $__I = 1 To $AFOLDERS [ 0 ]
		$OFOLDER = $OSERVICE .GetFolder ( $AFOLDERS [ $__I ] )
		If Not IsObj ( $OFOLDER ) Then Return SetError ( 2 , 0 , 0 )
		$OTASKS = $OFOLDER .GetTasks ( $BHIDDEN )
		If Not IsObj ( $OTASKS ) Then Return SetError ( 3 , 0 , 0 )
		For $OITEM In $OTASKS
			$TNAME = $OITEM .Name
			$LASTRUN = StringRegExpReplace ( $OITEM .LastRunTime , "(....)(..)(..)(..)(..)(..)" , "$1-$2-$3 $4:$5:$6" )
			$LASTRUN = StringRegExpReplace ( $LASTRUN , "1\d\d\d-\d+-\d+ \d+:\d+:\d+" , "NA" )
			$NEXTRUN = StringRegExpReplace ( $OITEM .NextRunTime , "(....)(..)(..)(..)(..)(..)" , "$1-$2-$3 $4:$5:$6" )
			$NEXTRUN = StringRegExpReplace ( $NEXTRUN , "1\d\d\d-\d+-\d+ \d+:\d+:\d+" , "N/A" )
			$STATUS = ( $OITEM .State = 0 ? "Unknown" : ( $OITEM .State = 1 ? "Disabled" : ( $OITEM .State = 2 ? "Queued" : ( $OITEM .State = 3 ? "Ready" : ( $OITEM .State = 4 ? "Running" : $OITEM .State ) ) ) ) )
			$OTASKDEFINITION = $OITEM .Definition
			$COLTASKTRIGGERS = $OTASKDEFINITION .Triggers
			Local $TRIGER [ 1 ]
			For $OTASKTRIGGERS In $COLTASKTRIGGERS
				$TYPE = ( $OTASKTRIGGERS .Type = 0 ? "Event" : ( $OTASKTRIGGERS .Type = 1 ? "Time" : ( $OTASKTRIGGERS .Type = 2 ? "Daily" : ( $OTASKTRIGGERS .Type = 3 ? "Weekly" : ( $OTASKTRIGGERS .Type = 4 ? "Monthly" : ( $OTASKTRIGGERS .Type = 5 ? "Monthly on Specific Day" : ( $OTASKTRIGGERS .Type = 6 ? "When Computer is idle" : ( $OTASKTRIGGERS .Type = 7 ? "When Task is registered" : ( $OTASKTRIGGERS .Type = 8 ? "Boot" : ( $OTASKTRIGGERS .Type = 9 ? "Logon" : ( $OTASKTRIGGERS .Type = 11 ? "Session State Change" : ( $OTASKTRIGGERS .Type = 12 ? "WNF State Change" : $OTASKTRIGGERS .Type ) ) ) ) ) ) ) ) ) ) ) )
				_ARRAYADD ( $TRIGER , $TYPE , 0 , "||||" )
			Next
			$TRIGER = _ARRAYUNIQUE ( $TRIGER , 0 , 0 , 0 , 0 , 1 )
			$TYPE1 = ""
			Switch UBound ( $TRIGER )
			Case 1
				$TYPE1 = "Undefined"
			Case 2
				$TYPE1 = $TRIGER [ 1 ]
		Case Else
				For $TR = 1 To UBound ( $TRIGER ) + 4294967295
					$TYPE1 = $TYPE1 & " & " & $TRIGER [ $TR ]
				Next
			EndSwitch
			$TYPE1 = StringRegExpReplace ( $TYPE1 , "^\s&\s" , "" )
			$TRIGER = ""
			FileWrite ( $HFIXLOG , $TNAME & " (LastRunTime: " & $LASTRUN & " -> NextRunTime: " & $NEXTRUN & " -> Status: " & $STATUS & " -> Schedule Type: " & $TYPE1 & ")" & @CRLF )
		Next
	Next
	FileWrite ( $HFIXLOG , @CRLF & "====== " & $END & " " & $OF & " TasksDetails: ======" & @CRLF & @CRLF )
EndFunc
Func _UASSO ( $ASSO , ByRef $ARR )
	$FASSO = StringRegExpReplace ( $ASSO , "\.(.+)" , "$1file" )
	$E = + 4294967295
	While 1
		$E += 1
		$USER = __REGENUMKEY ( 2147483651 , $E )
		If @error Then ExitLoop
		If StringRegExp ( $USER , "(^(S-1-5-18|.default|S-1-5-19|S-1-5-20)|_Classes)" ) Then ContinueLoop
		RegRead ( "HKU\" & $USER & "\Software\Classes\" & $FASSO , "" )
		If @error < 1 Then
			$RUN1 = RegRead ( "HKU\" & $USER & "\Software\Classes\" & $FASSO & "\shell\open\command" , "" )
			_ARRAYADD ( $ARR , "HKU\" & $USER & "\Software\Classes\" & $FASSO & ": " & $RUN1 & " <==== " & $UPD1 , 0 , "|||" )
		EndIf
		$RUN1 = RegRead ( "HKU\" & $USER & "\Software\Classes\" & $ASSO , "" )
		If @error > 0 Then ContinueLoop
		$RET = RegRead ( "HKU\" & $USER & "\Software\Classes\" & $RUN1 & "\shell\open\command" , "" )
		$ATTEN = " <==== " & $UPD1
		If $ASSO = ".scr" And StringRegExp ( $RUN1 , "(?i)(AutoCAD|DWGTrueView|AutoCADLT)ScriptFil" ) Then $ATTEN = ""
		_ARRAYADD ( $ARR , "HKU\" & $USER & "\Software\Classes\" & $ASSO & ": " & $RUN1 & " => " & $RET & $ATTEN , 0 , "|||" )
	WEnd
EndFunc
Func _UASSOFIX ( )
	$USER = StringRegExpReplace ( $FIX , "(?i)HKU\\(.+?)\\Software\\.+" , "$1" )
	$ASSO = StringRegExpReplace ( $FIX , ".+Classes\\(.+?):.*" , "$1" )
	If Not StringInStr ( $ASSO , "file" ) Then
		$RET = RegRead ( "HKU\" & $USER & "\Software\Classes\" & $ASSO , "" )
		If Not @error And $RET <> " " Then
			RegRead ( "HKU\" & $USER & "\Software\Classes\" & $RET , "" )
			If @error < 1 Then
				DELKEY ( "HKU\" & $USER & "\Software\Classes\" & $RET )
			EndIf
		EndIf
	EndIf
	DELKEY ( "HKU\" & $USER & "\Software\Classes\" & $ASSO )
EndFunc
Func _UASSOJAV ( )
	$E = + 4294967295
	While 1
		$E += 1
		$USER = __REGENUMKEY ( 2147483651 , $E )
		If @error Then ExitLoop
		If StringRegExp ( $USER , "(^(S-1-5-18|.default|S-1-5-19|S-1-5-20)|_Classes)" ) Then ContinueLoop
		$HKEY = _REGOPENKEYEX3 ( "HKU\" & $USER & "\Software\Classes" )
		If @error Or $HKEY = 0 Then ContinueLoop
		$W = 0
		While 1
			$ASSO = __REGENUMKEY ( $HKEY , $W )
			If @error Then ExitLoop
			$JAV = RegRead ( "HKU\" & $USER & "\Software\Classes\" & $ASSO & "\shell\open\command" , "" )
			If StringInStr ( $JAV , "javascript:" ) Then _ARRAYADD ( $ARRCLSID , "HKU\" & $USER & "\Software\Classes\" & $ASSO & ": " & $JAV & " <==== " & $UPD1 , 0 , "||||" )
			$W += 1
		WEnd
	WEnd
	If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
EndFunc
Func _UNITOST ( $UNICODE )
	Local $APPENDED
	$UNICODE = StringRegExpReplace ( $UNICODE , "^0x" , "" )
	$ARR = StringRegExp ( $UNICODE , "\w{4}" , 3 )
	For $T = 0 To UBound ( $ARR ) + 4294967295
		$TMP = StringRegExpReplace ( $ARR [ $T ] , "(\w{2})(\w{2})" , "$2$1" )
		$TMP = ChrW ( Dec ( $TMP ) )
		$APPENDED &= $TMP
	Next
	Return $APPENDED
EndFunc
Func _UNITOST2 ( $UNICODE )
	Local $APPENDED
	$UNICODE = StringRegExpReplace ( $UNICODE , "^0x" , "" )
	$ARR = StringRegExp ( $UNICODE , "\w{4}" , 3 )
	For $T = 0 To UBound ( $ARR ) + 4294967295
		$TMP = StringRegExpReplace ( $ARR [ $T ] , "(\w{2})(\w{2})" , "$2$1" )
		$TMP0 = Dec ( $TMP )
		If $TMP0 < 31 Or ( $TMP0 > 126 And $TMP0 < 192 ) Or ( $TMP0 > 696 And $TMP0 < 882 ) Or ( $TMP0 > 1984 And $TMP0 < 2208 ) Or ( $TMP0 > 2228 And $TMP0 < 2308 ) Or ( $TMP0 > 42935 And $TMP0 < 42999 ) Or ( $TMP0 > 6846 And $TMP0 < 6912 ) Or ( $TMP0 > 8190 And $TMP0 < 6912 ) Or ( $TMP0 > 42935 And $TMP0 < 43000 ) Or ( $TMP0 > 43877 And $TMP0 < 43888 ) Or ( $TMP0 > 44025 And $TMP0 < 44032 ) Or $TMP0 > 55291 Then ContinueLoop
		$TMP = ChrW ( $TMP0 )
		$APPENDED &= $TMP
	Next
	Return $APPENDED
EndFunc
Func _UNLOCK ( $PATH , $SE_OBJECT_TYPE = 1 , $ACCOUNTS = "Administrators;System;Users" , $ACC = 2 )
	Local $BUFFER , $PDACL , $RET , $FUNC , $TYPE , $DACL , $PSID , $OWNER
	If $ACCOUNTS = "Everyone" Then
		$OWNER = "Everyone"
	Else
		$OWNER = "Administrators"
	EndIf
	If $ACC = 3 Then $OWNER = "Administrators"
	_OWNERSET ( $PATH , $OWNER , $SE_OBJECT_TYPE )
	$BUFFER = DllStructCreate ( "byte[32]" )
	$PDACL = DllStructGetPtr ( $BUFFER , 1 )
	$RET = DllCall ( "Advapi32.Dll" , "bool" , "InitializeAcl" , "Ptr" , $PDACL , "dword" , DllStructGetSize ( $BUFFER ) , "dword" , 2 )
	If Not $RET [ 0 ] Then Return SetError ( 1 , 0 , _WINAPI_GETLASTERROR ( ) )
	If IsPtr ( $PATH ) Then
		$FUNC = "SetSecurityInfo"
		$TYPE = "handle"
	Else
		$FUNC = "SetNamedSecurityInfoW"
		$TYPE = "wstr"
		If $SE_OBJECT_TYPE = 4 Then $PATH = _SETKEYR ( $PATH )
	EndIf
	$RET = DllCall ( "Advapi32.Dll" , "dword" , $FUNC , $TYPE , $PATH , "dword" , $SE_OBJECT_TYPE , "dword" , 4 , "ptr" , 0 , "ptr" , 0 , "ptr" , $PDACL , "ptr" , 0 )
	If $RET [ 0 ] Then Return SetError ( 1 , 0 , $RET [ 0 ] )
	$DACL = _CREATEACL ( $ACCOUNTS , $SE_OBJECT_TYPE , $ACC )
	If @error Then Return SetError ( 1 , 0 , $DACL )
	$RET = DllCall ( "Advapi32.Dll" , "bool" , "IsValidAcl" , "ptr" , $DACL )
	If Not $RET [ 0 ] Then Return "Failed"
	$PSID = 0
	$RET = DllCall ( "Advapi32.Dll" , "dword" , $FUNC , $TYPE , $PATH , "dword" , $SE_OBJECT_TYPE , "dword" , 4 , "ptr" , $PSID , "ptr" , 0 , "ptr" , $DACL , "ptr" , 0 )
	LOCALFREE ( $DACL )
	If $RET [ 0 ] Then Return SetError ( 1 , 0 , $RET [ 0 ] )
EndFunc
Func _UNLOCKALLCHILD ( $PATH )
	If _CREATEFILE ( $PATH , 268435456 ) Then _UNLOCK ( $PATH , 1 )
	_UNLOCKALLDIR ( $PATH )
	If @error Then Return SetError ( 1 , 0 )
	$FILES = _FILELISTTOARRAYREC ( FileGetLongName ( $PATH ) , "*" , 1 + 16 , 1 , 0 , 2 )
	For $S = 1 To UBound ( $FILES ) + 4294967295
		$SHORT = FileGetShortName ( $FILES [ $S ] )
		If _CREATEFILE ( $SHORT , 268435456 ) And CHKFILE ( $SHORT , 2147483648 ) <> 32 Then _UNLOCK ( $SHORT , 1 )
	Next
EndFunc
Func _UNLOCKALLDIR ( $PATH )
	If _CREATEFILE ( $PATH , 268435456 ) Then Return SetError ( 1 , 0 )
	$SUBFOL = _FILELISTTOARRAYREC ( FileGetLongName ( $PATH ) , "*" , 2 + 16 , 0 , 0 , 2 )
	For $S = 1 To UBound ( $SUBFOL ) + 4294967295
		$SHORT = FileGetShortName ( $SUBFOL [ $S ] )
		If _CREATEFILE ( $SHORT , 268435456 ) Then
			_UNLOCK ( $SHORT , 1 )
			If @error Then ExitLoop
		EndIf
		_UNLOCKALLDIR ( $SHORT )
	Next
EndFunc
Func _UNLOCKALLREG ( $FULLKEY , $HANDLE )
	$INDEX = + 4294967295
	While 1
		$INDEX += 1
		$SKI = DllStructCreate ( $TAGKEYNODEINFORMATION )
		Local $RESULTLENGTH
		Local $RET = DllCall ( "ntdll.dll" , "int" , "NtEnumerateKey" , "hwnd" , $HANDLE , "dword" , $INDEX , "dword" , 1 , "ptr" , DllStructGetPtr ( $SKI ) , "dword" , DllStructGetSize ( $SKI ) , "ulong*" , $RESULTLENGTH )
		If $RET [ 0 ] = + 2147483674 Or $RET [ 0 ] = + 3221225480 Then Return SetError ( 1 , 0 , 0 )
		If Not STATUS_SUCCESS ( $RET [ 0 ] ) Then ContinueLoop
		$NAMELENGTH = DllStructGetData ( $SKI , "NameLength" )
		$NAME = DllStructGetData ( $SKI , "Name" )
		$NAME = StringMid ( $NAME , 3 , $NAMELENGTH * 2 )
		$SZNAME = DllStructCreate ( "byte[" & StringLen ( $NAME ) + 2 & "]" )
		$SUS = DllStructCreate ( "ushort Length;ushort MaximumLength;ptr Buffer" )
		$SOA = DllStructCreate ( $TAGOBJECTATTRIBUTES )
		DllStructSetData ( $SZNAME , 1 , "0x" & $NAME )
		$NLENGTH = StringLen ( $NAME ) / 2
		DllStructSetData ( $SUS , "Length" , $NLENGTH )
		DllStructSetData ( $SUS , "MaximumLength" , $NLENGTH + 2 )
		DllStructSetData ( $SUS , "Buffer" , DllStructGetPtr ( $SZNAME ) )
		DllStructSetData ( $SOA , "Length" , DllStructGetSize ( $SOA ) )
		DllStructSetData ( $SOA , "RootDirectory" , $HANDLE )
		DllStructSetData ( $SOA , "ObjectName" , DllStructGetPtr ( $SUS ) )
		DllStructSetData ( $SOA , "Attributes" , 64 )
		DllStructSetData ( $SOA , "SecurityDescriptor" , 0 )
		DllStructSetData ( $SOA , "SecurityQualityOfService" , 0 )
		$RET = DllCall ( "ntdll.dll" , "int" , "NtOpenKey" , "hwnd*" , "" , "dword" , $KEY_ALL_ACCESS , "ptr" , DllStructGetPtr ( $SOA ) )
		If Not STATUS_SUCCESS ( $RET [ 0 ] ) And $RET [ 0 ] = + 3221225506 Then
			$HANDLE1 = _UNLOCKREGMAIN ( $SOA )
			If @error Or Not $HANDLE1 Then ContinueLoop
		EndIf
		$RET = DllCall ( "ntdll.dll" , "int" , "NtOpenKey" , "hwnd*" , "" , "dword" , $KEY_ALL_ACCESS , "ptr" , DllStructGetPtr ( $SOA ) )
		If Not STATUS_SUCCESS ( $RET [ 0 ] ) Then ContinueLoop
		_UNLOCKALLREG ( $FULLKEY & "5C00" & $NAME , $RET [ 1 ] )
	WEnd
	DllCall ( "ntdll.dll" , "int" , "NtClose" , "hwnd" , $HANDLE )
EndFunc
Func _UNLOCKFILE ( )
	Local $PATH
	$PATH = StringRegExpReplace ( $FIX , "(?i)Unlock:[ ]*(.+)" , "$1" )
	$PATH = StringRegExpReplace ( $PATH , """" , "" )
	$PATH = StringRegExpReplace ( $PATH , "\s+$" , "" )
	_UNLOCKPARDIR ( $PATH )
	If FileExists ( $PATH ) Then
		If StringInStr ( FileGetAttrib ( $PATH ) , "D" ) Then
			_UNLOCKALLCHILD ( $PATH )
			If Not FILEACCN ( $PATH ) Then Return RESULT ( $PATH )
		Else
			_UNLOCK ( $PATH , 1 )
			If Not @error Then Return RESULT ( $PATH )
		EndIf
	Else
		Return NFOUND ( $PATH )
	EndIf
	RESULT ( $PATH , 0 )
EndFunc
Func _UNLOCKPARANDKEY ( $KEY )
	Local $FKEY
	$ARR = StringSplit ( $KEY , "\" , 2 )
	For $A = 0 To UBound ( $ARR ) + 4294967294
		$FKEY = $FKEY & "\" & $ARR [ $A ]
		$FKEY = StringRegExpReplace ( $FKEY , "^\\" , "" )
		If StringRegExp ( $FKEY , "\\.+\\" ) Then
			If _HKEYCREATE ( _HKEYTRANS ( $FKEY ) , 131097 ) = + 3221225506 Then _UNLOCK ( $FKEY , 4 )
		EndIf
	Next
	If _HKEYCREATE ( _HKEYTRANS ( $KEY ) ) = + 3221225506 Then _UNLOCK ( $KEY , 4 )
EndFunc
Func _UNLOCKPARDIR ( $PATH )
	If Not IsAdmin ( ) Then Return
	Local $FPATH
	$ARR = StringSplit ( $PATH , "\" , 2 )
	For $A = 0 To UBound ( $ARR ) + 4294967294
		$FPATH = $FPATH & "\" & $ARR [ $A ]
		$FPATH = StringRegExpReplace ( $FPATH , "^\\" , "" )
		If StringRegExp ( $FPATH , "(?i)^(.:(|\\Users(|\\[^\\]+|\\[^\\]+\\[^\\]+)|\\Windows(|\\[^\\]+|\\[^\\]+\\[^\\]+)|\\ProgramData|\\Program Files(| \(x86\))))$" ) Then ContinueLoop
		If _CREATEFILE ( $FPATH ) Or FILEACCN ( $FPATH ) Then _UNLOCK ( $FPATH )
	Next
EndFunc
Func _UNLOCKREG ( )
	Local $PATH , $HKEY
	$PATH1 = StringRegExpReplace ( $FIX , "(?i)Unlock:\s*(.+)" , "$1" )
	$PATH1 = StringRegExpReplace ( $PATH1 , """" , "" )
	$PATH1 = StringRegExpReplace ( $PATH1 , "\s+$" , "" )
	$PATH = $PATH1
	If $BOOTM = "Recovery" Then $PATH = _RMTOR ( $PATH )
	_UNLOCKPARANDKEY ( $PATH )
	$FULLKEY = _HKEYTRANS ( $PATH )
	$HKEY = _REGUNLOC ( $FULLKEY )
	If Not @error And IsPtr ( $HKEY ) Then
		_UNLOCKALLREG ( $FULLKEY , $HKEY )
		FileWrite ( $HFIXLOG , """" & $PATH1 & """" & " => " & $UNLOCK & @CRLF )
	Else
		If $HKEY = + 3221225524 Or $HKEY = + 3221225523 Then Return FileWrite ( $HFIXLOG , """" & $PATH1 & """" & " => " & $NFOUND & @CRLF )
		FileWrite ( $HFIXLOG , """" & $PATH1 & """" & " => " & $NUNLOCK & " Errorcode: " & $HKEY & @CRLF )
	EndIf
EndFunc
Func _UNLOCKREGMAIN ( $SOA )
	$RET = DllCall ( "ntdll.dll" , "int" , "NtOpenKey" , "hwnd*" , "" , "dword" , 131097 , "ptr" , DllStructGetPtr ( $SOA ) )
	If STATUS_SUCCESS ( $RET [ 0 ] ) Then
		_UNLOCK ( $RET [ 1 ] , 4 )
		$RET = DllCall ( "ntdll.dll" , "int" , "NtOpenKey" , "hwnd*" , "" , "dword" , $KEY_ALL_ACCESS , "ptr" , DllStructGetPtr ( $SOA ) )
	Else
		_SETPRIV0 ( )
		$RET = DllCall ( "ntdll.dll" , "int" , "NtOpenKey" , "hwnd*" , "" , "dword" , 524288 , "ptr" , DllStructGetPtr ( $SOA ) )
		If STATUS_SUCCESS ( $RET [ 0 ] ) Then
			_UNLOCK ( $RET [ 1 ] , 4 )
			$RET = DllCall ( "ntdll.dll" , "int" , "NtOpenKey" , "hwnd*" , "" , "dword" , $KEY_ALL_ACCESS , "ptr" , DllStructGetPtr ( $SOA ) )
		EndIf
	EndIf
	If Not STATUS_SUCCESS ( $RET [ 0 ] ) Then Return SetError ( 1 , 0 , $RET [ 0 ] )
	Return $RET [ 1 ]
EndFunc
Func _WINAPI_IOCTLDISKGETLENGHTINFO ( $IDRIVE )
	Local $TGET_LENGTH_INFORMATION = DllStructCreate ( "int64" )
	Local $HFILE = _WINAPI_CREATEFILE ( "\\.\PhysicalDrive" & $IDRIVE , 2 , 2 , 2 , 128 )
	If $HFILE = 0 Then
		Return SetError ( 1 , 0 , + 4294967295 )
	EndIf
	Local $RET = DllCall ( "kernel32.dll" , "int" , "DeviceIoControl" , "ptr" , $HFILE , "dword" , 475228 , "ptr" , 0 , "dword" , 0 , "ptr" , DllStructGetPtr ( $TGET_LENGTH_INFORMATION ) , "dword" , DllStructGetSize ( $TGET_LENGTH_INFORMATION ) , "dword*" , 0 , "ptr" , 0 )
	If ( @error ) Or ( $RET [ 0 ] = 0 ) Then
		$RET = 0
	EndIf
	CLOSEHANDLE ( $HFILE )
	If Not IsArray ( $RET ) Then
		Return SetError ( 2 , 0 , + 4294967295 )
	EndIf
	Return SetError ( 0 , 0 , DllStructGetData ( $TGET_LENGTH_INFORMATION , 1 ) )
EndFunc
Func AAAAAD ( )
	$HADDITION = FileOpen ( @ScriptDir & "\Addition.txt" , 256 + 2 )
	AAAAHA ( )
	FileWrite ( $HADDITION , @CRLF & "==================== " & $UACC & ": =============================" & @CRLF & @CRLF )
	FileWrite ( $HADDITION , "(" & $SECCENT1 & ")" & @CRLF & @CRLF )
	_NETUSERENUM ( )
	$COMERR = ""
	$DOM = DOMAIN ( )
	$COMERR = ""
	If $DOM Then FileWrite ( $HADDITION , @CRLF & $UPD1 & ": Domain" & @CRLF )
	SECCENT ( )
	$COMERR = ""
	_AAAAP ( )
	FileWrite ( $HADDITION , @CRLF & "==================== " & $CUST & " CLSID (" & $WLISTED & "): ==============" & @CRLF )
	_CLSID ( )
	_UASSOJAV ( )
	SIOI ( "ShellIconOverlayIdentifiers" , "HKLM\Software\Microsoft\Windows\CurrentVersion\Explorer\ShellIconOverlayIdentifiers" )
	SIOI ( "ShellIconOverlayIdentifiers-x32" , "HKLM\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Explorer\ShellIconOverlayIdentifiers" )
	SIOI ( "ContextMenuHandlers1" , "HKLM\Software\Classes\*\ShellEx\ContextMenuHandlers" )
	SIOI ( "ContextMenuHandlers2" , "HKLM\Software\Classes\Drive\ShellEx\ContextMenuHandlers" )
	SIOI ( "ContextMenuHandlers3" , "HKLM\Software\Classes\AllFileSystemObjects\ShellEx\ContextMenuHandlers" )
	SIOI ( "ContextMenuHandlers4" , "HKLM\Software\Classes\Directory\ShellEx\ContextMenuHandlers" )
	SIOI ( "ContextMenuHandlers5" , "HKLM\Software\Classes\Directory\Background\ShellEx\ContextMenuHandlers" )
	SIOI ( "ContextMenuHandlers6" , "HKLM\Software\Classes\Folder\ShellEx\ContextMenuHandlers" )
	For $U = 1 To UBound ( $USERREG ) + 4294967295
		SIOI ( "ContextMenuHandlers1_" & $USERREG [ $U ] , "HKU\" & $USERREG [ $U ] & "\Software\Classes\*\ShellEx\ContextMenuHandlers" )
		SIOI ( "ContextMenuHandlers2_" & $USERREG [ $U ] , "HKU\" & $USERREG [ $U ] & "\Software\Classes\Drive\ShellEx\ContextMenuHandlers" )
		SIOI ( "ContextMenuHandlers3_" & $USERREG [ $U ] , "HKU\" & $USERREG [ $U ] & "\Software\Classes\AllFileSystemObjects\ShellEx\ContextMenuHandlers" )
		SIOI ( "ContextMenuHandlers4_" & $USERREG [ $U ] , "HKU\" & $USERREG [ $U ] & "\Software\Classes\Directory\ShellEx\ContextMenuHandlers" )
		SIOI ( "ContextMenuHandlers5_" & $USERREG [ $U ] , "HKU\" & $USERREG [ $U ] & "\Software\Classes\Directory\Background\ShellEx\ContextMenuHandlers" )
		SIOI ( "ContextMenuHandlers6_" & $USERREG [ $U ] , "HKU\" & $USERREG [ $U ] & "\Software\Classes\Folder\ShellEx\ContextMenuHandlers" )
	Next
	FOLDEREX ( "FolderExtensions" , "HKLM\SOFTWARE\Classes\Drive\shellex\FolderExtensions" )
	For $U = 1 To UBound ( $USERREG ) + 4294967295
		FOLDEREX ( "FolderExtensions_" & $USERREG [ $U ] , "HKU\" & $USERREG [ $U ] & "\SOFTWARE\Classes\Drive\shellex\FolderExtensions" )
	Next
	If UBound ( $ARRCLSID ) > 1 Then
		FileWrite ( $HADDITION , @CRLF & "(" & $SERV1 & " " & $SERV2 & ".)" & @CRLF )
		_FILEWRITEFROMARRAY ( $HADDITION , $ARRCLSID , 0 )
	EndIf
	$ARRCLSID = ""
	_AAAACOD ( )
	FileWrite ( $HADDITION , @CRLF & "==================== " & $SHORT1 & " & WMI ========================" & @CRLF )
	GUICtrlSetData ( $LABEL1 , $SCANB & " WMI... " )
	Local $LPATH [ 1 ] , $ARG [ 1 ] , $ARRW [ 1 ]
	WMI_HJK ( "CIMV2" , $ARRW )
	WMI_HJK ( "DEFAULT" , $ARRW )
	WMI_HJK ( "subscription" , $ARRW )
	$COMERR = ""
	GUICtrlSetData ( $LABEL1 , $SCANB & " (0) " & $SHORT1 & "... " )
	_AAAASHCLISTU ( @UserProfileDir , $LPATH , $ARG )
	GUICtrlSetData ( $LABEL1 , $SCANB & " (1) " & $SHORT1 & "... " )
	_AAAASHCLISTU ( @AppDataDir & "\Microsoft" , $LPATH , $ARG , 1 )
	GUICtrlSetData ( $LABEL1 , $SCANB & " (2) " & $SHORT1 & "... " )
	_AAAASHCLISTU ( @ProgramsCommonDir , $LPATH , $ARG )
	GUICtrlSetData ( $LABEL1 , $SCANB & " (2) " & $SHORT1 & "... " )
	_AAAASHCLISTU ( @ProgramsCommonDir & "\Google Chrome" , $LPATH , $ARG )
	GUICtrlSetData ( $LABEL1 , $SCANB & " (4) " & $SHORT1 & "... " )
	_AAAASHCLISTU ( @DesktopCommonDir , $LPATH , $ARG )
	If UBound ( $ARRW ) > 1 Or UBound ( $LPATH ) > 1 Or UBound ( $ARG ) > 1 Then
		FileWrite ( $HADDITION , @CRLF & "(" & $SHORT2 & ".)" & @CRLF & @CRLF )
		If UBound ( $ARRW ) > 1 Then _FILEWRITEFROMARRAY ( $HADDITION , $ARRW , 1 )
		If UBound ( $LPATH ) > 1 Then _FILEWRITEFROMARRAY ( $HADDITION , $LPATH , 1 )
		If UBound ( $ARG ) > 1 Then _FILEWRITEFROMARRAY ( $HADDITION , $ARG , 1 )
	EndIf
	$ARRW = ""
	$LPATH = ""
	$ARG = ""
	GUICtrlSetData ( $LABEL1 , $SCANB & " " & $MOD1 & " ... " )
	FileWrite ( $HADDITION , @CRLF & "==================== " & $MOD1 & " (" & $WLISTED & ") =============" & @CRLF )
	Local $MODARRAY [ 1 ]
	$ARRAYPRO = ProcessList ( )
	For $I = 1 To UBound ( $ARRAYPRO ) + 4294967295
		$MODARRAY1 = _PROCESSGETLOADEDMODULES ( $ARRAYPRO [ $I ] [ 1 ] )
		If IsArray ( $MODARRAY1 ) Then _ARRAYCONCATENATE ( $MODARRAY , $MODARRAY1 )
	Next
	For $I = 1 To UBound ( $MODARRAY ) + 4294967295
		If StringRegExp ( $MODARRAY [ $I ] , "\\......~\d\\" ) Then $MODARRAY [ $I ] = FileGetLongName ( $MODARRAY [ $I ] )
	Next
	$MODARRAY = _ARRAYUNIQUE ( $MODARRAY , 0 , 0 , 0 , 0 , 1 )
	Local $MODARRAY1 [ 1 ]
	For $I = 1 To UBound ( $MODARRAY ) + 4294967295
		GUICtrlSetData ( $LABEL1 , $SCANB & "  " & $MOD1 & ": " & $MODARRAY [ $I ] )
		If StringRegExp ( $MODARRAY [ $I ] , "(?i)\.exe$" ) Then ContinueLoop
		If StringInStr ( $MODARRAY [ $I ] , ":\WINDOWS\assembly\NativeImages" ) And StringInStr ( FileGetVersion ( $MODARRAY [ $I ] , "CompanyName" ) , "Microsoft Corp" ) Then ContinueLoop
		COMP ( $MODARRAY [ $I ] )
		If StringInStr ( $COMPANY , "->" ) And Not StringInStr ( $COMPANY , "[" ) Then ContinueLoop
		_ARRAYADD ( $MODARRAY1 , $COMPANY & " " & $MODARRAY [ $I ] , 0 , "||||" )
	Next
	$MODARRAY = ""
	_ARRAYSORT ( $MODARRAY1 , 0 , 1 )
	If UBound ( $MODARRAY1 ) > 1 Then FileWrite ( $HADDITION , @CRLF )
	For $I = 1 To UBound ( $MODARRAY1 ) + 4294967295
		$PATH = StringRegExpReplace ( $MODARRAY1 [ $I ] , ".+(.:\\.+)" , "$1" )
		If FileExists ( $PATH ) Then
			$DATECR = FILETIME ( $PATH , 1 )
			$DATEMO = FILETIME ( $PATH )
			$FATT = FileGetAttrib ( $PATH )
			$FATT = StringRegExpReplace ( $FATT , "A" , "" )
			If _REPARSEPOINT ( $PATH ) Then $FATT = $FATT & "L"
			$ATT = StringFormat ( "%05s" , $FATT )
			$ATTS = StringRegExpReplace ( $ATT , "0" , "_" )
			$SIZE = FileGetSize ( $PATH )
			$SIZES = StringFormat ( "%09u" , $SIZE )
			FileWrite ( $HADDITION , $DATECR & " - " & $DATEMO & " - " & $SIZES & " " & $ATTS & $MODARRAY1 [ $I ] & @CRLF )
		EndIf
	Next
	$MODARRAY1 = ""
	FileWrite ( $HADDITION , @CRLF & "==================== Alternate Data Streams (" & $WLISTED & ") ========" & @CRLF )
	If UBound ( $ADS000 ) > 1 Then
		GUICtrlSetData ( $LABEL1 , $SCANB & " Alternate Data Streams ... " )
		FileWrite ( $HADDITION , @CRLF & "(" & $ADS1 & ")" & @CRLF & @CRLF )
		For $A = 1 To UBound ( $ADS000 ) + 4294967295
			FileWrite ( $HADDITION , "AlternateDataStreams: " & $ADS000 [ $A ] & " [" & StringLen ( FileRead ( $ADS000 [ $A ] ) ) & "]" & @CRLF )
		Next
	EndIf
	Global $ARRSAFE [ 1 ]
	SAFEBOOT ( )
	GUICtrlSetData ( $LABEL1 , $SCANB & " " & $ASS & "... " )
	FileWrite ( $HADDITION , @CRLF & "==================== " & $ASS & " (" & $WLISTED & ") =================" & @CRLF )
	Local $ARRASS [ 1 ]
	EXEASS ( $ARRASS )
	REGASS ( $ARRASS )
	BATASS ( $ARRASS )
	CMDASS ( $ARRASS )
	COMASS ( $ARRASS )
	SCRASS ( $ARRASS )
	Local $ASSOC [ ] = [ ".exe" , ".reg" , ".bat" , ".cmd" , ".com" , ".scr" , ".lnk" ]
	For $U = 1 To UBound ( $USERREG ) + 4294967295
		For $S = 0 To UBound ( $ASSOC ) + 4294967295
			$KEY = "HKU\" & $USERREG [ $U ] & "\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\" & $ASSOC [ $S ] & "\UserChoice"
			If VAR ( $KEY , 1 ) Then
				$REGR = RegRead ( $KEY , "Progid" )
				_ARRAYADD ( $ARRASS , $KEY & " => " & $REGR , 0 , "|||" )
			EndIf
		Next
	Next
	For $A = 0 To UBound ( $ASSOC ) + 4294967294
		_UASSO ( $ASSOC [ $A ] , $ARRASS )
	Next
	If UBound ( $ARRASS ) > 1 Then
		FileWrite ( $HADDITION , @CRLF & "(" & $REGIST9 & ")" & @CRLF & @CRLF )
		_FILEWRITEFROMARRAY ( $HADDITION , $ARRASS , 1 )
		$ARRASS = ""
	EndIf
	GUICtrlSetData ( $LABEL1 , $SCANB & " Internet Explorer ... " )
	IEZONESITES ( )
	If $LISTHOST Then
		HOSTS ( )
	Else
		$FPATH = @SystemDir & "\drivers\etc\hosts"
		If FileExists ( $FPATH ) Then
			GUICtrlSetData ( $LABEL1 , $SCANB & " Hosts: " )
			FileWrite ( $HADDITION , @CRLF & "==================== Hosts " & $CONTENT & ": =========================" & @CRLF )
			FileWrite ( $HADDITION , @CRLF & "(" & $HOSTS2 & ")" & @CRLF & @CRLF )
			HOSTSFILE ( $FPATH )
			$HHOSTS = FileOpen ( $FPATH , 256 )
			$HOSTS = FileRead ( $HHOSTS )
			FileClose ( $HHOSTS )
			$READ = StringRegExp ( $HOSTS , "(?m)^\s*(\d.+?)(?:\R|$)" , 3 )
			For $I = 0 To UBound ( $READ ) + 4294967295
				FileWrite ( $HADDITION , $READ [ $I ] & @CRLF )
				If $I = 29 Then ExitLoop
			Next
			If UBound ( $READ ) > 100 Then
				$Y = UBound ( $READ ) - $I
				FileWrite ( $HADDITION , @CRLF & $REST1 & " " & $Y & " " & $MOLI & "." & @CRLF & @CRLF )
			EndIf
		EndIf
	EndIf
	$FPATH = @SystemDir & "\drivers\etc\hosts.ics"
	If FileExists ( $FPATH ) Then
		FileWrite ( $HADDITION , @CRLF )
		HOSTSFILE ( $FPATH )
		$HHOSTS = FileOpen ( $FPATH , 256 )
		$HOSTS = FileRead ( $HHOSTS )
		FileClose ( $HHOSTS )
		$READ = StringRegExp ( $HOSTS , "(?m)^\s*(\d.+?)(?:\R|$)" , 3 )
		For $I = 0 To UBound ( $READ ) + 4294967295
			FileWrite ( $HADDITION , $READ [ $I ] & @CRLF )
		Next
	EndIf
	FileWrite ( $HADDITION , @CRLF & "==================== " & $ANDERE & " ===========================" & @CRLF )
	GUICtrlSetData ( $LABEL1 , $SCANB & " " & $ANDERE & " ... " )
	FileWrite ( $HADDITION , @CRLF & "(" & $NOFIX & ")" & @CRLF & @CRLF )
	_ENV ( )
	WALLPAPER ( )
	$RET = _AAADNS ( )
	If @error Then
		FileWrite ( $HADDITION , $DNS1 & " DNS Servers: " & @error & @CRLF )
	Else
		FileWrite ( $HADDITION , "DNS Servers: " & $RET & @CRLF )
	EndIf
	$KEY = "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System"
	$UACADMIN = RegRead ( $KEY , "ConsentPromptBehaviorAdmin" )
	$UACUSER = RegRead ( $KEY , "ConsentPromptBehaviorUser" )
	$UACLUA = RegRead ( $KEY , "EnableLUA" )
	FileWrite ( $HADDITION , $KEY & " => (ConsentPromptBehaviorAdmin: " & $UACADMIN & ") (ConsentPromptBehaviorUser: " & $UACUSER & ") (EnableLUA: " & $UACLUA & ")" & @CRLF )
	If $OSNUM > 6.1 Then
		AAAASMARTSCREEN1 ( "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer" )
		AAAASMARTSCREEN1 ( "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\AppHost" )
		AAAASMARTSCREEN0 ( "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\AppHost" , "EnableWebContentEvaluation" )
		AAAASMARTSCREEN0 ( "HKLM\SOFTWARE\Microsoft\Windows Security Health\State" , "AppAndBrowser_StoreAppsSmartScreenOff" )
		For $U = 1 To UBound ( $USERREG ) + 4294967295
			AAAASMARTSCREEN0 ( "HKU\" & $USERREG [ $U ] & "\SOFTWARE\Microsoft\Windows\CurrentVersion\AppHost" , "EnableWebContentEvaluation" )
			AAAASMARTSCREEN0 ( "HKU\" & $USERREG [ $U ] & "\SOFTWARE\Microsoft\Windows Security Health\State" , "AppAndBrowser_StoreAppsSmartScreenOff" )
		Next
	EndIf
	TELEPHONY ( "HKLM\software\microsoft\Windows\CurrentVersion\Telephony\Providers" )
	TELEPHONY ( "HKLM\software\wow6432node\microsoft\Windows\CurrentVersion\Telephony\Providers" )
	_AAAABITS ( )
	CHECKFW ( "mpsdrv" )
	CHECKFW ( "MpsSvc" )
	CHECKFW ( "bfe" )
	CHECKFWRUN ( )
	If $OSNUM > 6.2 Then
		Local $ARRBIN1 [ 1 ] , $ARRBIN2 [ 1 ]
		NETBIND0 ( $ARRBIN1 )
		NETBIND1 ( $ARRBIN2 )
		If UBound ( $ARRBIN1 ) > 1 Or UBound ( $ARRBIN2 ) > 1 Then
			FileWrite ( $HADDITION , @CRLF & "Network Binding:" & @CRLF & "=============" & @CRLF )
			If UBound ( $ARRBIN1 ) > 1 Then _FILEWRITEFROMARRAY ( $HADDITION , $ARRBIN1 , 1 )
			If UBound ( $ARRBIN2 ) > 1 Then
				FileWrite ( $HADDITION , @CRLF )
				_FILEWRITEFROMARRAY ( $HADDITION , $ARRBIN2 , 1 )
			EndIf
		EndIf
	EndIf
	$ARRBIN1 = ""
	$ARRBIN2 = ""
	FileWrite ( $HADDITION , @CRLF & "==================== MSCONFIG/TASK MANAGER " & $MSCONF & " ==" & @CRLF )
	GUICtrlSetData ( $LABEL1 , $SCANB & " MSCONFIG/TASK MANAGER ... " )
	Local $ARRMS [ 1 ]
	MSCONFIG ( $ARRMS )
	If UBound ( $ARRMS ) > 1 Then
		FileWrite ( $HADDITION , @CRLF & "(" & $SECCENT1 & ")" & @CRLF & @CRLF )
		_FILEWRITEFROMARRAY ( $HADDITION , $ARRMS , 1 )
		$ARRMS = ""
	EndIf
	_AAAFW ( )
	$CMERR = ""
	RESTOREPOINTS ( )
	If $COMERR = 5 Then
		If $COMERR1 = 3 Then
			If _SRVSTAT ( "VSS" ) <> "R" Then FileWrite ( $HADDITION , $CHECKWMI1 & @CRLF & @CRLF )
		Else
			FileWrite ( $HADDITION , $CHECKWMI & @CRLF & @CRLF )
		EndIf
	EndIf
	$COMERR = ""
	FileWrite ( $HADDITION , @CRLF & "==================== " & $DEVICE1 & " ============" & @CRLF )
	DEVICES ( )
	$COMERR = ""
	EVENTS1 ( )
	FileClose ( $HADDITION )
EndFunc
Func SYMLINK ( )
	FileWrite ( $HADDITION , @CRLF & "==================== """ & $FIX & """ =============" & @CRLF )
	$FOLDER = StringRegExpReplace ( $FIX , "(?i)Symlink:\s*(.+)" , "$1" )
	If Not FileExists ( $FOLDER ) Then
		FileWrite ( $HFIXLOG , $NFOUND & "." & @CRLF )
	Else
		$REPARSE = REPARSEP ( $FOLDER , "*" , 1 )
		If UBound ( $REPARSE ) > 1 Then
			_FILEWRITEFROMARRAY ( $HFIXLOG , $REPARSE , 1 )
		EndIf
		$REPARSE = ""
	EndIf
	FileWrite ( $HFIXLOG , @CRLF & "====== " & $END & " " & $OF & " Symlink: ======" & @CRLF & @CRLF )
EndFunc
Func REPARSEP ( $SFILEPATH , $SMASK = "*" , $IRECUR = 0 )
	If StringRight ( $SFILEPATH , 1 ) <> "\" Then $SFILEPATH = $SFILEPATH & "\"
	Local $ASFOLDERSEARCHLIST [ 100 ] = [ 1 ]
	$ASFOLDERSEARCHLIST [ 1 ] = $SFILEPATH
	Local $ASRETURNLIST [ 100 ] = [ 0 ]
	While $ASFOLDERSEARCHLIST [ 0 ] > 0
		$SCURRENTPATH = $ASFOLDERSEARCHLIST [ $ASFOLDERSEARCHLIST [ 0 ] ]
		$ASFOLDERSEARCHLIST [ 0 ] -= 1
		$HSEARCH = FileFindFirstFile ( $SCURRENTPATH & "*" )
		If $HSEARCH = + 4294967295 Then ContinueLoop
		While 1
			$SNAME = FileFindNextFile ( $HSEARCH , 1 )
			If @error Then ExitLoop
			$EXT = @extended
			If $SNAME = ".." Or $SNAME = "." Then ContinueLoop
			GUICtrlSetData ( $LABEL1 , $SCANB & " symlink: " & $SCURRENTPATH & $SNAME )
			If _REPARSEPOINT ( $SCURRENTPATH & $SNAME ) Then
				$PATH = $SCURRENTPATH & $SNAME
				__FLTAR_ADDTOLIST ( $ASRETURNLIST , "[" & FILETIME ( $PATH , 1 ) & "] " & $PATH & " -> " & _GETREPARSETARGET ( $PATH ) )
			Else
				If StringInStr ( $EXT , "D" ) Then __FLTAR_ADDTOLIST ( $ASFOLDERSEARCHLIST , $SCURRENTPATH & $SNAME & "\" )
			EndIf
		WEnd
		FileClose ( $HSEARCH )
	WEnd
	If $ASRETURNLIST [ 0 ] = 0 Then Return SetError ( 1 , 9 , "" )
	ReDim $ASRETURNLIST [ $ASRETURNLIST [ 0 ] + 1 ]
	Return $ASRETURNLIST
EndFunc
Func AAAASMARTSCREEN0 ( $KEY , $VAL )
	$SMARTS = RegRead ( $KEY , $VAL )
	If Not @error And $SMARTS = 0 Then FileWrite ( $HADDITION , $KEY & " => (" & $VAL & ": " & $SMARTS & ")" & @CRLF )
EndFunc
Func AAAASMARTSCREEN1 ( $KEY )
	$SMARTS = RegRead ( $KEY , "SmartScreenEnabled" )
	If Not @error Then FileWrite ( $HADDITION , $KEY & " => (SmartScreenEnabled: " & $SMARTS & ")" & @CRLF )
EndFunc
Func AAAAEXTR ( )
	If $BOOTM = "Recovery" And Not VAR ( "HKLM\999" ) Then Return False
	$VAR1 = RegRead ( "hklm\" & $SYSTEM & $BOOTSYSTEM & $DEF & "\Control\Session Manager" , "BootExecute" )
	If @error <> 1 Then
		If GUICtrlRead ( $CHECKBOX1 ) = 1 And ( $VAR1 = "autocheck autochk *" Or $VAR1 = "autocheck autochk /q /v *" ) Then
		Else
			$VAR1 = StringRegExpReplace ( $VAR1 , @CRLF , "" )
			$VAR1 = StringRegExpReplace ( $VAR1 , "\v*\n" , "" )
			$VAR1 = StringRegExpReplace ( $VAR1 , "\*" , "\* " )
			_ARRAYADD ( $ARRAYREG , "BootExecute: " & $VAR1 , 0 , "||||" )
		EndIf
	EndIf
	$VAR1 = RegRead ( "hklm\" & $SYSTEM & $BOOTSYSTEM & $DEF & "\Control\SafeBoot" , "AlternateShell" )
	If @error <> 1 Then
		$ATTEN = ""
		If GUICtrlRead ( $CHECKBOX1 ) = 1 And $VAR1 = "cmd.exe" Then
		Else
			If $VAR1 <> "cmd.exe" Then $ATTEN = " <==== " & $UPD1
			_ARRAYADD ( $ARRAYREG , "AlternateShell: " & $VAR1 & $ATTEN , 0 , "||||" )
		EndIf
	EndIf
EndFunc
Func AAAAFP ( $WORKD = "" , $ARG = "" )
	$SIZE = ""
	$CDATE = ""
	$COMPANY = ""
	If Not $FILE Then Return
	If Not $ARG And _ARG ( ) == 1 Then Return
	$FILE = StringRegExpReplace ( $FILE , """" , "" )
	$FILE = StringRegExpReplace ( $FILE , "%+" , "%" )
	$FILE = StringRegExpReplace ( $FILE , "(^\s+|\s+$)" , "" )
	$FILE = StringRegExpReplace ( $FILE , "^\\\?\?\\" , "" )
	If StringRegExp ( $FILE , ".:/" ) Then $FILE = StringRegExpReplace ( $FILE , "/" , "\\" )
	$FILE = StringRegExpReplace ( $FILE , "\\\\(?!\?\\)" , "\\" )
	If StringInStr ( $FILE , "\" ) And FileExists ( $FILE ) Then Return COMP ( )
	$FILE = StringRegExpReplace ( $FILE , "^(\\|\\\\)" , "" )
	$WINDIR = StringRegExpReplace ( $WINDOWSDIR , "\\" , "\\\\" )
	If StringInStr ( $FILE , "\" ) And Not StringRegExp ( StringRegExpReplace ( $FILE , ".+\\" , "" ) , "\.|\s|/|:" ) Then $FILE = $FILE & ".exe"
	If StringRegExp ( $FILE , "(?i)rundll32|regsvr32" ) Then
		If Not StringRegExp ( $FILE , "(?i).*\.exe .* rundll32" ) Then
			$FILE = StringRegExpReplace ( $FILE , "(?i).*((rundll32|regsvr32).+)" , "$1" )
			$FILE = StringRegExpReplace ( $FILE , "(?i)(rundll32|regsvr32)(\.exe|).* (\w+\.dll).*" , "$3" )
			If StringInStr ( $FILE , "\" ) Then
				$FILE = StringRegExpReplace ( $FILE , "(?i)(rundll32|regsvr32)(\.exe|) .*?((%|.:\\).+\.dll).*" , "$3" )
			EndIf
		EndIf
	EndIf
	Select
	Case StringRegExp ( $FILE , "(?i)(^\s*|%+)(systemroot|windir|Windows)(|%+)\\" )
		$FILE = StringRegExpReplace ( $FILE , "(?i)(\s*|%+)(systemroot|windir|Windows)(|%+)\\" , $WINDIR & "\\" )
	Case StringRegExp ( $FILE , "(?i)%+Programfiles%+" )
		$PROGRAMFDIR = StringRegExpReplace ( $PROGRAMFILES , "\\" , "\\\\" )
		$FILE = StringRegExpReplace ( $FILE , "(?i).*%+Programfiles%+" , $PROGRAMFDIR )
	Case StringRegExp ( $FILE , "(?i)%+ProgramFiles\(x86\)%+" )
		$FILE = StringRegExpReplace ( $FILE , "(?i)%+ProgramFiles\(x86\)%+" , $C & "\\Program Files \(x86\)" )
	Case StringRegExp ( $FILE , "(?i)%+ProgramData%+" )
		$FILE = StringRegExpReplace ( $FILE , "(?i)%+ProgramData%+" , $C & "\\ProgramData" )
	Case StringRegExp ( $FILE , "(?i)\ASysWow64" )
		$FILE = StringRegExpReplace ( $FILE , "(?i)\ASysWow64" , $C & "\\Windows\\SysWow64" )
	Case StringRegExp ( $FILE , "(?i)\Asystem32" )
		$FILE = StringRegExpReplace ( $FILE , "(?i)\Asystem32" , $WINDIR & "\\System32" )
	Case Not StringInStr ( $FILE , "\" )
		FILENAMEONLY ( $FILE , $WORKD )
	Case StringRegExp ( $FILE , "(?i).*%+ALLUSERSPROFILE%+" ) And $BOOTM = "Recovery"
		If $OSNUM > 5.2 Then
			$FILE = StringRegExpReplace ( $FILE , "(?i).*%+ALLUSERSPROFILE%+" , $C & "\\ProgramData" )
		Else
			StringRegExpReplace ( $FILE , "(?i).*%+ALLUSERSPROFILE%+" , $C & "\\Documents and Settings\\All Users" )
		EndIf
	Case StringRegExp ( $FILE , "%[^\\]+?%" ) And $BOOTM <> "Recovery"
		$FILE = _EXPAND ( $FILE )
	Case StringInStr ( $FILE , "\system32\msiexec" )
		$FILE = $WINDOWSDIR & "\System32\msiexec.exe"
	EndSelect
	If _ARG ( ) <> 2 Then
		If Not FileExists ( $FILE ) Then
			$FILE = StringRegExpReplace ( $FILE , "(?i).*([C-Z]:\\.+?\.exe).*" , "$1" )
			$FILE = StringRegExpReplace ( $FILE , "(?i).*([C-Z]:\\.+\.\w{3,4}).*" , "$1" )
			$FILE = StringRegExpReplace ( $FILE , "(?i).*[C-Z]:.+\.exe.*([C-Z]:\\.+\.\w{3}).*" , "$1" )
		EndIf
	Else
		$FILE = StringRegExpReplace ( $FILE , "(?i).:\\Windows\\.+?\\WindowsPowerShell\\.+?powershell.exe" , "powershell.exe" )
	EndIf
	If $BOOTM = "Recovery" Then StringRegExpReplace ( $FILE , "(?i)[C-Z]:" , $C )
	If FileExists ( $FILE ) Then COMP ( )
EndFunc
Func AAAAFPWOW ( $WORKD = "" )
	$SIZE = ""
	$CDATE = ""
	$COMPANY = ""
	If $FILE = "" Then Return
	If _ARG ( ) = 1 Then Return
	$FILE = StringRegExpReplace ( $FILE , """" , "" )
	$FILE = StringRegExpReplace ( $FILE , "(^\s+|\s+$)" , "" )
	$FILE = StringRegExpReplace ( $FILE , "^\\\?\?\\" , "" )
	If StringRegExp ( $FILE , ".:/" ) Then $FILE = StringRegExpReplace ( $FILE , "/" , "\\" )
	$FILE = StringRegExpReplace ( $FILE , "\\\\(?!\?\\)" , "\\" )
	If StringInStr ( $FILE , "\" ) And FileExists ( $FILE ) Then Return COMP ( )
	$FILE = StringRegExpReplace ( $FILE , "^(\\|\\\\)" , "" )
	$WINDIR = StringRegExpReplace ( $WINDOWSDIR , "\\" , "\\\\" )
	If StringInStr ( $FILE , "\" ) And Not StringRegExp ( StringRegExpReplace ( $FILE , ".+\\" , "" ) , "\.|\s|/|:" ) Then $FILE = $FILE & ".exe"
	If StringRegExp ( $FILE , "(?i)rundll32|regsvr32" ) Then
		If Not StringRegExp ( $FILE , "(?i).*\.exe .* rundll32" ) Then
			$FILE = StringRegExpReplace ( $FILE , "(?i).*((rundll32|regsvr32).+)" , "$1" )
			$FILE = StringRegExpReplace ( $FILE , "(?i)(rundll32|regsvr32)(\.exe|).* (\w+\.dll).*" , "$3" )
			If StringInStr ( $FILE , "\" ) Then
				$FILE = StringRegExpReplace ( $FILE , "(?i)(rundll32|regsvr32)(\.exe|) .*?((%|.:\\).+\.dll).*" , "$3" )
			EndIf
		EndIf
	EndIf
	Select
	Case StringRegExp ( $FILE , "(?i)\ASysWow64" )
		$FILE = StringRegExpReplace ( $FILE , "(?i)\ASysWow64" , $C & "\\Windows\\SysWow64" )
	Case StringRegExp ( $FILE , "(?i)%+systemroot%+" )
		If $BOOTM = "Recovery" Then
			$FILE = StringRegExpReplace ( $FILE , "(?i)%+systemroot%+" , $C & "\\Windows" )
		Else
			$FILE = StringRegExpReplace ( $FILE , "(?i)%+systemroot%+" , $WINDIR )
		EndIf
	Case StringRegExp ( $FILE , "(?i)\Asystemroot" )
		$FILE = StringRegExpReplace ( $FILE , "(?i)systemroot" , $C & "\\Windows" )
	Case StringRegExp ( $FILE , "(?i)\Asystem32" )
		$FILE = StringRegExpReplace ( $FILE , "(?i)\Asystem32" , $C & "\\Windows\\System32" )
	Case StringRegExp ( $FILE , "(?i).*%+ALLUSERSPROFILE%+" ) And $BOOTM = "Recovery"
		$FILE = StringRegExpReplace ( $FILE , "(?i).*%+ALLUSERSPROFILE%+" , $C & "\\ProgramData" )
	Case Not StringInStr ( $FILE , "\" )
		FILENAMEONLY86 ( $FILE , $WORKD )
	Case StringRegExp ( $FILE , "%[^\\]+?%" )
		$ENVAR1 = StringRegExpReplace ( $FILE , ".*%([^\\]+?)%.*" , "$1" )
		$ENVAR = EnvGet ( $ENVAR1 & "(x86)" )
		If $ENVAR Then
			$ENVAR = StringRegExpReplace ( $ENVAR , "\\" , "\\\\" )
			$FILE = StringRegExpReplace ( $FILE , "^%[^\\]+?%" , $ENVAR )
		Else
			$FILE = _EXPAND ( $FILE )
		EndIf
	EndSelect
	If _ARG ( ) <> 2 Then
		If Not FileExists ( $FILE ) Then
			$FILE = StringRegExpReplace ( $FILE , "(?i).*([C-Z]:\\.+\.exe).*" , "$1" )
			$FILE = StringRegExpReplace ( $FILE , "(?i).*([C-Z]:\\.+\.\w{3,4}).*" , "$1" )
			$FILE = StringRegExpReplace ( $FILE , "(?i).*[C-Z]:.+\.exe.*([C-Z]:\\.+\.\w{3}).*" , "$1" )
		EndIf
	Else
		$FILE = StringRegExpReplace ( $FILE , "(?i).:\\Windows\\.+?\\WindowsPowerShell\\.+?powershell.exe" , "powershell.exe" )
	EndIf
	$FILE = StringRegExpReplace ( $FILE , "(?i)\\system32\\" , "\\SysWOW64\\" )
	If $BOOTM = "Recovery" Then StringRegExpReplace ( $FILE , "(?i)[C-Z]:" , $C )
	If Not FileExists ( $FILE ) Then
		If StringRegExp ( $FILE , "(?i).:\\Windows" ) And Not StringRegExp ( $FILE , "(?i)SysWOW64" ) Then $FILE = StringRegExpReplace ( $FILE , "(?i)\\Windows\\" , "\\Windows\\SysWOW64\\" )
	EndIf
	If FileExists ( StringRegExpReplace ( $FILE , "(?i)\\system32\\" , "\\SysWOW64\\" ) ) Then $FILE = StringRegExpReplace ( $FILE , "(?i)\\system32\\" , "\\SysWOW64\\" )
	If FileExists ( $FILE ) Then COMP ( )
EndFunc
Func AAAAH ( )
	Local $ADMIN , $OLD
	GUICtrlSetData ( $LABEL1 , $SCAN1 & " " & $PW0 )
	$FRSTLOG = FileOpen ( @ScriptDir & "\FRST.txt" , 256 + 2 )
	If $BOOTM = "Recovery" Then
		If FileExists ( $C & "\Users" ) Then
			GETFILELIST2 ( $C & "\Users" )
		Else
			GETFILELIST2 ( $C & "\Documents and Settings" )
		EndIf
	Else
		$FOLDER = _WINAPI_GETPROFILESDIRECTORY ( )
		GETFILELIST2 ( $FOLDER )
	EndIf
	Local $ERROR
	$D = StringRegExpReplace ( $VERSION , " \(x64\) Version: (\d\d)-.+" , "$1" )
	$M = StringRegExpReplace ( $VERSION , " \(x64\) Version: ..-(\d\d)-.+" , "$1" )
	$Y = StringRegExpReplace ( $VERSION , " \(x64\) Version: ..-..-(\d\d\d\d).*" , "$1" )
	$V = _DATEDIFF ( "d" , $Y & "/" & $M & "/" & $D , _NOWCALCDATE ( ) )
	If $V > 90 Then $OLD = " ([color=red]" & $UPD1 & ": ====> FRST " & $SCAN2 & " " & $V & " " & $SCAN3 & "[/color])"
	$CDATE = DATE ( )
	If $BOOTM <> "Recovery" Then
		If IsAdmin ( ) Then
			$ADMIN = " (" & $ADMINIS & ")"
		Else
			$ADMIN = " (" & $UPD1 & ": " & $SCAN4 & ")"
		EndIf
	Else
		$ADMIN = ""
	EndIf
	$DEFBROWSER = ""
	If $BOOTM <> "Recovery" Then
		$VAL1 = RegRead ( "HKCU\Software\Microsoft\Windows\Shell\Associations\UrlAssociations\http\UserChoice" , "Progid" )
		If Not @error Then
			$VAL = RegRead ( "HKCR\" & $VAL1 & "\shell\open\command" , "" )
		Else
			$VAL = RegRead ( "HKCR\http\shell\open\command" , "" )
		EndIf
		If $VAL <> "" Then
			Select
			Case StringInStr ( $VAL , "Mozilla Firefox\firefox.exe" )
				$DEFBROWSER = $SCAN5 & ": FF"
			Case StringInStr ( $VAL , "internet explorer\iexplore.exe" )
				$DEFBROWSER = $SCAN5 & ": IE"
			Case StringInStr ( $VAL , "Google\Chrome\Application\chrome.exe" )
				$DEFBROWSER = $SCAN5 & ": Chrome"
			Case StringInStr ( $VAL , "launcher.exe" )
				$DEFBROWSER = $SCAN5 & ": Opera"
			Case StringInStr ( $VAL , "\BraveSoftware\Brave-Browser\Application\brave.exe" )
				$DEFBROWSER = $SCAN5 & ": Brave"
			Case StringInStr ( $VAL , "\Vivaldi\Application\vivaldi.exe" )
				$DEFBROWSER = $SCAN5 & ": Vivaldi"
			Case StringInStr ( $VAL , "YandexBrowser\Application\browser.exe" )
				$DEFBROWSER = $SCAN5 & ": Yandex Browser"
			Case StringRegExp ( $VAL , "(?i)(LaunchWinApp|Microsoft\\Edge\\Application\\msedge).exe" )
				$DEFBROWSER = $SCAN5 & ": Edge"
		Case Else
				$DEFBROWSER = $SCAN5 & ": " & $VAL
			EndSelect
		Else
			$DEFBROWSER = $SCAN5 & " " & $SCAN7 & "!"
		EndIf
	EndIf
	$IEVERSION = ""
	If $DEFBROWSER Then $IEVERSION = $DEFBROWSER & @CRLF
	If @OSServicePack <> "" Then
		$OSSP = @OSServicePack & " "
	Else
		$OSSP = RegRead ( "hklm\" & $SOFTWARE & "\Microsoft\Windows NT\CurrentVersion" , "CSDVersion" )
		If Not @error Then $OSSP = $OSSP & " "
	EndIf
	$UPDATE = OSUPDATE ( )
	$LANG = LANG ( )
	$PROFS = ""
	$MAKEMODEL = ""
	If $BOOTM <> "Recovery" Then
		$ATTEN = ""
		If Not LOGGEDU ( ) Or StringRegExpReplace ( @UserProfileDir , ".+\\(.+)" , "$1" ) = "TEMP" Then $ATTEN = " <==== " & $UPD1 & " (" & $SCAN8 & "?)"
		$PROFS = $SCAN9 & ": " & LOGGEDU ( ) & $ATTEN & @CRLF
		$SYSMAN = RegRead ( "HKLM\HARDWARE\DESCRIPTION\System\BIOS" , "SystemManufacturer" )
		$SYSPRO = RegRead ( "HKLM\HARDWARE\DESCRIPTION\System\BIOS" , "SystemProductName" )
		Select
		Case $SYSMAN And Not StringRegExp ( $SYSMAN , "(?i)System manufacturer|To Be Filled By" ) And Not StringRegExp ( $SYSPRO , "(?i)To Be Filled By" )
			$MAKEMODEL = " (" & $SYSMAN & " " & $SYSPRO & ")"
		Case Not $SYSMAN Or StringRegExp ( $SYSMAN , "(?i)System manufacturer|To Be Filled By" ) Or StringRegExp ( $SYSPRO , "(?i)To Be Filled By" )
			$SYSMAN = AAAAHAA ( )
			If StringRegExp ( $SYSMAN , "\w" ) And Not StringRegExp ( $SYSMAN , "(?i)System manufacturer|To Be Filled By" ) Then $MAKEMODEL = " (" & $SYSMAN & ")"
		EndSelect
	EndIf
	FileWrite ( $FRSTLOG , $SCAN10 & " Farbar Recovery Scan Tool (FRST)" & $VERSION & $OLD & @CRLF & $SCAN11 & " " & @UserName & $ADMIN & " " & $ON & " " & @ComputerName & $MAKEMODEL & " (" & $CDATE & ")" & @CRLF & $SCAN13 & " " & @ScriptDir & "\" & @ScriptName & @CRLF & $PROFS & $PLATF & ": " & $SVERSION & " " & $OSSP & $UPDATE & "(" & @OSArch & ") " & $SCAN14 & ": " & $LANG & @CRLF & $IEVERSION & $SCAN15 & ": " & $BOOTM & @CRLF )
	If $BOOTM = "Recovery" And $DEF1 > 0 Then FileWrite ( $FRSTLOG , $DEFA & ": ControlSet0" & $DEF & @CRLF & "[b]" & $UPD1 & "!:=====> " & $SCAN16 & "[/b]" & @CRLF & @CRLF )
	If $BOOTM = "Recovery" And $DEF1 = "" Then
		FileWrite ( $FRSTLOG , $UPD1 & ": " & $SCAN17 & @CRLF )
		RunWait ( @ComSpec & " /c reg load hklm\999 c:\Windows\System32\config\System > c:\frst\debug 2>&1" , "" , @SW_HIDE )
		$HREAD = FileOpen ( $C & "\frst\debug" , 256 )
		$ERROR = FileRead ( $HREAD )
		FileClose ( $HREAD )
		FileWrite ( $FRSTLOG , $ERROR )
		FileDelete ( $C & "\frst\debug" )
	EndIf
	If $BOOTM = "Recovery" And Not FileExists ( $C & "\windows\system32\config\system" ) Then FileWrite ( $FRSTLOG , "" & $UPD1 & ": " & $SCAN18 & @CRLF & @CRLF )
	If $BOOTM = "Recovery" Then
		RegRead ( "HKLM\" & $SYSTEM & $BOOTSYSTEM & $DEF & "\Control\Session Manager\KnownDLLs" , "DllDirectory" )
		If Not @error Then
			RegRead ( "HKLM\" & $SYSTEM & $BOOTSYSTEM & $DEF & "\Control\Session Manager\KnownDLLs" , "DllDirectory32" )
			If @error And @OSArch = "X64" And $BOOTM = "Recovery" Then FileWrite ( $FRSTLOG , @CRLF & $UPD1 & "!:=====> " & $SCAN64 & @CRLF )
		EndIf
	EndIf
EndFunc
Func AAAAHA ( )
	Local $INSDATE
	If @OSServicePack <> "" Then
		$OSSP = @OSServicePack & " "
	Else
		$OSSP = RegRead ( "hklm\" & $SOFTWARE & "\Microsoft\Windows NT\CurrentVersion" , "CSDVersion" )
		If Not @error Then $OSSP = $OSSP & " "
	EndIf
	$UPDATE = OSUPDATE ( )
	$RET = RegRead ( "HKLM\SOFTWARE\MICROSOFT\WINDOWS NT\CURRENTVERSION" , "InstallDate" )
	If Not @error And $RET Then $INSDATE = " (" & _DATEADD ( "s" , $RET , "1970/01/01 00:00:00" ) & ")"
	$INSDATE = StringRegExpReplace ( $INSDATE , "/" , "-" )
	$CDATE = DATE ( )
	FileWrite ( $HADDITION , $ADD1 & " Farbar Recovery Scan Tool" & $VERSION & @CRLF & $SCAN11 & " " & "" & @UserName & " (" & $CDATE & ")" & @CRLF & $SCAN13 & " " & @ScriptDir & @CRLF & $SVERSION & " " & $OSSP & $UPDATE & "(" & @OSArch & ")" & $INSDATE & @CRLF & $SCAN15 & ": " & $BOOTM & @CRLF & "==========================================================" & @CRLF & @CRLF )
EndFunc
Func LANG ( )
	$LANOS = _WINAPI_GETLOCALEINFO ( Dec ( @OSLang ) , 2 )
	If Not $LANOS Then $LANOS = @OSLang
	If @OSLang = @MUILang Then Return $LANOS
	Return $LANOS & " -> " & _WINAPI_GETLOCALEINFO ( Dec ( @MUILang ) , 2 )
EndFunc
Func AAAAHAA ( )
	$OUTPUT = ""
	$OBJWMISERVICE = ObjGet ( "winmgmts:{impersonationLevel=impersonate}!\\.\root\cimv2" )
	If Not IsObj ( $OBJWMISERVICE ) Then Return
	$COLITEMS = $OBJWMISERVICE .ExecQuery ( "SELECT * FROM Win32_ComputerSystem" , "WQL" , 16 + 32 )
	If IsObj ( $COLITEMS ) Then
		For $OBJITEM In $COLITEMS
			$OUTPUT = $OBJITEM .Manufacturer & " " & $OBJITEM .Model
		Next
	EndIf
	Return $OUTPUT
EndFunc
Func AAAAHKU ( $USER )
	HKURUN ( $USER , "Run" )
	HKURUN ( $USER , "RunOnce" )
	Local $ARRAYNAME , $ARRAYDATA
	GUICtrlSetData ( $LABEL1 , $SCANB & " " & $REGB & ": HKU\" & $USER & "\Software\Microsoft\Windows\CurrentVersion\Policie\Explorer\Run" )
	$MKEY = "HKU\" & $USER & "\Software\Microsoft\Windows\CurrentVersion\Policies\"
	$FULLKEY = "HKU\" & $USER & "\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run"
	$HKEY = _REGOPENKEYEX3 ( $FULLKEY )
	If Not @error And IsPtr ( $HKEY ) Then
		$ARRAYNAME = _LISTVAL ( $HKEY )
		For $I = 0 To UBound ( $ARRAYNAME ) + 4294967295
			$ATTEN = ""
			$COMPANY = ""
			$SIZE = ""
			$CDATE = ""
			$VALNAME = $ARRAYNAME [ $I ] [ 0 ]
			$FILE = $ARRAYNAME [ $I ] [ 1 ]
			Select
			Case StringInStr ( $VALNAME , "<*>" )
				$LRCHAR = " **"
				$LRCHAR = StringRegExp ( $LRCHAR , "\*(.)\*" , 3 )
				If IsArray ( $LRCHAR ) Then $LRCHAR = $LRCHAR [ 0 ]
				$FILE = StringRegExpReplace ( $FILE , $LRCHAR , "" )
				$ATTEN = " <==== " & $UPD1 & " (" & $REGIST4 & ")"
		Case Else
				If Not StringRegExp ( $ARRAYNAME [ $I ] [ 1 ] , "(?i)\bmsiexec\b" ) Then AAAAFP ( )
			EndSelect
			Select
			Case StringInStr ( $FILE , $VALNAME ) And StringRegExp ( $FILE , "(?i)\\AppData" ) And StringRegExp ( $FILE , "(?i)(REGSVR32|rundll32|wscript)" )
				$ATTEN = " <==== " & $UPD1
			Case StringInStr ( $FILE , "\Temp\" ) And Not StringInStr ( $FILE , "\spool\" )
				$ATTEN = " <==== " & $UPD1
			Case StringRegExp ( $VALNAME , "(?i)^InetHelper$" )
				$ATTEN = " <==== " & $UPD1
			Case StringRegExp ( $FILE , "(?i)\\AppData\\Local\\\w+\\" & $VALNAME & "\.exe" )
				$ATTEN = " <==== " & $UPD1
			EndSelect
			If FileExists ( $FILE ) Then
				If StringRegExp ( $FILE , "\\\w{6}~\d\\" ) Then $FILE = FileGetLongName ( $FILE )
				_ARRAYADD ( $ARRAYREG , "HKU\" & $USER & "\...\Policies\Explorer\Run: [" & $VALNAME & "] => " & $FILE & " [" & $SIZE & " " & $CDATE & "]" & $COMPANY & $ATTEN , 0 , "||||" )
			Else
				If _CREATEFILE ( $FILE ) Then $ATTEN = " (" & $NOACC & ") <==== " & $UPD1
				_ARRAYADD ( $ARRAYREG , "HKU\" & $USER & "\...\Policies\Explorer\Run: [" & $VALNAME & "] => " & $FILE & $ATTEN , 0 , "||||" )
			EndIf
		Next
	EndIf
	$KEY = $MKEY & "system"
	GUICtrlSetData ( $LABEL1 , $SCANB & " " & $REGB & ": " & $KEY )
	$HKEY = _REGOPENKEYEX3 ( $KEY , 1 )
	If Not @error And IsPtr ( $HKEY ) Then
		$ARRAYNAME = _LISTVAL ( $HKEY )
		For $V = 0 To UBound ( $ARRAYNAME ) + 4294967295
			$ATTEN = ""
			$VALNAME = $ARRAYNAME [ $V ] [ 0 ]
			$VALDATA = $ARRAYNAME [ $V ] [ 1 ]
			If $VALNAME = "shell" Then $ATTEN = " <==== " & $UPD1
			_ARRAYADD ( $ARRAYREG , "HKU\" & $USER & "\...\Policies\system: [" & $VALNAME & "] " & $VALDATA & $ATTEN , 0 , "||||" )
		Next
	EndIf
	$KEY = $MKEY & "Explorer"
	$HKEY = _REGOPENKEYEX3 ( $KEY , 1 )
	If Not @error And IsPtr ( $HKEY ) Then
		$ARRAYNAME = _LISTVAL ( $HKEY )
		For $V = 0 To UBound ( $ARRAYNAME ) + 4294967295
			$ATTEN = ""
			$VALNAME = $ARRAYNAME [ $V ] [ 0 ]
			$VALDATA = $ARRAYNAME [ $V ] [ 1 ]
			If $VALNAME = "NoDesktop" And $VALDATA = 1 Then $ATTEN = " <==== " & $UPD1
			_ARRAYADD ( $ARRAYREG , "HKU\" & $USER & "\...\Policies\Explorer: [" & $VALNAME & "] " & $VALDATA & $ATTEN , 0 , "||||" )
		Next
	EndIf
	$VALDATA = RegRead ( $KEY , "DisallowRun" )
	If @error = 0 And $VALDATA = 1 Then
		$HKEY = _REGOPENKEYEX3 ( $MKEY & "Explorer\DisallowRun" , 1 , $KEY_ALL_ACCESS )
		If Not @error And IsPtr ( $HKEY ) Then
			$ARRAYNAME = _LISTVAL ( $HKEY )
			For $V = 0 To UBound ( $ARRAYNAME ) + 4294967295
				$VALNAME = $ARRAYNAME [ $V ] [ 0 ]
				$VALDATA = $ARRAYNAME [ $V ] [ 1 ]
				$DELFRST = ""
				If StringInStr ( $VALDATA , "frst" ) Then
					$RET = DllCall ( "advapi32.dll" , "long" , "RegDeleteValueW" , "handle" , $HKEY , "wstr" , $VALNAME )
					If Not $RET [ 0 ] Then $DELFRST = " => " & $DELETED
				EndIf
				_ARRAYADD ( $ARRAYREG , "HKU\" & $USER & "\...\Policies\Explorer\DisallowRun: [" & $VALNAME & "] " & $VALDATA & $DELFRST , 0 , "||||" )
			Next
		EndIf
	EndIf
	$KEY = "HKU\" & $USER & "\Software\Policies\Microsoft\Windows\System"
	$HKEY = _REGOPENKEYEX3 ( $KEY , 1 )
	If Not @error And IsPtr ( $HKEY ) Then
		$ARRAYNAME = _LISTVAL ( $HKEY )
		For $V = 0 To UBound ( $ARRAYNAME ) + 4294967295
			$ATTEN = ""
			$VALNAME = $ARRAYNAME [ $V ] [ 0 ]
			$VALDATA = $ARRAYNAME [ $V ] [ 1 ]
			_ARRAYADD ( $ARRAYREG , "HKU\" & $USER & "\Software\Policies\...\system: [" & $VALNAME & "] " & $VALDATA & $ATTEN , 0 , "||||" )
		Next
	EndIf
	$KEY = "HKU\" & $USER & "\Software\Microsoft\Windows NT\CurrentVersion\Windows"
	GUICtrlSetData ( $LABEL1 , $SCANB & " " & $REGB & ": " & $KEY )
	$HKEY = _REGOPENKEYEX3 ( $KEY , 1 )
	If Not @error And IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
	$VALDATA = RegRead ( $KEY , "Load" )
	If @error = 0 And $VALDATA <> "" Then _ARRAYADD ( $ARRAYREG , "HKU\" & $USER & "\...\CurrentVersion\Windows: [Load] " & $VALDATA & " <==== " & $UPD1 , 0 , "||||" )
	$VALDATA = RegRead ( $KEY , "Run" )
	If @error = 0 And $VALDATA <> "" Then _ARRAYADD ( $ARRAYREG , "HKU\" & $USER & "\...\CurrentVersion\Windows: [Run] " & $VALDATA & " <==== " & $UPD1 , 0 , "||||" )
	If $BOOTM <> "Recovery" Then
		$KEY = "HKU\" & $USER & "\Software\Microsoft\Windows\CurrentVersion\Explorer\MountPoints2"
		GUICtrlSetData ( $LABEL1 , $SCANB & " " & $REGB & ": " & $KEY )
		$HKEY = _REGOPENKEYEX3 ( $KEY , 1 )
		If Not @error And IsPtr ( $HKEY ) Then
			$M = 0
			While 1
				$MP = __REGENUMKEY ( $HKEY , $M )
				If @error Then ExitLoop
				$VALDATA = RegRead ( $KEY & "\" & $MP & "\Shell\AutoRun\command" , "" )
				If Not @error Then _ARRAYADD ( $ARRAYREG , "HKU\" & $USER & "\...\MountPoints2: " & $MP & " - " & $VALDATA , 0 , "||||" )
				$M += 1
			WEnd
		EndIf
	EndIf
	GUICtrlSetData ( $LABEL1 , $SCANB & " " & $REGB & ": HKU\" & $USER & "\Software\Microsoft\Windows NT\CurrentVersion\Winlogon" )
	$VALDATA = RegRead ( "HKU\" & $USER & "\Software\Microsoft\Windows NT\CurrentVersion\Winlogon" , "Userinit" )
	If @error = 0 Then
		If StringRegExp ( $VALDATA , "(?i)^(userinit.exe|" & $C & "\\Windows\\system32\\userinit.exe),?$" ) Then
			$FILE = $C & "\Windows\system32\userinit.exe"
		Else
			$FILE = StringRegExpReplace ( $VALDATA , ".*[C-Z]:(\\.+\..{3}).*" , $C & "$1" )
			If $FILE = "" Then $FILE = $VALDATA
		EndIf
		AAAAFP ( )
		If FileExists ( $FILE ) Then
			_ARRAYADD ( $ARRAYREG , "HKU\" & $USER & "\...\Winlogon: [Userinit] " & $FILE & " [" & $SIZE & " " & $CDATE & "]" & $COMPANY , 0 , "||||" )
		Else
			_ARRAYADD ( $ARRAYREG , "HKU\" & $USER & "\...\Winlogon: [Userinit] " & $VALDATA , 0 , "||||" )
		EndIf
	EndIf
	$VALDATA = RegRead ( "HKU\" & $USER & "\Software\Microsoft\Windows NT\CurrentVersion\Winlogon" , "Shell" )
	If @error = 0 Then
		$FILE = $VALDATA
		If $VALDATA <> "" Then
			$ATTEN = " <==== " & $UPD1
		Else
			$ATTEN = ""
		EndIf
		AAAAFP ( )
		If FileExists ( $FILE ) Then
			_ARRAYADD ( $ARRAYREG , "HKU\" & $USER & "\...\Winlogon: [Shell] " & $FILE & " [" & $SIZE & " " & $CDATE & "]" & $COMPANY & $ATTEN , 0 , "||||" )
		Else
			_ARRAYADD ( $ARRAYREG , "HKU\" & $USER & "\...\Winlogon: [Shell] " & $VALDATA & $ATTEN , 0 , "||||" )
		EndIf
	EndIf
	$VALDATA = RegRead ( "HKU\" & $USER & "\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.exe" , "" )
	If $VALDATA <> "" Then _ARRAYADD ( $ARRAYREG , "HKU\" & $USER & "\...\FileExts\.exe: " & $VALDATA & " <==== " & $UPD1 , 0 , "||||" )
	$VALDATA = RegRead ( "HKU\" & $USER & "\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.exe\\OpenWithProgids" , "exefile" )
	If $VALDATA <> "" Then _ARRAYADD ( $ARRAYREG , "HKU\" & $USER & "\...\FileExts\.exe\OpenWithProgids: " & "[exefile] " & $VALDATA & " <==== " & $UPD1 , 0 , "||||" )
	$VALDATA = RegRead ( "HKU\" & $USER & "\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.exe\\OpenWithProgids" , "secfile" )
	If $VALDATA <> "" Then _ARRAYADD ( $ARRAYREG , "HKU\" & $USER & "\...\FileExts\.exe\OpenWithProgids: " & "[secfile] " & $VALDATA & " <==== " & $UPD1 , 0 , "||||" )
	$KEY = "HKU\" & $USER & "\Software\Microsoft\Command Processor"
	RegRead ( $KEY , "" )
	If @error = 1 Then _SETREGACE ( $KEY , 1 )
	$RUN1 = RegRead ( $KEY , "AutoRun" )
	If $RUN1 <> "" Then
		$FILE = $RUN1
		AAAAFP ( )
		If FileExists ( $FILE ) Then
			_ARRAYADD ( $ARRAYREG , "HKU\" & $USER & "\...\Command Processor: " & $FILE & " [" & $SIZE & " " & $CDATE & "]" & $COMPANY & " <==== " & $UPD1 , 0 , "||||" )
		Else
			_ARRAYADD ( $ARRAYREG , "HKU\" & $USER & "\...\Command Processor: " & $RUN1 & " <==== " & $UPD1 , 0 , "||||" )
		EndIf
	EndIf
	$KEY = "HKU\" & $USER & "\Control Panel\Desktop"
	$VALDATA = RegRead ( $KEY , "SCRNSAVE.EXE" )
	If Not @error Then
		$FILE = $VALDATA
		$ATTEN = ""
		AAAAFP ( )
		If FileExists ( $FILE ) Then
			_ARRAYADD ( $ARRAYREG , $KEY & "\\SCRNSAVE.EXE -> " & $FILE & " [" & $SIZE & " " & $CDATE & "]" & $COMPANY & $ATTEN , 0 , "||||" )
		Else
			_ARRAYADD ( $ARRAYREG , $KEY & "\\SCRNSAVE.EXE -> " & $FILE & $ATTEN , 0 , "||||" )
		EndIf
	EndIf
	$HKEY = _REGOPENKEYEX3 ( "HKU\" & $USER & "\Environment" )
	If Not @error And IsPtr ( $HKEY ) Then
		$ARRAYNAME = _LISTVAL ( $HKEY )
		For $V = 0 To UBound ( $ARRAYNAME ) + 4294967295
			$ATTEN = ""
			If StringInStr ( $ARRAYNAME [ $V ] [ 1 ] , "powershell.exe" ) Then
				$ATTEN = " <==== " & $UPD1
				_ARRAYADD ( $ARRAYREG , "HKU\" & $USER & "\Environment: [" & $ARRAYNAME [ $V ] [ 0 ] & "] " & $ARRAYNAME [ $V ] [ 1 ] & $ATTEN , 0 , "||||" )
				If VAR ( "HKU\" & $USER & "\Software\" & $ARRAYNAME [ $V ] [ 0 ] , 1 ) Then _ARRAYADD ( $ARRAYREG , "RegKey: [HKU\" & $USER & "\Software\" & $ARRAYNAME [ $V ] [ 0 ] & "]" & $ATTEN )
				If VAR ( "HKU\" & $USER & "\Software\" & $ARRAYNAME [ $V ] [ 0 ] & "1" , 1 ) Then _ARRAYADD ( $ARRAYREG , "RegKey: [HKU\" & $USER & "\Software\" & $ARRAYNAME [ $V ] [ 0 ] & "1]" & $ATTEN )
			EndIf
		Next
	EndIf
	ENVHIJ ( "HKU\" & $USER & "\Environment" , 1 )
	If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
EndFunc
Func ENVHIJ ( $KEY , $AD = 0 )
	$HKEY = _REGOPENKEYEX3 ( $KEY , 1 )
	If Not @error And IsPtr ( $HKEY ) Then
		$ARRAYNAME = _LISTVAL ( $HKEY )
		For $V = 0 To UBound ( $ARRAYNAME ) + 4294967295
			If StringRegExp ( $ARRAYNAME [ $V ] [ 1 ] , "\bcmd\b.+\b\.(exe|dll|sys)\b" ) Then
				If $AD Then
					_ARRAYADD ( $ARRAYREG , $KEY & ": [" & $ARRAYNAME [ $V ] [ 0 ] & "] " & $ARRAYNAME [ $V ] [ 1 ] & " <==== " & $UPD1 , 0 , "||||" )
				Else
					FileWrite ( $HADDITION , $KEY & ": [" & $ARRAYNAME [ $V ] [ 0 ] & "] " & $ARRAYNAME [ $V ] [ 1 ] & " <==== " & $UPD1 & @CRLF )
				EndIf
			EndIf
		Next
	EndIf
	If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
EndFunc
Func CLEAREVENTS ( )
	GUICtrlSetData ( $LABEL1 , "EmptyEventLogs" )
	FileWrite ( $HFIXLOG , @CRLF & "=========== EmptyEventLogs: ==========" & @CRLF )
	$ARG = "'wevtutil.exe el'"
	$READ = CMDRUN ( "for /F ""tokens=*"" %i in (" & $ARG & ") DO wevtutil.exe cl ""%i""" )
	$NR = StringRegExp ( $READ , "\.\bexe\b cl " , 3 )
	$READ = StringRegExpReplace ( $READ , "(?im).:\\.+\.\bexe\b cl .+" , "" )
	$READ = StringRegExpReplace ( $READ , "\R+" , @CRLF )
	FileWrite ( $HFIXLOG , @CRLF & UBound ( $NR ) & " Event logs cleared. " & @CRLF & $READ & @CRLF & "================================" & @CRLF )
EndFunc
Func AAAAR ( )
	Local $VALDATA , $VALDATA2 , $VALNAME
	GUICtrlSetData ( $LABEL1 , $REGIST1 & ": " )
	If $BOOTM = "Recovery" Then
		If Not FileExists ( $C & "\windows\system32\config\software" ) Then Return _ARRAYADD ( $ARRAYREG , $UPD1 & ": " & $REGIST2 )
		If Not VAR ( "HKLM\888" ) Then Return _ARRAYADD ( $ARRAYREG , $UPD1 & ": " & $REGIST3 )
	EndIf
	RUNKEY ( "Run" )
	RUNKEY ( "Run" , 1 )
	RUNKEY ( "RunOnce" )
	RUNKEY ( "RunOnce" , 1 )
	RUNKEYEX ( )
	RUNKEY ( "RunServices" )
	RUNKEY ( "RunServicesOnce" )
	RUNKEYEX ( "1" )
	HKLM ( )
	POLICIESRUN ( "HKLM\" )
	POLICIES ( "HKLM\" )
	AAAAPOL0 ( "HKLM\SOFTWARE\Policies\Microsoft\Windows Defender" )
	AAAAPOL0 ( "HKLM\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate" )
	AAAAPOL0 ( "HKLM\SOFTWARE\Policies\Microsoft\MRT" )
	AAAAPOL0 ( "HKLM\SOFTWARE\Policies\Microsoft\Windows Defender Security Center" )
	AAAAPOL0 ( "HKLM\SOFTWARE\Policies\Microsoft\WindowsFirewall" )
	POL1 ( "legalnoticecaption" )
	POL1 ( "legalnoticetext" )
	$KEY = "HKLM\" & $SOFTWARE & "\Policies\Microsoft\Windows\System"
	$HKEY = _REGOPENKEYEX3 ( $KEY , 1 )
	If Not @error And IsPtr ( $HKEY ) Then
		$ARRAYNAME = _LISTVAL ( $HKEY )
		For $V = 0 To UBound ( $ARRAYNAME ) + 4294967295
			$ATTEN = ""
			$VALNAME = $ARRAYNAME [ $V ] [ 0 ]
			$VALDATA = $ARRAYNAME [ $V ] [ 1 ]
			_ARRAYADD ( $ARRAYREG , "HKLM\Software\Policies\...\system: [" & $VALNAME & "] " & $VALDATA & $ATTEN , 0 , "||||" )
		Next
		If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
	EndIf
	For $U = 1 To UBound ( $USERREG ) + 4294967295
		CERTDISALLOW ( "HKU\" & $USERREG [ $U ] & "\" )
		CERTDISALLOW ( "HKU\" & $USERREG [ $U ] & "\" , "\Policies" )
	Next
	$KEY = "HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server"
	$HKEY = _REGOPENKEYEX3 ( $KEY , 1 )
	If Not @error And IsPtr ( $HKEY ) Then
		$VDATA = RegRead ( $KEY , "fDenyTSConnections" )
		If RegRead ( $KEY , "fDenyTSConnections" ) <> 1 Then
			_ARRAYADD ( $ARRAYREG , "HKLM\SYSTEM\...\Terminal Server: [fDenyTSConnections] = " & $VDATA & " <==== " & $UPD1 , 0 , "||||" )
		EndIf
		_REGCLOSE ( $HKEY )
	EndIf
	COMMANDPROC ( "HKLM\" )
	HKU ( )
	PROVIDER ( )
	PRINTPROC ( )
	PRINTMON ( )
	SHIM ( "Custom" )
	SHIM ( "InstalledSDB" )
	SHIM ( "Custom" , 1 )
	SHIM ( "InstalledSDB" , 1 )
	SHIMU ( "Custom" )
	SHIMU ( "InstalledSDB" )
	$KEY = "HKLM\System\CurrentControlSet\Control\Session Manager\Environment"
	_ENV1 ( $KEY , "COR_PROFILER" )
	_ENV1 ( $KEY , "COR_PROFILER_PATH" )
	For $U = 1 To UBound ( $USERREG ) + 4294967295
		_ENV1 ( "HKU\" & $USERREG [ $U ] & "\Environment" , "COR_PROFILER" )
		_ENV1 ( "HKU\" & $USERREG [ $U ] & "\Environment" , "COR_PROFILER_PATH" )
	Next
	ACTIVESETUP ( )
	ACTIVESETUP ( 1 )
	AUTHENTICS ( "Credential Providers" )
	AUTHENTICS ( "Credential Provider Filters" )
	AUTHENTICS ( "PLAP Providers" )
	GPEXTENSIONS ( )
	USERINITMPR ( "HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\Environment" )
	For $V = 0 To UBound ( $USERREG ) + 4294967295
		USERINITMPR ( "HKU\" & $USERREG [ $V ] & "\Environment" )
	Next
	$KEY = "HKLM\" & $SOFTWARE & "\Microsoft\Windows NT\CurrentVersion\Windows"
	GUICtrlSetData ( $LABEL1 , $KEY )
	$VALDATA = RegRead ( $KEY , "AppInit_DLLs" )
	If @error = 0 Then
		$VALDATA = StringRegExpReplace ( $VALDATA , "\s{2,}" , " " )
		$VALDATA = StringRegExpReplace ( $VALDATA , "(^[ ]+|[ ]+$)" , "" )
		If $VALDATA <> "" Then
			$VALDATA = StringRegExpReplace ( $VALDATA , "(?i)(\.dll)" , "$1|" )
			$ARRAY = StringSplit ( $VALDATA , "|" , 1 )
			For $I = 1 To UBound ( $ARRAY ) + 4294967295
				If $ARRAY [ $I ] <> " " And $ARRAY [ $I ] <> "" Then
					$DATA = $ARRAY [ $I ]
					If StringLeft ( $ARRAY [ $I ] , 1 ) = " " Then $ARRAY [ $I ] = StringTrimLeft ( $ARRAY [ $I ] , 1 )
					If StringLeft ( $ARRAY [ $I ] , 1 ) = "," Then $ARRAY [ $I ] = StringTrimLeft ( $ARRAY [ $I ] , 1 )
					$FILE = $ARRAY [ $I ]
					AAAAFP ( )
					If FileExists ( $FILE ) Then
						$FILE = $FILE & " [" & $SIZE & " " & $CDATE & "]" & $COMPANY
					Else
						$FILE = $REGIST8
					EndIf
					_ARRAYADD ( $ARRAYREG , "AppInit_DLLs: " & $DATA & " => " & $FILE , 0 , "||||" )
				EndIf
			Next
		EndIf
	EndIf
	$VALDATA = RegRead ( "HKLM\" & $SOFTWARE & "\Wow6432Node\Microsoft\Windows NT\CurrentVersion\Windows" , "AppInit_DLLs" )
	If @error = 0 Then
		$VALDATA = StringRegExpReplace ( $VALDATA , "\s{2,}" , " " )
		$VALDATA = StringRegExpReplace ( $VALDATA , "(^[ ]+|[ ]+$)" , "" )
		If $VALDATA <> "" Then
			$VALDATA = StringRegExpReplace ( $VALDATA , "(?i)(\.dll)" , "$1|" )
			$ARRAY = StringSplit ( $VALDATA , "|" , 1 )
			For $I = 1 To UBound ( $ARRAY ) + 4294967295
				If $ARRAY [ $I ] <> " " And $ARRAY [ $I ] <> "" Then
					$ATTEN = ""
					$DATA = $ARRAY [ $I ]
					If StringLeft ( $ARRAY [ $I ] , 1 ) = " " Then $ARRAY [ $I ] = StringTrimLeft ( $ARRAY [ $I ] , 1 )
					If StringLeft ( $ARRAY [ $I ] , 1 ) = "," Then $ARRAY [ $I ] = StringTrimLeft ( $ARRAY [ $I ] , 1 )
					If StringRegExp ( $ARRAY [ $I ] , "(?i)\\System\\symsrv.dll" ) Then $ATTEN = " <==== " & $UPD1
					$FILE = $ARRAY [ $I ]
					AAAAFPWOW ( )
					If FileExists ( $FILE ) Then
						$FILE = $FILE & " [" & $SIZE & " " & $CDATE & "]" & $COMPANY
					Else
						$FILE = $REGIST8
					EndIf
					_ARRAYADD ( $ARRAYREG , "AppInit_DLLs-x32: " & $DATA & " => " & $FILE & $ATTEN , 0 , "||||" )
				EndIf
			Next
		EndIf
	EndIf
	$KEY = "HKLM\" & $SOFTWARE & "\microsoft\windows nt\currentversion\Image File Execution Options"
	RegRead ( $KEY , "" )
	If @error = 1 Then _SETREGACE ( $KEY , 1 )
	$IF = RegRead ( $KEY , "Debugger" )
	If @error = 0 Then _ARRAYADD ( $ARRAYREG , "IFEO: [Debugger] " & $IF , 0 , "||||" )
	$HKEY = _REGOPENKEYEX3 ( $KEY )
	If Not @error And IsPtr ( $HKEY ) Then
		$I = 0
		While 1
			$SUB = __REGENUMKEY ( $HKEY , $I )
			If @error Then ExitLoop
			RegRead ( $KEY & "\" & $SUB , "" )
			If @error = 1 Then _SETREGACE ( $KEY & "\" & $SUB , 1 )
			$IFEO = RegRead ( $KEY & "\" & $SUB , "Debugger" )
			If @error = 0 Then _ARRAYADD ( $ARRAYREG , "IFEO\" & $SUB & ": [Debugger] " & $IFEO , 0 , "||||" )
			$IFEO = RegRead ( $KEY & "\" & $SUB , "MinimumStackCommitInBytes" )
			If @error = 0 Then
				_ARRAYADD ( $ARRAYREG , "IFEO\" & $SUB & ": [MinimumStackCommitInBytes] " & $IFEO , 0 , "||||" )
			EndIf
			$DWVAL = RegRead ( $KEY & "\" & $SUB , "GlobalFlag" )
			If Not @error Then
				$IFEO = RegRead ( $KEY & "\" & $SUB , "VerifierDlls" )
				If Not @error Then _ARRAYADD ( $ARRAYREG , "IFEO\" & $SUB & ": [VerifierDlls] " & $IFEO , 0 , "||||" )
				$IFEO = RegRead ( "HKLM\" & $SOFTWARE & "\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\" & $SUB , "MonitorProcess" )
				If Not @error Then
					_ARRAYADD ( $ARRAYREG , "IFEO\" & $SUB & ": [GlobalFlag] " & $IFEO , 0 , "||||" )
					_ARRAYADD ( $ARRAYREG , "HKLM\...\SilentProcessExit\" & $SUB & ": [MonitorProcess] " & $IFEO , 0 , "||||" )
				EndIf
			EndIf
			$I = $I + 1
		WEnd
		If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
	EndIf
	For $V = 0 To UBound ( $USERREG ) + 4294967295
		UDEBUG0 ( "HKU\" & $USERREG [ $V ] & "\Software\Microsoft\Windows\CurrentVersion\PackagedAppXDebug" )
	Next
	For $V = 0 To UBound ( $USERREG ) + 4294967295
		UDEBUG ( "HKU\" & $USERREG [ $V ] & "\Software\Classes\ActivatableClasses\Package" )
	Next
	$VAR1 = RegRead ( "HKLM\" & $SYSTEM & $BOOTSYSTEM & $DEF & "\Control\Lsa" , "Authentication Packages" )
	If @error = 0 Then
		$VAR1 = StringRegExpReplace ( $VAR1 , "\v" , " " )
		_ARRAYADD ( $ARRAYREG , "Lsa: [Authentication Packages] " & $VAR1 , 0 , "||||" )
	EndIf
	$VAR1 = RegRead ( "HKLM\" & $SYSTEM & $BOOTSYSTEM & $DEF & "\Control\Lsa" , "Notification Packages" )
	If @error = 0 Then
		$VAR1 = StringRegExpReplace ( $VAR1 , "\v" , " " )
		_ARRAYADD ( $ARRAYREG , "Lsa: [Notification Packages] " & $VAR1 , 0 , "||||" )
	EndIf
	$VAR1 = RegRead ( "HKLM\" & $SYSTEM & $BOOTSYSTEM & $DEF & "\Control\SecurityProviders" , "SecurityProviders" )
	If @error = 0 Then
		_ARRAYADD ( $ARRAYREG , "SecurityProviders: " & $VAR1 , 0 , "||||" )
	EndIf
	$VAR1 = SUB ( )
	If $VAR1 Then
		$VAR2 = RegRead ( "HKLM\" & $SYSTEM & $BOOTSYSTEM & $DEF & "\Control\Session Manager\SubSystems" , "Windows" )
		If $VAR1 <> $VAR2 Then _ARRAYADD ( $ARRAYREG , "SubSystems: [Windows] => """ & $VAR2 & """ <==== " & $UPD1 , 0 , "||||" )
	EndIf
	APPCERT ( )
EndFunc
Func PRINTPROC ( )
	$KEY = "HKLM\" & $SYSTEM & $BOOTSYSTEM & $DEF & "\Control\Print\Environments"
	$HKEY = _REGOPENKEYEX3 ( $KEY )
	$I = 0
	While 1
		$SUB = __REGENUMKEY ( $HKEY , $I )
		If @error Then ExitLoop
		$I += 1
		$KEY1 = $KEY & "\" & $SUB & "\Print Processors"
		$DIR = RegRead ( $KEY & "\" & $SUB , "Directory" )
		$HKEY1 = _REGOPENKEYEX3 ( $KEY1 )
		$II = 0
		While 1
			$SUB1 = __REGENUMKEY ( $HKEY1 , $II )
			If @error Then ExitLoop
			$II += 1
			$ATT = ""
			$KEY2 = $KEY1 & "\" & $SUB1
			$VAL1 = RegRead ( $KEY2 , "Driver" )
			If @error Then ContinueLoop
			$FILE = $C & "\Windows\System32\spool\prtprocs\" & $DIR & "\" & $VAL1
			AAAAFP ( )
			If FileExists ( $FILE ) Then
				$VAL1 = $FILE & " [" & $SIZE & " " & $CDATE & "]" & $COMPANY
				If GUICtrlRead ( $CHECKBOX1 ) = 1 Then
					Select
					Case StringRegExp ( $VAL1 , "(?i):\\Windows\\System32\\spool\\prtprocs\\x64\\winprint\.dll.+Microsoft Corporation\)$" )
						ContinueLoop
					Case StringRegExp ( $VAL1 , "(?i):\\Windows\\System32\\spool\\prtprocs\\x64\\(us008pc|us013pc)\.dll.+Codename Longhorn DDK provider\)$" )
						ContinueLoop
					EndSelect
				EndIf
			Else
				$VAL1 &= " (" & $REGIST8 & ")"
			EndIf
			_ARRAYADD ( $ARRAYREG , "HKLM\...\" & $SUB & "\Print Processors\" & $SUB1 & ": " & $VAL1 & $ATT , 0 , "||||" )
		WEnd
	WEnd
	If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
EndFunc
Func PRINTPROCFIX ( )
	$KEY1 = StringRegExpReplace ( $FIX , "HKLM\\...\\([^\\]+)\\.+" , "$1" )
	$KEY2 = StringRegExpReplace ( $FIX , "HKLM\\...\\[^\\]+\\Print Processors\\([^:]+):.*" , "$1" )
	DELKEY ( "HKLM\" & $SYSTEM & $BOOTSYSTEM & $DEF & "\Control\Print\Environments\" & $KEY1 & "\Print Processors\" & $KEY2 )
EndFunc
Func PRINTMON ( )
	$KEY = "HKLM\" & $SYSTEM & $BOOTSYSTEM & $DEF & "\Control\Print\Monitors"
	$HKEY = _REGOPENKEYEX3 ( $KEY )
	If @error Or Not $HKEY Then Return
	$I = 0
	While 1
		$SUB = __REGENUMKEY ( $HKEY , $I )
		If @error Then ExitLoop
		$I += 1
		$ATT = ""
		$KEY1 = $KEY & "\" & $SUB
		$VAL1 = RegRead ( $KEY1 , "Driver" )
		If @error Then ContinueLoop
		$FILE = $VAL1
		AAAAFP ( )
		If FileExists ( $FILE ) Then
			$VAL1 = $FILE & " [" & $SIZE & " " & $CDATE & "]" & $COMPANY
			If GUICtrlRead ( $CHECKBOX1 ) = 1 And StringRegExp ( $VAL1 , "(?i):\\Windows\\System32\\(AppMon|localspl|FXSMON|tcpmon|usbmon|APMon|WSDMon|LPRMon)\.dll.+Microsoft Corporation\)$" ) Then ContinueLoop
		Else
			$VAL1 &= " (" & $REGIST8 & ")"
		EndIf
		_ARRAYADD ( $ARRAYREG , "HKLM\...\Print\Monitors\" & $SUB & ": " & $VAL1 & $ATT , 0 , "||||" )
	WEnd
	If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
EndFunc
Func PRINTMONFIX ( )
	$KEY = StringRegExpReplace ( $FIX , "HKLM\\...\\Print\\Monitors\\([^:]+):.*" , "$1" )
	DELKEY ( "HKLM\" & $SYSTEM & $BOOTSYSTEM & $DEF & "\Control\Print\Monitors\" & $KEY )
EndFunc
Func AAAARP ( )
	Local $ARRAYRP [ 1 ] = [ @CRLF ]
	FileClose ( $FRSTLOG )
	$FRSTLOG = FileOpen ( @ScriptDir & "\FRST.txt" , 256 + 1 )
	$HTEMPRP = FileOpen ( $C & "\frst\bin\temprp" , 256 + 2 )
	$HTEMPRP2 = FileOpen ( $C & "\frst\bin\temprp2" , 256 + 2 )
	$ARRAYPRO = ProcessList ( )
	For $I = 1 To UBound ( $ARRAYPRO ) + 4294967295
		If @ScriptName = $ARRAYPRO [ $I ] [ 0 ] Then ContinueLoop
		$PATH = _RUNPR ( $ARRAYPRO [ $I ] [ 1 ] )
		If $PATH Then
			FileWrite ( $HTEMPRP , "<" & $ARRAYPRO [ $I ] [ 1 ] & ">" & $PATH & @CRLF )
		Else
			If ProcessExists ( $ARRAYPRO [ $I ] [ 1 ] ) And Not StringRegExp ( $ARRAYPRO [ $I ] [ 0 ] , "(?i)\A((Secure |)system|Memory Compression|Registry|vmmem)$" ) Then _ARRAYADD ( $ARRAYRP , $PROCESS1 & " -> " & $ARRAYPRO [ $I ] [ 0 ] , 0 , "||||" )
		EndIf
	Next
	$HREAD = FileRead ( $C & "\frst\bin\temprp" )
	$I = 0
	While 1
		$I += 1
		$PATH = FileReadLine ( $C & "\frst\bin\temprp" , $I )
		If @error Then ExitLoop
		$PATH1 = StringRegExpReplace ( $PATH , "\\" , "\\\\" )
		$PATH1 = StringRegExpReplace ( $PATH1 , "\(" , "\\(" )
		$PATH1 = StringRegExpReplace ( $PATH1 , "\)" , "\\)" )
		$PATH1 = StringRegExpReplace ( $PATH1 , "<.*>" , "" )
		$READ2 = FileRead ( $C & "\frst\bin\temprp2" )
		If StringRegExp ( $READ2 , "(?i)" & $PATH1 ) Then ContinueLoop
		FileWrite ( $HTEMPRP2 , $PATH & @CRLF )
		$RET = StringRegExp ( $HREAD , "(?i)<.*>" & $PATH1 , 3 )
		$CT = UBound ( $RET )
		$N = ""
		If $CT > 1 Then $N = " <" & $CT & ">"
		$PID = StringRegExpReplace ( $PATH , "<(.*)>.+" , "\1" )
		$PPID = _WINAPI_GETPARENTPROCESS ( $PID )
		$PPATH = _RUNPR ( $PPID )
		If $PPATH Then
			$PPATH = StringRegExpReplace ( $PPATH , "(?i).:\\Windows\\System32\\" , "" )
			$PPATH = StringRegExpReplace ( $PPATH , "(?i).:\\Windows\\explorer.exe" , "explorer.exe" )
			$PPATH = "(" & $PPATH & " ->) "
		Else
			$PPATH = ""
		EndIf
		$PATH = StringRegExpReplace ( $PATH , "<.*>" , "" )
		COMP ( $PATH )
		$COMPANY = StringRegExpReplace ( $COMPANY , "^\s+" , "" )
		_ARRAYADD ( $ARRAYRP , $PPATH & $COMPANY & " " & $PATH & $N , 0 , "||||" )
	WEnd
	FileClose ( $HTEMPRP )
	FileDelete ( $C & "\frst\bin\temprp" )
	FileClose ( $HTEMPRP2 )
	FileDelete ( $C & "\frst\bin\temprp2" )
	_ARRAYSORT ( $ARRAYRP , 0 )
	FileWrite ( $FRSTLOG , @CRLF & "==================== " & $PROCB & " (" & WL ( $CHECKBOX8 ) & ") =================" & @CRLF )
	If GUICtrlRead ( $CHECKBOX8 ) = 4 Then
		_FILEWRITEFROMARRAY ( $FRSTLOG , $ARRAYRP , 1 )
	Else
		FileWrite ( $FRSTLOG , @CRLF & "(" & $PROCESS3 & ")" & @CRLF & @CRLF )
		For $I = 1 To UBound ( $ARRAYRP ) + 4294967295
			Select
			Case StringRegExp ( $ARRAYRP [ $I ] , "(?i)\(Skype.+->Skype.+\) \w:\\Program Files\\WindowsApps\\Microsoft.SkypeApp_(\d+\.)+\d+_x\d+__kzf8qxf38zg5c\\Skype\\Skype.exe" )
				ContinueLoop
			Case Not StringRegExp ( $ARRAYRP [ $I ] , "Microsoft (Windows|Corporation).* -> " ) Or StringInStr ( $ARRAYRP [ $I ] , "[" )
				FileWrite ( $FRSTLOG , $ARRAYRP [ $I ] & @CRLF )
				ContinueLoop
			Case StringRegExp ( $ARRAYRP [ $I ] , "(?i)\(Microsoft.+->.+\) \w:\\Program Files\\WindowsApps\\Microsoft\.?.+_(\d+\.)+\d+_x64__(8wekyb3d8bbwe|cw5n1h2txyewy)\\(gamingservices(|net)|YourPhone|Microsoft.Photos|YourPhoneServer\\YourPhoneServer|PeopleApp|Video.UI|msteams|(Dashboard|WidgetService)\\Widget(s|Service)|Cortana|PhoneExperienceHost).exe" )
				ContinueLoop
			Case StringRegExp ( $ARRAYRP [ $I ] , "(?i)(Microsoft|OEMTest OS).+-> Microsoft[^[]+ WINDOWS\\System32\\SurfaceColorService.exe" )
				ContinueLoop
			Case StringRegExp ( $ARRAYRP [ $I ] , "(?i):\\Windows\\system32\\" )
				If StringRegExp ( $ARRAYRP [ $I ] , "(?i):\\Windows\\system32\\(ShellHost|oobe\\UserOOBEBroker|AggregatorHost|CloudExperienceHostBroker|SurfaceColorService|psxss|Surface(UsbHubFwUpdateService|Service|DtxService|ColorTracker|ColorService|DTX)|CISVC|snmp|vmms|vmcompute|TCPSVCS|nfsclnt|mqtgsvc|mqsvc|inetsrv\\inetinfo|LsaIso|(Sgrm\\|)SgrmBroker|SettingSyncHost|SecurityHealthService|mmc|smss|conhost|ctfmon|wuauclt|taskhostex|msdtc|csrss|wininit|services|lsass|RuntimeBroker|lsm|winlogon|svchost|ThumbnailExtractionHost|taskhost|taskeng|WUDFHost|SearchIndexer|vssvc|spoolsv|Dwm|sppsvc|NOTEPAD|SearchProtocolHost|SearchFilterHost|audiodg|dasHost|sihost|taskhostw|ApplicationFrameHost|SystemSettingsBroker|fontdrvhost|backgroundTaskHost|UsoClient|wsqmcons|wermgr|msfeedssync|SIHClient|SecurityHealthSystray|CompPkgSrv)\.exe" ) Then ContinueLoop
				If StringRegExp ( $ARRAYRP [ $I ] , "(?i)\\Windows\\system32\\wbem\\(wmiprvse|unsecapp|WmiApSrv)\.exe" ) Then ContinueLoop
				If StringRegExp ( $ARRAYRP [ $I ] , "(?i)\\Windows\\system32\\DriverStore\\FileRepository\\surfaceservice.+?\\SurfaceService.exe" ) Then ContinueLoop
			Case StringRegExp ( $ARRAYRP [ $I ] , "(?i):\\Windows\\SystemApps\\.+?\\(MiniSearchHost|SearchHost|SearchApp|TextInputHost|StartMenuExperienceHost|ShellExperienceHost|SearchUI|LockApp|WindowsInternal.ComposableShell.Experiences.TextInput.InputApp)\.exe" )
				ContinueLoop
			Case StringRegExp ( $ARRAYRP [ $I ] , "(?i):\\Windows\\" )
				If StringRegExp ( $ARRAYRP [ $I ] , "(?i):\\Windows\\(NOTEPAD|Explorer).exe" ) Then ContinueLoop
				If StringRegExp ( $ARRAYRP [ $I ] , "(?i):\\Windows\\servicing\\TrustedInstaller\.exe" ) Then ContinueLoop
				If StringRegExp ( $ARRAYRP [ $I ] , "(?i):\\Windows\\SysWOW64\\(ctfmon|vmnetdhcp|vmnat)\.exe" ) Then ContinueLoop
			Case StringRegExp ( $ARRAYRP [ $I ] , "(?i):\\Program Files" )
				If StringRegExp ( $ARRAYRP [ $I ] , "(?i):\\Program Files(| \(x86\))\\(Windows Media Player|Internet Explorer|rempl|Windows MultiPoint Server)\\(WmsSvc|WmsSessionAgent|WmsSelfHealingSvc|sedsvc|wmplayer|wmpnetwk|iexplore).exe" ) Then ContinueLoop
				If StringRegExp ( $ARRAYRP [ $I ] , "(?i):\\Program Files(| \(x86\))\\Common Files\\microsoft shared\\ink\\TabTip(|32)\.exe" ) Then ContinueLoop
				If StringRegExp ( $ARRAYRP [ $I ] , "(?i):\\Program Files(| \(x86\))\\Microsoft Office\\Office12\\OUTLOOK.EXE" ) Then ContinueLoop
			Case StringRegExp ( $ARRAYRP [ $I ] , "(?i):\\Users\\.+?\\AppData\\Local\\Microsoft\\OneDrive\\OneDrive.exe" )
				ContinueLoop
			EndSelect
			FileWrite ( $FRSTLOG , $ARRAYRP [ $I ] & @CRLF )
		Next
		$ARRAYRP = ""
	EndIf
EndFunc
Func AAAARPM ( )
	$BAD = _FILELISTTOARRAY ( $C & "\FRST" , "*.exe" , 1 , True )
	If Not IsArray ( $BAD ) Then Return
	FileClose ( $FRSTLOG )
	$FRSTLOG = FileOpen ( @ScriptDir & "\FRST.txt" , 256 + 1 )
	FileWrite ( $FRSTLOG , @CRLF & "========================================================" & @CRLF & @CRLF )
	For $B = 1 To UBound ( $BAD ) + 4294967295
		$ARRAYPRO = ProcessList ( )
		For $D = 1 To UBound ( $ARRAYPRO ) + 4294967295
			If $BAD [ $B ] = _RUNPR ( $ARRAYPRO [ $D ] [ 1 ] ) Then
				If PROCRIT ( $ARRAYPRO [ $D ] [ 1 ] ) Then
					ProcessClose ( $ARRAYPRO [ $D ] [ 1 ] )
					If Not @error Then FileWrite ( $FRSTLOG , $BAD [ $B ] & " => " & $PRO5 & @CRLF )
				EndIf
			EndIf
		Next
		If StringRegExp ( FileGetAttrib ( $BAD [ $B ] ) , "(?i)S|R|H" ) Then FileSetAttrib ( $BAD [ $B ] , "-RSH" )
		$SDEST = DESTIN ( $BAD [ $B ] , 1 )
		$RET = FileMove ( $BAD [ $B ] , $SDEST , 1 )
		Select
		Case $RET = 1
			FileWrite ( $FRSTLOG , $BAD [ $B ] & " => " & $MOVED & @CRLF )
		Case $RET = 0
			_GRANTE ( $BAD [ $B ] , 1 , 0 )
			If StringRegExp ( FileGetAttrib ( $BAD [ $B ] ) , "(?i)S|R|H" ) Then FileSetAttrib ( $BAD [ $B ] , "-RSH" )
			$RET = FileMove ( $BAD [ $B ] , $SDEST , 1 + 8 )
			Select
			Case $RET = 1
				FileWrite ( $FRSTLOG , $BAD [ $B ] & " => " & $MOVED & @CRLF )
			Case $RET = 0
				FileWrite ( $FRSTLOG , """" & $BAD [ $B ] & """" & " => " & $FIX8 & @CRLF )
			EndSelect
		EndSelect
	Next
EndFunc
Func AAAARPOL ( )
	FileClose ( $FRSTLOG )
	$FRSTLOG = FileOpen ( @ScriptDir & "\FRST.txt" , 256 + 1 )
	AAAARPOL1 ( $SYSTEMDIR & "\GroupPolicy\Machine\Registry.pol" )
	AAAARPOL1 ( $WINDOWSDIR86 & "\GroupPolicy\Machine\Registry.pol" )
	AAAARPOL1 ( $SYSTEMDIR & "\GroupPolicy\User\Registry.pol" )
	AAAARPOL1 ( $WINDOWSDIR86 & "\GroupPolicy\User\Registry.pol" )
	AAAARPOL1 ( $PROGRAMFILES & "\Mozilla Firefox\distribution\policies.json" )
	AAAARPOL1 ( $PROGRAMFILES86 & "\Mozilla Firefox\distribution\policies.json" )
	AAAARPOL2 ( $SYSTEMDIR & "\GroupPolicyUsers" )
	AAAARPOL2 ( $WINDOWSDIR86 & "\GroupPolicyUsers" )
	AAAARPOL3 ( $SYSTEMDIR & "\GroupPolicy\Machine\Scripts" )
	AAAARPOL3 ( $SYSTEMDIR & "\GroupPolicy\User\Scripts" )
	AAAARPOL3 ( $WINDOWSDIR86 & "\GroupPolicy\Machine\Scripts" )
	AAAARPOL3 ( $WINDOWSDIR86 & "\GroupPolicy\User\Scripts" )
	AAAARPOL4 ( $SYSTEMDIR & "\GroupPolicyUsers" )
	AAAARPOL4 ( $WINDOWSDIR86 & "\GroupPolicyUsers" )
	AAAARPOL5 ( )
	AAAARPOL6 ( "Mozilla\Firefox" )
	AAAARPOL6 ( "Google" )
	AAAARPOL6 ( "Microsoft\Edge" )
	AAAARPOL6 ( "BraveSoftware\Brave" )
	AAAARPOL6 ( "Vivaldi" )
	AAAARPOL6 ( "YandexBrowser" )
EndFunc
Func AAAARPOL5 ( )
	For $P = 1 To UBound ( $ALLUSERS ) + 4294967295
		$UPOL = $ALLUSERS [ $P ] & "\NTUSER.pol"
		If Not FileExists ( $UPOL ) Then ContinueLoop
		$READ = FileRead ( $UPOL )
		If StringLen ( $READ ) < 30 Then ContinueLoop
		FileWrite ( $FRSTLOG , "Policies: " & $UPOL & ": " & $RESTRICT & " <==== " & $UPD1 & @CRLF )
	Next
EndFunc
Func AAAARPOL6 ( $SKEY )
	$KEY = "HKLM\SOFTWARE\Policies\" & $SKEY
	RegRead ( $KEY , "" )
	If @error < 1 Then Return AAAPOL00 ( $KEY , 1 )
	For $U = 1 To UBound ( $USERREG ) + 4294967295
		$KEY = "HKU\" & $USERREG [ $U ] & "\SOFTWARE\Policies\" & $SKEY
		RegRead ( $KEY , "" )
		If @error < 1 Then Return AAAPOL00 ( $KEY , 1 )
	Next
EndFunc
Func AAAAPOL0 ( $KEY , $IE = "" )
	RegRead ( $KEY , RegEnumVal ( $KEY , 1 ) )
	If Not @error Then Return AAAPOL00 ( $KEY , $IE )
	$HKEY = _REGOPENKEYEX3 ( $KEY )
	If @error Or Not $HKEY Then Return
	$K = + 4294967295
	While 1
		$K += 1
		$SUB = __REGENUMKEY ( $HKEY , $K )
		If @error Then ExitLoop
		$KEY1 = $KEY & "\" & $SUB
		RegRead ( $KEY1 , RegEnumVal ( $KEY1 , 1 ) )
		If Not @error Then
			Return AAAPOL00 ( $KEY , $IE )
		Else
			$HKEY1 = _REGOPENKEYEX3 ( $KEY1 )
			If @error Or Not $HKEY1 Then ContinueLoop
			$L = 0
			While 1
				$SUB1 = __REGENUMKEY ( $HKEY1 , $L )
				If @error Then ExitLoop
				$KEY2 = $KEY1 & "\" & $SUB1
				RegRead ( $KEY2 , RegEnumVal ( $KEY2 , 1 ) )
				If Not @error Then Return AAAPOL00 ( $KEY , $IE )
				$L += 1
			WEnd
		EndIf
	WEnd
	If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
EndFunc
Func AAAPOL00 ( $KEY , $IE )
	If $IE Then
		FileWrite ( $FRSTLOG , $KEY & ": " & $RESTRICT & " <==== " & $UPD1 & @CRLF )
	Else
		_ARRAYADD ( $ARRAYREG , $KEY & ": " & $RESTRICT & " <==== " & $UPD1 , 0 , "||||" )
	EndIf
EndFunc
Func AAAARPOL1 ( $FPATH )
	$PRE = "GroupPolicy"
	If StringInStr ( $FPATH , "SysWOW64\GroupPolicy\Machine" ) Then $PRE = "GroupPolicy-x32"
	If StringInStr ( $FPATH , "\User\" ) Then $PRE = "GroupPolicy\User"
	If StringInStr ( $FPATH , "SysWOW64\GroupPolicy\User" ) Then $PRE = "GroupPolicy-x32\User"
	If StringInStr ( $FPATH , "\Mozilla Firefox\" ) Then $PRE = "GroupPolicy-Firefox"
	If StringInStr ( $FPATH , "(x86)\Mozilla Firefox\" ) Then $PRE = $PRE & "-x32"
	If FileExists ( $FPATH ) Then
		If StringInStr ( $FPATH , "\Mozilla Firefox\" ) Then Return FileWrite ( $FRSTLOG , $PRE & ": " & $RESTRICT & " <==== " & $UPD1 & @CRLF )
		$READ = FileRead ( $FPATH )
		If StringLen ( $READ ) < 30 Then Return
		$READ = _STRINGTOHEX ( $READ )
		$READ = StringRegExpReplace ( $READ , "([^x][^x])00" , "$1" )
		$READ = _HEXTOSTRING ( $READ )
		Select
		Case StringInStr ( $READ , "Chrome" )
			FileWrite ( $FRSTLOG , $PRE & ": " & $RESTRICT & " - Chrome <==== " & $UPD1 & @CRLF )
		Case StringInStr ( $READ , "Firefox" )
			FileWrite ( $FRSTLOG , $PRE & ": " & $RESTRICT & " - Firefox <==== " & $UPD1 & @CRLF )
		Case StringInStr ( $READ , "Edge" )
			FileWrite ( $FRSTLOG , $PRE & ": " & $RESTRICT & " - Edge <==== " & $UPD1 & @CRLF )
		Case StringInStr ( $READ , "Windows Defender\Exclusions" )
			FileWrite ( $FRSTLOG , $PRE & ": " & $RESTRICT & " - Windows Defender <==== " & $UPD1 & @CRLF )
	Case Else
			FileWrite ( $FRSTLOG , $PRE & ": " & $RESTRICT & " ? <==== " & $UPD1 & @CRLF )
		EndSelect
	EndIf
EndFunc
Func AAAARPOL2 ( $FPATH )
	If Not FileExists ( $FPATH ) Then Return 1
	$ARR = _FILELISTTOARRAYREC ( $FPATH , "Registry.pol" , 1 + 16 , 1 , 0 , 2 )
	$PRE = "GroupPolicyUsers\"
	If StringInStr ( $FPATH , "SysWOW64" ) Then $PRE = "SysWOW64\GroupPolicyUsers\"
	For $I = 1 To UBound ( $ARR ) + 4294967295
		If StringInStr ( $ARR [ $I ] , "Registry.pol" ) Then
			$READ = FileRead ( $ARR [ $I ] )
			If StringLen ( $READ ) < 30 Then ContinueLoop
			$USERSID = StringRegExpReplace ( $ARR [ $I ] , "(?i).+GroupPolicyUsers\\(.+?)\\Registry.pol" , "$1" )
			$READ = _STRINGTOHEX ( $READ )
			$READ = StringRegExpReplace ( $READ , "([^x][^x])00" , "$1" )
			$READ = _HEXTOSTRING ( $READ )
			Select
			Case StringInStr ( $READ , "Chrome" )
				FileWrite ( $FRSTLOG , $PRE & $USERSID & ": " & $RESTRICT & " - Chrome <==== " & $UPD1 & @CRLF )
			Case StringInStr ( $READ , "Firefox" )
				FileWrite ( $FRSTLOG , $PRE & $USERSID & ": " & $RESTRICT & " - Firefox <==== " & $UPD1 & @CRLF )
			Case StringInStr ( $READ , "Edge" )
				FileWrite ( $FRSTLOG , $PRE & $USERSID & ": " & $RESTRICT & " - Edge <==== " & $UPD1 & @CRLF )
		Case Else
				FileWrite ( $FRSTLOG , $PRE & $USERSID & ": " & $RESTRICT & " <==== " & $UPD1 & @CRLF )
			EndSelect
		EndIf
	Next
EndFunc
Func AAAARPOL3 ( $FPATH )
	If Not FileExists ( $FPATH & "\scripts.ini" ) And Not FileExists ( $FPATH & "\psscripts.ini" ) Then Return
	$PRE = "GroupPolicyScripts"
	If StringInStr ( $FPATH , "SysWOW64" ) Then $PRE = "GroupPolicyScripts-x32"
	If StringInStr ( $FPATH , "\User\" ) Then
		FileWrite ( $FRSTLOG , $PRE & "\User: " & $RESTRICT & " <==== " & $UPD1 & @CRLF )
	Else
		FileWrite ( $FRSTLOG , $PRE & ": " & $RESTRICT & " <==== " & $UPD1 & @CRLF )
	EndIf
EndFunc
Func AAAARPOL4 ( $FPATH )
	If Not FileExists ( $FPATH & "\scripts.ini" ) And Not FileExists ( $FPATH & "\psscripts.ini" ) Then Return
	$ARR = _FILELISTTOARRAYREC ( $FPATH , "Scripts" , 2 + 16 , 1 , 0 , 2 )
	$PRE = "GroupPolicyUsers\"
	If StringInStr ( $FPATH , "SysWOW64" ) Then $PRE = "SysWOW64\GroupPolicyUsers\"
	For $I = 1 To UBound ( $ARR ) + 4294967295
		If StringInStr ( $ARR [ $I ] , "Scripts" ) Then
			$USERSID = StringRegExpReplace ( $ARR [ $I ] , "(?i).+GroupPolicyUsers\\(.+?)\\Scripts" , "$1" )
			FileWrite ( $FRSTLOG , $PRE & $USERSID & "\Scripts: " & $RESTRICT & " <==== " & $UPD1 & @CRLF )
		EndIf
	Next
EndFunc
Func AAAARSF ( )
	If $BOOTM <> "Recovery" Then
		If $OSNUM > 5.2 Then
			$KEY = "HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders"
		Else
			$KEY = "HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\User Shell"
		EndIf
		$STARTUPDIR = RegRead ( $KEY , "startup" )
		If $OSNUM > 5.2 And Not StringRegExp ( $STARTUPDIR , "(?i)AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup$|^\\\\[^\\]+\\users\\[^\\]+\\Start Menu\\Programs\\Startup" ) Then _ARRAYADD ( $ARRAYREG , "StartupDir: " & $STARTUPDIR & " <==== " & $UPD1 , 0 , "|||" )
		STARTUPFOLDER ( _EXPAND ( $STARTUPDIR ) )
	Else
		For $P = 1 To UBound ( $ALLUSERS ) + 4294967295
			If StringRegExp ( $ALLUSERS [ $P ] , "(?i)\\(All Users|default|public|ProgramData)$" ) Then ContinueLoop
			$USER = StringRegExpReplace ( $ALLUSERS [ $P ] , ".+\\(.+)" , "$1" )
			RunWait ( @ComSpec & " /c reg load ""hku\" & $USER & """ """ & $ALLUSERS [ $P ] & "\ntuser.dat""" , "" , @SW_HIDE )
			$STARTUPDIR = RegRead ( "HKU\" & $USER & "\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders" , "startup" )
			If Not StringRegExp ( $STARTUPDIR , "(?i)AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup$|^\\\\[^\\]+\\users\\[^\\]+\\Start Menu\\Programs\\Startup" ) Then _ARRAYADD ( $ARRAYREG , "StartupDir[" & $USER & "]: " & $STARTUPDIR & " <==== " & $UPD1 , 0 , "|||" )
			RunWait ( @ComSpec & " /c reg unload ""hku\" & $USER & """" , "" , @SW_HIDE )
		Next
	EndIf
	If $OSNUM > 5.2 Then
		$KEY = "HKLM\" & $SOFTWARE & "\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders"
	Else
		$KEY = "HKLM\" & $SOFTWARE & "\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders"
	EndIf
	$COMSTARTUPDIR = RegRead ( $KEY , "Common Startup" )
	If $OSNUM > 5.2 And Not StringRegExp ( $COMSTARTUPDIR , "(?i)ProgramData(|%)\\Microsoft\\Windows\\Start Menu\\Programs\\Startup$" ) Then _ARRAYADD ( $ARRAYREG , "StartupCommonDir: " & $COMSTARTUPDIR & " <==== " & $UPD1 , 0 , "|||" )
	STARTUPFOLDER ( _EXPAND ( $COMSTARTUPDIR ) )
	$COMSTARTUPDIR86 = RegRead ( "HKLM\" & $SOFTWARE & "\WOW6432Node\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders" , "Common Startup" )
	If $OSNUM > 5.2 And Not StringRegExp ( $COMSTARTUPDIR86 , "(?i)ProgramData(|%)\\Microsoft\\Windows\\Start Menu\\Programs\\Startup$" ) Then _ARRAYADD ( $ARRAYREG , "StartupCommonDirx86: " & $COMSTARTUPDIR86 & " <==== " & $UPD1 , 0 , "|||" )
	If $COMSTARTUPDIR <> $COMSTARTUPDIR86 Then STARTUPFOLDER ( _EXPAND ( $COMSTARTUPDIR86 ) )
EndFunc
Func _EXPAND ( $PATH )
	$DIR = StringRegExpReplace ( $PATH , "%([^\\]+)%.*" , "$1" )
	$DIR = StringRegExpReplace ( EnvGet ( $DIR ) , "\\" , "\\\\" )
	Return StringRegExpReplace ( $PATH , "%.+?%" , $DIR )
EndFunc
Func STARTUPFIX ( )
	If StringRegExp ( $FIX , "StartupDir(|\[.+\]):" ) Then
		$USER = StringRegExpReplace ( $FIX , "StartupDir\[(.+?)\].+" , "$1" )
		If $OSNUM > 5.2 Then
			$KEY = "HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders"
			If $BOOTM = "recovery" Then $KEY = "HKU\" & $USER & "\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders"
			$VAL = "%USERPROFILE%\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup"
			$REGSZ = "REG_EXPAND_SZ"
		Else
			$KEY = "HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\User Shell"
			$VAL = "C:\Documents and Settings\Winxp\Start Menu\Programs\Startup"
			$REGSZ = "REG_SZ"
		EndIf
		If $BOOTM = "recovery" Then RELOAD ( $USER )
		If RegWrite ( $KEY , "Startup" , $REGSZ , $VAL ) Then
			FileWrite ( $HFIXLOG , $FIX & " => " & $RESTORED & @CRLF )
		Else
			FileWrite ( $HFIXLOG , $FIX & " => " & $NRESTORE & @CRLF )
		EndIf
		If $BOOTM = "recovery" Then REUNLOAD ( $USER )
	Else
		If $OSNUM > 5.2 Then
			$KEY = "HKLM\" & $SOFTWARE & "\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders"
			If StringInStr ( $FIX , "x86:" ) Then $KEY = "HKLM\" & $SOFTWARE & "\WOW6432Node\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders"
			$REGSZ = "REG_EXPAND_SZ"
		Else
			$KEY = "HKLM\" & $SOFTWARE & "\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders"
			$REGSZ = "REG_SZ"
		EndIf
		If RegWrite ( $KEY , "Common Startup" , $REGSZ , "%ProgramData%\Microsoft\Windows\Start Menu\Programs\Startup" ) Then
			FileWrite ( $HFIXLOG , $FIX & " => " & $RESTORED & @CRLF )
		Else
			FileWrite ( $HFIXLOG , $FIX & " => " & $NRESTORE & @CRLF )
		EndIf
	EndIf
EndFunc
Func AAAARW ( )
	FileClose ( $FRSTLOG )
	$FRSTLOG = FileOpen ( @ScriptDir & "\FRST.txt" , 256 + 1 )
	$REG101 = FileOpen ( @TempDir & "\reg101" , 256 + 2 )
	FileWrite ( $FRSTLOG , @CRLF & "==================== " & $REGB & " (" & WL ( $CHECKBOX1 ) & ") ===================" & @CRLF & @CRLF )
	FileWrite ( $REG101 , "(" & $REGIST9 & " " & $REGIST10 & ")" & @CRLF & @CRLF )
	_FILEWRITEFROMARRAY ( $REG101 , $ARRAYREG , 1 )
	$ARRAYREG = ""
	FileClose ( $REG101 )
	$REG101 = FileOpen ( @TempDir & "\reg101" , 256 )
	$REGEXPR = FileRead ( $REG101 )
	FileClose ( $REG101 )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)http(s|):" , "hxxp\1:" )
	If GUICtrlRead ( $CHECKBOX1 ) = 1 Then
		WHITELISTREG ( )
	EndIf
	FileWrite ( $FRSTLOG , $REGEXPR )
	FileDelete ( @TempDir & "\reg101" )
EndFunc
Func AAAAS ( )
	GUICtrlSetData ( $LABEL1 , $SCANB & " " & $SERVB & ": " )
	If $BOOTM = "Recovery" Then $VAR0 = "S"
	Local $LOCK1 , $ARRAYSRV [ 1 ] , $ARRAYSRVR [ 1 ] , $ARRAYDR [ 1 ] , $ARRAYDRR [ 1 ] , $ARRAYLOCK [ 1 ]
	If $BOOTM <> "Recovery" Then
		If FileExists ( $C & "\FRST\" & $SFOL & "\system" ) Then
			_RKS ( $ARRAYLOCK )
		Else
			_FLT ( $ARRAYLOCK )
		EndIf
	EndIf
	$MAINKEY = "HKLM\" & $SYSTEM & $BOOTSYSTEM & $DEF & "\Services"
	RegRead ( $MAINKEY , "" )
	If @error = 1 Then _ARRAYADD ( $ARRAYLOCK , """" & $MAINKEY & """ => " & $NFOUND & " <==== " & $UPD1 , 0 , "||||" )
	If RegRead ( $MAINKEY & "\pcw" , "start" ) = 4 Then
		RegWrite ( $MAINKEY & "\pcw" , "Start" , "REG_DWORD" , "0" )
		If Not @error Then
			_ARRAYADD ( $ARRAYDR , "PCW (Start=4 -> Start=0) <==== " & $RESTORED )
		Else
			_ARRAYADD ( $ARRAYDR , "PCW (Start=4) <==== " & $NRESTORE )
		EndIf
	EndIf
	If $BOOTM = "Recovery" Then DEL ( $ARRAYSRV )
	$FULLKEY = _HKEYTRANS ( $MAINKEY )
	$HKEY = _HKEY ( $FULLKEY )
	If @error Or $HKEY = 0 Then Return False
	$I = 0
	While 1
		$FILE = ""
		$COMPANY = ""
		Local $VAR0 , $NOFILE1 , $NOFILE2 , $FILE1
		$SNAME = __REGENUMKEY ( $HKEY , $I )
		If @error Then ExitLoop
		GUICtrlSetData ( $LABEL1 , $SCANB & " " & $SERVB & ": " & $SNAME )
		If $BOOTM <> "Recovery" Then
			$VAR0 = _SRVSTAT ( $SNAME )
		EndIf
		$SUB = $MAINKEY & "\" & $SNAME
		$START = RegRead ( $SUB , "Start" )
		If Not @error Then
			If $START < 0 Or $START > 4 Then $START = 5
			$TYPE = RegRead ( $SUB , "type" )
			If Not @error Then
				Select
				Case $TYPE = 0 Or $TYPE = 1 Or $TYPE = 2 Or $TYPE = 4 Or $TYPE = 8
					$IPATH = RegRead ( $SUB , "Imagepath" )
					If Not @error Then
						$FILE = $IPATH
						$FILE1 = ""
						$NOFILE1 = ""
						AAAAFP ( )
						If FileExists ( $FILE ) Then
							$ATTEN = ""
							_ARRAYADD ( $ARRAYDR , $VAR0 & $START & " " & $SNAME & "; " & $FILE & " [" & $SIZE & " " & $CDATE & "]" & $COMPANY & $ATTEN , 0 , "||||" )
							$FILE1 = $FILE
						Else
							$PATH1 = AAAAS1 ( $FILE , $IPATH )
							If StringInStr ( $PATH1 , "[X]" ) Then
								$NOFILE1 = 1
							Else
								_ARRAYADD ( $ARRAYDRR , $VAR0 & $START & " " & $SNAME & "; " & $PATH1 , 0 , "||||" )
							EndIf
						EndIf
						$FILE = $IPATH
						AAAAFPWOW ( )
						If FileExists ( $FILE ) Then
							If $FILE <> $FILE1 Then
								$ATTEN = ""
								_ARRAYADD ( $ARRAYDR , $VAR0 & $START & " " & $SNAME & "; " & $FILE & " [" & $SIZE & " " & $CDATE & "]" & $COMPANY & $ATTEN , 0 , "||||" )
							EndIf
						Else
							$PATH1 = AAAAS1 ( $FILE , $IPATH )
							If StringInStr ( $PATH1 , "[X]" ) Then
								If $NOFILE1 = 1 Then _ARRAYADD ( $ARRAYDRR , $VAR0 & $START & " " & $SNAME & "; " & $PATH1 , 0 , "||||" )
							Else
								_ARRAYADD ( $ARRAYDRR , $VAR0 & $START & " " & $SNAME & "; " & $PATH1 , 0 , "||||" )
							EndIf
						EndIf
					Else
						$FILE = $C & "\Windows\System32\Drivers\" & $SNAME & ".sys"
						If FileExists ( $FILE ) Then
							$ATTEN = ""
							AAAAFP ( )
							_ARRAYADD ( $ARRAYDR , $VAR0 & $START & " " & $SNAME & "; " & $FILE & " [" & $SIZE & " " & $CDATE & "]" & $COMPANY & $ATTEN , 0 , "||||" )
						Else
							$PATH1 = AAAAS1 ( $FILE , $FILE )
							If StringInStr ( $PATH1 , "[X]" ) Then
								$NOFILE1 = 2
							Else
								_ARRAYADD ( $ARRAYDRR , $VAR0 & $START & " " & $SNAME & "; " & $PATH1 , 0 , "||||" )
							EndIf
						EndIf
						$FILE = $C & "\Windows\SysWow64\Drivers\" & $SNAME & ".sys"
						If FileExists ( $FILE ) Then
							$ATTEN = ""
							AAAAFP ( )
							$IPATH = $FILE
							_ARRAYADD ( $ARRAYDR , $VAR0 & $START & " " & $SNAME & "; " & $IPATH & " [" & $SIZE & " " & $CDATE & "]" & $COMPANY & $ATTEN , 0 , "||||" )
						Else
							$PATH1 = AAAAS1 ( $FILE , $FILE )
							If StringInStr ( $PATH1 , "[X]" ) Then
								If $NOFILE1 = 2 Then _ARRAYADD ( $ARRAYDR , $VAR0 & $START & " " & $SNAME & "; " & $NO & " ImagePath" , 0 , "||||" )
							Else
								_ARRAYADD ( $ARRAYDRR , $VAR0 & $START & " " & $SNAME & "; " & $PATH1 , 0 , "||||" )
							EndIf
						EndIf
					EndIf
				Case $TYPE = 16 Or $TYPE = 32 Or $TYPE = 96 Or $TYPE = 224 Or $TYPE = 272 Or $TYPE = 288
					$IPATH = RegRead ( $SUB , "Imagepath" )
					If Not @error Then
						$IPATH = StringRegExpReplace ( $IPATH , "(?i)http(s|):" , "hxxp\1:" )
						If StringRegExp ( $IPATH , "(?i)(dllhost|msiexec)\.exe" ) Then
							$IPATHARG = StringRegExpReplace ( $IPATH , ".+(?:dllhost|msiexec)\.exe(.*)" , "$1" )
							$IPATH = StringRegExpReplace ( $IPATH , "(.+(?:dllhost|msiexec)\.exe).*" , "$1" )
						EndIf
						If VAR ( $SUB & "\parameters" ) Then
							RegRead ( $SUB & "\parameters" , "" )
							If @error = 1 Then _SETREGACE ( $SUB & "\parameters" , 1 )
						EndIf
						$SDLL = RegRead ( $SUB , "ServiceDll" )
						If @error Then $SDLL = RegRead ( $SUB & "\parameters" , "ServiceDLL" )
						If Not @error Then
							$FILE = $SDLL
							AAAAFP ( )
							If FileExists ( $FILE ) Then
								$ATTEN = ""
								_ARRAYADD ( $ARRAYSRV , $VAR0 & $START & " " & $SNAME & "; " & $FILE & " [" & $SIZE & " " & $CDATE & "]" & $COMPANY & $ATTEN , 0 , "||||" )
								$FILE1 = $FILE
							Else
								$PATH1 = AAAAS1 ( $FILE , $SDLL )
								If StringInStr ( $PATH1 , "[X]" ) Then
									$NOFILE1 = 3
								Else
									_ARRAYADD ( $ARRAYSRVR , $VAR0 & $START & " " & $SNAME & "; " & $PATH1 , 0 , "||||" )
								EndIf
							EndIf
							$FILE = $SDLL
							AAAAFPWOW ( )
							If FileExists ( $FILE ) Then
								If $FILE <> $FILE1 Then
									$ATTEN = ""
									_ARRAYADD ( $ARRAYSRV , $VAR0 & $START & " " & $SNAME & "; " & $FILE & " [" & $SIZE & " " & $CDATE & "]" & $COMPANY & $ATTEN , 0 , "||||" )
								EndIf
							Else
								$SDLL = AAAAS1 ( $FILE , $SDLL )
								If $NOFILE1 = 3 Then _ARRAYADD ( $ARRAYSRVR , $VAR0 & $START & " " & $SNAME & "; " & $SDLL , 0 , "||||" )
							EndIf
							$FILE1 = ""
							$NOFILE1 = ""
						Else
							$FILE = $IPATH
							AAAAFP ( )
							If FileExists ( $FILE ) Then
								$ATTEN = ""
								If $SIZE > 314572800 And StringInStr ( $COMPANY , "[" ) Then $ATTEN = " <==== " & $UPD1
								If StringRegExp ( $FILE , "(?i)(dllhost|msiexec)\.exe" ) Then $FILE = $FILE & $IPATHARG
								_ARRAYADD ( $ARRAYSRV , $VAR0 & $START & " " & $SNAME & "; " & $FILE & " [" & $SIZE & " " & $CDATE & "]" & $COMPANY & $ATTEN , 0 , "||||" )
								$FILE1 = $FILE
							Else
								If StringRegExp ( $FILE , "(?i)(dllhost|msiexec)\.exe" ) Then
									$FILE = $FILE & $IPATHARG
									_ARRAYADD ( $ARRAYSRVR , $VAR0 & $START & " " & $SNAME & "; " & $FILE & " [X]" , 0 , "||||" )
								EndIf
								$NOFILE1 = 4
							EndIf
							If StringRegExp ( $SUB , "(?i)\\Termservice$" ) Then
								$I += 1
								ContinueLoop
							EndIf
							$FILE = $IPATH
							AAAAFPWOW ( )
							If FileExists ( $FILE ) Then
								If $FILE <> $FILE1 Then
									$ATTEN = ""
									If StringRegExp ( $FILE , "(?i)(dllhost|msiexec)\.exe" ) Then $FILE = $FILE & $IPATHARG
									If $SIZE > 314572800 And StringInStr ( $COMPANY , "[" ) Then $ATTEN = " <==== " & $UPD1
									_ARRAYADD ( $ARRAYSRV , $VAR0 & $START & " " & $SNAME & "; " & $FILE & " [" & $SIZE & " " & $CDATE & "]" & $COMPANY & $ATTEN , 0 , "||||" )
								EndIf
							Else
								If $NOFILE1 = 4 Then
									If Not StringRegExp ( $IPATH , "(?i).*[c-z]:\\.+[c-z]:(\\|//).+" ) Then $IPATH = AAAAS1 ( $FILE , $IPATH )
									_ARRAYADD ( $ARRAYSRVR , $VAR0 & $START & " " & $SNAME & "; " & $IPATH , 0 , "||||" )
								EndIf
							EndIf
							$FILE1 = ""
							$NOFILE1 = ""
						EndIf
					Else
						_ARRAYADD ( $ARRAYSRVR , $VAR0 & $START & " " & $SNAME & "; " & $NO & " ImagePath" , 0 , "||||" )
					EndIf
			Case Else
					$IPATH = RegRead ( $SUB , "Imagepath" )
					If Not @error Then
						$IPATH = StringRegExpReplace ( $IPATH , "(?i)http(s|):" , "hxxp\1:" )
						$FILE = $IPATH
						AAAAFP ( )
						If FileExists ( $FILE ) Then
							$ATTEN = ""
							_ARRAYADD ( $ARRAYSRV , $VAR0 & $START & " " & $SNAME & "; " & $FILE & " [" & $SIZE & " " & $CDATE & "]" & $COMPANY & $ATTEN , 0 , "||||" )
							$FILE1 = $FILE
						Else
							$NOFILE1 = 6
						EndIf
						$FILE = $IPATH
						AAAAFPWOW ( )
						If FileExists ( $FILE ) Then
							If $FILE <> $FILE1 Then
								$ATTEN = ""
								_ARRAYADD ( $ARRAYSRV , $VAR0 & $START & " " & $SNAME & "; " & $FILE & " [" & $SIZE & " " & $CDATE & "]" & $COMPANY & $ATTEN , 0 , "||||" )
							EndIf
						Else
							If $NOFILE1 = 6 Then
								If Not StringRegExp ( $IPATH , "(?i).*[c-z]:\\.+[c-z]:(\\|//).+" ) Then $IPATH = AAAAS1 ( $FILE , $IPATH )
								_ARRAYADD ( $ARRAYSRVR , $VAR0 & $START & " " & $SNAME & "; " & $IPATH , 0 , "||||" )
							EndIf
						EndIf
						$FILE1 = ""
						$NOFILE1 = ""
					Else
						$IPATH = $NO & " ImagePath"
						_ARRAYADD ( $ARRAYDR , $VAR0 & $START & " " & $SNAME & "; " & $IPATH , 0 , "||||" )
					EndIf
				EndSelect
			Else
				$IPATH = RegRead ( $SUB , "Imagepath" )
				If @error = 0 Then
					$FILE = $IPATH
					$FILE1 = ""
					AAAAFP ( )
					If FileExists ( $FILE ) Then
						$ATTEN = ""
						_ARRAYADD ( $ARRAYDR , $VAR0 & $START & " " & $SNAME & "; " & $FILE & " [" & $SIZE & " " & $CDATE & "]" & $COMPANY & $ATTEN , 0 , "||||" )
						$FILE1 = $FILE
					Else
						$NOFILE1 = 1
					EndIf
					$FILE = $IPATH
					AAAAFPWOW ( )
					If FileExists ( $FILE ) Then
						If $FILE <> $FILE1 Then
							$ATTEN = ""
							_ARRAYADD ( $ARRAYSRV , $VAR0 & $START & " " & $SNAME & "; " & $FILE & " [" & $SIZE & " " & $CDATE & "]" & $COMPANY & $ATTEN , 0 , "||||" )
						EndIf
					Else
						$IPATH = AAAAS1 ( $FILE , $IPATH )
						If $NOFILE1 = 1 Then _ARRAYADD ( $ARRAYDRR , $VAR0 & $START & " " & $SNAME & "; " & $IPATH , 0 , "||||" )
					EndIf
					$NOFILE1 = ""
					$FILE1 = ""
				Else
					If $IPATH = "" Then $IPATH = $NO & " ImagePath"
					_ARRAYADD ( $ARRAYDRR , $VAR0 & $START & " " & $SNAME & "; " & $IPATH , 0 , "||||" )
				EndIf
			EndIf
		Else
			$START = 5
			$IPATH = RegRead ( $SUB , "Imagepath" )
			If Not @error Then
				$FILE = $IPATH
			Else
				$FILE = $C & "\Windows\System32\Drivers\" & $SNAME & ".sys"
			EndIf
			AAAAFP ( )
			If FileExists ( $FILE ) Then
				$ATTEN = ""
				_ARRAYADD ( $ARRAYDR , $VAR0 & $START & " " & $SNAME & "; " & $FILE & " [" & $SIZE & " " & $CDATE & "]" & $COMPANY & $ATTEN , 0 , "||||" )
			EndIf
			$FILE = $C & "\Windows\SysWOW64\Drivers\" & $SNAME & ".sys"
			If FileExists ( $FILE ) Then
				$ATTEN = ""
				AAAAFP ( )
				_ARRAYADD ( $ARRAYDRR , $VAR0 & $START & " " & $SNAME & "; " & $FILE & " [" & $SIZE & " " & $CDATE & "] " & $COMPANY & $ATTEN , 0 , "||||" )
			Else
				RegRead ( $SUB , "" )
				If @error = 1 Then _ARRAYADD ( $ARRAYDRR , $VAR0 & $START & " " & $SNAME & "; " & $IPATH & " <==== " & $UPD1 & ": " & $LOCLSRV , 0 , "||||" )
			EndIf
		EndIf
		$I += 1
	WEnd
	If Not FileExists ( @ScriptDir & "\FRST.txt" ) And $BOOTM <> "Recovery" Then
		AAAAH ( )
		AAAARPM ( )
		AAAARP ( )
		$ARRAYREG = ""
		Global $ARRAYREG [ 1 ]
		AAAAR ( )
		AAAAEXTR ( )
		AAAARW ( )
		AAAARPOL ( )
		_AAAAT ( "HKLM\" & $SOFTWARE & "\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tasks" )
		INTERNET ( )
	EndIf
	FileClose ( $FRSTLOG )
	If Not FileExists ( @ScriptDir & "\FRST.txt" ) Then FileWrite ( @ScriptDir & "\FRST.txt" , "No log file" & @CRLF )
	If Not FileGetSize ( @ScriptDir & "\FRST.txt" ) Then FileWrite ( @ScriptDir & "\FRST.txt" , "Log file is empty" & @CRLF )
	$FRSTLOG = FileOpen ( @ScriptDir & "\FRST.txt" , 256 + 1 )
	FileWrite ( $FRSTLOG , @CRLF )
	FileWrite ( $FRSTLOG , "==================== " & $SERVB & " (" & WL ( $CHECKBOX2 ) & ") ===================" & @CRLF & @CRLF )
	$HSERVICE = FileOpen ( @TempDir & "\service" , 256 + 2 )
	FileWrite ( $HSERVICE , "(" & $SERV1 & " " & $SERV2 & ".)" & @CRLF & @CRLF )
	If $BOOTM <> "recovery" And Not $CRYPT Then FileWrite ( $HSERVICE , $UPD1 & ": => " & $NOCRYPT & "." & @CRLF & @CRLF )
	If UBound ( $ARRAYLOCK ) > 1 Then
		_FILEWRITEFROMARRAY ( $HSERVICE , $ARRAYLOCK , 1 )
		FileWrite ( $HSERVICE , @CRLF )
	EndIf
	$ARRAYLOCK = ""
	$ARRAYSRV = _ARRAYUNIQUE ( $ARRAYSRV , 0 , 0 , 0 , 0 , 1 )
	_FILEWRITEFROMARRAY ( $HSERVICE , $ARRAYSRV , 1 )
	$ARRAYSRV = ""
	If UBound ( $ARRAYSRVR ) > 1 Then _FILEWRITEFROMARRAY ( $HSERVICE , $ARRAYSRVR , 1 )
	$ARRAYSRVR = ""
	FileClose ( $HSERVICE )
	$HSERVICE = FileOpen ( @TempDir & "\service" , 256 )
	$REGEXPR = FileRead ( $HSERVICE )
	FileClose ( $HSERVICE )
	$DEPVAL = RegRead ( "hklm\" & $SYSTEM & $BOOTSYSTEM & $DEF & "\Services\Themes" , "DependOnService" )
	If Not @error Then $REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)([RS][234] Themes; [c-z]:\\WINDOWS\\system32\\themeservice.dll \[.+\] \(Microsoft.+\))\v+" , "$1 [DependOnService: " & $DEPVAL & "]<==== " & $UPD1 & @CRLF )
	If GUICtrlRead ( $CHECKBOX2 ) = 1 Then
		GUICtrlSetData ( $LABEL1 , $SCANB & " " & $SERVB & "..." )
		WHITELISTSRV ( )
	EndIf
	BLACKLISTSRV ( )
	FileWrite ( $FRSTLOG , $REGEXPR )
	FileDelete ( @TempDir & "\service" )
	$DRIVER = FileOpen ( @TempDir & "\driver" , 2 + 256 )
	FileWrite ( $FRSTLOG , @CRLF & "===================== " & $DRIVB & " (" & WL ( $CHECKBOX3 ) & ") ===================" & @CRLF )
	FileWrite ( $DRIVER , @CRLF & "(" & $SERV1 & " " & $SERV2 & ".)" & @CRLF & @CRLF )
	_FILEWRITEFROMARRAY ( $DRIVER , $ARRAYDR , 1 )
	FileClose ( $DRIVER )
	$ARRAYDR = ""
	$DRIVER = FileOpen ( @TempDir & "\driver" , 256 + 1 )
	If UBound ( $ARRAYDRR ) > 1 Then _FILEWRITEFROMARRAY ( $DRIVER , $ARRAYDRR , 1 )
	$ARRAYDRR = ""
	FileClose ( $DRIVER )
	$DRIVER = FileOpen ( @TempDir & "\driver" , 256 )
	$REGEXPR = FileRead ( $DRIVER )
	FileClose ( $DRIVER )
	If GUICtrlRead ( $CHECKBOX3 ) = 1 Then
		GUICtrlSetData ( $LABEL1 , $SCANB & " " & $DRIVB & "..." )
		WHITELISTDRV ( )
	EndIf
	BLACKLISTDRV ( )
	FileWrite ( $FRSTLOG , $REGEXPR )
	FileDelete ( @TempDir & "\driver" )
	If $BOOTM = "recovery" Then LUFIL ( )
EndFunc
Func AAAAS1 ( $PATH , $PATH2 )
	If _CREATEFILE ( $PATH ) Then
		Return $PATH & " <==== " & $UPD1 & " (" & $NOACC & ")"
	Else
		Return $PATH2 & " [X]"
	EndIf
EndFunc
Func AAAAUD ( )
	Local $YN1 , $D , $M , $Y , $V
	$D = StringRegExpReplace ( $VERSION , " \(x64\) Version: (\d\d)-.+" , "$1" )
	$M = StringRegExpReplace ( $VERSION , " \(x64\) Version: ..-(\d\d)-.+" , "$1" )
	$Y = StringRegExpReplace ( $VERSION , " \(x64\) Version: ..-..-(\d\d\d\d).*" , "$1" )
	$V = _DATEDIFF ( "d" , $Y & "/" & $M & "/" & $D , _NOWCALCDATE ( ) )
	If $V > 60 Then
		$YN1 = MsgBox ( 262144 + 0 , $FRST , $UPD1 & @CRLF & @CRLF & $UPD2 & $V & " " & $UPD3 , 5 )
	EndIf
EndFunc
Func AAAKND ( )
	GUICtrlSetData ( $LABEL1 , "KnownDLL: " & $FILE )
	If FileExists ( @TempDir & "\dlls" ) Then FileDelete ( @TempDir & "\dlls" )
	If GUICtrlRead ( $CHECKBOX4 ) = 4 Then FileWrite ( $FRSTLOG , @CRLF & "==================== KnownDLLs (" & $ALL & ") =========================" & @CRLF & @CRLF )
	$KEY = "HKLM\" & $SYSTEM & $BOOTSYSTEM & $DEF & "\Control\Session Manager\KnownDLLs"
	$I = 0
	While 1
		$I += 1
		$VAR1 = RegEnumVal ( $KEY , $I )
		If @error Then ExitLoop
		If StringRegExp ( $VAR1 , "(?i)DLLDirectory|DllDirectory32|_wowarmhw|_xtajit|xtajit64" ) Then ContinueLoop
		$VAR2 = RegRead ( $KEY , $VAR1 )
		$FILE = $C & "\Windows\System32\" & $VAR2
		If GUICtrlRead ( $CHECKBOX4 ) = 1 Then
			If StringInStr ( $VAR1 , "wow64base" ) And StringRegExp ( "(?i)" & MD5 ( $FILE ) , "CDA647B0FFF5A41AC4D69DBFE66EDE2A" ) Then ContinueLoop
			If StringInStr ( $VAR1 , "wow64con" ) And StringRegExp ( "(?i)" & MD5 ( $FILE ) , "B4BB38B4CEB356EA80089D7E227DCAEA" ) Then ContinueLoop
		EndIf
		DLLS ( )
		$FILE = $C & "\Windows\SysWOW64\" & $VAR2
		If Not StringRegExp ( $FILE , "(?i)(Wow64cpu|Wow64win|Wow64|wow64base|wow64con)\.dll" ) Then DLLS ( )
	WEnd
	$REGEXPR = FileRead ( @TempDir & "\dlls" )
	If GUICtrlRead ( $CHECKBOX4 ) = 1 Then
		FileWrite ( $FRSTLOG , @CRLF & "==================== KnownDLLs (" & $WLISTED & ") =========================" & @CRLF & @CRLF )
		WHITELISTDLL ( )
	EndIf
	FileWrite ( $FRSTLOG , $REGEXPR )
	FileDelete ( @TempDir & "\dlls" )
EndFunc
Func ACTIVESETUP ( $WOW = "" )
	Local $ARRAYNAME , $WOWKEY
	If $WOW Then $WOWKEY = "\Wow6432Node"
	$KEY = "HKLM\Software" & $WOWKEY & "\Microsoft\Active Setup\Installed Components"
	$HKEY = _REGOPENKEYEX3 ( $KEY )
	If @error Or $HKEY = 0 Then Return
	$I = + 4294967295
	While 1
		$I += 1
		$SUB = __REGENUMKEY ( $HKEY , $I )
		If @error Then ExitLoop
		$DATA = RegRead ( $KEY & "\" & $SUB , "StubPath" )
		If @error Then ContinueLoop
		If RegRead ( $KEY & "\" & $SUB , "ShellComponent" ) Then $DATA = RegRead ( $KEY & "\" & $SUB , "ShellComponent" )
		$CDATE = ""
		$COMPANY = ""
		$FILE = $DATA
		If $WOW Then
			AAAAFPWOW ( )
		Else
			AAAAFP ( )
		EndIf
		If $CDATE Then
			$CDATE = " [" & $CDATE & "]"
			$DATA = $FILE
		EndIf
		If GUICtrlRead ( $CHECKBOX1 ) = 1 Then
			If StringInStr ( $COMPANY , "Microsoft Corp" ) Then
				Select
				Case StringRegExp ( $DATA , "(?i):\\WINDOWS\\(System32|SysWOW64)\\(unregmp2|ie4uinit)\.exe" )
					ContinueLoop
				Case StringRegExp ( $DATA , "(?i):\\WINDOWS\\(System32|SysWOW64)\\(themeui|shell32|mscories|IEDKCS32)\.dll" )
					ContinueLoop
				Case StringRegExp ( $DATA , "(?i):\\Program Files(| \(x86\))\\Windows Mail\\WinMail.exe" )
					ContinueLoop
				Case StringRegExp ( $DATA , "(?i):\\Program Files(| \(x86\))\\Microsoft\\Edge\\Application\\(\d+\.)+\d+\\Installer\\setup.exe" )
					ContinueLoop
				EndSelect
			EndIf
			If StringRegExp ( $DATA , "(?i)%SystemRoot%\\system32\\regsvr32.exe /s /n /i:/UserInstall %SystemRoot%\\system32\\themeui.dll$" ) Then ContinueLoop
			If StringRegExp ( $DATA , "(?i)regsvr32.exe /s /n /i:U (%SystemRoot%\\System32\\|)shell32\.dll$" ) Then ContinueLoop
		EndIf
		$ATTEN = ""
		If StringRegExp ( $DATA , "(?i)InstallDir\\Server.exe|(:\\Windows|%SystemRoot%)\\servicing\\(?!TrustedInstaller)[^\\]+\.exe" ) Then $ATTEN = " <==== " & $UPD1
		_ARRAYADD ( $ARRAYREG , "HKLM\Software" & $WOWKEY & "\Microsoft\Active Setup\Installed Components: [" & $SUB & "] -> " & $DATA & $CDATE & $COMPANY & $ATTEN , 0 , "||||" )
		$ARRAYNAME = ""
	WEnd
	If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
EndFunc
Func ACTIVESETUPFIX ( )
	Local $WOWKEY
	If StringInStr ( $FIX , "Wow6432Node\" ) Then $WOWKEY = "\Wow6432Node"
	$KEY = "HKLM\Software" & $WOWKEY & "\Microsoft\Active Setup\Installed Components"
	$SUB = StringRegExpReplace ( $FIX , ".+?:\s*\[(.+?)\].*" , "$1" )
	DELKEY ( $KEY & "\" & $SUB )
EndFunc
Func ADSDELETE ( $FILE , $ADS )
	$FILE1 = $FILE
	If _REPARSEPOINT ( $FILE ) Then $FILE1 = _GETREPARSETARGET ( $FILE )
	$SZONEIDFILENAME = $FILE1 & $ADS
	If FileExists ( $SZONEIDFILENAME ) Then
		$ARET = DllCall ( "kernel32.dll" , "bool" , "DeleteFileW" , "wstr" , $SZONEIDFILENAME )
		If @error Then Return 2
		If $ARET [ 0 ] Then Return 1
		Return 2
	Else
		If IsArray ( _ADS_LIST_NTQUERY ( $FILE ) ) Then Return 2
		Return 0
	EndIf
EndFunc
Func ADSFIX ( )
	$FILEP = StringRegExpReplace ( $FIX , "(?i)AlternateDataStreams: ([c-z]:\\[^:]+):.*" , "$1" )
	$ADS = StringRegExpReplace ( $FIX , "(?i)AlternateDataStreams: [c-z]:\\[^:]+(:.*) \[.+" , "$1" )
	$RET = ADSDELETE ( $FILEP , $ADS )
	Switch $RET
	Case 1
		FileWrite ( $HFIXLOG , $FILEP & " => """ & $ADS & """ ADS " & $DELETED & @CRLF )
	Case 0
		FileWrite ( $HFIXLOG , """" & $FILEP & """ => """ & $ADS & """ ADS " & $NFOUND & "." & @CRLF )
	Case 2
		FileWrite ( $HFIXLOG , $FILEP & " => """ & $ADS & """ ADS " & $NDELETED & "." & @CRLF )
	EndSwitch
EndFunc
Func ALTERNATESHELLFIX ( )
	RESTOREVAL ( "HKLM\" & $SYSTEM & $BOOTSYSTEM & $DEF & "\Control\SafeBoot" , "AlternateShell" , "REG_SZ" , "cmd.exe" )
EndFunc
Func APPCERT ( )
	Local $ARRAYNAME
	$KEY = "HKLM\" & $SYSTEM & $BOOTSYSTEM & $DEF & "\Control\Session Manager\AppCertDlls"
	GUICtrlSetData ( $LABEL1 , $REGIST1 & ": " & $KEY )
	$HKEY = _REGOPENKEYEX3 ( $KEY )
	If Not @error And IsPtr ( $HKEY ) Then $ARRAYNAME = _LISTVAL ( $HKEY )
	If UBound ( $ARRAYNAME ) > 0 Then
		$ATTEN = " <==== " & $UPD1
		For $V = 0 To UBound ( $ARRAYNAME ) + 4294967295
			$VALNAME = $ARRAYNAME [ $V ] [ 0 ]
			$VALDATA = $ARRAYNAME [ $V ] [ 1 ]
			$FILE = $VALDATA
			AAAAFP ( )
			If FileExists ( $FILE ) Then
				_ARRAYADD ( $ARRAYREG , "HKLM\...\AppCertDlls: [" & $VALNAME & "] -> " & $FILE & " [" & $SIZE & " " & $CDATE & "]" & $COMPANY & $ATTEN , 0 , "||||" )
			Else
				If $VALDATA = "" Or StringRegExp ( $VALDATA , "\A\s+\Z" ) Then $VALDATA = "[X]"
				_ARRAYADD ( $ARRAYREG , "HKLM\...\AppCertDlls: [" & $VALNAME & "] -> " & $VALDATA & $ATTEN , 0 , "||||" )
			EndIf
		Next
		$ARRAYNAME = ""
	EndIf
	If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
EndFunc
Func APPCERTFIX ( )
	$VAL = StringRegExpReplace ( $FIX , "(?i)HKLM\\.+AppCertDlls: \[(.*)\] ->.*" , "$1" )
	$KEY = "HKLM\" & $SYSTEM & $BOOTSYSTEM & $DEF & "\Control\Session Manager\AppCertDlls"
	DELVALUE ( $KEY , $VAL )
EndFunc
Func APPINITFIX ( $WOW = "" )
	If $WOW Then
		$REGEX = StringRegExpReplace ( $FIX , "AppInit_DLLs-x32: (.+) =>.*" , "$1" )
		$WOW64 = "\Wow6432Node"
	Else
		$REGEX = StringRegExpReplace ( $FIX , "AppInit_DLLs: (.+) =>.*" , "$1" )
		$WOW64 = ""
	EndIf
	$VAR1 = RegRead ( "HKLM\" & $SOFTWARE & $WOW64 & "\Microsoft\Windows NT\CurrentVersion\Windows" , "AppInit_DLLs" )
	$REGEX1 = StringRegExpReplace ( $REGEX , "\\" , "\\\\" )
	If Not StringRegExp ( $VAR1 , "(?i)" & $REGEX1 ) Then Return FileWrite ( $HFIXLOG , """" & $REGEX & """ => " & $DATA0 & " " & $NFOUND & "." & @CRLF )
	$VAR1 = StringRegExpReplace ( $VAR1 , "(?i)" & $REGEX1 , "" )
	$VAR1 = StringRegExpReplace ( $VAR1 , "\s{2,}" , " " )
	RegWrite ( "HKLM\" & $SOFTWARE & $WOW64 & "\Microsoft\Windows NT\CurrentVersion\Windows" , "AppInit_DLLs" , "REG_SZ" , $VAR1 )
	If Not @error Then
		FileWrite ( $HFIXLOG , """" & $REGEX & """ => " & $DATA0 & " " & $DELETED & @CRLF )
		$VAR1 = RegRead ( "HKLM\" & $SOFTWARE & $WOW64 & "\Microsoft\Windows NT\CurrentVersion\Windows" , "AppInit_DLLs" )
		If $VAR1 = " " Then RegWrite ( "HKLM\" & $SOFTWARE & $WOW64 & "\Microsoft\Windows NT\CurrentVersion\Windows" , "AppInit_DLLs" , "REG_SZ" , "" )
	Else
		FileWrite ( $HFIXLOG , """" & $REGEX & """ => " & $DATA0 & $NDELETED & @CRLF )
	EndIf
EndFunc
Func AUTHENTICS ( $SUB )
	$KEY = "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Authentication\" & $SUB
	$HKEY = _REGOPENKEYEX3 ( $KEY )
	If @error Or $HKEY = 0 Then Return
	$I = + 4294967295
	While 1
		$I += 1
		$SKEY = __REGENUMKEY ( $HKEY , $I )
		If @error Then ExitLoop
		$CDATE = ""
		$COMPANY = ""
		$FILE = ""
		$PATH = RegRead ( "HKCR\CLSID\" & $SKEY & "\InprocServer32" , "" )
		If Not @error Then
			$FILE = $PATH
			AAAAFP ( )
		Else
			If GUICtrlRead ( $CHECKBOX1 ) = 1 And StringRegExp ( $SKEY , "(?i)^{(2D8B3101-E025-480D-917C-835522C7F628|A910D941-9DA9-4656-8933-AA1EAE01F76E)}$" ) Then ContinueLoop
		EndIf
		If $CDATE Then
			$CDATE = " [" & $CDATE & "]"
			$PATH = $FILE
		EndIf
		If GUICtrlRead ( $CHECKBOX1 ) = 1 Then
			If StringRegExp ( $COMPANY , "Microsoft .+ ->" ) And Not StringInStr ( $COMPANY , "[" ) And StringRegExp ( $PATH , "(?i):\\WINDOWS\\System32\\(StartTileData|rdpcredentialprovider|authui|VaultCredProvider|certCredProvider|BioCredProv|cxcredprov|mgmtrefreshcredprov|SmartcardCredentialProvider|credprovslegacy|TrustedSignalCredProv|credprovs|devicengccredprov|cngcredui|FaceCredentialProvider|ngccredprov|wlidcredprov|fidocredprov|rasplap)\.dll" ) Then ContinueLoop
		EndIf
		_ARRAYADD ( $ARRAYREG , "HKLM\Software\...\Authentication\" & $SUB & ": [" & $SKEY & "] -> " & $PATH & $CDATE & $COMPANY , 0 , "||||" )
	WEnd
	If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
EndFunc
Func AUTHENTICSFIX ( )
	$SUB = StringRegExpReplace ( $FIX , ".+\\(.+?): \[.+" , "$1" )
	$SKEY = StringRegExpReplace ( $FIX , ".+?: \[(.+?)\].+" , "$1" )
	DELKEY ( "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Authentication\" & $SUB & "\" & $SKEY )
	$KEY = "HKLM\Software\Classes\CLSID\" & $SKEY
	If VAR ( $KEY ) Then DELKEY ( $KEY )
EndFunc
Func AUTOCONFIGURLFIX ( )
	$USER = StringRegExpReplace ( $FIX , "AutoConfigURL: \[(.+?)\] =>.*" , "$1" )
	If Not StringInStr ( $USER , "HKLM" ) And Not StringRegExp ( $USER , "^S-1-5-|^\.DEFAULT" ) Then Return DELKEY ( "HKLM\SYSTEM\CurrentControlSet\Services\iphlpsvc\Parameters\ProxyMgr\" & $USER )
	$KEY = "HKU\" & $USER & "\Software\Microsoft\Windows\CurrentVersion\Internet Settings"
	If $USER = "HKLM" Then $KEY = "HKLM\Software\Microsoft\Windows\CurrentVersion\Internet Settings"
	If $USER = "HKLM-x32" Then $KEY = "HKLM\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Internet Settings"
	$VAL = "AutoConfigURL"
	DELVALUE ( $KEY , $VAL )
EndFunc
Func DNSPOLICYFIX ( )
	$KEY = StringRegExpReplace ( $FIX , "DnsPolicyConfig: \[(.+?)\] =>.*" , "$1" )
	DELKEY ( "HKLM\SYSTEM\CurrentControlSet\Services\Dnscache\Parameters\DnsPolicyConfig\" & $KEY )
EndFunc
Func DOMAIN ( )
	Dim $OBJWMISVC = ObjGet ( "winmgmts:\\.\root\cimv2" )
	Dim $COLITEMS = $OBJWMISVC .ExecQuery ( "Select * from Win32_ComputerSystem" , "WQL" , 48 )
	If Not IsObj ( $COLITEMS ) Then Return
	For $OBJITEM In $COLITEMS
		If $OBJITEM .PartOfDomain Then Return $OBJITEM .Domain
	Next
EndFunc
Func BAM ( )
	FileClose ( $FRSTLOG )
	GUICtrlSetData ( $LABEL1 , $SCANB & " SigCheck" )
	$FRSTLOG = FileOpen ( @ScriptDir & "\FRST.txt" , 256 + 1 )
	FileWrite ( $FRSTLOG , @CRLF & "==================== SigCheck ============================" & @CRLF )
	FileWrite ( $FRSTLOG , @CRLF & "(" & $BAM & ".)" & @CRLF & @CRLF )
	$FILE = $SYSTEMDIR & "\winlogon.exe"
	FILECHEK ( "06F01546E31B2C07BC4E1BEFD1995F04|31BD96BF39C5B62C17A4629BADF1323F|0C3FA09E0F3D223D3A6BF7DC34657131|2985613F9F28FB2E214F590295CE601B|EF0BEA08543CFAE93F231EE2D19CB1AA|5FB96BC3A8C64881E9DF25067592EA0E|B547D076A6A62634918B8B762B50B734|5CF49C3BBD3D21EF689112C01503AB04|519C6AB40D0CEBBD558935D10A3950C6|6E3EE4B417FB75A06B6117D2D6215AB7|AC8E6842E0A9C37B747F62D23EF372E9|4DEFA8B9492D944ACD6CC8FD7777B1B0|D0AEE0650591DF85618062825F8400A8|41791CB9318CFF31F32B01ABF1A70762|675B79984BB19B9E565EAEF7479A594C|F597FA958FD63ACCC90CB469E7DDC2A5|78FD6DC1F98BC559DF306EA756751B7D|F8B41A1B3E569E7E6F990567F21DCE97|B94EBFFE9D39584DBC7F7D062181A25B|85B8AC5DECA9A06475B26F2816105D43|FC7F68EE85A3AE64D6E58C2B2D673793|DA73454469C92DD85778A2737CC09510|B343A0B87CB179B4FE694E5371DF909A|7C91F62FBEC99E0EBBB2550FDB88E4C0|362F9D6C0C525A21E586E509ED79907C|A987B43E6A8E8F894B98A3DF022DB518|EE86712DDF0C59E6921D548B5548FF9C|DE4C860EC6038509E06E580F1BC375E9|BF6EA00C7E364065320924D71D545113|790D2A6C194038513919DA17C6B91549|8B9B35206487D39B2D3D076444485EC2|F85DEFC2BE480CB713D2F179CB5782E0|E7590FA4991FE5A934AE8B09C6362C7E|30B8FF833FB3D892DAB4827E00F530B2|CA0E2DF49879C57652531331EF5AE632|0F1284DA246D81DBE28FA6D5B48EE6CE|7A67355C1AD5CDD2E56DE303E4A3E31E|1690E047E23E9F89579D74DB747838A7|0DAE4B9FB1E2043C18B7A7E7CBA5964B|4294D7AD504EA206A4A03DB29311B6C2|11D6A262B617130F7C16E308C12E0D41|92419F3B74C6C3D7304B7665DA984552|749CA1F1B638E4E4A8A1F0990377012F|F9017F2DC455AD373DF036F5817A8870|C67E7F605A830AA96A204ECCDC678FBC|D0926E8FC082646487BD159538F4D9F5|8B67C13E6C000B14C1551FF07F15242E|B1102BBDDD9C87B3D609D6C08F7A3DBD|3F8645885823692D93765817759BE21C|9562F469F07315BE916AE3B780E2C42C|47FF22F309A19C495E6BDD90DFA92A95|EC498BAE1F0D3E0E401C963F8D76C437|536B686D86402D254C59B5DE3A575F45|7B24B823404D53DA4748F21AD2BF04C9|8CEBD9D0A0A879CDE9F36F4383B7CAEA|75DD70A14145499C9F7D903CF9A8C91B|88AB9B72B4BF3963A0DE0820B4B0B06C|306EB21E5B480AE9065EA55AC8C35936|BCF2036A0DD579E47C008C133550283E|7C94FDA3809015B8F2208D2E1C221F17|1151B1BAA6F350B1DB6598E0FEA7C457|93AB226C07A9789B2EC7B41F73602F76|1F84B5F8DBDFFD36DF143C61CE25F12A|DA3E2A6FA9660CC75B471530CE88453A|132328DF455B0028F13BF0ABEE51A63A|6D0773A3A65D28B663F334C90441D01A|856491FCED98093D824B9EB2892F564A|7FF135ECEB263BB7B26B1D06AFE49548" )
	$FILE = $SYSTEMDIR & "\wininit.exe"
	FILECHEK ( "FD874679F962A4CA611332D569ECEDAF|75E4D270028EBD17A2E60F707F930894|92D877C85741FEE1EED8D22D566F56F8|583B60A43F502D90331E6589E1DBC6DD97C1650A27721BA00D39DA7D8092276E|11E8AAD88B0BEFD6D87FD003052AA78A|E72284A1301EC8A119AE863ADD26D0AA|926BC1C0F525809AEF198F563FA6BA86|2E3ED905EDA55A2F8F0D592A58661D52|1FD4446BC2C8154A3A063EF0DEE5C166|3B27F411AC8A94BA927614D7C598EBBC|5564A66919C86CCE0D91DEE29C613704|D6E3B995E46D08046875E60ECCFF109B|9EFA02FBA3A4A914F7E800F3D5B2DF54|6A5110ED320EE52FE069A68F3D989836|3588C1AC44DCE86A043310B07679C508|663AADD311AB334B5715D16731A4BB93|F3828D75795D5AE4B2D8B828026A4EAA|9EF51C8AD595C5E2A123C06AD39FCCD7|DB516676B9D40004985E6D25A74943D7|4BD4AFF6FD90E92043818B79FDE27F09|E83650F70459A027AA596E1A73C961A1|9520279A6AD9B4A25815135C6B39CE16|4E20895E641F2C3E68AB3DB91A1A16F1|A58B0CB069DA7840B935872ADCD7F0C2|BF3E1D9B2360C6BE4CC3094CD2DDC617|D9516405E05F24EDCD90B1988FAF3948|EC302D06155F8E3C383750993FCB6B27|9A4BA96E87A1FD69381249557BDE2BF0|A570A64292214C43E0BA50E6A72A6380|CAAA293DD133160DF13D95CC48FC42B9|CAD491DD9EC00BB841EA407D9C498C4A|FE9AB232B56A12224E8A3F3F9878C9A3|94355C28C1970635A31B3FE52EB7CEBA|48CFA7BE561A7BE144C29BB912055016|117EA87DF785CA1B9D821F6F213DCE07|AF04DB3505B6316458381C1BBCF34D2E" )
	If ( $OSNUM = 6 And @OSVersion = "WIN_VISTA" ) Or ( $OSNUM = 6.1 And @OSVersion = "WIN_7" ) Then
		$FILE = $WINDOWSDIR86 & "\wininit.exe"
		FILECHEK ( "B5C5DCAD3899512020D135600129D665|101BA3EA053480BB5D957EF37C06B5ED" )
	EndIf
	$FILE = $WINDOWSDIR & "\explorer.exe"
	FILECHEK ( "546B7ED311EC0DF8097B6F8B206BEC8C|0ADEA275061771555E05F5FD383CA4E1|75CB22AADAAA6FB15CE7646ABFE40AD6|F1846BB7F670919E97C2196F5EB6FAA6|8479DBE06193148EBB71915209E8EC26|38C5BAA5BB4685A66F7B661B17BA53D7|7BE03DCC9E6EEE0F811F680C66CA05E0|238538D74FEA273BFF1E00622ECCAF3A|5B7BD7BAA985FAAC55616EE65AF77E7A|8E53A6DFAF47CFD6368940AA5CB1C817|90F012A88EAA904F0A62A86141BE4C2B|93233D1A8C042DBA4326BE6EF83DAF5A|02280F4613E3D8EB6579D79AB7A182CA|DCABB72C31BEBBFDBCB2315450FD3283|DDB206DDECAF3B327A418B262EE33468|B65C956775B7ED15B10CCD90CC9D55E1|CD9DCE5F27AB619F277FEC6101346532|8615CD26B8A7C9C591F715690F0CB615|8469E944453ACCCB97CA140F5232616D|D5DB5FCE46653533C7E2880D0C36EEC3|E810428CB38EC7C960C98BF36F9A240D|BF28F45B6CC2B125A10C0F7CF4AFFDAD|7A413DDD10E81ADB6BB5D5E38F399D08|2B47C89252BB932B292122E54C3DAF25|5D7CB52E9A35F4AF3B3592BBC69CA64D|1BD5BAA72845A11622F75731658C515B|30DECEE483A8196B30643EC6A453A7DE|3F786F7D200D0530757B91C5C80BC049|6BE0C03FDF70476959B6BF38A5924A34|5EA66FF5AE5612F921BC9DA23BAC95F7|FD5541611456E27D8BF3E90DDA34DC4E|62022614D1D9290CD1069234F2A55CF8|4BF8CF1A2379B0054860EC220CA329B9|F5883F210AF1795C1868AE570FCB7185|EEC7F02FBAE12687726D441FFADC051D|91BCFCAB8092A94CB7D60509BA75ED1C|A19D650F03BCFFDA514B068CF2DF61BA|12321D7CB0BB6BB113297E915BC248C4|3EAF5EA1C929922873016439091C21A0|8916534C5CDB068AAB715B0EBDA01539|C56BF71C18D9CB67F7B9986817A481BE|A0CA08AE74281E353039AE76CDA20EA9|5D8F7342385AEDA1FAC6B34EA91014B4|F2DD6ACDA452863DC7CFFCC4582FA970|021A4A566AE86079929A482DCE9B76A7|F7DC8A74E30E08B9510380274CFB9288|EDB7310E307174A6BDF0DD8FDF366464|4E196CEA0C9C46A7D656C67E52E8C7C7|5BF20D72234EFA5640E8DF7F25F3CDC1|D7874DD30BA935AAED6F730A0ED84610|F1D9600C5E0A191C6FE18A4436116C7D|2F62005FCEA7430BB871A56F7700F81C|D033CC75DD4CC0856E89B2A87559C2CC|E4A81EDDFF8B844D85C8B45354E4144E|28A9316147DF6223D0AB7774706B55EC|AD5296B280E8F522A8A897C96BAB0E1D|A77D56422C38C1F8A00D95D2D5B1675E|2B41096DED5180E1FE733DFC652D1AFF|92B369312AF5D0B83AEF82D5DE0428D2|00ED6649EF613696448C57FA9236B998|302F451BF9FAD6BC69E76D98CDBCA2BC|4312C7F7CA8CC13A475CB150EEB5F35E|C10A66189DC8C090E7C84873EDCEBC88|ED6B4C95E2A6D67480B9DBB8A8E7D9B4|38AE1B3C38FAEF56FE4907922F0385BA|94FDE1A551352E1305E48EA853C4E907|4E09D16BD3D98831C42CFD59E88E5807|4CE0C733CDCF1D2F78532BBD9CE3441D|E1B0AF69BFB6CBDE9B53C55E4BF91992|C6F56519F6F8A5C1B4144CF863CDE0CA|95D730526EF81792CD6848D8D10FAA1C|9D77CC4A36FEEA644D002CFB9B2D42C0|ACDBE1ED38167C8B01B8F63161BB2CEA|81394C91B7B5A7C799E249AE82491F13|AC4C51EB24AA95B77F705AB159189E24|928791755FDDEA721B053535EF84FA17|63DC38C3E4564B2405D562855643ABA2|C1400519D76A364E974E47BBA62B95B0|0E8E6463F81C80AFBED533E0F1F8895D|0862495E0C825893DB75EF44FAEA8E93|E13A31D5254C25406A7946BDD9B06364|332FEAB1435662FC6C672E25BEB37BE3|9AAAEC8DAC27AA17B053E6352AD233AE|C235A51CB740E45FFA0EBFB9BAFCDA64|BBD8E74F23D7605CB0CDB57A1B25D826|6B08E54A451B3F95E4109DBA7E594270|F170B4A061C9E026437B193B4D571799|ACF8D985D07999DAA575AE64E9768A96" )
	$FILE = $WINDOWSDIR86 & "\explorer.exe"
	FILECHEK ( "7B9E25BB59909CEAC53361D01663F4BA|F06FC587301B8756921A63BA1C86A1DD|207148EBD2AFD7AFA61CFB97F12AB5AB|463A96F7D9E4CB3F515FED4D906B92B0|F8251AA3D577984E40EE630527942AA6|06C1C043320B6E66458520C2C75F7C64|004695C197499EBA4679ED11075157C8|900D6BF82CABD9093CD9727C409210CA|F23DCD3ECA152C3EFA1759E778409C61|614CB1AAA6261E599FC1A90C9C0AFC74|CAD2D8D2F34B38A1F912FA36B99C2A6B|312DB894D605E5389EC84C5250D5BE84|252F7F69634B8371CA99BABD26AEF475|21E54AF2E20C62DA924C69D48E1DE399|6F5D250EAEDE1D80806ECBC487C7B9B8|700A010F0AFD16C8FB7DFDE2C2963ECF|501A977DF9DB631BCBD324A941E02909|9AE7BB1F840AE6EC66892F936148BFB2|286973D47102E8C76AEFF7A54A53BAE1|69B42943C3004791E159D4CA49A5A901|9F774AF4280D3CC30298722826F08850|4B553A43D062B7552AF00805D13CB37A|0941E61FF4B1C20B183843C66A939B3F|4E211C42F3AECBEDE0E29950ED3C4368|7D2C395B629A32108F8ED201D7D4600C|1E06C1656E1567F3ABF6FEFD729351CF|0155E85852FDE62A441CBAF485E023BE|00974A3EC781EE51D73C44F8FB64E85F|C35C6E5CAF6E0BC33AB3C68C4448754E|ED8F152C2498988F130BA8D85B321E12|702A3DE5C468897888D634F3CAC254F7|77984E5D22B97FBFF9FE326DC96F2C19|FDBB40401DECD8585D534A41AE2960FE|6B94A743F19EB84FC32DD86FAFE73D48|5E384A7E1F5A78A091ED7B0AD4D62724|6C0318E0320C85767DEB30CE42EFFB09|D7F24279DBF00B5E19DD7CA4B71D83FD|0E43AA24BF23EAEC5F4A4A77B318AD58|537FAD154748A9A1114F4EAA6547DB1A|A36E0D372EF2E31690D642220EF482AB|BCACBDB782A0D1AD4EBBEE43DA490876|044012CDAB5ADE610782EAFA1C384CB5|2AC8E2DE1A3C2DDE2C37568AB007153F|B8744AC6493A5126DA7E2349D3DCAA9A|710CD555C00C29C59152DD50CAA553ED|11C8E05CE261AA96A47BB6196E906579|66D168B3A5CAF573FD8399BDCB9269A7|9F1D18583C7DDB8FC8DA09A37A830EDB|1473B9D949F2480A92B876DCC0682532|33B132BE164983BA14F732253E786DFE|5E6C45B6B2F9BEA0650CF2279ADE678B|170A2515F8C7B58697E45720A8324FEB|499B0D1F6277F17B3BAC525B8717C064|F173C38E9BAA09191312B3E706C1DFD5|166AB1B9462E5C1D6D18EC5EC0B6A5F7|E79CC4B9A9EAA1E5D801742C093043A9|3F7DFCC49334A83CF9CA1213A70CBC9E|152D8FB49984351A39F87A592EECD896|DE1770C753FBBB197FD16A02422A9962|EE1258224916C55F4251ACE1153620A9|51BF1A2C033F61A7CF665244731D6C8E|91E24273FCA076EA9E65DAFA98901225|042216FBB8B0CCC7402C3C77E58E1BC9|6DDCA324434FFA506CF7DC4E51DB7935|DD5FC870BDE759BF621B86C9BEB8FDE6|B118183E015EE8EE5EE0FB650C2D8813|E0C84A30581BC508E289E4371A723F58|9180E7A47852FC2EBDAEF0B1F0D146BD|49A9479F4044CC5734DF2FA0831B5F61|FCBCED2A237DCD7EF86CED551B731742|2A156D5EBF221EF2A6AE7CE452324DAC|195822ACCDAA2B4815DD01BAFC335595|119E091B5386379BC5AA598BE9440C75|40D777B7A95E00593EB1568C68514493|1A0BC9598E4A58FC84570FFF5A108E58|5B6ED1B57DBFF18D405A0260559B571E|EAFE46B0292D2BD2467835E2ACF717CC|712B0D2ADE5297563168C997DDC2DD13|8B88EBBB05A0E56B7DCC708498C02B3E|953ADECFF08202A01EFC6110214FDE02|D07D4C3038F3578FFCE1C0237F2A1253|2AF58D15EDC06EC6FDACCE1F19482BBF|2626FC9755BE22F805D3CFA0CE3EE727|15BC38A7492BEFE831966ADB477CF76F|B95EEB0F4E5EFBF1038A35B3351CF047|4F554999D7D5F05DAAEBBA7B5BA1089D|9CF221011009E82742CDE1BA4AE94F5C" )
	$FILE = $SYSTEMDIR & "\svchost.exe"
	FILECHEK ( "7469CC568AD6821FD9D925542730A7D8|0CD128F416A04C06D50EC56392C25D9F|145DCF6706EEEA5B066885EE17964C09|8EC922C7A58A8701AB481B7BE9644536|2A40173302513B119DE147EE43E07189|B7F884C1B74A263F746EE12A5F7C9F6A|CD10CB894BE2128FCA0BF0E2B0C27C16|FB118E243E216B84B3838332DA8F5665|F586835082F632DC8D9404D83BC16316|95043977365CF88A80161BE9CF3281FB|9520A99E77D6196D0D09833146424113|8A0A29438052FAED8A2532DA50455756|32569E403279B3FD2EDB7EBD036273FA|440684C4F823AAE2CC587363F9C477A6|2F50120369617267F94C0A139542EB7C|3120B24060924F9B94182A1432B2D7F9|E3A2AD05E24105B35E986CF9CB38EC47|A1AEAFC58DF7803B8AA2B09EA93C722F|8497852ED44AFF902D502015792D315D|DFDE777FAF31DC25E3624E8071073146|C78655BC80301D76ED4FEF1C1EA40A7D|E4CA434F251681590D0538BC21C32D2F|57350BEDE3834915B6145B67C71C7BDA|EDE27EACE742EE2888C5DD36400A2EC0|CDA9F1373805AF88F6FA4F2064BBA24D|6F68F63794097E54F36474ED4384B759|92B919655BA013E8687E2AE873BA56ED" )
	$FILE = $WINDOWSDIR86 & "\svchost.exe"
	FILECHEK ( "3EFEB8ACDF4ED1D79EBBBCA4D2294B78|3062DADB197FE1AA0EB47D646B639145|BBFF42F3C7E8FC0E3049F6F88FBB88E2|B96D1C078A724E31B6F98CDB999E47F6|5B17B6349FFBAB655649CEA001431379|1ED18311E3DA35942DB37D15FA40CC5B|47E30C6C77B4149C7F50BB7C22CC4A76|03C502D5D9F66850493F66FBAC233105|B7C999040D80E5BF87886D70D992C51E|5465B544907B32F8665635A68EA623B1|A7296C1245EE76768D581C6330DADE06|23E47CE30CFC49F60A6E24B50AA83B9B|FA6C268A5B5BDA067A901764D203D433|15556928CB0E9F74F4036411D8CC111E|51EEFC52268490E767D5587C9CFF4376|6BDB3091562E7DD2C877472286B6CC46|D0ABC231C0B3E88C6B612B28ABBF734D|A412DEDAC6A1FF7BA06FEB3B6725495E|6A1212077C0559029CDFB9C39580C835|FFB38D8AFD6F4FCA1D46D64F1EDE0B9F|54A47F6B5E09A77E61649109C6A08866|425E22D9F5C01616AFC92987791B19E9|0A175AF8B65797BD22C11903A8BFEB2D|A46DC432F81473F526E3994AA483E366|3794B461C45882E06856F282EEF025AF|ECDB182F885292145826C58252B53000|D5B55F18A7CD2A6F4019B17BAEEDC2F3" )
	$FILE = $SYSTEMDIR & "\services.exe"
	FILECHEK ( "5A9F3CBEC6D26A85C2557937C57384BE|5659BAF3AE9DE6E8374F1FC62749B1DF|8F599360AA25B66146755C48BBBF4E3A|4EACBE64BB1E7D58E8A26340ED1C7CBD|F262BA7A4F04124CFD06D6D8FE69CEAE|8D82D0A9B53FC1C83858006E92D5755D|C497C3C5EB0FE16A43D56B9B1EAE8D3B|E606E7E0D5E94AF8222715A24DF0776B|14B88FF4833012512278A5F3A5712BD2|2195E001BA051309255F7519CC0E9333|8EF1B55ADE9CCC3C6D0E1EC8B2205F20|D8E577BF078C45954F4531885478D5A9|2E462089E921C88A95706F58FF7A1D5C|1B8FD5BCAF4B90950D50AAC16B0DF9A3|448CC197BC3B10D3E36A2CD30CF32DFE|EA0F7BD8DCE3ED0DF7D477B5F09986BA|D02627D25AC3351BB87760B9D1C7F1F4|C9998B1FBD08EC9E2F2914BA7718F297|9E5DCAF803A296D5C7F0185BD3EA4BE4|BCCC12EB2EF644E662A63A023FB83F9B|4B3A70E412A7A18A4DBA277251E85BCF|4686755EC38D16D00963518D9A0BB394|FAE441A6EC7FD8F55A404797A25C8910|7FA1495521AF93EACC859E104D8CD7AF|7A20DA1F1406492A70E9C8243634467B|2FC61B2CF84792516D543CA94139A92C|E2F4C75AFA20E742DE1B70372F15DCD7|AB75687641C9ADBE22336EC3C496909C|A219989791DDE8880B048E2214867E6A|16B7B5FC9533777CE5770CEE52D81A86|E0C7813A97CA7947FF5C18A8F3B61A45|38382A6B73FB37EF692DCBD882AB1FC4|800D00D1A7ADA9E341CACDF287347584|5BF02EBEFEDC706318C96E2E60EDCB91|BB3D8E1C108F7244613FF3993291A922|6FF8248F3A9D69A095C7F3F42BC29CB2|71C85477DF9347FE8E7BC55768473FCA|067CB90C277DB4A737D5DEABA3055972|0e776ed5f7cc9f94299e70461b7b8185|24ACB7E5BE595468E3B9AA488B9B4FCB|754A2CC1F32107EA87CBD305ABE3E618|B4B610BBCB002EC478C6FD80CF915697|8F226143046435C75C033B0C52E90FFE|DFAC660F0F139276CC9299812DE42719|934E0B7D77FF78C18D9F8891221B6DE3|0A87F57DFC2C0EB9BBA8BE1C87BAFE1A|B5643CD44EF5F7514D1C6BA2FBBD5E7E" )
	$FILE = $SYSTEMDIR & "\User32.dll"
	FILECHEK ( "C4DD13147F87E30004862306929E5600|70B722061D4F603B8BFC81EA6EDB9FCA|CA8C49E2D541D4564DCEC9C6CE7D97B3|69D72A21D743029EBF6B61F9BD856D3A|60C9BA328231A75B2437E479E88E0942|CA582529DA408164F6B8128AC5B72F16|CA582529DA408164F6B8128AC5B72F16|F67C73427D36BBD605C23EFFA9A97785|654491562EA71AEFAB781A4DF4430DF4|9C97D5400DF844FB7E920AEE07A5FE58|0B46860C338BF961B9215AD3891E051B|3FFE39167D90AE8CBC341233E6304026|4D3D5B2D922C3AEFB10B50B93C04BA4F|C4355F76AEFAC4CD89F4F61555701930|47E9504B11E474139DC34730ADF59B64|87892D4DBC67D42CBA05F9924A98ABD4|027BE4EC2E361F040BF186279C73D05F|AE7078CA50E8ED3923B3E0FFCC82D539|771DD44C3A1376243765108561BF6FF4|3D2A6411D06E658A2AB3C893CA691EA3|8638404CAC7EAC3F44824EAFBF91A715|4D523C5D081B51CCF43E0C6470C2F50A|83F6D081F9C1E9700DBB45CECFE72D9D|F804D60514EC31233E6DF99949B7FF1E|50B8764263C11FCF598B5818CD3E86FA|A344B6C6304FCD7DAE72DACA784EE53C|BE905FF10FC444DEAF15C21A18EF29C2|C71797F0E8E247DBCD2EE0428382E159|123D3E401EFA07BBAA395DB996FA18EB|442D79E9E74E7B8C2905CF2FE6215F46|1128DD0060477750C956CF800F62B468|CD33B1087F83D31DEE23DA99F8CE7158|97B722DA297E386669756B9ABD318C02|8960A03B202D765B63677F85AE2647C3|0122FEC539513A4C76E4DAAC2A0BC929|CB9689A5C8F7B8025F21415B92D1629D|98FACB2867900B776180BDBB3239BDFB|110F910867E0E0604BA1A9D561C23AB9|D462BE9023E652F3250A7732064117DB|75FC38097045E797A5F6ADBED5B464E0|B1BE32DF154076078F0DDE943D8F2BAC|B99165762698FA1C73198CA4E1D84A48|AB7FB6A73396C3DF05B37C19BFF87609|56668D916062FB7D6919886CCD295932|FD0928BF36D147267C7934CE1703BD0A|4BDBC4CF9685010B81F74A40D40BEF9F|7728E3DDB4422490ABA0CC60A1764B93|44F5E9206813B92918F5BB5F42F8E5D0|F9068469C512AB3B8EE0306A1B40CB56|CEC499E17074BEF1CF32BB0AF742F2D2|1B795B9EC9E0EAADC5B37006BBE44646|0370364D4D8846B6CF316ABBB2EDB083|3A4B2BBB3DA12E9DF2FE07D834026485|A5EEE7887B788F369D480C44C3410751|421B695412FE0D5B0C0DB00C51EABA1B|33094E2182C451BCFCFD60F734B1C4EF|A1FCBB7AFAB5CA0ED9E61ED047412941|34BA256FBF83457F9D5E51A56DB54542|9F67071B597A3CCC8C11CE761CE88B04|25026E350BC3BE37631634EC72B10BD5|75EBC59EAB1B4484FFC9B81DD5F4BE46|DD97EF0AE9224B8C1161736E033C03F1|06BF84D26A05D400F6B3FB3D3DE0B03A|F0A117D19873FCDF801F082F33BFBB6C|CEB069C882A0DFEDBE5C1590D44B1052|FE70103391A64039A921DBFFF9C7AB1B|1D08594400EE1B500B93256795FE30AE|1A811BAFA2114C2FC878507F9F86566C|A99AD14F26BDA7D7F27F76BC91B7EED7|72D7B3EA16946E8F0CF7458150031CC6|F3F5549E69AE8509342E67E4F972CA1C|32B87D215905F648EBE36A621978442C|955A6AA5B81C2BFFF8A47DBD9D7F568E" )
	$FILE = $WINDOWSDIR86 & "\User32.dll"
	FILECHEK ( "65D0F8ED768B5B8E286C09D1C1CAE63E|DEBE5FBB616458CC34C40256C34C9EE7|43032302B18479547BB9299EDBCE7F5E|3AA92390ABE2CCFB285F983C59D5702E|8C16D1E30535FC070A80315013E0D847|750BE480E63C634A714E7E164D5AD068|85EF046E39F2327FA7E6B736C3CD0746|85EF046E39F2327FA7E6B736C3CD0746|F3FB731066326B30BFC6FF2D6E334123|D3ABF15D19973B6CE01B990A34FFA7FE|C18AC44F6C9A81455BE75C3515F112C0|6270CE7EF03A2627560D4138802CFCCF|CEB9E8C335C1718E0172E252E378B2C6|8CC3839D55AB79F060F09093E561780B|373C78AEF88583589E559B8EAA94D4D2|87016F302E009BB5D38D2B8EC8611F8A|214CF0B780451854F1BB4EBDF3B7CB49|A4501B99978719BA1514447DA624A6A9|0BC1062627E152B7A7A1806D97D9161C|54C5EBB3384477ABBA845923612698CD|45EE87D6AE95CDEF8F5B8CF837DD60F6|19D817C63F1F07B18DA9E8A586BC699E|41C780A6DB5D02CC13D8707D944BB599|A64E7FD0E1E63CA187C07B8E09A3E838|75C321F6A9811A6A52F29C8442757506|EF8B92D396945E045A3A9CFFBA7D2E67|190C432478FDE34D30A1290B56FE25D5|B08CE13BBA10E6ACE0EF6C6314A205BC|293B7C869E23F4EDEBA66731CF33EE92|8A4B88FFFCC661A3824860467CEB1D78|5870EA0D6BA8DD6E2008466BDD00E0F4|312C65117D8DFA76CDCA3386A970FF9A|8E381385EF64C4F29A1001141BACCC97|61641CD06DB43BA5F9BC324AA76C6BF8|89F28DFC4587691C52CC08FB098DDFBD|CA6F790EC4E46F728FD3D0BDA863CEE0|0476CBD27FE1B8F5F6BA31359156B247|2A29F3B102E10B0E5E7036CD4D03A27B|ADFCF768FDFCAD0B8EEADD3D9CC6CE30|0B744F1AF04F7AF4EFEE73BF1DEAB1FD|860C531059A578292D780DDD5C1EAE1E|CCD4AE6A766033327A2A23AFD1D4A0DD|0190E2C9E5D53BE9CD22FB12A7F95EEC|7394F7E64440C916C8E2A9860D680873|E5DB7A5F13AB271A33E2C265AE264C10|FCEBED2FB83A6D28DD93A2A5F19CE05D|EC0B340C394C5FBAE4FC0144A86C5E49|5497403DFC45BC98B56BBEE569CC92A6|ACE797CA100BA7AE807BFB4F4DBE3B85|7341DFF925603ABB45B65088454DA487|704773372C9F0E74C70732B1FFF6251E|64B757C329016884AD578CC77A306673|8F5D67DF2DDCFC69E952042D48B9E4C1|4FAE44C596DABF42F1D7093D7B39A426|13EF48D0755A489F5BED67BFD5E145A0|5AA0F4573AB4E6B12E0542A23857E1EE|F0D05651268F96C4CC4CE5D813159DC5|80C661ABE79DE151456280D27FA83243|B9DFDDCD276872A0A71A3A6081FE3019|5D41A00F6ED104C9639D5CBF0D38A1D6|BA27A4D9D32C0D0999DC9165E648F70C|8CFE0C52FF552AB385570EB38FCFE766|94106EEBAF6E43C7E31E26E1C378BBBA|72DF14DA8F1CC15F7BE4176DE0404D9E|43A63F0C3F3EE760D10F98EEBAE07CB2|CB074875AC88A7C1010A2A7F9881A8C|CCA445CB2F0B36B651E976A3BD1FE26E|76C5CF09F53A3B089B5581B9938F8CAE|729FE09CBAE7DCCBE43FA83D63A87278|B8C4EFAA6AAED98E6B5AB57CAFA489B9|0A78439765E31510D75C9E2284F3A722|5F333FDBF392850373C89BDA31EBEC1B|C7099D6A46B880EE194F7A4473D71E10|5E0DB2D8B2750543CD2EBB9EA8E6CDD3|8A93F57772FD24959F76A65FF79D282D|C72456BFFE941714CF05B0AA0BEE5B45|170A3370144196F72A04038B652732EF|BA1C3ACD929A71E88B49C2B6E38F92B3|E8B0FFC209E504CB7E79FC24E6C085F0|D29FDB5DEDBDC1BD882164DC6DC4DD53|3D691030DBD3BD75DE1501BE54F0D425|5B03C1B3BA9AE9A2BE741683ABFB4B74" )
	$FILE = $SYSTEMDIR & "\userinit.exe"
	FILECHEK ( "90936148E7E5C4CC749EF4FF53EDBD43|FDCEA6A7CC59C20D3A4B474E3807D14C|FB4384E967D98D449142B8EFEA52AF45|5CDC907C7818FBAA658FC9F2ABB238F1|27FD6CD54247A6584CF95E20F5F90A1C|2D655E1228377BA11549A886D46BCF92|1412FBA6C15428830BC27383D9D34D6D|AEBBFF5E67C820F9A1C0242B004872C6|961093C2AA93542221884B14EC103899|9C4C281156040CF01EA35D759092F540|C0C3F54B6193AB5C5C20701F989B2D85|4BD360AA9EE1D969468D2FBD5632DDBC|47BBDBE152A597F4A840C5269ED961E8|F8DE4D36B6E6F7D7D6666A882312E1D1|D0C11ABFD6C7E4C58CED7B12953565E8|582A919CA5F944AA83895A5C633C122C|B78269EF4034474766CB1351E94EDF5C|BF8825D08BC235F0609CA8BBEF4E179C|7866C803DDD8D626D760A313B6D92F16|755ED4FDBD7D6C3980610E26E527E2F5|46B72E05D0B9F489CA60DBD7361039B0|5C131534A3EA4A461A793FB507A8004F|5F6D4F12EA33BFC0F0F8CEEAC332AB2B|8F3ECCB5DC878FA14887B43CD148CBA9|BAFE84E637BF7388C96EF48D4D3FDD53|0E925F7BA032920D58DD284B6181A247|08C191B2917862BE90C33E31CB6B6D79|6F8F1376A13114CC10C0E69274F5A4DE|A0AB2BB9A92293D9CE66E252719AB5FE|A46B3610D3AC5A9DB204DD2B40E298CF" )
	$FILE = $WINDOWSDIR86 & "\userinit.exe"
	FILECHEK ( "2F17D465E68C134FA258A903ABF78F6C|066FCC3972F458B8CA64C9786F6F9983|0CA2094D5A3F1829A4DFD82B4C6A2A4D|63EDB0AED4F70B7ADBCFDD3935389322|772F493D66617F7FD8435BEDECCCFC6E|150F3EFE33C9355A15450D39678E05DF|33C9780D854A400DAB73D8FC050127DF|A2AD18D222862AE52FD94AEDA82E8EEC|CA9EF43AE662E5EE8B28A125FE5F7CFC|ED4BA229401F1F61C9736682F42FBBE5|DCE5C8895E5CB0FCA1AEAF980D8C2DE7|24892AC6E39679E3BD3B0154DE97C53A|E280CA75A47614D70C4DC791A1236B73|05D02F412A916B7322AB94E5D8EA9767|A83702100F695127901004594BAF8E84|2FA05B1CFC52E590E090705EA56F5B02|B01FC72D5368EFED56F253D5A9D4CB60|5495BEE081B682FADE7B79C331711D2B|61E7F56A1C00894FCB212F25BB52EE68|D10643FC0095434C819316CA6CD748C0|A89C18F5E6D8981D5E937B325290915A|A878CF325C93723B5017642E6FDB80E8|61AC3EFDFACFDD3F0F11DD4FD4044223|9F6289D194A04A09671FEED4B6CB6EF7|41636F77AD6D9A396EA34E4786B96F2B|0E135526E9785D085BCD9AEDE6FBCBF9|6DE80F60D7DE9CE6B8C2DDFDF79EF175|782E2A50EA4AE8AA5A9646413A7822C1" )
	$FILE = $SYSTEMDIR & "\rpcss.dll"
	FILECHEK ( "598E205B456397FB3ECE22C8967F3999|3B98BF2D10DCEE0AA59E83A79259FF61|5EF1F90CC980FAC57663DC50C2E43F50|68034F1CF2E86E3666B6ECA2FF2847FC|5E8588E949BE4ACDA4441CCC87A97FCC|335C6C7E5620AE647F64FA24463F4B16|6FC2A7C860A88AF1BF105C794EAA2C3C|7639473C18F7FA1D916B9A2CAED66B29|9DAA00D0170676AC6E74C046148399FF|6C85B32CA9AF8B783143E5D17E7DC474|5FBBC87CBD53C3E62943967D316DFFD8|1B84B7D4FDA29AFD2312A7F608B7B154|BEFE10345C47D15B20683D4B95E836C2|06C2E8588FDED3AB167731C956944D81|A7B781A5899398C9504609FE9E2B6252|23E572605024008FEB74562A2D483B94|FF07D41EEEF5AC405022AADB80EB7377|55CFA0278C257DD337DCB07C073EB5E7|BE596C8A66CA8207353253901CEC8EE2|1479FEC9F1E32838E5BEEB8A10D6FBBB|A581987DEF38785B8D86B949DFB7426A|21E86D09F3A66C0C53109E7527ECCE78|6F075709F37B4098351C04CEC65C48AB|A1C505016129C1253AD2261E112DC89A|879243651021EA78E416C17FB7FD028C|E28AED40B4D89F5BDCE0C50B5B8E8C00|EBD998A6A7842E695702A978BBABDD46|F760407909EE4DC6A17C24CEF36CB6C4|F55723DCF149FF3DB40B9C918F51BBF5|B79BB10F43B1D71B6969D6769DCAE9B1|F89062AEDA8BEA7023712ABC25C33F8A|24A9440DA8E44F65682639599F6E04FC|62E6F8ED10F2864DCCD5793C9E899EC8|DC3F4E5A6ACEC3EC10FD082E8C40DEFB|5F3EB8162C7289C576BA23730193FB6A|9996195077AE83EF7A57C58E136F551E|490B92124B583E021B9EEED7BC654DED|8F68048BE535590C38611E87008112C3|6903B7516D5A766E4690CF6F31A20F7F|39A5C2364B79B050AA530FF4ADA168E0|34EA1A04B3D62138CFD3ABD866AB589A|B28217BB1D7324D2216ADD010B596FA4|3DB8175934AB0C11F32A11A8BB0073F1|3BC25B8189367964F8CEBCFAF05FB6D0|91A48288ADE146E978BB2876F2DB62C5|DB18C02A5503BFDFA3251AB571509D80|05197CDF0C771BC0B8C2D5F4A88E0055|2E4B239C94C1D64F321C1261611157E0|5EA4EC00F765C3208AA08116FF6CC6C6|E0D1E2A22B39782081D3FC64AB8ABA35|8CE6D7338F84B228450C8240BB77DB16|1914D0E999F9F63E96980F1D0F504737|3F1A199859B4F3F8357B2A0AF5666A54|79BDBB684629A526CCD958F06B9D6FAD|18E8C40C3C2AB0D315331677823555C0|7830CEA509693DE0817DF2F3F2D80E89|E4220FD9C7F1579D9C5F9DFB00427841|4B1099E362ADAF9A4FA9B06D76294349|18440D3E6011A2D4E8965ADA201A089B|A6F17C299A03BAFEFB9257C462A19E00|5E57B9FBB4E9C43EE5B69BEE01A1819F|B339861C6A2A86FBCA67C2006B461473|622C96AFB07BB82C8650B47172137AC4|81979817943D830BF24571B7C1B28A1A|F3EF088F45BE326B4EDAC8C1C5A35105|2589fe6015a316c0f5d5112b4da7b509|5C627D1B1138676C0A7AB2C2C190D123|CF8B9A3A5E7DC57724A89D0C3E8CF9EF|3FD5AE42EC87C6F532A931F96BE731DD|7266972E86890E2B30C0C322E906B027|BAE7247CD5CD393CB3DA600AABE02177|6446876DDE28C69B344FCB0C15D8604E|1EC6E533C954BDDF2A37E7851A7E58FD" )
	$FILE = $SYSTEMDIR & "\dnsapi.dll"
	FILECHEK ( "5B5546D1DC8060C52865CBC8AFBBB383|A21D8B6746406A23C883B1B144224EB9|6D66C6447256E379DE36AAF8D1860543|7003A5F440D9C972911A454A7E92608C|7CD32F5CF65B86C38DDEA8D86D2C71CA|EC2E174BE6BC0A57843C1F8A6A4FE5E8|3AC24120EF5F7CEE3D6DDB104AB0E34D|35EA42BFE8AB49496C142901664390F6|DE67B43CCFF4861AA8D4951974C9BFDC|02C77411C2E4DEFEF1A00DCB7A3442D8|55C17AD6C235AF6F7F5C45F79D4D854B|3BFBF674CF23E6F1501AC8599BCAF610|31FB3E81A27A3518B9898AE396391032|8D3FA8525AF5D010C589B63B47993798|E53CC7C163A98D53323E8B077862514B|C34BA7E91B599463DA4E7B6FA5207BE7|26DCA9271F5447C51E99F145F0414454|B431E0F34DAA9DC2493D368D99DD1745|74D1435D58E09FC9164A4338D5C40E97|938FC11B0FB23C366C0438880EBF6598|F95C45BA387227962BB79A59D88AF6E3|0B082D6D7A53D91678E7409DD145E89C|E628DAB4C21A76EF68CF1F6A4C76387C|C123B395A027AF02EC36CEAA8A75690B|145C2F1180736E3B23410C17C966749B|13A5DAEB307AB54C1060B003D2075DF2|C1D0F62643FB7B87BB44B705754B8B86|C5C29811183FDA496AF83088217E5C90|403BAB9BFBDD33E52451F59FE02629C1|A0327C16972B8ED38459E4DBCFFF25A7|4EC8CF01C5CF13CF0D0AD2E313950D9E|B0F1AF6795A83628F7D785FC4621507E|2F9444B55CDC2C66CD692D6088091EF4|2B1627A5E6EFAA1C100A1CD87E37F7DA|C9C6033116C4F7128AC11A7096765E92|CEF34C5A608ED7BD604A006624397BB8|9B86DF86D1EFF32893BC3FB49BFAA993|018D6E7BA23E28ECA0CB7F071A9FF291|86FE93AFDD8B2BCD389E30839A652181|F4B9F200B9D7EBC8BD4C8E39F02A44E3|912DDBEC210B4B47941319BF991CFD98|51A5224C9B00B1F31C016B4B29F3DFB7|5AE3B789BC547BBBE2A876F587BE60F6|A94E2533A7604E4AA05DCCC675A9F396|CF5FA7E4FB587B0F09BB0C143EB49797|EADE4BE01706A206121608CFAB2A78EC|0F9FA6A2D4EAE50393DCE473759A9845|A5675939CF0F99B20B5A3CFCC3C1B46A|C287D0E32771E3222A444DC527A29477|E7B524818100B0FDE2B057C74B0C0DCD|B7E51F949ED8C3A75C1D3121AF9A4B6C|5A2020DDCCBB0ED08BAC2355A075F303|59E2D5DD885C5A06C16CD5E309A5060A|492D07D79E7024CA310867B526D9636D|DCC0888655823103F19EF8FFD330080D|A52B6CC24063CC83C78C0E6F24DEEC01|B538E393F7FD85A054106FF21A4240EA|E247E7DEB20C0CF0801A8AC39E9CE1DF|05A2D26ACF0939A4E97160315F1FA12E" )
	$FILE = $WINDOWSDIR86 & "\dnsapi.dll"
	FILECHEK ( "204B079364FCB5ECA27B7D1178CA3A60|C520D66CCA62E99847F63DFA284C18C2|61C8CB7C963DADFBF5A5A5EDEA7DA527|0BD622B2AFA36E585C452B029006CA00|DE5762BFDE6D02F60FED8702089|4EDEAE8C3A2AFF92F8F4C4344D933E69|E4BA1C61246B01D5BD0544661AF902C8|271A609513721E394A9E22D12B2BDC58|C94BF70DEBB894C69AAA358E39E062A4|EF1D97BBFC518F3896657FD495E3A782|8854E5A5353A5C3E9F5B93E5FDFFD0E3|F1AC5FCDF2A974E81EDF0B14A9F648AC|05AA79C0776E5F1E67EEEEAA4872655F|DD58CF5A9D6D0E65267263782DB258A5|FB82749FE45A8F7746AF3416EB5A981E|1849E5C84B6EB6EB56EEB842D8CD467E|4DB7C8C5B36819751E6B134E62BE4D6A|070FFE687DF50D1731DCB633E8CB9851|805E28764CA53118327A4869DBDE7093|22154B3585E91168ED4C1C7CAA114AE7|01FB99440B5353ED56D518F4FD171166|205BDB00F4C032AF45A6BFD18EA7886C|BB53D85BBE3A1DD8373F95FF573C4053|FC2A488D91040FF1F0471801D78B7E34|277A7A6DBD6078F25AA2EFB2C3E88F4A|A87020923FAB680F0057A4397F0F5036|35CC261A565BF54BA739024040559ED8|1F321F11E4B95EAE34EAB5F4BE0A0E60|4116BF1EEA2BA39A56C83274AA6D92D8|27618FAE442F44C1A4B7C428A4030991|1478BADEF19E84593B9174B24A50F1D7|23F45825244CFCB11CC6355690F3FFAB|8ECD87F592CF60DA7CCFB3AC80A52C10|23E73E7D3B304E661DC14F8D7217872C|E38864C62641DF22A4AFD2B6C59BD61B|A4CB6481213A18FA184CBE82A972DB20|4A35D7B172AFF9C6B362D7297568836A|052495BF199C5369F9C86BF9B26F2A3A|B668D6FD24465E11155B47808553DA61|BE663A3C8E4F3ED2E8404A808614BCE3|CCF0DECFEB3D31F4CB733B39EFDFBAB3|E393B53837F6778C8FE0B27B58478B37|66342F3BB289A5A370127F8385512A84|0A821BF024E347943D6F5C5180FAEA31|F2E67F682DDCFE2C2C170F2AA3650ED6|BD9C7A068C46053F8747CEA73B5930AB|7610A035A4D37B5ECC7CED7430C37E49|3F969D5ADEAB3284ABD500B37D74A8F8|BB5BBD0E4D04047585E4ED0F07AA51E7|2796C0957F6F05A528DD64B8591371B6|FF0EE1B87E5DD7A82F7BB124D5CA8BB6|2B9EED6835D269F35B310DC03D0F5768|9AE11282C83784273732ED155BC9FF4A|B40420876B9288E0A1C8CCA8A84E5DC9|59DF156711A76BCB993253EC6C9BBF41|11DD7EB4446F25C132D0D8527DDCAF4D|62390F4ACE9E2B63E3CA26B7F7497897|6D5A49D6479EB753C7879F73A4C35E0F|1F79F611109C2B97260B68FD6B4FC7DD" )
	$FILE = $SYSTEMDIR & "\dllhost.exe"
	FILECHEK ( "7450570BA423A8E9864D498D3241FFD4|DFE1E4B1B8714CBE1005EE9413C2BAE9|144FA51A15E98D84D28EEAB815BC9A8B|B620F16B5BE791ADE73EC395C7EC1B53|08EB78E5BE019DF044C26B14703BD1FA|0934499394EB3D8027B8AB78C07D56CB|C6723950D1A8CD49D93C8D082B175D41|680045579134D8AD9D0400A9DBE30786|9361355721F51E3A25DF53702D10E9DE|2528137C6745C4EADD87817A1909677E|D2AB39EA2C0FCD172751F84BDA723A97|A8EDB86FC2A4D6D1285E4C70384AC35A" )
	$FILE = $WINDOWSDIR86 & "\dllhost.exe"
	FILECHEK ( "48CB27060C97AD5D2F35C67AC217DDB3|61DF0FA6EF720DDB2C284349D848599F|BF60B3F6E01EDDEDE8551FA076472057|AE1936CE9A4B92E69493470B1009AD5A|F3C9485F8F97AC04C8E43EF4463A68C|EE7C82B0D69F038245CECBCE9EC45A9A|BE467A8F33CDEB0538E98CF10101E9E0|60D0B50CFF3A0722ADC274F49FB16F14|CC05C14EEFF5E7813A49718BA88E59B0|70E2034A1C3D0ECCB73F57E33D4BFFA0|B5A6D2FB3F4521C37D613DE52AB3467D|A63DC5C2EA944E6657203E0C8EDEAF61" )
	$FILE = $SYSTEMDIR & "\Drivers\volsnap.sys"
	FILECHEK ( "2B6D4D84CE893D0234877B03FD80EC00|26E1B735BA5879B42B324F1D3163FC68|484DC5AD718AE12B3AD99B511FABE088|37988A4065ACBC7A6A7E03E25AFFAE4A|346AFD3A66E77F234E05BE439730013C|4B7955D9DE9CF26928968E93C6C30E95|988A7A685BB51BAC62F4E176BE5432AC|33D398981F1B198477EBD9F7D7430F1B|7764E62EF94DDA90E87309E739F6970E|B4D173B92E4715CEC1FB8C830747852A|0F13F63BA93C89DA4F54B8830EB5410B|F0EE4E6028CCA58BEA9A04E7BEAB7DB4|5B27846CF4B1C21AFB3A35A8336BA02F|6AF9BCB1FFD127B8F4E7E7B9FF9351EA|17F7B0F2298D97F4B6C7A69511033D3D|B52F1F5F55CD773BA89E5739B82E9C34|3E3429DBBEA3965BB96E24B16EF4A2551|823A237D871CD652C6BFD47BECB6810A|E1F91A727A04C9F8199D04FF3BBBF63C|64CA2B4A49A8EAF495E435623ECCE7DB|4BB9BC49DEE1A319EC58274A7BBED663|3595FBDF25F8BA6256072D103937D7D6|C85C075DE5B6D0FE116043054DE8EE02|DF83AA1C4278E2C0E36C0479C1555A9C|0D08D2F3B3FF84E433346669B5E0F639|582F710097B46140F5A89A19A6573D4B|9F9CE33B50611A1C61A46B8911E0B30B|78A5BBA3819FFFC62FFEC3E2220D102D|58F82EED8CA24B461441F9C3E4F0BF5C|2FB3CDFD5EAF4CD9D4AFAF96877D13AE|DE4307412D98050239026E56A7DFF3C0|5280AADA24AB36B01A84A6424C475C8D|DF8126BD41180351A093A3AD2FC8903B|90245509D137B8BC46CE50124FC5676E|9E425AC5C9A5A973273D169F43B4F5E1" )
	If $OSNUM < 6 Then Return
	If $BOOTM = "Recovery" Then
		If $OSNUM < 10 Then BAMMIS ( $SYSTEMDIR & "\codeintegrity\Bootcat.cache" )
		BAMMIS ( $SYSTEMDIR & "\catroot\{F750E6C3-38EE-11D1-85E5-00C04FC295EE}" )
		If $OSNUM = 10 Then BAMMIS ( $SYSTEMDIR & "\InputHost.dll" )
	EndIf
	BAMMIS ( $SYSTEMDIR & "\winsrv.dll" )
	BCD ( )
EndFunc
Func FILECHEK ( $HASHES )
	If Not FileExists ( $FILE ) Then
		BAMMIS ( )
	Else
		If Not BAMWL ( ) Then
			$HASH = MD5 ( $FILE )
			If StringRegExp ( $HASH , "(?i)" & $HASHES ) Then
				FileWrite ( $FRSTLOG , $FILE & " => " & $MD5L & @CRLF )
			Else
				SYSTEMFILE ( $HASH )
			EndIf
		EndIf
	EndIf
EndFunc
Func BAMMIS ( $PATH = $FILE )
	If Not FileExists ( $PATH ) Then FileWrite ( $FRSTLOG , $PATH & " " & $MISS & " <==== " & $UPD1 & @CRLF )
EndFunc
Func BAMWL ( )
	If $CRYPT = 1 And _CHECKSIG ( $FILE ) = 11 And StringRegExp ( _CHECKSIG ( $FILE , 1 ) , "^(?i)Microsoft " ) Then Return 1
EndFunc
Func BATASS ( ByRef $ARR )
	$RUN1 = RegRead ( "HKLM\software\Classes\.bat" , "" )
	If $RUN1 <> "batfile" Then
		$RET = RegRead ( "HKLM\software\Classes\" & $RUN1 & "\shell\open\command" , "" )
		_ARRAYADD ( $ARR , "HKLM\...\.bat: " & $RUN1 & " => " & $RET & " <==== " & $UPD1 , 0 , "|||" )
	EndIf
	$RUN1 = RegRead ( "HKLM\software\Classes\batfile\DefaultIcon" , "" )
	If $RUN1 <> "%SystemRoot%\System32\imageres.dll,-68" Then _ARRAYADD ( $ARR , "HKLM\...\batfile\DefaultIcon: " & $RUN1 & " <==== " & $UPD1 , 0 , "|||" )
	$RUN1 = RegRead ( "HKLM\software\Classes\batfile\shell\open\command" , "" )
	If $RUN1 <> """%1"" %*" Then _ARRAYADD ( $ARR , "HKLM\...\batfile\shell\open\command: " & $RUN1 & " <==== " & $UPD1 , 0 , "|||" )
EndFunc
Func BCD ( )
	If $BOOTM <> "Recovery" Then
		$READ = CMDRUN ( @SystemDir & "\bcdedit.exe /enum" )
		If Not StringRegExp ( $READ , "\{.+\}" ) Then
			$XX = ""
			If Not IsAdmin ( ) Then $XX = $SCAN4
			FileWrite ( $FRSTLOG , @CRLF & @CRLF & $UPD1 & ": ==> " & $BCDNR & " " & $XX & " -> " & $READ & @CRLF )
		EndIf
	EndIf
	$READ = CMDRUN ( @SystemDir & "\bcdedit.exe /enum {default}" )
	If StringRegExp ( $READ , "(?i)testsigning\s*Yes" ) Then FileWrite ( $FRSTLOG , @CRLF & @CRLF & "testsigning: ==> " & $TESTS & " <==== " & $UPD1 & @CRLF )
	If StringRegExp ( $READ , "(?i)recoveryenabled\s*No" ) Then
		$COMMAND = @SystemDir & "\bcdedit.exe /set {default} recoveryenabled yes"
		RunWait ( @ComSpec & " /c " & $COMMAND , "" , @SW_HIDE )
		$READ = CMDRUN ( @SystemDir & "\bcdedit.exe /enum {default}" )
		If StringRegExp ( $READ , "(?i)recoveryenabled\s*Yes" ) Then FileWrite ( $FRSTLOG , @CRLF & "BCD (recoveryenabled=No -> recoveryenabled=Yes) <==== " & $RESTORED & @CRLF )
	EndIf
	If StringRegExp ( $READ , "(?i)safeboot\s" ) Then
		$READ2 = StringRegExpReplace ( $READ , "(?is).*safeboot\s+(\w+?)\R.*" , "$1" )
		FileWrite ( $FRSTLOG , @CRLF & @CRLF & "safeboot: " & $READ2 & " => " & $BCDSM & " <==== " & $UPD1 & @CRLF )
	EndIf
EndFunc
Func BHO ( $KEY )
	Local $CLSID , $VALNAME , $FILEPATH
	GUICtrlSetData ( $LABEL1 , $SCANB & " Internet: " & $KEY )
	$HKEY = _REGOPENKEYEX3 ( $KEY )
	If @error Or $HKEY = 0 Then Return
	$I = + 4294967295
	While 1
		$I = $I + 1
		$COMPANY = ""
		$CDATE = ""
		$CLSID = __REGENUMKEY ( $HKEY , $I )
		If @error Then ExitLoop
		If StringRegExp ( $CLSID , "\{.+\}" ) Then
			$VALNAME = RegRead ( $REGEXPR & $CLSID , "" )
			If $VALNAME = "" Then $VALNAME = $FF1
			$FILEPATH = RegRead ( $REGEXPR & $CLSID & "\InprocServer32" , "" )
			If StringInStr ( $FILEPATH , "mscoree.dll" ) Then MSCOREE ( $REGEXPR & $CLSID & "\InprocServer32" , $FILEPATH )
			$FILE = $FILEPATH
			If StringInStr ( $KEY , "Wow6432Node" ) Then
				AAAAFPWOW ( )
			Else
				AAAAFP ( )
			EndIf
			If Not FileExists ( $FILE ) Then
				If StringRegExpReplace ( $FILEPATH , "\s" , "" ) Then
					$FILEPATH = $FILEPATH & " => " & $REGIST8
				Else
					$FILEPATH = $REGIST8
				EndIf
			Else
				$CDATE = " [" & $CDATE & "]"
				$FILEPATH = $FILE
			EndIf
			If GUICtrlRead ( $CHECKBOX11 ) = 1 And StringRegExp ( $FILEPATH , ":\\Program Files \(x86\)\\Microsoft\\Edge\\Application\\[^\\]+\\BHO\\ie_to_edge_bho(_64|).dll" ) And StringRegExp ( $COMPANY , "Microsoft.+-> Microsoft.+" ) Then ContinueLoop
			FileWrite ( $HADDITION , $HIVE & $VALNAME & " -> " & $CLSID & " -> " & $FILEPATH & $CDATE & $COMPANY & @CRLF )
		EndIf
	WEnd
	If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
EndFunc
Func BHOFIX ( )
	Local $CLSID
	If StringInStr ( $FIX , "BHO: " ) Then
		$KEY = "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Browser Helper Objects\"
		$REGEXPR = "HKLM\Software\Classes\CLSID\"
	Else
		$KEY = "HKLM\SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\Explorer\Browser Helper Objects\"
		$REGEXPR = "HKLM\Software\Wow6432Node\Classes\CLSID\"
	EndIf
	$CLSID = StringRegExpReplace ( $FIX , ".+? -> (.+?) ->.*" , "$1" )
	$KEY = $KEY & $CLSID
	DELKEY ( $KEY )
	$KEY = $REGEXPR & $CLSID
	If VAR ( $KEY ) Then DELKEY ( $KEY )
EndFunc
Func BLACKLISTDRV ( )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)([RSU][012345] (netfilter|webshieldfilter|browserMon|Winmon.*|udiskMgr|mrxsmb22|cytdsk|JszipProtect|UefGdstor|Uefochubsrv|TMKernel|LanmaMaster|WiserIso|ServiceMgr|MaohaWifiNetPro|iSafe.*?|NetUtils\d{4}|drmkpro64|mwescontroller|NetUtils\d+|MPCKpt|MPCBase|cherimoya5|bsdp32|KuaiZipDrive\d|UCGuard|pcwatch|cmwr|cmwf|fileHiders|webTinstMKTN\d+);.+)\v{2}" , "$1 <==== " & $UPD1 & @CRLF )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)([RSU][012345] .+\\Program Files(| \(x86\))\\LuDaShi\\.+(\)|\]))\v{2}" , "$1 <==== " & $UPD1 & @CRLF )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "([RSU][012345] .+; .+\\[^[]+:[^\\\{].+)\v+" , "$1 <==== " & $UPD1 & @CRLF )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)([RSU][012345].+; .+\\(SAntivirus|Segurazo|(Local|Windows)\\Temp|UBar|Common Files\\.oobzo)\\.*|MoriyaStreamWatchmen.sys)\v+" , "$1 <==== " & $UPD1 & @CRLF )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)([RSU][012345].+(?:.+Driver|\(technologie\w+\.com|PC DRIVERS HEADQUARTERS).*)\v+" , "$1 <==== " & $UPD1 & @CRLF )
EndFunc
Func BLACKLISTSRV ( )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)([RSU][2345] .+(?<!System32)\\csrss\.exe[^<]+?)\v{2}" , "$1 <==== " & $UPD1 & @CRLF )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)([RSU][2345] (sftmgr|svcmgr|RDP-Controller|ScreenConnect.*|WindowsAutHostOutbyteDUHelper|WindowsUpdate|GoogleUpdateTaskMachineQC|compiler|Atruct.*|Registry1|Dinosecurity\w+|game-downloader|secureboot|AltruisticsService|MsHelper|asrscan|WMS|MFService|Great Discover|RestoroActiveProtection|AppService\w?|pubgame-updater|ZzNetSvc|WinDefender|SystemServices|RecipeHub_2jService|SysSvc|Kolnixo|WNetworkMgmt|SystemUpdate64|MicroService|Winmon(|FS|ProcessMonito)|Quoteex|NativeDesktopMediaService|Ea3Host|chip1click|cstlsvc|iSafe.*?|mptpmdxm|JszipService|TMKernelHelpU|TMService|PrefersSecure|NetUtils2016srv|Subair|backlh|Nettrans|IISvr|SysLinkMapper|srcsrv|MVCSrv|AppleCloudSvc|WinAppSvr|MaohaWifiSvr|HPWombat Service|Web Cache Manager|CORE Software Updater|WindowsOfficeSrv|WeatherService|Disrupt Software Update|NetUtils\d{4}|qdcomsvc|PremierOpinion|NetUtils\d+|SPS|RunBooster|WinDivert\d+|Lace\d+|OtherSearch|iThemes5|windowsmanagementservice|Dataup|mwescontroller|mweshield.*|Undp\d*|FastCompress|ProntSpooler|nrtService|netaie|confine.*|MFLService.*|consumerinput.*|(Service|Update) Mgr .+|VSSS|hola_(updater|svc)|BitTorrent|Utatity|BluetoothPoint|PCKeeperOcfService|PCKeeper2Service|AccountService|UniversalUpdater|AlaPerformance|.*Sale.?Charger|7a094844|WindowsMangerProtect|MediaUpdater.*|JokerAds.*|BeSecure.*|Bogard.*|mintcast.*|Shell&ServicesEngine.*|globalUpdate|globalUpdatem|MyOSProtect|Updater.exe|PrivoxyService|Live Malware Protection|Savdm|SavdmMonitor|StormAlert|sndappv2|Application Sendori|WindowsProtectManger|(Update|Util) Mega Browse|SecureUpdateSvc|RelevantKnowledge|winzipersvc|Adobe Licensing Console|SavingsbullFilterService64|desksvc|qtypesvc|LPTSystemUpdater|PCProtect|ProtectMonitor|Re-markit|TorchCrashHandler|Update EnhanceTronic|Update qualitink|Util EnhanceTronic|vosr|Wajam.+?|AppInf|SoEasy.*);[^<]+?)\v{2}" , "$1 <==== " & $UPD1 & @CRLF )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)([RSU][2345] .+(?<!\\amd64)\\nssm.exe[^<]+?|.+\\(?:Users\\[^\\]+\\ClientRuntime|Microsoft\\IObitUnlocker|ProgramData\\WindowsServices|registry\\reghost\.exe|csrss\.exe|ProgramData\\GoogleUP\\|Altruist\\|MaskVPN\\|Web Companion\\|runchos\.exe|winnet\.exe|winsvc\.exe|Pictures\\Minor Policy|Reimage\\|ORBTR\\|transmission-qt.exe|VBoxNetFlt.exe|SearchProtect\\|ChromiumUpdate.exe|TotalAV\\|SAntivirus\\|Segurazo\\|MyPC Backup\\|bytefence\\|Program Files[^\\]*\\Mail.Ru\\|XBox\\|System\.exe|ProgramData\\.+Provider.dll|UCBrowser\\|(Local|Windows)\\Temp(\\|/)|UBar\\|Program Files(| \(x86\))\\Firefox\\bin|amuleC\d|WinArcher|ProxyGate|PC Speed Up|ShopperPro|YTDownloader|desktopfindkey|MSUser.Default|SoSoIm|SOEasy|Common Files\\.oobzo|PrefersSecure|Main Services\\|\\VLCStreamer\\)[^<]+?|(\\Windows|%SystemRoot%)\\servicing\\(?!TrustedInstaller)[^\\]+\.exe[^<]+?|.+\bpowershell\b.+\.ps1|.+\bmshta\b\s+http[^<]+?|:\\Users\\[^\\]+\\[^\\]+\.(vbs|bat|exe)\b[^<]+?)\v{2}" , "$1 <==== " & $UPD1 & @CRLF )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)([RSU][2345] (\w+) Updater; .:Program Files(?:| \(x86\))\\\2 Updater\\\2 Updater\.exe .+)\v{2}" , "$1 <==== " & $UPD1 & @CRLF )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)([RSU][2345] (?:Diagnostics|Proxy);.+\\service\.exe.*)\v{2}" , "$1 <==== " & $UPD1 & @CRLF )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)([RSU][2345] scan;.+\\iYogi.+)\v{2}" , "$1 <==== " & $UPD1 & @CRLF )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)([RSU][2345] .+\\ProgramData\\.+?\[[^]]+\] \(\) \[[^]]+\][^<]*)\v{2}" , "$1 <==== " & $UPD1 & @CRLF )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)([RSU][2345] .+\[[^]]+\] \[[^]]+\][^<]*?)\v{2}" , "$1 <==== " & $UPD1 & @CRLF )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)([RSU][2345] .+\\(?:ProwebiSvc|DeltaFix|OptProMon|decodit)\.dll.*)\v{2}" , "$1 <==== " & $UPD1 & @CRLF )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)([RSU][2345] .+(?:zdengine|\\VOsrv|MPCProtectService|WindowsLogger\\winlogger)\.exe.*)\v{2}" , "$1 <==== " & $UPD1 & @CRLF )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)([RSU][2345] (.+?); .:\\Program Files (\(x86\)\\\2\\\2\.exe \[.+?\] \(\) \[" & $FILENS & "\])\v{2}" , "$1 <==== " & $UPD1 & @CRLF )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)([RSU][2345] .+\\Program Files(?:| \(x86\))\\(?:LuDaShi|ziptool|ScreenshotPro|WebDiscoverBrowser|amuleC)\\.+(?:\)|\]))\v{2}" , "$1 <==== " & $UPD1 & @CRLF )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "([RSU][2345] [a-z0-9]{32,}; .:\\Program Files(?:| \(x86\))\\[a-z0-9]{32,}\\[a-z0-9]{32,}\.exe \[.+\] \(\) \[.+\])\v{2}" , "$1 <==== " & $UPD1 & @CRLF )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)([RSU][2345] .+; [c-z]:\\ProgramData\\[^\\]+\.(exe|dll)(| \[.+\] \(.*\)(| \[.+\])))\v+" , "$1 <==== " & $UPD1 & @CRLF )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)([RSU][2345] WindowsSecurity; [c-z]:\\ProgramData\\Windows Security\\winsecurity\.exe \[.+\] \(.+\) \[.+\])\v+" , "$1 <==== " & $UPD1 & @CRLF )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)([RSU][2345].+; [c-z]:\\Program Files(?:| \(x86\))\\XBox\\XBLive.exe \[.+\] \(.+\))\v+" , "$1 <==== " & $UPD1 & @CRLF )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)([RSU][2345].+; [c-z]:\\Program Files(?:| \(x86\))\\Mozilla Firefox\\.+?\.dll \[.+\] \(.*\) \[.+\])\v+" , "$1 <==== " & $UPD1 & @CRLF )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)([RSU][2345] (.+); .+?\\AppData\\(Roaming|Local)\\\2\\[^\\]+?\.dll.*)\v+" , "$1 <==== " & $UPD1 & @CRLF )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)([RSU][2345] (.+); .+?\\AppData\\(Roaming|Local)\\\2\\\2\.exe .*)\v+" , "$1 <==== " & $UPD1 & @CRLF )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)([RSU][2345] (.+); [c-z]:\\ProgramData\\\2\\\2\.(dll|exe).*)\v+" , "$1 <==== " & $UPD1 & @CRLF )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)([RSU][2345] (.+); [c-z]:\\ProgramData\\Microsoft\\(?!Windows Defender).+)\v+" , "$1 <==== " & $UPD1 & @CRLF )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "([RSU][2345] [A-Z]+; .:\\ProgramData\\[a-z]+\\[a-z]+\.exe \[.+\[.+)\v+" , "$1 <==== " & $UPD1 & @CRLF )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)([RSU][2345] (.+); [c-z]:\\Windows\\svchost.exe.*)\v+" , "$1 <==== " & $UPD1 & @CRLF )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)([RSU][2345] (.+); [c-z]:\\.+" & "\[" & $NOACC & "\])\v+" , "$1 <==== " & $UPD1 & @CRLF )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)([RSU][2345] (U_.+); [c-z]:\\Program Files\\\2\\\2\.exe.*)\v+" , "$1 <==== " & $UPD1 & @CRLF )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)([RSU][2345].+\((technologie\w+\.com|PC DRIVERS HEADQUARTERS).*)\v+" , "$1 <==== " & $UPD1 & @CRLF )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)([RSU][2345] (A\w+Service); [c-z]:\\Program Files(| \(x86\))\\\w+soft\\\2.exe \[[^]]+\].+\[[^]]+\].*)\v+" , "$1 <==== " & $UPD1 & @CRLF )
	If StringRegExp ( $REGEXPR , "(?i)[RSU][2345] TermService;" ) And Not StringRegExp ( $REGEXPR , "(?i)\\System32\\termsrv\.dll" ) Then $REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)([RSU][2345] TermService; .+)\v+" , "$1 <==== " & $UPD1 & " (" & $NO & " ServiceDLL)" & @CRLF )
	If $BOOTM <> "recovery" And IsAdmin ( ) Then $REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)([SU][2345] (?!.+(Service|SVC|User)_).+?; [c-z]:\\Windows\\(System32|SysWOW64)\\svchost\.exe.*)\v+" , "$1 <==== " & $UPD1 & " (" & $NO & " ServiceDLL)" & @CRLF )
EndFunc
Func BOOTEXECUTEFIX ( )
	RESTOREVAL ( "HKLM\" & $SYSTEM & $BOOTSYSTEM & $DEF & "\Control\Session Manager" , "BootExecute" , "REG_MULTI_SZ" , "autocheck autochk *" )
EndFunc
Func BROWSERSTARTFIX ( )
	Local $KEY , $DATA
	$BROW = StringRegExpReplace ( $FIX , "StartMenuInternet: (.+?) -.*" , "$1" )
	$AKEY = "HKLM\SOFTWARE\Clients\StartMenuInternet\" & $BROW & "\shell\open\command"
	Select
	Case StringInStr ( $BROW , "Chrome" )
		$KEY = $AKEY
		If FileExists ( $PROGRAMFILES86 & "\Google\Chrome\Application\chrome.exe" ) Then $DATA = """" & $PROGRAMFILES86 & "\Google\Chrome\Application\chrome.exe"""
		If FileExists ( @ProgramFilesDir & "\Google\Chrome\Application\chrome.exe" ) Then $DATA = """" & @ProgramFilesDir & "\Google\Chrome\Application\chrome.exe"""
	Case StringInStr ( $BROW , "Brave" )
		$KEY = $AKEY
		$DATA = """" & @ProgramFilesDir & "\BraveSoftware\Brave-Browser\Application\brave.exe"""
	Case StringInStr ( $BROW , "IEXPLORE" )
		$KEY = $AKEY
		$DATA = @ProgramFilesDir & "\Internet Explorer\iexplore.exe"
	Case StringInStr ( $BROW , "FIREFOX" )
		$KEY = $AKEY
		If FileExists ( $PROGRAMFILES86 & "\Mozilla Firefox\firefox.exe" ) Then $DATA = """" & $PROGRAMFILES86 & "\Mozilla Firefox\firefox.exe"""
		If FileExists ( @ProgramFilesDir & "\Mozilla Firefox\firefox.exe" ) Then $DATA = """" & @ProgramFilesDir & "\Mozilla Firefox\firefox.exe"""
	Case StringInStr ( $FIX , "Opera" ) And StringInStr ( $FIX , "(HKLM)" )
		$BROW = StringRegExpReplace ( $FIX , ".+?HKLM\) (.+?) -.*" , "$1" )
		$KEY = "HKLM\SOFTWARE\Clients\StartMenuInternet\" & $BROW & "\shell\open\command"
		If FileExists ( @LocalAppDataDir & "\Programs\Opera\Opera.exe" ) Then $VALDATA = """" & @LocalAppDataDir & "\Programs\Opera\Opera.exe"""
		If FileExists ( @LocalAppDataDir & "\Programs\Opera\Launcher.exe" ) Then $VALDATA = """" & @LocalAppDataDir & "\Programs\Opera\Launcher.exe"""
		If FileExists ( @ProgramFilesDir & "\Opera\Opera.exe" ) Then $DATA = """" & @ProgramFilesDir & "\Opera\Opera.exe"""
		If FileExists ( @ProgramFilesDir & "\Opera\Launcher.exe" ) Then $DATA = """" & @ProgramFilesDir & "\Opera\Launcher.exe"""
		If FileExists ( $PROGRAMFILES86 & "\Opera\Opera.exe" ) Then $DATA = """" & $PROGRAMFILES86 & "\Opera\Opera.exe"""
		If FileExists ( $PROGRAMFILES86 & "\Opera\Launcher.exe" ) Then $DATA = """" & $PROGRAMFILES86 & "\Opera\Launcher.exe"""
	Case StringRegExp ( $FIX , "Opera|Vivaldi|Yandex" ) And StringInStr ( $FIX , "(HKU" )
		BROWSERSTARTOPUSER ( $KEY , $DATA )
	EndSelect
	If $KEY <> "" Then RESTOREVAL ( $KEY , "" , "REG_SZ" , $DATA )
EndFunc
Func BROWSERSTARTOPUSER ( ByRef $UKEY , ByRef $VALDATA )
	Local $NAME
	$BROWSER = StringRegExpReplace ( $FIX , ".+?HKU.+?\) (.+?) -.*" , "$1" )
	$USER = StringRegExpReplace ( $FIX , ".+?\(HKU\\(.+?)\).+" , "$1" )
	$UKEY = "HKU\" & $USER & "\SOFTWARE\Clients\StartMenuInternet\" & $BROWSER & "\shell\open\command"
	$ACCOUNTNAME = _SECURITY__LOOKUPACCOUNTSID ( $USER )
	If IsArray ( $ACCOUNTNAME ) Then $NAME = $ACCOUNTNAME [ 0 ]
	$USERLOCALAPPDATADIR = StringRegExpReplace ( @LocalAppDataDir , "(?i)([a-z]:\\.+?\\)(.+?)(\\.+)" , "$1" & $NAME & "$3" )
	Select
	Case StringInStr ( $BROWSER , "Opera" )
		If FileExists ( $USERLOCALAPPDATADIR & "\Programs\Opera\Opera.exe" ) Then $VALDATA = """" & $USERLOCALAPPDATADIR & "\Programs\Opera\Opera.exe"""
		If FileExists ( $USERLOCALAPPDATADIR & "\Programs\Opera\Launcher.exe" ) Then $VALDATA = """" & $USERLOCALAPPDATADIR & "\Programs\Opera\Launcher.exe"""
		If FileExists ( @ProgramFilesDir & "\Opera\Opera.exe" ) Then $DATA = """" & @ProgramFilesDir & "\Opera\Opera.exe"""
		If FileExists ( @ProgramFilesDir & "\Opera\Launcher.exe" ) Then $DATA = """" & @ProgramFilesDir & "\Opera\Launcher.exe"""
		If FileExists ( $PROGRAMFILES86 & "\Opera\Opera.exe" ) Then $DATA = """" & $PROGRAMFILES86 & "\Opera\Opera.exe"""
		If FileExists ( $PROGRAMFILES86 & "\Opera\Launcher.exe" ) Then $DATA = """" & $PROGRAMFILES86 & "\Opera\Launcher.exe"""
	Case StringInStr ( $BROWSER , "Vivaldi" )
		$VALDATA = """" & $USERLOCALAPPDATADIR & "\Vivaldi\Application\vivaldi.exe"""
	Case StringInStr ( $BROWSER , "Yandex" )
		$VALDATA = """" & $USERLOCALAPPDATADIR & "\Yandex\YandexBrowser\Application\browser.exe"""
	EndSelect
EndFunc
Func CERTDISALLOW ( $HIVE , $POL = "" )
	$KEY = $HIVE & $SOFTWARE & $POL & "\Microsoft\SystemCertificates\Disallowed\Certificates"
	$HKEY = _REGOPENKEYEX3 ( $KEY , 1 )
	If @error Or Not $HKEY Then Return
	$I = 0
	While 1
		$SUB = __REGENUMKEY ( $HKEY , $I )
		If @error Then ExitLoop
		$ATT = ""
		$NAME = CERTNAME ( $SUB )
		If $NAME <> "U" Then $ATT = " <==== " & $UPD1
		$POL = StringRegExpReplace ( $POL , "\\" , "" )
		_ARRAYADD ( $ARRAYREG , $HIVE & " " & $POL & "DisallowedCertificates: " & $SUB & " (" & $NAME & ")" & $ATT , 0 , "||||" )
		$I += 1
	WEnd
	If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
EndFunc
Func CERTFIX ( )
	If $BOOTM <> "Recovery" And _SRVSTAT ( "AppInf" ) = "R" Then
		_STOPSERVICE ( "AppInf" )
		If Not @error Then
			If _SRVSTAT ( "AppInf" ) <> "S" Then Sleep ( 2500 )
			If _SRVSTAT ( "AppInf" ) <> "S" Then Sleep ( 2500 )
		EndIf
	EndIf
	$SUB = StringRegExpReplace ( $FIX , ".*?: (.+?) \(.+" , "$1" )
	If StringInStr ( $FIX , "HKLM\" ) Then
		$KEY = "HKLM\" & $SOFTWARE & "\Microsoft\SystemCertificates\Disallowed\Certificates\" & $SUB
		If StringInStr ( $FIX , "policies" ) Then $KEY = "HKLM\" & $SOFTWARE & "\Policies\Microsoft\SystemCertificates\Disallowed\Certificates\" & $SUB
	Else
		$USER = StringRegExpReplace ( $FIX , "(?i)HKU\\(.+?)\\.+" , "$1" )
		$KEY = "HKU\" & $USER & "\Software\Microsoft\SystemCertificates\Disallowed\Certificates\" & $SUB
		If StringInStr ( $FIX , "policies" ) Then $KEY = "HKU\" & $USER & "\Software\Policies\Microsoft\SystemCertificates\Disallowed\Certificates\" & $SUB
	EndIf
	DELKEY ( $KEY )
EndFunc
Func CERTNAME ( $N )
	Switch $N
	Case "9132E8B079D080E01D52631690BE18EBC2347C1E"
		$NAME = "Adaware Software"
	Case "181E2AE5727DE60F52EF26D90BC6919481601793" , "AD4C5429E10F4FF6C01840C20ABA344D7401209F" , "DB77E5CFEC34459146748B667C97B185619251BA" , "F75019695C0504E3ABEFEDCD8FBE500DA08EC8FA"
		$NAME = "Avast Antivirus/Software"
	Case "18AA37360A0698E6A1F54A9E8268FB127B70E189"
		$NAME = "AVG Netherlands B.V"
	Case "F74407DCA8D49D42D72D88863C17AB905EB94D1C" , "AB7E760DA2485EA9EF5A6EEE7647748D4BA6B947" , "3D496FA682E65FC122351EC29B55AB94F3BB03FC" , "E513EAB8610CFFD7C87E00BCA15C23AAB407FCEF" , "E64232B7757A335C032414C6888633CC498E7CD6" , "58939B78BC28EF464220127BB754E3D130306988"
		$NAME = "AVG Technologies"
	Case "B1E5407220D2E41A2045A5B183AE83F54E3C9643" , "A1F8DCB086E461E2ABB4B46ADCFA0B48C58B6E99" , "9900CFAABC45B4247F9D78EE7E12B102D25EA325" , "8887AF2636E0D3B763AC4D56729218AF89653CA4"
		$NAME = "Avira Operations GmbH & Co. KG"
	Case "4B953F30F1DE4DFEF894B136DAA155CEAFC243A0"
		$NAME = "Baidu Online Network Technology"
	Case "82F19360B15655A94E875A5B5F7844E2932FC2A6" , "ED841A61C0F76025598421BC1B00E24189E68D54" , "18DEA4EFA93B06AE997D234411F3FD72A677EECE" , "328E73F58737F1AB8DB0DA98FECFA17EB7BFAA40" , "8B6DD299C6E4092040E98EB773F3818DF50B038D"
		$NAME = "Bitdefender SRL"
	Case "76A9295EF4343E12DFC5FE05DC57227C1AB00D29" , "A5341949ABE1407DD7BF7DFE75460D9608FBC309"
		$NAME = "BullGuard Ltd"
	Case "5240AB5B05D11B37900AC7712A3C6AE42F377C8C" , "84C08B7A367422AF5FEF8D353B36191ECE9DBAF7"
		$NAME = "Check Point Software Technologies Ltd."
	Case "03D22C9C66915D58C88912B64C1F984B8344EF09" , "872CD334B7E7B3C3D1C6114CD6B221026D505EAB" , "6CD253D636A7B4D0E0981431BC064061A9853ED9" , "76FBABF1EADED3B91DD7A76A6678301F1F87AA97" , "D70D7D00CA12E1B3E20F3BF7534DEB2C2E7C2404"
		$NAME = "Comodo Security Solutions"
	Case "0A0CF21F2AD2796FCC1309F2993659FC9F4BBFB9" , "9E3F95577B37C74CA2F70C1E1859E798B7FC6B13"
		$NAME = "Curio Systems GmbH"
	Case "FFFA650F2CB2ABC0D80527B524DD3F9FC172C138" , "4420C99742DF11DD0795BC15B7B0ABF090DC84DF" , "4E393AA1586C93E0BC9E7FEBCF7BFB62066DC22A" , "E27AA5FFDCA62A60E435292A243D0C6D43DCC513"
		$NAME = "Doctor Web Ltd."
	Case "5DD3D41810F28B2A13E9A004E6412061E28FA48D" , "4C0AF5719009B7C9D85C5EAEDFA3B7F090FE5FFF" , "1F25DF887B158E34E2FCB13171924610C8F6BA2F" , "BFA87DC996BD6BCB02B6F530D2C646A0B5A0D5A9" , "BDEEFEC5F002E281B2292A8C72EACA468CBF9952"
		$NAME = "Emsisoft Ltd"
	Case "65AFAA515036C38C9EC28248C453FB0F6B1E7094" , "A59CC32724DD07A6FC33F7806945481A2D13CA2F" , "F83099622B4A9F72CB5081F742164AD1B8D048C9" , "42A8984E8B9C51F6B7274866F8726CA1E9057FAA" , "8DC9FE53D5F1D7D558EBE131E922730780D88865" , "B59165451BE46B8D72D09191D0961C755D0107C8"
		$NAME = "ESET"
	Case "BD22822F42C0B3F61AA0F30360EFB2A15068893B"
		$NAME = "ESS Distribution"
	Case "1667908C9E22EFBD0590E088715CC74BE4C60884"
		$NAME = "FRISK Software International/F-Prot"
	Case "0F684EC1163281085C6AF20528878103ACEFCAAB" , "5AACB6A43D9D806E6963937BE702B7A43C1978AE"
		$NAME = "F-Secure Corporation"
	Case "2026D13756EB0DB753DF26CB3B7EEBE3E70BB2CF"
		$NAME = "G DATA Software AG"
	Case "42727E052C0C2E1B35AB53E1005FD9EDC9DE8F01" , "7457A3793086DBB58B3858D6476889E3311E550E" , "AA8399A239AE1785200917D32C21F6B662477BE4" , "B7E607E1FB8943C634580F621788C01C962E8280"
		$NAME = "K7 Computing Pvt Ltd"
	Case "3850EDD77CC74EC9F4829AE406BBF9C21E0DA87F" , "D3F78D747E7C5D6D3AE8ABFDDA7522BFB4CBD598" , "3C92C9274AB6D3DD520B13029A2490C4A1D98BC0" , "BF9254919794C1075EA027889C5D304F1121C653"
		$NAME = "Kaspersky Lab"
	Case "89B89723B7106A1926036B1469D2497B85841849"
		$NAME = "Lavasoft"
	Case "622271AF668F99BD94AC12E5EBF86E48FD50AECB" , "4E564B9FBCE8F496FFF51278CCD14EE17F09A1CE"
		$NAME = "Qihu 360 Software Co. Limited"
	Case "883224FAB9D5BC431563A00AF10A79AA78087584" , "FBB42F089AF2D570F2BF6F493D107A3255A9BB1A" , "1B581436B0ED7536755B8B1C81112509A5AAF6ED"
		$NAME = "Panda Security S.L"
	Case "4243A03DB4C3C15149CEA8B38EEA1DA4F26BD159"
		$NAME = "PC Tools"
	Case "982D98951CF3C0CA2A02814D474A976CBFF6BDB1" , "9A32249E9A6B9CF5C36B0749C81613524D37C594"
		$NAME = "Safer Networking Ltd."
	Case "9C2479D4BEF807FEFE3CE2B6B2D7FC4C71E0EBA5"
		$NAME = "Sophos Ltd"
	Case "31F5EE85DA34AD374D43776B54F6686E7E922737" , "2F56FF8F95EE69A27C05DBB35924F847C86A66B4"
		$NAME = "SurfRight B.V."
	Case "373C33726722D3A5D1EDD1F1585D5D25B39BEA1A"
		$NAME = "SUPERAntiSpyware.com"
	Case "AEEA60E86C66327BFBB8492C33122687AB2B5D91"
		$NAME = "Support.com, Inc."
	Case "AD96BB64BA36379D2E354660780C2067B81DA2E0" , "31AC96A6C17C425222C46D55C3CCA6BA12E54DAF" , "BEBFAE20957D4DE689A8B962AEE358EFE39F195F" , "BE894F99B870DA5FCA623F7F4A85D3970A46CDE1"
		$NAME = "Symantec Corporation"
	Case "E22240E837B52E691C71DF248F12D27F96441C00"
		$NAME = "Total Defense, Inc."
	Case "8138B44330354E413DC52AF1DBFCA8BA1C0F6C0A" , "DB303C9B61282DE525DC754A535CA2D6A9BD3D87" , "9C43F665E690AB4D486D4717B456C5554D4BCEB5"
		$NAME = "ThreatTrack Security"
	Case "2FA3FB2570A7A859026C59A1C723E7EF9F9AF13D" , "331E2046A1CCA7BFEF766724394BE6112B4CA3F7" , "CDC37C22FE9272D8F2610206AD397A45040326B8" , "1518752920E9221E1FE1728AACAC536728B37BA7" , "7450C07722C75E711EF24209A22F0C5C6A5BEC4E"
		$NAME = "Trend Micro"
	Case "C1437F2BC6F11F4806EAD857982457BF7828CE15" , "249BDA38A611CD746A132FA2AF995A2D3C941264" , "B8EBF0E696AF77F51C96DB4D044586E2F4F8FD84" , "DBFAD9D59A6A07DCEB004DBE2DC246B547249E86" , "816BE9397F66D1A26EFA04035BCA3BB9E3779740"
		$NAME = "Malwarebytes Corporation"
	Case "D37F61D57CB0481F3D77EDAC7DE72196C4314E2C" , "775B373B33B9D15B58BC02B184704332B97C3CAF" , "88AD5DFE24126872B33175D1778687B642323ACF"
		$NAME = "McAfee"
	Case "2CC344E13934A69AA993E80C8E20FF0ACCB33F1E"
		$NAME = "Qihu 360 Software Co. Limited"
	Case "5DE56B2BAAA995F447949B869356528F91230A49"
		$NAME = "VIPRE Security"
	Case "9A08641F7C5F2CCA0888388BE3E5DBDDAAA3B361" , "3353EA609334A9F23A701B9159E30CB6C22D4C59" , "78C55D604474B534EB2B565CAD312FC7D71FE9DE" , "E4A0C1054F8025DD88EE5053094A9A61661AE123"
		$NAME = "Webroot Inc."
	Case "5CA5F811E011742B05D014D03F85848D81F41A63"
		$NAME = "Zemana"
	Case "5CA5F811E011742B05D014D03F85848D81F41A63"
		$NAME = "U?"
Case Else
		$NAME = "U"
	EndSwitch
	Return $NAME
EndFunc
Func CHECKFW ( $SRV )
	If $BOOTM = "Normal" And _SRVSTAT ( $SRV ) <> "R" Then FileWrite ( $HADDITION , $SRV & " => " & $FWNRUN & @CRLF )
EndFunc
Func CHECKFWRUN ( )
	If $BOOTM = "Safe Mode (minimal)" Then Return
	$FWMGR = ObjCreate ( "HNetCfg.FwMgr" )
	If Not IsObj ( $FWMGR ) Then Return
	$PROFILE = $FWMGR .LocalPolicy .CurrentProfile
	If @error Then Return
	If ( $PROFILE .FirewallEnabled ) Then
		FileWrite ( $HADDITION , $WINFW & " " & $INTERNET2 & @CRLF )
	Else
		FileWrite ( $HADDITION , $WINFW & " " & $FWDIS & @CRLF )
	EndIf
EndFunc
Func CHKFILE ( $PATH , $IACCESS = 0 , $DSHARE = 0 )
	If StringLeft ( $PATH , 4 ) <> "\\?\" Then $PATH = "\\?\" & $PATH
	Local $RET = DllCall ( "kernel32.dll" , "handle" , "CreateFileW" , "wstr" , $PATH , "dword" , $IACCESS , "dword" , $DSHARE , "ptr" , 0 , "dword" , 3 , "dword" , 0 , "ptr" , 0 )
	If $RET [ 0 ] = + 4294967295 Then Return _WINAPI_GETLASTERROR ( )
	CLOSEHANDLE ( $RET [ 0 ] )
EndFunc
Func CHROME ( $BRO = "CHR" )
	Local $KEYWORD , $NAME , $SEARCHURL , $SUGGESTURL , $REGEX , $PATH , $COMP , $NEWTABURL , $PREFERENCES , $REGEX1 , $FILEARRAY , $CL , $DATECR , $CUR , $ARR , $MS , $DATEC , $P , $SUBK , $DATA
	Local $CHROME [ 1 ]
	GUICtrlSetData ( $LABEL1 , $SCANB & " " & $BRO & ": Preferences" )
	Select
	Case $BRO = "BRA"
		$FOL = @LocalAppDataDir & "\BraveSoftware\Brave-Browser\User Data"
	Case $BRO = "CHR"
		$FOL = @LocalAppDataDir & "\Google\Chrome\User Data"
	Case $BRO = "OPR"
		$FOL = @AppDataDir & "\Opera Software\Opera Stable"
	Case $BRO = "VIV"
		$FOL = @LocalAppDataDir & "\Vivaldi\User Data"
	Case $BRO = "YAN"
		$FOL = @LocalAppDataDir & "\Yandex\YandexBrowser\User Data"
	EndSelect
	$HREAD = FileOpen ( $FOL & "\Local State" , 256 )
	$PROFILE = FileRead ( $HREAD )
	FileClose ( $HREAD )
	$PROFILE = StringRegExp ( $PROFILE , """last_used"":\s*""(.+?)""," , 1 )
	If IsArray ( $PROFILE ) Then
		$PROFILE = $PROFILE [ 0 ]
		_ARRAYADD ( $CHROME , $BRO & " DefaultProfile: " & $PROFILE , 0 , "||||" )
	EndIf
	GUICtrlSetData ( $LABEL1 , $SCANB & " " & $BRO & ": Extensions" )
	$ARRFOLD = _FILELISTTOARRAYREC ( $FOL , "*" , 2 , 0 , 0 , 2 )
	If $BRO = "OPR" Then Local $ARRFOLD [ ] = [ "" , $FOL ]
	For $N = 1 To UBound ( $ARRFOLD ) + 4294967295
		If Not FileExists ( $ARRFOLD [ $N ] & "\secure preferences" ) Then ContinueLoop
		$ATT = ""
		If Not StringRegExp ( StringRegExpReplace ( $ARRFOLD [ $N ] , ".+\\(.+)" , "$1" ) , "(?i)^(Default|Profile \d+|(Guest|System) Profile|Backup Default|Opera Stable)$" ) Then $ATT = " <==== " & $UPD1
		$DATECR = FILETIMECM ( $ARRFOLD [ $N ] )
		_ARRAYADD ( $CHROME , $BRO & " Profile: " & $ARRFOLD [ $N ] & " [" & $DATECR & "]" & $ATT , 0 , "||||" )
		$HREAD = FileOpen ( $ARRFOLD [ $N ] & "\Preferences" , 256 )
		$PREFERENCES = FileRead ( $HREAD )
		FileClose ( $HREAD )
		$PATH = StringRegExp ( $PREFERENCES , "(?i)""download""\s*[^""]+""default_directory""\s*:\s*""([^""]*)""" , 1 )
		If IsArray ( $PATH ) Then _ARRAYADD ( $CHROME , $BRO & " DownloadDir: " & StringRegExpReplace ( $PATH [ 0 ] , "\\\\" , "\\" ) , 0 , "||||" )
		$HREAD = FileOpen ( $ARRFOLD [ $N ] & "\secure preferences" , 256 )
		$SECPREFERENCES = FileRead ( $HREAD )
		FileClose ( $HREAD )
		$PROFILE = StringRegExpReplace ( $ARRFOLD [ $N ] , ".+\\(.+)" , "$1" ) & " -> "
		CHROMENOTI ( $PREFERENCES , $CHROME , $PROFILE , $BRO & " Notifications: " )
		Select
		Case $SECPREFERENCES = ""
			If FileExists ( $FILE & "\secure preferences" ) Then _ARRAYADD ( $CHROME , "Error reading preferences. Please check ""Secure Preferences"" file for possible corruption. <==== " & $UPD1 )
	Case Else
			If $BRO = "VIV" Then
				$PRE = $PREFERENCES
				$PATH = StringRegExp ( $PRE , """custom_url""\s*:\s*""([^""]*?(?:[a-z]|\.)+.*?)""" , 1 )
				If IsArray ( $PATH ) Then _ARRAYADD ( $CHROME , $BRO & " Custom_url: " & $PROFILE & $PATH [ 0 ] , 0 , "||||" )
			Else
				$PRE = $SECPREFERENCES
			EndIf
			$PATH = StringRegExp ( $PRE , """homepage""\s*:\s*""([^""]*?(?:[a-z]|\.)+.*?)""" , 1 )
			If IsArray ( $PATH ) Then _ARRAYADD ( $CHROME , $BRO & " HomePage: " & $PROFILE & $PATH [ 0 ] , 0 , "||||" )
			$PATH = StringRegExp ( $SECPREFERENCES , "(?i)""urls_to_restore_on_startup""\s*:\s*\[\s*(""[^]]*"")" , 1 )
			If IsArray ( $PATH ) Then _ARRAYADD ( $CHROME , $BRO & " RestoreOnStartup: " & $PROFILE & $PATH [ 0 ] , 0 , "||||" )
			$PATH = StringRegExp ( $SECPREFERENCES , "(?i)""startup_urls""\s*:\s*\[\s*(""[^]]*?)\]" , 1 )
			If IsArray ( $PATH ) Then _ARRAYADD ( $CHROME , $BRO & " StartupUrls: " & $PROFILE & $PATH [ 0 ] , 0 , "||||" )
			$PATH = StringRegExp ( $PREFERENCES , "(?i)""newtab""\s*:\s*\[\s*\{?\s*(""[^]]*?)\}?\]" , 1 )
			If IsArray ( $PATH ) Then
				$PATH = $PATH [ 0 ]
				$PATH = StringRegExpReplace ( $PATH , "(?i)""active"":true,""entry""" , " Active" )
				$PATH = StringRegExpReplace ( $PATH , "(?i)""active"":false,""entry""" , " Not-active" )
				$PATH = StringRegExpReplace ( $PATH , "(?i)\{|\}" , "" )
				_ARRAYADD ( $CHROME , $BRO & " NewTab: " & $PROFILE & $PATH , 0 , "||||" )
			EndIf
			$SEARCHURL = StringRegExp ( $SECPREFERENCES , ",""(?:search_|)url""\s*:\s*""([^""]*?(?:[a-z]|\.)+.*?)""" , 1 )
			If IsArray ( $SEARCHURL ) Then
				If GUICtrlRead ( $CHECKBOX11 ) = 1 Then
					If Not StringRegExp ( $SEARCHURL [ 0 ] , "(?)\{google:baseURL\}.+={inputEncoding}$" ) Then _ARRAYADD ( $CHROME , $BRO & " DefaultSearchURL: " & $PROFILE & $SEARCHURL [ 0 ] , 0 , "||||" )
				Else
					_ARRAYADD ( $CHROME , $BRO & " DefaultSearchURL: " & $PROFILE & $SEARCHURL [ 0 ] , 0 , "||||" )
				EndIf
			EndIf
			$RET = StringRegExp ( $SECPREFERENCES , ",\s*""keyword""\s*:\s*""([^""]*?(?:[a-z]|\.)+.*?)""" , 1 )
			If IsArray ( $RET ) Then
				If GUICtrlRead ( $CHECKBOX11 ) = 1 Then
					If Not StringRegExp ( $RET [ 0 ] , "(?i)google.(com|[a-z][a-z])$" ) Then _ARRAYADD ( $CHROME , $BRO & " DefaultSearchKeyword: " & $PROFILE & $RET [ 0 ] , 0 , "||||" )
				Else
					_ARRAYADD ( $CHROME , $BRO & " DefaultSearchKeyword: " & $PROFILE & $RET [ 0 ] , 0 , "||||" )
				EndIf
			EndIf
			$NEWTABURL = StringRegExp ( $SECPREFERENCES , "(?i)""new_tab_url""\s*:\s*""([^""]*)""" , 1 )
			If IsArray ( $NEWTABURL ) Then
				If $NEWTABURL [ 0 ] <> "" Then
					If GUICtrlRead ( $CHECKBOX11 ) = 1 Then
						If Not StringRegExp ( $NEWTABURL [ 0 ] , "(?)\{google:baseURL\}.+={inputEncoding}$" ) Then _ARRAYADD ( $CHROME , $BRO & " DefaultNewTabURL: " & $PROFILE & $NEWTABURL [ 0 ] , 0 , "||||" )
					Else
						_ARRAYADD ( $CHROME , $BRO & " DefaultNewTabURL: " & $PROFILE & $NEWTABURL [ 0 ] , 0 , "||||" )
					EndIf
				EndIf
			EndIf
			If $BRO = "OPR" Then
				$SUGGESTURL = StringRegExp ( $PREFERENCES , "(?i)\s*""suggest(?:ions|)_url""\s*:\s*""([^""]*)""" , 1 )
			Else
				$SUGGESTURL = StringRegExp ( $SECPREFERENCES , "(?i)\s*""suggest(?:ions|)_url""\s*:\s*""([^""]*)""" , 1 )
			EndIf
			If IsArray ( $SUGGESTURL ) Then
				If $SUGGESTURL [ 0 ] Then
					If GUICtrlRead ( $CHECKBOX11 ) = 1 Then
						If Not StringRegExp ( $SUGGESTURL [ 0 ] , "(?i){google:baseSuggestURL}.+={google:suggestAPIKeyParameter}$" ) Then _ARRAYADD ( $CHROME , $BRO & " DefaultSuggestURL: " & $PROFILE & $SUGGESTURL [ 0 ] , 0 , "||||" )
					Else
						_ARRAYADD ( $CHROME , $BRO & " DefaultSuggestURL: " & $PROFILE & $SUGGESTURL [ 0 ] , 0 , "||||" )
					EndIf
				EndIf
			EndIf
			$RET = StringRegExp ( $SECPREFERENCES , """restore_on_startup""\s*:\s*(\d)(}|,)" , 1 )
			If IsArray ( $RET ) And $RET [ 0 ] = 1 Then _ARRAYADD ( $CHROME , $BRO & " Session Restore: " & $PROFILE & $INTERNET2 , 0 , "||||" )
		EndSelect
		CHROMEEX ( $ARRFOLD [ $N ] , $CHROME , $BRO )
	Next
	If $BRO = "BRA" Then
		$ARR1 = _FILELISTTOARRAYREC ( $FOL , "*" , 2 , 0 , 0 , 2 )
		For $E = 1 To UBound ( $ARR1 ) + 4294967295
			$ARR2 = _FILELISTTOARRAY ( $ARR1 [ $E ] , "*" , 2 , True )
			If IsArray ( $ARR2 ) And FileExists ( $ARR2 [ 1 ] & "\manifest.json" ) Then
				$NAME = $FF1
				$RET = FileRead ( $ARR2 [ 1 ] & "\manifest.json" )
				If Not StringInStr ( $RET , """key""" ) Then ContinueLoop
				$NAME1 = StringRegExp ( $RET , """name""\s*:\s*""(.+?)""" , 1 )
				If IsArray ( $NAME1 ) Then $NAME = $NAME1 [ 0 ]
				$DATECR = FILETIMECM ( $ARR1 [ $E ] )
				_ARRAYADD ( $CHROME , $BRO & " Extension: (" & $NAME & ") - " & $ARR1 [ $E ] & " [" & $DATECR & "]" , 0 , "|||" )
			EndIf
		Next
	EndIf
	Select
	Case $BRO = "CHR"
		$BRO1 = "Chrome"
		CHROMEHKLM ( "HKLM\SOFTWARE\Google\Chrome\Extensions" , $CHROME )
		For $U = 1 To UBound ( $USERREG ) + 4294967295
			CHROMEHKLM ( "HKU\" & $USERREG [ $U ] & "\SOFTWARE\Google\Chrome\Extensions" , $CHROME )
		Next
		CHROMEHKLM ( "HKLM\SOFTWARE\Wow6432Node\Google\Chrome\Extensions" , $CHROME )
	Case $BRO = "BRA"
		$BRO1 = "Brave"
	Case $BRO = "VIV"
		$BRO1 = "Vivaldi"
	Case $BRO = "YAN"
		$BRO1 = "Yandex"
	Case $BRO = "OPR"
		$BRO1 = "Opera"
	EndSelect
	$HKEY = _REGOPENKEYEX3 ( "HKLM\SOFTWARE\Clients\StartMenuInternet" , 1 )
	If Not @error And IsPtr ( $HKEY ) Then
		$P = 0
		While 1
			$OPERABRO = __REGENUMKEY ( $HKEY , $P )
			If @error Then ExitLoop
			If StringInStr ( $OPERABRO , $BRO1 ) Then
				$BROWSER = $OPERABRO
				BROWSERSTART ( $BROWSER , $CHROME , "HKLM" )
			EndIf
			$P += 1
		WEnd
	EndIf
	If StringRegExp ( $BRO1 , "Vivaldi|Opera|Yandex" ) Then
		For $U = 1 To UBound ( $USERREG ) + 4294967295
			If Not StringRegExp ( $USERREG [ $U ] , "(?i)^(S-1-5-19|S-1-5-20|.default)$" ) Then
				$HKEY = _REGOPENKEYEX3 ( "HKU\" & $USERREG [ $U ] & "\SOFTWARE\Clients\StartMenuInternet" , 1 )
				If Not @error And IsPtr ( $HKEY ) Then
					$P = 0
					While 1
						$OPERABRO = __REGENUMKEY ( $HKEY , $P )
						If @error Then ExitLoop
						If StringInStr ( $OPERABRO , $BRO1 ) Then
							$BROWSER = $OPERABRO
							BROWSERSTART ( $BROWSER , $CHROME , "HKU\" & $USERREG [ $U ] )
						EndIf
						$P += 1
					WEnd
				EndIf
			EndIf
		Next
	EndIf
	If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
	Return $CHROME
EndFunc
Func BROWSERSTART ( $BROWSER , ByRef $STARTMENU , $HIV )
	Local $VAL5 , $DATA
	$VAL5 = RegRead ( $HIV & "\SOFTWARE\Clients\StartMenuInternet\" & $BROWSER & "\shell\open\command" , "" )
	If @error = 0 Then
		Local $OPERAHIVE
		If StringRegExp ( $BROWSER , "(?i)Opera|Vivaldi|Yandex" ) Then $OPERAHIVE = "(" & $HIV & ") "
		$VAL5 = StringRegExpReplace ( $VAL5 , "(?i)http(s|):" , "hxxp\1:" )
		If GUICtrlRead ( $CHECKBOX11 ) = 4 Then
			_ARRAYADD ( $STARTMENU , "StartMenuInternet: " & $OPERAHIVE & $BROWSER & " - " & $VAL5 , 0 , "||||" )
		Else
			If $HIV = "HKLM" Then
				$VAL5 = StringRegExpReplace ( $VAL5 , """" , "" )
				Select
				Case StringInStr ( $BROWSER , "Chrome" ) And $VAL5 <> @ProgramFilesDir & "\Google\Chrome\Application\chrome.exe" And $VAL5 <> $PROGRAMFILES86 & "\Google\Chrome\Application\chrome.exe"
					_ARRAYADD ( $STARTMENU , "StartMenuInternet: " & $BROWSER & " - " & $VAL5 , 0 , "||||" )
				Case StringInStr ( $BROWSER , "Brave" ) And $VAL5 <> @ProgramFilesDir & "\BraveSoftware\Brave-Browser\Application\brave.exe"
					_ARRAYADD ( $STARTMENU , "StartMenuInternet: " & $BROWSER & " - " & $VAL5 , 0 , "||||" )
				Case StringInStr ( $BROWSER , "FIREFOX" ) And $VAL5 <> $PROGRAMFILES86 & "\Mozilla Firefox\firefox.exe" And $VAL5 <> @ProgramFilesDir & "\Mozilla Firefox\firefox.exe"
					_ARRAYADD ( $STARTMENU , "StartMenuInternet: " & $BROWSER & " - " & $VAL5 , 0 , "||||" )
				Case StringInStr ( $BROWSER , "IEXPLORE" ) And $VAL5 <> @ProgramFilesDir & "\Internet Explorer\iexplore.exe" And $VAL5 <> $PROGRAMFILES86 & "\Internet Explorer\iexplore.exe" And $VAL5 <> "%programfiles%\Internet Explorer\iexplore.exe"
					_ARRAYADD ( $STARTMENU , "StartMenuInternet: " & $BROWSER & " - " & $VAL5 , 0 , "||||" )
				Case StringInStr ( $BROWSER , "Opera" ) And $VAL5 <> @ProgramFilesDir & "\Opera\Launcher.exe" And $VAL5 <> $PROGRAMFILES86 & "\Opera\Launcher.exe" And $VAL5 <> $PROGRAMFILES86 & "\Opera\Opera.exe" And $VAL5 <> $PROGRAMFILES86 & "\Opera Mail\OperaMail.exe"
					_ARRAYADD ( $STARTMENU , "StartMenuInternet: " & $OPERAHIVE & $BROWSER & " - " & $VAL5 , 0 , "||||" )
				Case StringInStr ( $BROWSER , "Edge" ) And $VAL5 <> $PROGRAMFILES86 & "\Microsoft\Edge\Application\msedge.exe"
					_ARRAYADD ( $STARTMENU , "StartMenuInternet: " & $BROWSER & " - " & $VAL5 , 0 , "||||" )
				EndSelect
			Else
				BROWSERSTARTWL ( $HIV , $BROWSER , $DATA )
				If Not StringInStr ( $DATA , $VAL5 ) Then
					_ARRAYADD ( $STARTMENU , "StartMenuInternet: " & $OPERAHIVE & $BROWSER & " - " & $VAL5 , 0 , "||||" )
				EndIf
			EndIf
		EndIf
	EndIf
EndFunc
Func BROWSERSTARTWL ( $MKEY , $BROWSER , ByRef $VALDATA )
	Local $NAME
	$USER = StringRegExpReplace ( $MKEY , "HKU\\(.+)" , "$1" )
	$ACCOUNTNAME = _SECURITY__LOOKUPACCOUNTSID ( $USER )
	If IsArray ( $ACCOUNTNAME ) Then $NAME = $ACCOUNTNAME [ 0 ]
	$USERLOCALAPPDATADIR = StringRegExpReplace ( @LocalAppDataDir , "(?i)([a-z]:\\.+?\\)(.+?)(\\.+)" , "$1" & $NAME & "$3" )
	Select
	Case StringInStr ( $BROWSER , "Opera" )
		$VALDATA = """" & $USERLOCALAPPDATADIR & "\Programs\Opera\Opera.exe""" & """" & $USERLOCALAPPDATADIR & "\Opera Mail\OperaMail.exe""" & """" & @ProgramFilesDir & "\Opera\Launcher.exe""" & """" & $USERLOCALAPPDATADIR & "\Programs\Opera\Launcher.exe"""
	Case StringInStr ( $BROWSER , "Vivaldi" )
		$VALDATA = """" & $USERLOCALAPPDATADIR & "\Vivaldi\Application\vivaldi.exe"""
	Case StringInStr ( $BROWSER , "Yandex" )
		$VALDATA = """" & $USERLOCALAPPDATADIR & "\Yandex\YandexBrowser\Application\browser.exe"""
	EndSelect
EndFunc
Func CHROMEEX ( $FILE , ByRef $ARRCHROM , $BRO )
	$HREAD = FileOpen ( $FILE & "\Preferences" , 256 )
	$PREFERENCES = FileRead ( $HREAD )
	FileClose ( $HREAD )
	$HREAD = FileOpen ( $FILE & "\secure preferences" , 256 )
	$SECPREFERENCES = FileRead ( $HREAD )
	FileClose ( $HREAD )
	$EXTFOLDERALL = $FILE & "\Extensions"
	$FILEARRAY = _FILELISTTOARRAYREC ( $EXTFOLDERALL , "*|TEMP" , 2 , 0 , 0 , 0 )
	For $I = 1 To UBound ( $FILEARRAY ) + 4294967295
		$UPURL = ""
		$NAME = CHROMEEXNAME0 ( $PREFERENCES , $FILEARRAY [ $I ] )
		If Not $NAME Then $NAME = CHROMEEXNAME0 ( $SECPREFERENCES , $FILEARRAY [ $I ] )
		If Not $NAME Then
			$PATH = _FILELISTTOARRAY ( $EXTFOLDERALL & "\" & $FILEARRAY [ $I ] , "*" , 2 , True )
			If IsArray ( $PATH ) Then
				$RET = FileRead ( $PATH [ 1 ] & "\manifest.json" )
				If Not $UPURL Then
					$UPURL = StringRegExp ( $RET , "(?i)""update_url""\s*:\s*""(.+?)""" , 1 )
					If IsArray ( $UPURL ) Then $UPURL = $UPURL [ 0 ]
				EndIf
				$NAME = CHROMEEXNAME ( $PATH [ 1 ] )
			EndIf
		EndIf
		If Not $UPURL Then
			$PATH = _FILELISTTOARRAY ( $EXTFOLDERALL & "\" & $FILEARRAY [ $I ] , "*" , 2 , True )
			If IsArray ( $PATH ) Then
				$RET = FileRead ( $PATH [ 1 ] & "\manifest.json" )
				If Not $UPURL Then
					$UPURL = StringRegExp ( $RET , "(?i)""update_url""\s*:\s*""(.+?)""" , 1 )
					If IsArray ( $UPURL ) Then $UPURL = $UPURL [ 0 ]
				EndIf
			EndIf
		EndIf
		$NAME = CONV ( $NAME )
		$DATECR = FILETIMECM ( $EXTFOLDERALL & "\" & $FILEARRAY [ $I ] )
		If $UPURL And Not StringRegExp ( $UPURL , "(?i)http(|s)://(clients2\.google|extension-updates\.opera)\.com/" ) Then
			$UPURL = " [UpdateUrl:" & $UPURL & "] <==== " & $UPD1
		Else
			$UPURL = ""
		EndIf
		_ARRAYADD ( $ARRCHROM , $BRO & " Extension: (" & $NAME & ") - " & $EXTFOLDERALL & "\" & $FILEARRAY [ $I ] & " [" & $DATECR & "]" & $UPURL , 0 , "|||" )
	Next
	$EXT = StringRegExp ( $SECPREFERENCES , """path"":\s*""(.+?)""" , 3 )
	For $E = 0 To UBound ( $EXT ) + 4294967295
		$UPURL = ""
		If StringRegExp ( $EXT [ $E ] , "(?i)[c-z]:\\" ) And Not StringRegExp ( $EXT [ $E ] , "(?i)\\chrome\\.+\\resources" ) And Not StringRegExp ( $EXT [ $E ] , "(?i)User Data\\\\(Default|Profile \d+)\\\\Extensions|Brave-Browser\\\\User Data" ) Then
			$EXT [ $E ] = StringRegExpReplace ( $EXT [ $E ] , "\\\\" , "\\" )
			If FileExists ( $EXT [ $E ] & "\manifest.json" ) Then
				$RET = FileRead ( $EXT [ $E ] & "\manifest.json" )
				$UPURL = StringRegExp ( $RET , "(?i)""update_url""\s*:\s*""(.+?)""" , 1 )
				If IsArray ( $UPURL ) Then $UPURL = $UPURL [ 0 ]
				If $UPURL And Not StringRegExp ( $UPURL , "(?i)http(|s)://(clients2\.google|extension-updates\.opera)\.com/" ) Then
					$UPURL = " [UpdateUrl:" & $UPURL & "] <==== " & $UPD1
				Else
					$UPURL = ""
				EndIf
				$NAME = CHROMEEXNAME ( $EXT [ $E ] )
				$DATECR = FILETIMECM ( $EXT [ $E ] )
				_ARRAYADD ( $ARRCHROM , $BRO & " Extension: (" & $NAME & ") - " & $EXT [ $E ] & " [" & $DATECR & "]" & $UPURL , 0 , "|||" )
			EndIf
		EndIf
	Next
EndFunc
Func CHROMEEXNAME ( $PATH1 )
	$NAME = ""
	If StringRegExp ( $PATH1 , "\\manifest.*.json" ) Then
		$RET = FileRead ( $PATH1 )
		$PATH1 = StringRegExpReplace ( $PATH1 , "(.+)\\.+" , "$1" )
	Else
		$RET = FileRead ( $PATH1 & "\manifest.json" )
	EndIf
	If StringRegExp ( $RET , "(?i)""name""\s*:\s*""__MSG" ) Then
		$CL = StringRegExp ( $RET , "(?i)""default_locale""\s*:\s*""(.+?)""" , 1 )
		If IsArray ( $CL ) Then $CL = $CL [ 0 ]
		$MS = StringRegExp ( $RET , "(?i)""name""\s*:.*MSG_(.+?)__""" , 1 )
		If IsArray ( $MS ) Then
			$READJL = FileRead ( $PATH1 & "\_locales\" & $CL & "\messages.json" )
			$REGEX = StringRegExp ( $READJL , "(?is)""" & $MS [ 0 ] & """[^}]+?""message"":\s*""(.*?)""" , 1 )
			If IsArray ( $REGEX ) Then $NAME = FIREFOXEXTENSIONFILE1 ( $READJL , $MS [ 0 ] , $REGEX [ 0 ] )
		EndIf
	Else
		$RET = StringRegExpReplace ( $RET , "(?s)^\s*\{|\s*\}\s*$" , "" )
		$RET = StringRegExpReplace ( $RET , "(?s)\{[^{]+?\}" , "" )
		$RET = StringRegExpReplace ( $RET , "(?s)\{[^{]+?\}" , "" )
		If StringRegExp ( $RET , "(?i),name""\s*:\s*""(.+?)""" ) Then
			$REGEX = StringRegExp ( $RET , "(?i),name""\s*:\s*""(.+?)""" , 3 )
		Else
			$REGEX = StringRegExp ( $RET , "(?i)""name""\s*:\s*""(.+?)""" , 3 )
		EndIf
		If IsArray ( $REGEX ) Then $NAME = StringRegExpReplace ( $REGEX [ 0 ] , "(?i)http(s|):" , "hxxp\1:" )
	EndIf
	If Not $NAME Then $NAME = $FF1
	Return $NAME
EndFunc
Func CHROMEEXNAME0 ( $READ , $EXID )
	If StringRegExp ( $READ , $EXID & """\s*:\s*\{" ) And StringRegExp ( $READ , """path"":\s*""" & $EXID ) Then
		$ARR = StringRegExp ( $READ , "(?is)" & $EXID & "(?:.(?!" & $EXID & "))+?""path"":\s*""" & $EXID , 1 )
		If IsArray ( $ARR ) Then
			$NAME = StringRegExp ( $ARR [ 0 ] , ",""name""\s*:\s*""((?!__MS)[^:]+?)""," , 1 )
			If IsArray ( $NAME ) Then Return $NAME [ 0 ]
		EndIf
	EndIf
EndFunc
Func CHROMEFIX ( )
	$FILEP = ""
	$BRO = StringRegExpReplace ( $FIX , "(\w{3}) .+" , "$1" )
	Select
	Case $BRO = "CHR"
		$BRO = "Chrome"
		$FOL = @LocalAppDataDir & "\Google\Chrome\User Data\"
	Case $BRO = "BRA"
		$BRO = "Brave"
		$FOL = @LocalAppDataDir & "\BraveSoftware\Brave-Browser\User Data\"
	Case $BRO = "VIV"
		$BRO = "Vivaldi"
		$FOL = @LocalAppDataDir & "\Vivaldi\User Data\"
	Case $BRO = "YAN"
		$BRO = "Yandex"
		$FOL = @LocalAppDataDir & "\Yandex\YandexBrowser\User Data\"
	EndSelect
	If $BRO = "Yandex" Then
		$BRO1 = "Browser"
	Else
		$BRO1 = $BRO
	EndIf
	$ARRAYPRO = ProcessList ( )
	For $I = 1 To UBound ( $ARRAYPRO ) + 4294967295
		If StringRegExp ( $ARRAYPRO [ $I ] [ 0 ] , "(?i)" & $BRO1 & "\.exe" ) Then
			ProcessClose ( $ARRAYPRO [ $I ] [ 1 ] )
		EndIf
	Next
	If StringRegExp ( $FIX , "DefaultSearchProvider:" ) Then Return FileWrite ( $HFIXLOG , $FIX & " ==> " & $CHR1 & "." & @CRLF )
	If StringRegExp ( $FIX , "(?i)(HomePage|StartupUrls|DefaultSearchKeyword|RestoreOnStartup|NewTab|DefaultSearchURL|DefaultSuggestURL|DefaultNewTabURL|Session Restore|crx|Notifications|Custom_url):" ) Then
		$PROFILE = StringRegExpReplace ( $FIX , "^\w{3} .+?: (.+?) ->.*" , "$1" )
		$PATH = $FOL & $PROFILE & "\preferences"
		$PATHSEC = $FOL & $PROFILE & "\Secure Preferences"
		$HREAD = FileOpen ( $PATH , 256 )
		$PREFERENCES = FileRead ( $HREAD )
		FileClose ( $HREAD )
		$HREAD = FileOpen ( $PATHSEC , 256 )
		$SECPREFERENCES = FileRead ( $PATHSEC )
		FileClose ( $HREAD )
		$HPREF = FileOpen ( @TempDir & "\preferences00" , 2 + 256 )
		Select
		Case StringInStr ( $FIX , "Custom_url:" )
			If Not StringRegExp ( $PREFERENCES , """custom_url""\s*:\s*""" ) Then Return NFOUND ( $BRO & " Custom_url" )
			$PREFERENCES = StringRegExpReplace ( $PREFERENCES , "(?is)""tabs""\s*:\s*{.*""new_page""\s*:\s*{""custom_url""\s*:\s*"".+?}},\s*\R*" , "" )
			FileWrite ( $HPREF , $PREFERENCES )
			FileClose ( $HPREF )
			FileMove ( @TempDir & "\preferences00" , $PATH , 1 )
			DELETED ( $BRO & " Custom_url" )
		Case StringInStr ( $FIX , "StartupUrls:" )
			If Not StringRegExp ( $SECPREFERENCES , "(?i)""startup_urls""\s*:\s*\[" ) Then Return NFOUND ( $BRO & " StartupUrls" )
			$SECPREFERENCES = StringRegExpReplace ( $SECPREFERENCES , "(?is)\s*""startup_urls""\s*:\s*\[[^]]*?\]\s*\R*" , "" )
			FileWrite ( $HPREF , $SECPREFERENCES )
			FileClose ( $HPREF )
			FileMove ( @TempDir & "\preferences00" , $PATHSEC , 1 )
			DELETED ( $BRO & " StartupUrls" )
		Case StringInStr ( $FIX , "DefaultSearchKeyword:" )
			If Not StringRegExp ( $SECPREFERENCES , ",\s*""keyword""\s*:\s*""[^""]*?(?:[a-z]|\.)+.*?""" ) Then Return NFOUND ( $BRO & " DefaultSearchKeyword" )
			$SECPREFERENCES = StringRegExpReplace ( $SECPREFERENCES , "(?is),\s*""keyword""\s*:\s*""[^""]*?(?:[a-z]|\.)+.*?"",?\s*\R*" , "" )
			FileWrite ( $HPREF , $SECPREFERENCES )
			FileClose ( $HPREF )
			FileMove ( @TempDir & "\preferences00" , $PATHSEC , 1 )
			DELETED ( $BRO & " DefaultSearchKeyword" )
		Case StringInStr ( $FIX , "HomePage:" )
			If $BRO = "Vivaldi" Then
				$SECPREFERENCES = $PREFERENCES
				$PATHSEC = $PATH
			EndIf
			If Not StringRegExp ( $SECPREFERENCES , """homepage""\s*:\s*""[^""]*?""," ) Then Return NFOUND ( $BRO & " HomePage" )
			$SECPREFERENCES = StringRegExpReplace ( $SECPREFERENCES , "(?is)\s*""homepage""\s*:\s*""[^""]*?""," , "" )
			If $BRO = "Vivaldi" Then $SECPREFERENCES = StringRegExpReplace ( $SECPREFERENCES , "\s*""homepage_cache""\s*:\s*""[^""]*?""," , "" )
			FileWrite ( $HPREF , $SECPREFERENCES )
			FileClose ( $HPREF )
			FileMove ( @TempDir & "\preferences00" , $PATHSEC , 1 )
			DELETED ( $BRO & " HomePage" )
		Case StringInStr ( $FIX , "RestoreOnStartup:" )
			If Not StringRegExp ( $SECPREFERENCES , "(?i)""urls_to_restore_on_startup"":" ) Then Return NFOUND ( $BRO & " RestoreOnStartup" )
			$SECPREFERENCES = StringRegExpReplace ( $SECPREFERENCES , "(?is)\s*""urls_to_restore_on_startup""\s*:\s*\[[^]]*?\]\s*\R*" , "" )
			FileWrite ( $HPREF , $SECPREFERENCES )
			FileClose ( $HPREF )
			FileMove ( @TempDir & "\preferences00" , $PATHSEC , 1 )
			DELETED ( $BRO & " RestoreOnStartup" )
		Case StringInStr ( $FIX , "Notifications:" )
			$READ1 = StringRegExp ( $PREFERENCES , "(?i),""notifications"":\{\}," , 1 )
			If IsArray ( $READ1 ) Then Return NFOUND ( $BRO & " Notifications:" )
			$READ1 = StringRegExp ( $PREFERENCES , "(?i),""notifications"":\{.+?\}\}," , 1 )
			If Not IsArray ( $READ1 ) Then Return NFOUND ( "CHR Notifications:" )
			$PREFERENCES = StringRegExpReplace ( $PREFERENCES , "(?is),""notifications"":\{(.+?)\}\}," , ",""notifications"":\{\}," )
			FileWrite ( $HPREF , $PREFERENCES )
			FileClose ( $HPREF )
			FileMove ( @TempDir & "\preferences00" , $PATH , 1 )
			DELETED ( $BRO & " Notifications" )
		Case StringInStr ( $FIX , "NewTab:" )
			If Not StringRegExp ( $PREFERENCES , "(?i)""chrome_url_overrides""\s*:" ) Then Return NFOUND ( $BRO & " NewTab" )
			$PREFERENCES = StringRegExpReplace ( $PREFERENCES , "(?is)\s*""chrome_url_overrides""\s*:.+?,""newtab""[^]]*\]\},?\s*\R*" , "" )
			FileWrite ( $HPREF , $PREFERENCES )
			FileClose ( $HPREF )
			FileMove ( @TempDir & "\preferences00" , $PATH , 1 )
			DELETED ( $BRO & " NewTab" )
		Case StringInStr ( $FIX , "DefaultSearchURL:" )
			If Not StringRegExp ( $SECPREFERENCES , ",\s*""(?:search_|)url""\s*:\s*""[^""]*?(?:[a-z]|\.)+.*?""" ) Then Return NFOUND ( $BRO & " DefaultSearchURL" )
			$SECPREFERENCES = StringRegExpReplace ( $SECPREFERENCES , ",\s*""(?:search_|)url""\s*:\s*""[^""]*?(?:[a-z]|\.)+.*?"",?\R*" , "" )
			FileWrite ( $HPREF , $SECPREFERENCES )
			FileClose ( $HPREF )
			FileMove ( @TempDir & "\preferences00" , $PATHSEC , 1 )
			DELETED ( $BRO & " DefaultSearchURL" )
		Case StringInStr ( $FIX , "DefaultSuggestURL:" )
			If Not StringRegExp ( $SECPREFERENCES , "\s*""suggest(?:ions|)_url""\s*:\s*""[^""]*?(?:[a-z]|\.)+.*?""" ) Then Return NFOUND ( $BRO & " DefaultSuggestURL" )
			$SECPREFERENCES = StringRegExpReplace ( $SECPREFERENCES , "\s*""suggest(?:ions|)_url""\s*:\s*""[^""]*?(?:[a-z]|\.)+.*?"",?\R*" , "" )
			FileWrite ( $HPREF , $SECPREFERENCES )
			FileClose ( $HPREF )
			FileMove ( @TempDir & "\preferences00" , $PATHSEC , 1 )
			DELETED ( $BRO & " DefaultSuggestURL" )
		Case StringInStr ( $FIX , "DefaultNewTabURL:" )
			If Not StringRegExp ( $SECPREFERENCES , "(?i)""new_tab_url""\s*:" ) Then Return NFOUND ( $BRO & " DefaultNewTabURL" )
			$SECPREFERENCES = StringRegExpReplace ( $SECPREFERENCES , "(?is)\s*""new_tab_url""\s*:\s*"".*?"",?\s*\R*" , "" )
			FileWrite ( $HPREF , $SECPREFERENCES )
			FileClose ( $HPREF )
			FileMove ( @TempDir & "\preferences00" , $PATHSEC , 1 )
			DELETED ( $BRO & " DefaultNewTabURL" )
		Case StringInStr ( $FIX , "Session Restore:" )
			$RET = StringRegExp ( $SECPREFERENCES , """restore_on_startup""\s*:\s*(\d)(}|,)" , 1 )
			If Not IsArray ( $RET ) Or $RET [ 0 ] <> 1 Then Return NFOUND ( $BRO & " Session Restore:" )
			If StringRegExp ( $SECPREFERENCES , """restore_on_startup""\s*:\s*(\d)," ) Then $SECPREFERENCES = StringRegExpReplace ( $SECPREFERENCES , "(?is)""restore_on_startup""\s*:\s*\d," , """restore_on_startup"":5," )
			If StringRegExp ( $SECPREFERENCES , """restore_on_startup""\s*:\s*(\d)}" ) Then $SECPREFERENCES = StringRegExpReplace ( $SECPREFERENCES , "(?is)""restore_on_startup""\s*:\s*\d}" , """restore_on_startup"":5}" )
			FileWrite ( $HPREF , $SECPREFERENCES )
			FileClose ( $HPREF )
			FileMove ( @TempDir & "\preferences00" , $PATHSEC , 1 )
			DELETED ( $BRO & " Session Restore" )
		Case StringRegExp ( $FIX , "CHR crx:" )
			$FILEP = StringRegExpReplace ( $FIX , "(?i).*([A-Z]:\\.+?) \[.*\]" , "$1" )
			If FileExists ( $FILEP ) Then
				Return MOVEDIR ( $FILEP )
			Else
				NFOUND ( $FILEP )
			EndIf
		EndSelect
		Return 1
	EndIf
	If StringInStr ( $FIX , "Profile:" ) Then
		$FILEP = StringRegExpReplace ( $FIX , "(?i).*([A-Z]:\\.+?) \[.*" , "$1" )
		Return MOVEDIR ( $FILEP )
	EndIf
	If StringInStr ( $FIX , "HKLM\SOFTWARE\Policies\Google:" ) Then Return DELKEY ( "HKLM\SOFTWARE\Policies\Google" )
	If StringInStr ( $FIX , "SOFTWARE\Policies\Google:" ) Then
		$USER = StringRegExpReplace ( $FIX , "(?i)HKU\\(.+?)\\.+" , "$1" )
		Return DELKEY ( "HKU\" & $USER & "\SOFTWARE\Policies\Google" )
	EndIf
	If StringRegExp ( $FIX , "CHR (HKLM(-x32|)|HKU)\\" ) And StringInStr ( $FIX , "\Extension" ) Then
		$SUB = StringRegExpReplace ( $FIX , ".+? \[(.+?)\].*" , "$1" )
		If StringInStr ( $FIX , "CHR HKLM\" ) Then DELKEY ( "HKLM\SOFTWARE\Google\Chrome\Extensions" & "\" & $SUB )
		If StringInStr ( $FIX , "CHR HKU\" ) Then
			$USER = StringRegExpReplace ( $FIX , "CHR HKU\\(.+?)\\.+" , "$1" )
			DELKEY ( "HKU\" & $USER & "\SOFTWARE\Google\Chrome\Extensions" & "\" & $SUB )
		EndIf
		If StringInStr ( $FIX , "CHR HKLM-x32" ) Then DELKEY ( "HKLM\SOFTWARE\Wow6432Node\Google\Chrome\Extensions" & "\" & $SUB )
		If Not StringRegExp ( $FIX , "<.+>" ) And StringRegExp ( $FIX , "(?i)[c-z]:\\" ) And StringRegExp ( $FIX , "\[.*\]$" ) Then
			$FILEP = StringRegExpReplace ( $FIX , ".+ \[.+\] - (.+) \[.*\]" , "$1" )
		Else
			Return 1
		EndIf
		If Not FileExists ( $FILEP ) Then
			NFOUND ( $FILEP )
		Else
			$ATT = FileGetAttrib ( $FILEP )
			If StringInStr ( $ATT , "D" ) Then
				MOVEDIR ( $FILEP )
			Else
				MOVEFILENORMAL ( $FILEP )
			EndIf
		EndIf
	EndIf
EndFunc
Func CHROMEHKLM ( $KEY , ByRef $CHROME , $BRO = "Chrome" )
	$HKLM = "HKLM"
	If StringInStr ( $KEY , "Wow6432Node" ) Then $HKLM = "HKLM-x32"
	If StringInStr ( $KEY , "HKU\" ) Then $HKLM = StringRegExpReplace ( $KEY , "(HKU\.+?).+" , "$1" )
	$BRO1 = $BRO
	If $BRO = "Chrome" Then $BRO1 = "CHR"
	$HKEY = _REGOPENKEYEX3 ( $KEY , 1 )
	If Not @error And IsPtr ( $HKEY ) Then
		$I = 0
		While 1
			$SUBK = __REGENUMKEY ( $HKEY , $I )
			If @error Then ExitLoop
			$DATA = RegRead ( $KEY & "\" & $SUBK , "Path" )
			If Not @error Then
				$DATECR = ""
				$DATEC = FileGetTime ( $DATA , 1 )
				If Not @error Then
					$DATECR = " [" & $DATEC [ 0 ] & "-" & $DATEC [ 1 ] & "-" & $DATEC [ 2 ] & "]"
				Else
					If Not StringRegExp ( $DATA , "http(s|):" ) Then $DATECR = " <" & $NFOUND & ">"
				EndIf
				_ARRAYADD ( $CHROME , $BRO1 & " " & $HKLM & "\...\" & $BRO & "\Extension: " & "[" & $SUBK & "] - " & $DATA & $DATECR , 0 , "||||" )
				$I += 1
				ContinueLoop
			EndIf
			$DATA = RegRead ( $KEY & "\" & $SUBK , "update_url" )
			If Not @error Then
				If StringRegExp ( $DATA , "(?i)http(|s)://(edge\.microsoft\.com|extensionwebstorebase.edgesv.net|clients2\.google\.com)/" ) Then
					$DATA = ""
				Else
					$DATA = " - " & $DATA
				EndIf
				_ARRAYADD ( $CHROME , $BRO1 & " " & $HKLM & "\...\" & $BRO & "\Extension: " & "[" & $SUBK & "]" & $DATA , 0 , "||||" )
				$I += 1
				ContinueLoop
			EndIf
			_ARRAYADD ( $CHROME , $BRO1 & " " & $HKLM & "\...\" & $BRO & "\Extension: " & "[" & $SUBK & "] - <" & $NO & " Path/update_url>" , 0 , "||||" )
			$I += 1
		WEnd
		If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
	EndIf
EndFunc
Func CHROMENOTI ( $READ , ByRef $ARR , $PROF , $BROWS = "CHR Notifications: " )
	$READ1 = StringRegExp ( $READ , ",""notifications"":\{\}," , 1 )
	If IsArray ( $READ1 ) Then Return
	$READ1 = StringRegExp ( $READ , ",""notifications"":\{(.+?)\}\}," , 1 )
	If Not IsArray ( $READ1 ) Then Return
	$NOTI = StringRegExp ( $READ1 [ 0 ] , "(?i)http.+?setting"":\[?\d" , 3 )
	If Not IsArray ( $NOTI ) Then Return
	Local $ARR1 [ 1 ]
	For $I = 0 To UBound ( $NOTI ) + 4294967295
		If StringRegExp ( $NOTI [ $I ] , "(?i)setting"":\[?1" ) Then _ARRAYADD ( $ARR1 , StringRegExpReplace ( $NOTI [ $I ] , "(?i)(https?:[^:]+):.+" , "$1" ) , 0 , "||||" )
	Next
	If UBound ( $ARR1 ) > 1 Then _ARRAYADD ( $ARR , $BROWS & $PROF & _ARRAYTOSTRING ( $ARR1 , "; " , 1 ) , 0 , "|||" )
EndFunc
Func CMD ( ByRef $F , $BATCH1 = 0 )
	Global $CHCP
	$A = ""
	$RED = ""
	$COM = "Batch:"
	If Not $BATCH1 Then
		$COM = StringRegExpReplace ( $FIX , "(?i)CMD:\s*(.+)" , "$1" )
		$A = @CRLF
	EndIf
	FileWrite ( $HFIXLOG , @CRLF & "========= " & $COM & " =========" & $A & @CRLF )
	$ITIME = _TIMER_SETTIMER ( $FORM1 , 3600000 , TIMEA )
	If $BATCH1 Then
		CMDBATCH ( $F )
	Else
		If StringInStr ( $COM , ">" ) Then
			RunWait ( @ComSpec & " /u /c " & $COM , "" , @SW_HIDE )
		Else
			If StringRegExp ( $COM , "(?i)reg (delete|add) " ) And Not StringInStr ( $COM , "/f" ) Then $COM = StringRegExpReplace ( $COM , "(.+)" , "$1 /f" )
			If StringRegExp ( $COM , "(?i)reg export " ) And Not StringInStr ( $COM , "/y" ) Then $COM = StringRegExpReplace ( $COM , "(.+)" , "$1 /y" )
			If StringInStr ( $COM , "chkdsk" ) Then
				$YES = CMDYES ( )
				If $YES Then $COM = "ECHO " & $YES & " | " & $COM
			EndIf
			If Not $CHCP Then
				$PID = Run ( @ComSpec & " /c chcp" , "" , @SW_HIDE , 8 )
				ProcessWaitClose ( $PID )
				$READ1 = StdoutRead ( $PID )
				$CHCP = StringRegExpReplace ( $READ1 , ".+?(\d+)\s*" , "$1" )
			EndIf
			$READ = CMDRUN1 ( $COM , $CHCP )
			FileWrite ( $HFIXLOG , $READ & @CRLF )
		EndIf
	EndIf
	_TIMER_KILLTIMER ( $FORM1 , $ITIME )
	$COM = " Batch:"
	If Not $BATCH1 Then $COM = " CMD:"
	FileWrite ( $HFIXLOG , @CRLF & "========= " & $END & " " & $OF & $COM & " =========" & @CRLF & @CRLF )
EndFunc
Func CMDRUN1 ( $COM , $ENCODE = "" , $WDIR = "" )
	$NCHCP = ""
	If StringRegExp ( $ENCODE , "866|852" ) Or StringRegExp ( "0419|0422|0423|0402|042F|0C1A|1C1A|281A|301A|0428|0450|082C|0843|201A|0415" , @MUILang ) Then $NCHCP = "chcp 65001 >NUL & "
	Return CMDRUN ( $NCHCP & $COM , $WDIR )
EndFunc
Func CMDRUN ( $COM , $WDIR = "" )
	$PID = Run ( @ComSpec & " /u /c " & $COM , $WDIR , @SW_HIDE , 2 + 4 )
	ProcessWaitClose ( $PID )
	$READ1 = StdoutRead ( $PID , False , True )
	If $READ1 Then Return CMDRUN0 ( $READ1 )
	$READ2 = StderrRead ( $PID )
	If $READ2 Then Return CMDRUN0 ( $READ2 )
EndFunc
Func CMDRUN0 ( $READ )
	$PATH1 = $C & "\FRST\logs\cmd1" & Random ( 1000 , 9999 , 1 ) & ".txt"
	$HLOG1 = FileOpen ( $PATH1 , 256 + 2 )
	FileWrite ( $HLOG1 , $READ )
	FileClose ( $HLOG1 )
	$READ = FileRead ( $PATH1 )
	FileDelete ( $PATH1 )
	Return $READ
EndFunc
Func CMDBATCH ( ByRef $F )
	$WDIR = ""
	If Not $CHCP Then
		$PID = Run ( @ComSpec & " /c chcp" , "" , @SW_HIDE , 8 )
		ProcessWaitClose ( $PID )
		$READ1 = StdoutRead ( $PID )
		$CHCP = StringRegExpReplace ( $READ1 , ".+(\d+)\s*" , "$1" )
	EndIf
	$B = $F + 1
	While 1
		$COM = FileReadLine ( @ScriptDir & $FIXLIST , $B )
		If @error Then ExitLoop
		If Not $COM Or StringInStr ( $COM , "echo off" ) Then
			$B += 1
			ContinueLoop
		EndIf
		If StringInStr ( $COM , "endbatch" ) Then ExitLoop
		If StringRegExp ( $COM , "^(?i)(CD|CHDIR) " ) Then
			$WDIR = StringRegExpReplace ( $COM , "^(?i)(CD|CHDIR) (|/D )\s*(.+)\s*" , "$3" )
			$WDIR = StringRegExpReplace ( $WDIR , "^""|""$" , "$3" )
			If $WDIR = "CD\" Then $WDIR = $C & "\"
			If StringRegExp ( $WDIR , "^(?i)Windows" ) Then $WDIR = $C & "\" & $WDIR
			If StringRegExp ( $WDIR , "%.+%" ) Then $WDIR = _EXPAND ( $WDIR )
			$B += 1
			ContinueLoop
		EndIf
		If StringRegExp ( $COM , "^(?i)PUSHD" ) Then
			$WDIR = StringRegExpReplace ( $COM , "^(?i)PUSHD\s*(.+)\s*" , "$1" )
			$WDIR = StringRegExpReplace ( $WDIR , "^""|""$" , "$3" )
			If $WDIR = "CD\" Then $WDIR = $C & "\"
			If StringRegExp ( $WDIR , "^(?i)Windows" ) Then $WDIR = $C & "\" & $WDIR
			If StringRegExp ( $WDIR , "%.+%" ) Then $WDIR = _EXPAND ( $WDIR )
			$B += 1
			ContinueLoop
		EndIf
		If StringRegExp ( $COM , "^(?i)POPD" ) Then
			$WDIR = @ScriptDir
			$B += 1
			ContinueLoop
		EndIf
		$COM = StringRegExpReplace ( $COM , "%%" , "%" )
		If StringRegExp ( $COM , "(?i)reg (delete|add) " ) And Not StringInStr ( $COM , "/f" ) Then $COM = StringRegExpReplace ( $COM , "(.+)" , "$1 /f" )
		If StringRegExp ( $COM , "(?i)reg export " ) And Not StringInStr ( $COM , "/y" ) Then $COM = StringRegExpReplace ( $COM , "(.+)" , "$1 /y" )
		If StringInStr ( $COM , "chkdsk" ) And Not StringInStr ( $COM , "echo " ) Then
			$YES = CMDYES ( )
			If $YES Then $COM = "ECHO " & $YES & " | " & $COM
		EndIf
		$READ = CMDRUN1 ( $COM , $CHCP , $WDIR )
		FileWrite ( $HFIXLOG , $READ )
		FileWrite ( $HFIXLOG , @CR & @CR )
		$B += 1
	WEnd
	$F = $B
EndFunc
Func CMDASS ( ByRef $ARR )
	$RUN1 = RegRead ( "HKLM\software\Classes\.cmd" , "" )
	If $RUN1 <> "cmdfile" Then
		$RET = RegRead ( "HKLM\software\Classes\" & $RUN1 & "\shell\open\command" , "" )
		_ARRAYADD ( $ARR , "HKLM\...\.cmd: " & $RUN1 & " => " & $RET & " <==== " & $UPD1 , 0 , "|||" )
	EndIf
	$RUN1 = RegRead ( "HKLM\software\Classes\cmdfile\DefaultIcon" , "" )
	If $OSNUM < 6.1 Then
		If $RUN1 <> "%SystemRoot%\System32\shell32.dll,-153" Then _ARRAYADD ( $ARR , "HKLM\...\cmdfile\DefaultIcon: " & $RUN1 & " <==== " & $UPD1 , 0 , "|||" )
	Else
		If $RUN1 <> "%SystemRoot%\System32\imageres.dll,-68" Then _ARRAYADD ( $ARR , "HKLM\...\cmdfile\DefaultIcon: " & $RUN1 & " <==== " & $UPD1 , 0 , "|||" )
	EndIf
	$RUN1 = RegRead ( "HKLM\software\Classes\cmdfile\shell\open\command" , "" )
	If $RUN1 <> """%1"" %*" Then _ARRAYADD ( $ARR , "HKLM\...\cmdfile\shell\open\command: " & $RUN1 & " <==== " & $UPD1 , 0 , "|||" )
EndFunc
Func CMDUP ( $HWND , $IMSG , $IIDTIMER , $ITIME )
	#forceref $hWnd, $iMsg, $iIDTimer, $itime
	$ARRAYPRO = ProcessList ( )
	If Not IsArray ( $ARRAYPRO ) Then Return
	For $I = 1 To UBound ( $ARRAYPRO ) + 4294967295
		If StringRegExp ( $ARRAYPRO [ $I ] [ 0 ] , "(?i)(reg|cmd|conhost)\.exe" ) Then ProcessClose ( $ARRAYPRO [ $I ] [ 1 ] )
	Next
EndFunc
Func CMDYES ( )
	$PATH = $C & "\FRST\logs\cmd" & Random ( 1000 , 9999 , 1 ) & ".txt"
	$HLOG1 = FileOpen ( $PATH , 256 + 2 )
	FileClose ( $HLOG1 )
	$RET = CMDRUN ( "del /p " & $PATH )
	If Not StringRegExp ( $RET , "\(\w/\w\)\?" ) Then Return
	$YES = StringRegExpReplace ( $RET , ".+\((\w)/\w\).+\v*" , "$1" )
	FileDelete ( $PATH )
	Return $YES
EndFunc
Func CODEINTEGRITY ( )
	$PATH = @TempDir & "\codeint" & Random ( 1000 , 9999 , 1 )
	RunWait ( @ComSpec & " /c " & "wevtutil qe ""Microsoft-Windows-CodeIntegrity/Operational"" ""/q:*[System [(Level=2)]]"" /c:12 /rd:true /uni:true /f:text >> """ & $PATH & """" , "" , @SW_HIDE )
	$HCODE = FileOpen ( $PATH , 256 )
	$EVENT = FileRead ( $HCODE )
	If Not StringInStr ( $EVENT , ":" ) Then Return
	FileClose ( $HCODE )
	$EVENT = StringRegExpReplace ( $EVENT , "(?m)^\s*" , "" )
	$EVENT = StringRegExpReplace ( $EVENT , "(?m)^(Event\[\d\]|Log Name|Event ID|Task|Level|Opcode|Keyword|Source|User|User Name|Computer):?.*\v{2}" , "" )
	$EVENT = StringRegExpReplace ( $EVENT , "(?m)^(Date:.+\d)T(\d.+\v{2})" , @CRLF & "$1 $2" )
	$EVENT = StringRegExpReplace ( $EVENT , "(?m)^(Date:.+?)\.\d+Z" , "$1" )
	$EVENT = StringRegExpReplace ( $EVENT , "(?s)Date:[\s\d:-]+\RDescription:\s*\RN/A\R" , "" )
	$ARR1 = StringRegExp ( $EVENT , "(?s)Date:[\s\d:-]+\RDescription:\s*.+?\R" , 3 )
	If UBound ( $ARR1 ) < 1 Then Return
	$HCODE = FileOpen ( @TempDir & "\codeint2" , 256 + 2 )
	FileWrite ( $HCODE , @CRLF & "CodeIntegrity:" & @CRLF & "===============" & @CRLF )
	For $I = 0 To UBound ( $ARR1 ) + 4294967295
		$HCODE = FileOpen ( @TempDir & "\codeint2" , 256 )
		$READ = FileRead ( $HCODE )
		FileClose ( $HCODE )
		$RET = StringRegExpReplace ( $ARR1 [ $I ] , "(?s).+Description:\s*(.+)" , "$1" )
		If Not StringInStr ( $READ , $RET ) Then
			$HCODE = FileOpen ( @TempDir & "\codeint2" , 256 + 1 )
			FileWrite ( $HCODE , $ARR1 [ $I ] & @CRLF )
			FileClose ( $HCODE )
		EndIf
	Next
	$HCODE = FileOpen ( @TempDir & "\codeint2" , 256 )
	$READ = FileRead ( $HCODE )
	FileWrite ( $HADDITION , $READ )
	FileClose ( $HCODE )
	FileDelete ( @TempDir & "\codeint*" )
EndFunc
Func WINDEF ( )
	$PATH = @TempDir & "\codeint" & Random ( 1000 , 9999 , 1 )
	RunWait ( @ComSpec & " /c " & "wevtutil qe ""Microsoft-Windows-Windows Defender/Operational"" ""/q:*[System [(Level=3)]]"" /c:5 /rd:true /uni:true /f:text >> """ & $PATH & """" , "" , @SW_HIDE )
	RunWait ( @ComSpec & " /c " & "wevtutil qe ""Microsoft-Windows-Windows Defender/Operational"" ""/q:*[System [(Level=2)]]"" /c:5 /rd:true /uni:true /f:text >> """ & $PATH & """" , "" , @SW_HIDE )
	$HCODE = FileOpen ( $PATH , 256 )
	$EVENTS = FileRead ( $HCODE )
	FileClose ( $HCODE )
	If Not StringInStr ( $EVENTS , ":" ) Then Return
	$EVENTS = StringRegExpReplace ( $EVENTS , "(?m)^\s*" , "" )
	$EVENTS = StringRegExpReplace ( $EVENTS , "(?m)^Event\[\d\]:?\R" , "" )
	$EVENTS = StringRegExpReplace ( $EVENTS , "(?m)^(Log Name|(Scan|Event) ID|Task|Level|Opcode|Keyword|Source|User|User Name|Computer|ID):.*\R" , "" )
	$EVENTS = StringRegExpReplace ( $EVENTS , "(?m)^(Date:.+\d)T(\d.+\v{2})" , @CRLF & "$1 $2" )
	$EVENTS = StringRegExpReplace ( $EVENTS , "(?m)^(Date:.+?)\.\d+Z" , "$1" )
	$EVENTS = StringRegExpReplace ( $EVENTS , "(?s)\R{2,}" , @CRLF & @CRLF )
	FileWrite ( $HADDITION , @CRLF & "Windows Defender:" & @CRLF & "================" & $EVENTS )
	FileDelete ( $PATH )
EndFunc
Func CLOSEHANDLE ( ByRef $FHANDLE )
	If IsPtr ( $FHANDLE ) Then $ACALL = DllCall ( "kernel32.dll" , "bool" , "CloseHandle" , "handle" , $FHANDLE )
	$FHANDLE = ""
EndFunc
Func COMASS ( ByRef $ARR )
	$RUN1 = RegRead ( "HKLM\software\Classes\.com" , "" )
	If $RUN1 <> "comfile" Then
		$RET = RegRead ( "HKLM\software\Classes\" & $RUN1 & "\shell\open\command" , "" )
		_ARRAYADD ( $ARR , "HKLM\...\.com: " & $RUN1 & " => " & $RET & " <==== " & $UPD1 , 0 , "|||" )
	EndIf
	$RUN1 = RegRead ( "HKLM\software\Classes\comfile\DefaultIcon" , "" )
	If $RUN1 <> "%SystemRoot%\System32\shell32.dll,2" Then _ARRAYADD ( $ARR , "HKLM\...\comfile\DefaultIcon: " & $RUN1 & " <==== " & $UPD1 , 0 , "|||" )
	$RUN1 = RegRead ( "HKLM\software\Classes\comfile\shell\open\command" , "" )
	If $RUN1 <> """%1"" %*" Then _ARRAYADD ( $ARR , "HKLM\...\comfile\shell\open\command: " & $RUN1 & " <==== " & $UPD1 , 0 , "|||" )
EndFunc
Func COMMANDPROC ( $HIVE )
	$KEY = $HIVE & $SOFTWARE & "\Microsoft\Command Processor"
	GUICtrlSetData ( $LABEL1 , $KEY )
	RegRead ( $KEY , "" )
	If @error = 1 Then _SETREGACE ( $KEY , 1 )
	$VALDATA = RegRead ( $KEY , "AutoRun" )
	If $VALDATA Then _ARRAYADD ( $ARRAYREG , $HIVE & "...\Command Processor: " & $VALDATA & " <==== " & $UPD1 , 0 , "||||" )
	$KEY32 = $HIVE & $SOFTWARE & "\Wow6432Node\Microsoft\Command Processor"
	RegRead ( $KEY32 , "" )
	If @error = 1 Then _SETREGACE ( $KEY32 , 1 )
	$VALDATA = RegRead ( $KEY32 , "AutoRun" )
	If $VALDATA Then _ARRAYADD ( $ARRAYREG , "HKLM-x32\...\Command Processor: " & $VALDATA & " <==== " & $UPD1 , 0 , "||||" )
EndFunc
Func COMMANDPROCFIX ( )
	If StringInStr ( $FIX , "HKLM\" ) Then DELVALUE ( "HKLM\" & $SOFTWARE & "\Microsoft\Command Processor" , "AutoRun" )
	If StringInStr ( $FIX , "HKLM-x32\" ) Then DELVALUE ( "HKLM\" & $SOFTWARE & "\Wow6432Node\Microsoft\Command Processor" , "AutoRun" )
	If Not StringInStr ( $FIX , "HKU\" ) Then Return
	$USER = StringRegExpReplace ( $FIX , "(?i)HKU\\(.+?)\\.+" , "$1" )
	RELOAD ( $USER )
	$KEY = "HKU\" & $USER & "\Software\Microsoft\Command Processor"
	DELVALUE ( $KEY , "AutoRun" )
	REUNLOAD ( $USER )
EndFunc
Func COMP ( $PATH = $FILE )
	$SIZE = ""
	If StringRegExp ( $FILE , "\\\w{6}~\d\\" ) Then $FILE = FileGetLongName ( $FILE )
	If StringRegExp ( $FILE , ":[^\\]" ) Then $SIZE = StringLen ( FileRead ( $FILE ) )
	If Not $SIZE Then $SIZE = _FILEGETSIZE ( $PATH )
	If @error Then $SIZE = "?"
	$CDATE = FILETIMECM ( $PATH )
	If StringInStr ( $PATH , "\system32\drivers\appid.sys" ) And $BOOTM <> "Recovery" Then
		$COMPANY = "Microsoft Windows"
	Else
		$COMPANY = FileGetVersion ( $PATH , "CompanyName" )
	EndIf
	$COMPANY = StringRegExpReplace ( $COMPANY , "\s+" , " " )
	$COMPANY = StringRegExpReplace ( $COMPANY , "\s+$" , "" )
	$COMPANY = StringRegExpReplace ( $COMPANY , "(?i)http(s|):" , "hxxp\1:" )
	If $SIZE Then
		If StringInStr ( $PATH , ":\Program Files\WindowsApps\" ) Then
			$FILE1 = StringRegExpReplace ( $PATH , "(?i)(.:\\program Files\\WindowsApps\\[^\\]+).+" , "$1" )
			If FileExists ( $FILE1 & "\AppxSignature.p7x" ) Then $PATH = $FILE1 & "\AppxSignature.p7x"
		EndIf
		$OWNER = _CHECKSIG ( $PATH , 1 )
		If Not @error And $OWNER Then $COMPANY = $OWNER & " -> " & $COMPANY
		$COMPANY = " (" & $COMPANY & ")"
		If $CRYPT Then
			If _CHECKSIG ( $PATH ) = 11 Then
				Return
			Else
				$COMPANY = $COMPANY & " [" & $FILENS & "]"
				If _CREATEFILE ( $PATH ) Then
					$COMPANY = " (" & $NOACC & ") " & " [" & $FILENS & "?]"
				Else
					If CHKFILE ( $PATH , 1179785 ) = 32 Then $COMPANY = $COMPANY & " [" & $INUSE & "]"
				EndIf
			EndIf
		EndIf
	Else
		$GGG = ""
		Select
		Case _REPARSEPOINT ( $PATH )
			$PATH = _GETREPARSETARGET ( $PATH )
			$GGG = " [symlink -> " & $PATH & "]"
		Case _CREATEFILE ( $PATH )
			$GGG = " [" & $NOACC & "]"
		Case CHKFILE ( $PATH , 1179785 ) = 32
			$COMPANY = $COMPANY & " [" & $INUSE & "]" & " <==== " & $UPD1
	Case Else
			$LASTERROR = ""
			If StringLeft ( $PATH , 4 ) <> "\\?\" Then $PATH = "\\?\" & $PATH
			Local $RET = DllCall ( "kernel32.dll" , "handle" , "CreateFileW" , "wstr" , $PATH , "dword" , 1179785 , "dword" , 1 , "ptr" , 0 , "dword" , 3 , "dword" , 33554432 , "handle" , 0 )
			If $RET [ 0 ] = $INVALID_HANDLE_VALUE Or $RET [ 0 ] = + 4294967295 Then
				$LASTERROR = _WINAPI_GETLASTERROR ( )
				$GGG = " <==== " & $UPD1 & " [" & $ZBYTE & "? (" & $ERR0 & "=" & $LASTERROR & ")]"
			Else
				CLOSEHANDLE ( $RET [ 0 ] )
				$GGG = " <==== " & $UPD1 & " [" & $ZBYTE & " " & $FDIR & "]"
			EndIf
		EndSelect
		$COMPANY = " (" & $COMPANY & ")" & $GGG
	EndIf
EndFunc
Func CREATEFILE ( $PATH )
	If Not $BACKUPPRI Then _SETPRIV ( "SeBackupPrivilege" , True )
	$PATH = StringRegExpReplace ( $PATH , "\\\\(?!\?\\)" , "\\" )
	If Not StringInStr ( $PATH , "\\?\" ) Then $PATH = "\\?\" & $PATH
	Local $ARET = DllCall ( "kernel32.dll" , "hwnd" , "CreateFileW" , "wstr" , $PATH , "dword" , 1179785 , "dword" , 1 , "ptr" , 0 , "dword" , 3 , "dword" , 33554432 , "ptr" , 0 )
	If @error Or $ARET [ 0 ] = + 4294967295 Then Return SetError ( 1 , 0 , 0 )
	Return $ARET [ 0 ]
EndFunc
Func _FILEGETSIZE ( $PATH )
	$RET = FileGetSize ( $PATH )
	If Not @error Then Return $RET
	$HFILE = CREATEFILE ( $PATH )
	If @error Or Not IsPtr ( $HFILE ) Then Return SetError ( 1 , 0 , 0 )
	$ARET = DllCall ( "kernel32.dll" , "dword" , "GetFileSize" , "handle" , $HFILE , "dword*" , 0 )
	CLOSEHANDLE ( $HFILE )
	If $ARET [ 0 ] = 4294967295 Then Return SetError ( 1 , 0 , 0 )
	Return $ARET [ 0 ]
EndFunc
Func READFILE ( $HFILE , $IBYTESTOREAD = 10000 )
	Local $TBUFFER = DllStructCreate ( "byte[" & $IBYTESTOREAD & "]" )
	Local $TBYTESREAD = DllStructCreate ( "dword" )
	Local $ARESULT = DllCall ( "kernel32.dll" , "bool" , "ReadFile" , "handle" , $HFILE , "ptr" , DllStructGetPtr ( $TBUFFER ) , "dword" , $IBYTESTOREAD , "ptr" , DllStructGetPtr ( $TBYTESREAD ) , "ptr" , 0 )
	If @error Or Not $ARESULT [ 0 ] Then Return SetError ( 1 , 0 , 0 )
	$SBUFFER = DllStructGetData ( $TBUFFER , 1 )
	Return BinaryToString ( $SBUFFER , 2 )
EndFunc
Func CONV ( $ENAME )
	$ENAME = StringRegExpReplace ( $ENAME , "&amp;" , "&" )
	$ENAME = StringRegExpReplace ( $ENAME , "&quot;" , """" )
	$ENAME = StringRegExpReplace ( $ENAME , "&lt;" , "<" )
	$ENAME = StringRegExpReplace ( $ENAME , "&gt;" , ">" )
	$ENAME = StringRegExpReplace ( $ENAME , "&#178;" , "" )
	$ENAME = StringRegExpReplace ( $ENAME , "&apos;" , "'" )
	If StringRegExp ( $ENAME , "\\u\w{4}" ) Then $ENAME = Execute ( "'" & StringRegExpReplace ( $ENAME , "(\\u([[:xdigit:]]{4}))" , "' & ChrW(0x$2) & '" ) & "'" )
	Return FileGetLongName ( $ENAME )
EndFunc
Func CONVERTSIZE ( $SIZE )
	If $SIZE < 2000 Then
		$SIZE = $SIZE & " byte"
	Else
		$SIZE = $SIZE / 1024
		If $SIZE < 2000 Then
			$SIZE = Round ( $SIZE , 0 )
			$SIZE = $SIZE & " KB"
		Else
			$SIZE = $SIZE / 1024
			If $SIZE < 1024 Then
				$SIZE = Round ( $SIZE , 1 )
				$SIZE = $SIZE & " MB"
			Else
				$SIZE = $SIZE / 1024
				$SIZE = Round ( $SIZE , 1 )
				$SIZE = $SIZE & " GB"
			EndIf
		EndIf
	EndIf
	Return $SIZE
EndFunc
Func DATE ( )
	Return @MDAY & "-" & @MON & "-" & @YEAR & " " & @HOUR & ":" & @MIN & ":" & @SEC
EndFunc
Func DEF ( )
	RunWait ( @ComSpec & " /c reg load hklm\999 c:\Windows\System32\config\System" , "" , @SW_HIDE )
	RunWait ( @ComSpec & " /c reg load hklm\888 c:\Windows\System32\config\software" , "" , @SW_HIDE )
	$DEF1 = RegRead ( "HKLM\999\Select" , "default" )
	If $DEF1 < 10 Then $DEF = "0" & $DEF1
	If $DEF1 > 9 Then $DEF = $DEF1
	$SVERSION = RegRead ( "HKLM\888\Microsoft\Windows NT\CurrentVersion" , "ProductName" )
	If @error Then $SVERSION = @OSVersion
	$KEY = "HKLM\" & $SYSTEM & $BOOTSYSTEM & $DEF & "\Control\Session Manager\KnownDLLs"
	If @OSVersion = "WIN_11" Or RegRead ( $KEY , "wow64base" ) Or RegRead ( $KEY , "wow64con" ) Or FileExists ( $C & "\Windows\System32\wow64base.dll" ) Or FileExists ( $C & "\Windows\System32\wow64con.dll" ) Then $SVERSION = "Windows 11"
EndFunc
Func DEL ( ByRef $ARR )
	Local $CHK
	$MAINKEY = "HKLM\" & $SYSTEM & $BOOTSYSTEM & $DEF & "\Services"
	$FULLKEY = _HKEYTRANS ( $MAINKEY )
	$HKEY = _HKEY ( $FULLKEY )
	If @error Or $HKEY = 0 Then Return False
	$I = + 4294967295
	While 1
		$I += 1
		$FILE = ""
		$COMPANY = ""
		$SNAME = __REGENUMKEY ( $HKEY , $I )
		If @error Then ExitLoop
		$KEY = $MAINKEY & "\" & $SNAME
		If $SNAME = "{45487F67-EC9F-4449-A6F2-2D0970F9B80B}" Or $SNAME = "{DB437C57-08A3-47e9-ACFF-111254F830DF}" Then
			$FILE = RegRead ( $KEY , "Imagepath" )
			AAAAFP ( )
			DELKEYS ( $KEY , $ARR )
			If FileExists ( $FILE ) Then
				MOVEFILES ( $FILE )
				If FileExists ( $FILE ) Then
					_ARRAYADD ( $ARR , """" & $FILE & """" & " => " & $FIX8 & "." , 0 , "||||" )
				Else
					_ARRAYADD ( $ARR , $FILE & " => " & $MOVED , 0 , "||||" )
				EndIf
			EndIf
			ContinueLoop
		EndIf
		If RegRead ( $KEY & "\Instances\" & $SNAME & " Instance" , "Altitude" ) = 45888 And RegRead ( $KEY , "Start" ) = 3 Then
			$FILE = RegRead ( $KEY , "Imagepath" )
			AAAAFP ( )
			If Not FileExists ( $FILE ) Then DELKEYS ( $KEY , $ARR )
			ContinueLoop
		EndIf
		RegRead ( $KEY , "St" )
		If @error Then ContinueLoop
		If RegRead ( $KEY , "Group" ) <> "System Reserved" Then ContinueLoop
		If RegRead ( $KEY , "start" ) <> 0 Then ContinueLoop
		$FILE = RegRead ( $KEY , "Imagepath" )
		AAAAFP ( )
		If FileExists ( $FILE ) And Not FileGetVersion ( $FILE , "CompanyName" ) Then
			$CHK = 1
			DELKEYS ( $KEY , $ARR )
			MOVEFILES ( $FILE )
			If FileExists ( $FILE ) Then
				_ARRAYADD ( $ARR , """" & $FILE & """" & " => " & $FIX8 & "." , 0 , "||||" )
			Else
				_ARRAYADD ( $ARR , $FILE & " => " & $MOVED , 0 , "||||" )
			EndIf
		EndIf
	WEnd
	If Not $CHK Then Return
	For $P = 1 To UBound ( $ALLUSERS ) + 4294967295
		If StringRegExp ( $ALLUSERS [ $P ] , "(?i)\\Default(| user|.migrated)$" ) Then ContinueLoop
		$ARR1 = _FILELISTTOARRAYREC ( $ALLUSERS [ $P ] & "\AppData\Local" , "*" , 2 + 16 , 0 , 0 , 2 )
		For $M = 1 To UBound ( $ARR1 ) + 4294967295
			If Not StringRegExp ( StringRegExpReplace ( $ARR1 [ $M ] , ".+\\(.+)" , "$1" ) , "^\w+$" ) Then ContinueLoop
			$ARR2 = _FILELISTTOARRAYREC ( $ARR1 [ $M ] , "*.exe" , 1 + 16 , 0 , 0 , 2 )
			For $N = 1 To UBound ( $ARR2 ) + 4294967295
				If StringRegExp ( StringRegExpReplace ( $ARR2 [ $N ] , ".+\\" , "" ) , "(?i)update\.exe" ) Then ContinueLoop
				If Not FileGetVersion ( $ARR2 [ $N ] , "CompanyName" ) Then
					MOVEFILES ( $ARR2 [ $N ] )
					If Not FileExists ( $ARR2 [ $N ] ) Then _ARRAYADD ( $ARR , $ARR2 [ $N ] & " => " & $MOVED , 0 , "||||" )
				EndIf
			Next
		Next
	Next
EndFunc
Func DELACC ( )
	$RET1 = ""
	$ACCNAME = StringRegExpReplace ( $FIX , "^([^\(]+) \(.+" , "$1" )
	If StringRegExp ( $ACCNAME , "^(?i)(DevToolsUser|HomeGroupUser\$|sshd)$" ) Or StringRegExp ( $FIX , "(?i)S-1-5-21(-\d+)+-50(0|1|3|4) - " ) Then
		$RET1 = $NREMOV
	Else
		Local $RET = DllCall ( "Netapi32.dll" , "int" , "NetUserDel" , "wstr" , @ComputerName , "wstr" , $ACCNAME )
		Switch $RET [ 0 ]
		Case 0
			$RET1 = $DELETED
		Case 2221
			$RET1 = $NFOUND
		Case 5
			$RET1 = $NOACC
	Case Else
			$RET1 = $RET [ 0 ]
		EndSwitch
	EndIf
	FileWrite ( $HFIXLOG , $FIX & " => " & $RET1 & @CRLF )
EndFunc
Func DELCATALOG ( $KEY , $VAL )
	$KEY = $KEY & $VAL
	DELKEY ( $KEY )
EndFunc
Func DELETED ( $PATH )
	FileWrite ( $HFIXLOG , """" & $PATH & """ => " & $DELETED & @CRLF )
EndFunc
Func DELETEEPOLICIES ( )
	$VAL = StringRegExpReplace ( $FIX , "(?i)HKU\\.+\\Explorer: \[([^]]*)\].*" , "$1" )
	$USER = StringRegExpReplace ( $FIX , "(?i)HKU\\(.+?)\\.+" , "$1" )
	RELOAD ( $USER )
	$KEY = "HKU\" & $USER & "\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer"
	DELVALUE ( $KEY , $VAL )
	REUNLOAD ( $USER )
EndFunc
Func DELETENAMESERVER ( )
	$KEY = "HKLM\" & $SYSTEM & $BOOTSYSTEM & $DEF & "\Services\Tcpip\Parameters"
	$VAL = StringRegExpReplace ( $FIX , ".+?\[(.+?)\].*" , "$1" )
	DELVALUE ( $KEY , $VAL )
EndFunc
Func DELETEEPOLICIESLM ( )
	$VAL = StringRegExpReplace ( $FIX , "(?i)HKLM\\\.\.\.\\Policies\\Explorer: \[([^]]*)\].*" , "$1" )
	$KEY = "HKLM\" & $SOFTWARE & "\Microsoft\Windows\CurrentVersion\Policies\Explorer"
	DELVALUE ( $KEY , $VAL )
EndFunc
Func DELETEFILEEXTS ( )
	Local $KEYEXE
	$KEYEXE = "\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.exe"
	$KEY = "HKLM\" & $SOFTWARE & $KEYEXE
	DELKEY ( $KEY )
EndFunc
Func DELETEIFEO ( )
	$KEY = "HKLM\" & $SOFTWARE & "\microsoft\windows nt\currentversion\Image File Execution Options"
	$VAL = "Debugger"
	DELVALUE ( $KEY , $VAL )
EndFunc
Func DELETEIFEOS ( )
	$SKEY = StringRegExpReplace ( $FIX , "(?i)IFEO\\([^:]+):.+" , "$1" )
	DELKEY ( "HKLM\" & $SOFTWARE & "\microsoft\windows nt\currentversion\Image File Execution Options\" & $SKEY )
EndFunc
Func DELETEINTERFACES ( )
	$SUB = StringRegExpReplace ( $FIX , "(?i)Tcpip\\\.\.\\Interfaces\\(.+?):.*" , "$1" )
	$KEY = "HKLM\" & $SYSTEM & $BOOTSYSTEM & $DEF & "\Services\Tcpip\Parameters\Interfaces\" & $SUB
	$VAL = StringRegExpReplace ( $FIX , ".+?\[([^[]+)\].*" , "$1" )
	DELVALUE ( $KEY , $VAL )
EndFunc
Func DELETEJUNCTIONSINDIRECTORY ( )
	$FOLDER = StringRegExpReplace ( $FIX , """" , "" )
	$FOLDER = StringRegExpReplace ( $FOLDER , "(?i).*DeleteJunctionsIndirectory:[ ]*(.+)" , "$1" )
	If StringRegExp ( $FOLDER , "(?i)(.+) \Z" ) Then $FOLDER = StringTrimRight ( $FOLDER , 1 )
	If Not FileExists ( $FOLDER ) Then Return NFOUND ( $FOLDER )
	FileWrite ( $HFIXLOG , """" & $FOLDER & """" & " => " & $REP1 & " " & $STAR & ":" & @CRLF )
	DELJUNCTIONSH ( $FOLDER )
	If Not StringInStr ( FileGetAttrib ( $FOLDER ) , "D" ) Then Return
	FileDelete ( @TempDir & "\logfold" )
	RunWait ( @ComSpec & " /c " & "dir /a/b """ & $FOLDER & """ >""" & @TempDir & "\logfold""" , "" , @SW_HIDE )
	$I = 0
	While 1
		$I += 1
		$FILE = FileReadLine ( @TempDir & "\logfold" , $I )
		If @error Then ExitLoop
		$FILE1 = $FOLDER & "\" & $FILE
		If StringInStr ( $FILE1 , "\msseces.exe" ) Then
			ProcessClose ( "msseces.exe" )
			Sleep ( 2000 )
			FileWrite ( $C & "\FRST\re" , "P" )
		EndIf
		DELJUNCTIONSH ( $FILE1 )
		If Not StringInStr ( FileGetAttrib ( $FILE1 ) , "D" ) Then ContinueLoop
		FileDelete ( @TempDir & "\logfold1" )
		RunWait ( @ComSpec & " /c " & "dir /a/b """ & $FILE1 & """ >""" & @TempDir & "\logfold1""" , "" , @SW_HIDE )
		$Q = 0
		While 1
			$Q += 1
			$FILE2 = FileReadLine ( @TempDir & "\logfold1" , $Q )
			If @error Then ExitLoop
			$FILE3 = $FILE1 & "\" & $FILE2
			DELJUNCTIONSH ( $FILE3 )
			If Not StringInStr ( FileGetAttrib ( $FILE3 ) , "D" ) Then ContinueLoop
			FileDelete ( @TempDir & "\logfold2" )
			RunWait ( @ComSpec & " /c " & "dir /a/b """ & $FILE3 & """ >""" & @TempDir & "\logfold2""" , "" , @SW_HIDE )
			$X = 1
			While 1
				$FILE4 = FileReadLine ( @TempDir & "\logfold2" , $X )
				If @error Then ExitLoop
				$FILE5 = $FILE3 & "\" & $FILE4
				DELJUNCTIONSH ( $FILE5 )
				$X += 1
			WEnd
			FileDelete ( @TempDir & "\logfold2" )
		WEnd
		FileDelete ( @TempDir & "\logfold1" )
	WEnd
	FileDelete ( @TempDir & "\logfold" )
	FileWrite ( $HFIXLOG , """" & $FOLDER & """" & " =>" & $REP1 & " " & $DONE & "." & @CRLF )
EndFunc
Func DELETELOAD ( )
	$USER = StringRegExpReplace ( $FIX , "(?i)HKU\\(.+?)\\.+" , "$1" )
	RELOAD ( $USER )
	$KEY = "HKU\" & $USER & "\Software\Microsoft\Windows NT\CurrentVersion\Windows"
	If _CHECKKEYLOCKED ( $KEY ) Then
		$ACCOUNTNAME = _SECURITY__LOOKUPACCOUNTSID ( $USER )
		If IsArray ( $ACCOUNTNAME ) Then $USER = $ACCOUNTNAME [ 0 ]
		_UNLOCK ( $KEY , 4 , "Administrators;System;Users;" & $USER )
	EndIf
	If StringInStr ( $FIX , "[load]" ) Then DELVALUE ( $KEY , "Load" )
	If StringInStr ( $FIX , "[Run]" ) Then DELVALUE ( $KEY , "Run" )
	REUNLOAD ( $USER )
EndFunc
Func DELETEOPENWITHPROGIDS ( )
	$USER = StringRegExpReplace ( $FIX , "(?i)HKU\\(.+?)\\.+" , "$1" )
	RELOAD ( $USER )
	DELKEY ( "HKU\" & $USER & "\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.exe\OpenWithProgids" )
	REUNLOAD ( $USER )
EndFunc
Func DELETEQUARANTINE ( )
	$FOLDER = $C & "\FRST\Quarantine"
	_BBBBRD ( $FOLDER )
	If Not FileExists ( $FOLDER ) Then Return 1
	$Q = 1
	While 1
		DELETEQUARANTINE1 ( )
		If Not FileExists ( $FOLDER ) Then
			DELETED ( $FOLDER )
			ExitLoop
		EndIf
		If FileExists ( $FOLDER ) Then RunWait ( @ComSpec & " /c " & "rd /s/q " & $FOLDER , "" , @SW_HIDE )
		If FileExists ( $FOLDER ) Then RunWait ( @ComSpec & " /c " & "rd /s/q ""\\.\" & $FOLDER & """" , "" , @SW_HIDE )
		If Not FileExists ( $FOLDER ) Then
			DELETED ( $FOLDER )
			ExitLoop
		EndIf
		_UNLOCKALLCHILD ( $FOLDER )
		QUARFINAL ( )
		If FileExists ( $FOLDER ) Then QUARFINAL ( )
		If FileExists ( $FOLDER ) Then QUARFINAL ( )
		If Not FileExists ( $FOLDER ) Then
			DELETED ( $FOLDER )
			ExitLoop
		EndIf
		If $Q > 2 Then
			If Not FileExists ( $FOLDER ) Then
				DELETED ( $FOLDER )
				ExitLoop
			Else
				QUARFINAL ( )
				If FileExists ( $FOLDER ) Then QUARFINAL ( )
				RunWait ( @ComSpec & " /c " & "rd /s/q " & $FOLDER , "" , @SW_HIDE )
				If Not FileExists ( $FOLDER ) Then
					DELETED ( $FOLDER )
				Else
					NDELETED ( $FOLDER )
				EndIf
				ExitLoop
			EndIf
		EndIf
		If FileExists ( $FOLDER ) Then QUARANTINE ( $FOLDER )
		If FileExists ( $FOLDER ) Then
			RunWait ( @ComSpec & " /c " & "rd /s/q " & $FOLDER , "" , @SW_HIDE )
		Else
			DELETED ( $FOLDER )
			ExitLoop
		EndIf
		$Q += 1
	WEnd
EndFunc
Func DELETEQUARANTINE1 ( )
	$FOLDER = $C & "\frst\quarantine"
	If FILEACCN ( $FOLDER ) Then _GRANTE ( $FOLDER , 1 , 0 )
	Local $SUBFOLDERS , $AARRAYDIR
	$SUBFOLDERS = _GETALLSUBFOLDERSSHORT ( $FOLDER )
	If IsArray ( $SUBFOLDERS ) Then
		_ARRAYREVERSE ( $SUBFOLDERS , 1 )
		For $E = 1 To UBound ( $SUBFOLDERS ) + 4294967295
			$RET = DirRemove ( $SUBFOLDERS [ $E ] , 1 )
			If Not $RET Then _DIRREMOVE ( $SUBFOLDERS [ $E ] )
		Next
	EndIf
	$RET = DirRemove ( $FOLDER , 1 )
	If Not $RET Then _DIRREMOVE ( $FOLDER )
	If Not FileExists ( $FOLDER ) Then Return
	_BBBBDR ( $FOLDER )
EndFunc
Func DELETERUN ( )
	$VAL = StringRegExpReplace ( $FIX , "(?i)HKLM\\.+\\Run: \[(.*)\] =>.*" , "$1" )
	$KEY = "HKLM\" & $SOFTWARE & "\Microsoft\Windows\CurrentVersion\Run"
	DELVALUE ( $KEY , $VAL )
EndFunc
Func DELETERUN32 ( )
	$VAL = StringRegExpReplace ( $FIX , "(?i)HKLM-x32\\.+\\Run: \[(.*)\] =>.*" , "$1" )
	$KEY = "HKLM\" & $SOFTWARE & "\WOW6432Node\Microsoft\Windows\CurrentVersion\Run"
	DELVALUE ( $KEY , $VAL )
EndFunc
Func DELETERUNONCE ( )
	$VAL = StringRegExpReplace ( $FIX , "(?i)HKLM\\.+\\RunOnce: \[(.*)\] =>.*" , "$1" )
	$KEY = "HKLM\" & $SOFTWARE & "\Microsoft\Windows\CurrentVersion\RunOnce"
	DELVALUE ( $KEY , $VAL )
EndFunc
Func DELETERUNONCE32 ( )
	$VAL = StringRegExpReplace ( $FIX , "(?i)HKLM-x32\\.+\\RunOnce: \[(.*)\] =>.*" , "$1" )
	$KEY = "HKLM\" & $SOFTWARE & "\WOW6432Node\Microsoft\Windows\CurrentVersion\RunOnce"
	DELVALUE ( $KEY , $VAL )
EndFunc
Func DELETERUNONCEEX ( )
	$SUB = StringRegExpReplace ( $FIX , "(?i)HKLM(?:-x32|)\\...\\runonceex\\(.+?):.+" , "$1" )
	$KEY = "HKLM\" & $SOFTWARE & "\Microsoft\Windows\CurrentVersion\runonceex\" & $SUB
	If StringInStr ( $FIX , "HKLM-x32" ) Then $KEY = "HKLM\" & $SOFTWARE & "\WOW6432Node\Microsoft\Windows\CurrentVersion\runonceex\" & $SUB
	DELKEY ( $KEY )
EndFunc
Func DELETERUNSERVICES ( )
	$VAL = StringRegExpReplace ( $FIX , "(?i)HKLM\\.+\\RunServices: \[(.*)\] =>.*" , "$1" )
	$KEY = "HKLM\" & $SOFTWARE & "\Microsoft\Windows\CurrentVersion\RunServices"
	DELVALUE ( $KEY , $VAL )
EndFunc
Func DELETERUNSERVICESONCE ( )
	$VAL = StringRegExpReplace ( $FIX , "(?i)HKLM\\.+\\RunServicesOnce: \[(.*)\] =>.*" , "$1" )
	$KEY = "HKLM\" & $SOFTWARE & "\Microsoft\Windows\CurrentVersion\RunServicesOnce"
	DELVALUE ( $KEY , $VAL )
EndFunc
Func DELETESTARTUP ( )
	$FILEP = StringRegExpReplace ( $FIX , "(?i)Startup: ([A-Z]:\\.+?) \[.*" , "$1" )
	If Not FileExists ( $FILEP ) Then Return NFOUND ( $FILEP )
	MOVEFILER ( $FILEP )
EndFunc
Func DELETESTARTUPTARGET ( )
	$FILEP = StringRegExpReplace ( $FIX , "(?i)ShortcutTarget: .+ -> (.+) \(.*" , "$1" )
	If Not FileExists ( $FILEP ) Then
		NFOUND ( $FILEP )
	Else
		MOVEFILER ( $FILEP )
	EndIf
EndFunc
Func DELETEUFILEEXTS ( )
	$USER = StringRegExpReplace ( $FIX , "(?i)HKU\\(.+?)\\.+\\FileExts\\.exe:.*" , "$1" )
	RELOAD ( $USER )
	$KEY = "HKU\" & $USER & "\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.exe"
	DELVALUE ( $KEY , "" )
	REUNLOAD ( $USER )
EndFunc
Func DELETEUPOLICIES ( )
	Local $USER
	$VAL = StringRegExpReplace ( $FIX , "(?i)HKU\\.+\\Policies\\system: \[(.*)\] .*" , "$1" )
	$USER = StringRegExpReplace ( $FIX , "(?i)HKU\\(.+?)\\.+\\Policies\\system:.*" , "$1" )
	RELOAD ( $USER )
	$KEY = "HKU\" & $USER & "\Software\Microsoft\Windows\CurrentVersion\Policies\system"
	DELVALUE ( $KEY , $VAL )
	REUNLOAD ( $USER )
EndFunc
Func DELETEUPOLICIESRUN ( )
	$VAL = StringRegExpReplace ( $FIX , "(?i)HKU\\.+\\Policies\\Explorer\\Run: \[(.*)\] =>.*" , "$1" )
	$USER = StringRegExpReplace ( $FIX , "(?i)HKU\\(.+?)\\.*" , "$1" )
	RELOAD ( $USER )
	$KEY = "HKU\" & $USER & "\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run"
	DELVALUE ( $KEY , $VAL )
	REUNLOAD ( $USER )
EndFunc
Func DELETEURL ( )
	$FILEP = StringRegExpReplace ( $FIX , "(?i)InternetURL: ([A-Z]:\\.+) ->.*" , "$1" )
	If Not FileExists ( $FILEP ) Then Return NFOUND ( $FILEP )
	MOVEFILER ( $FILEP )
EndFunc
Func DELETEURUN ( )
	Local $USER
	$VAL = StringRegExpReplace ( $FIX , "(?i)HKU\\.+\\Run: \[(.*)\] =>.*" , "$1" )
	$USER = StringRegExpReplace ( $FIX , "(?i)HKU\\(.+?)\\.*" , "$1" )
	RELOAD ( $USER )
	$KEY = "HKU\" & $USER & "\Software\Microsoft\Windows\CurrentVersion\Run"
	DELVALUE ( $KEY , $VAL )
	REUNLOAD ( $USER )
EndFunc
Func DELETEURUNONCE ( )
	Local $USER
	$VAL = StringRegExpReplace ( $FIX , "(?i)HKU\\.+\\RunOnce: \[(.*)\] =>.*" , "$1" )
	$USER = StringRegExpReplace ( $FIX , "(?i)HKU\\(.+?)\\.+\\RunOnce:.*" , "$1" )
	RELOAD ( $USER )
	$KEY = "HKU\" & $USER & "\Software\Microsoft\Windows\CurrentVersion\RunOnce"
	DELVALUE ( $KEY , $VAL )
	REUNLOAD ( $USER )
EndFunc
Func DELETEVAL ( $STARTKEY , $KEY )
	$HANDLE = _HKEY ( $STARTKEY )
	If @error Or $HANDLE = 0 Then
		If $HANDLE = + 3221225506 Then
			_SETREGACE ( $KEY )
			$HANDLE = _HKEY ( $STARTKEY )
			If @error Or $HANDLE = 0 Then Return SetError ( 1 , 0 , "Error getting handle(0): " & $HANDLE )
		Else
			Return SetError ( 1 , 0 , "Error getting handle(1): " & $HANDLE )
		EndIf
	EndIf
	$INDEX = 0
	$CHECK = ""
	$SVI0 = DllStructCreate ( $TAGKEY_VALUE_BASIC_INFORMATION )
	While 1
		$BUFFERSIZE = 2048
		$SVI = $SVI0
		Local $RET = DllCall ( "ntdll.dll" , "int" , "NtEnumerateValueKey" , "hwnd" , $HANDLE , "dword" , $INDEX , "dword" , 0 , "ptr" , DllStructGetPtr ( $SVI ) , "dword" , DllStructGetSize ( $SVI ) , "ulong*" , "" )
		If $RET [ 0 ] = + 2147483674 Then ExitLoop
		While $RET [ 0 ] = + 2147483653
			$BUFFERSIZE += 2048
			$SVI = DllStructCreate ( "ulong TitleIndex;ulong Type;ulong NameLength;byte Name[" & $BUFFERSIZE & "]" )
			$RET = DllCall ( "ntdll.dll" , "int" , "NtEnumerateValueKey" , "hwnd" , $HANDLE , "dword" , $INDEX , "dword" , 0 , "ptr" , DllStructGetPtr ( $SVI ) , "dword" , DllStructGetSize ( $SVI ) , "ulong*" , "" )
		WEnd
		If Not STATUS_SUCCESS ( $RET [ 0 ] ) Then Return SetError ( 1 , 0 , "Error enumerating values: " & $RET [ 0 ] )
		$NAMELENGTH = DllStructGetData ( $SVI , "NameLength" )
		$NAME = DllStructGetData ( $SVI , "Name" )
		$NAME = StringMid ( $NAME , 3 , $NAMELENGTH * 2 )
		$CHEKINVAL = _CHKINVAL ( $NAME )
		$INVALID = $CHEKINVAL [ 0 ]
		$CHARS = $CHEKINVAL [ 1 ]
		If $INVALID Then
			_NTCLOSE ( $HANDLE )
			$HANDLE2 = _HKEY ( $STARTKEY , 1 , 2 )
			If @error Or $HANDLE = 0 Then
				If $HANDLE2 = + 3221225506 Then
					_SETREGACE ( $KEY )
					$HANDLE2 = _HKEY ( $STARTKEY , 1 , 2 )
					If @error Or $HANDLE2 = 0 Then Return SetError ( 1 , 0 , "Error getting handle(2): " & $HANDLE2 )
				Else
					If @error Or $HANDLE2 = 0 Then Return SetError ( 1 , 0 , "Error getting handle(3): " & $HANDLE2 )
				EndIf
			EndIf
			Local $SZNAME = DllStructCreate ( "byte[" & $BUFFERSIZE & "]" )
			Local $SUS = DllStructCreate ( "ushort Length;ushort MaximumLength;ptr Buffer" )
			DllStructSetData ( $SZNAME , 1 , "0x" & $NAME )
			$NLENGTH = StringLen ( $NAME ) / 2
			DllStructSetData ( $SUS , "Length" , $NLENGTH )
			DllStructSetData ( $SUS , "MaximumLength" , $NLENGTH + 2 )
			DllStructSetData ( $SUS , "Buffer" , DllStructGetPtr ( $SZNAME ) )
			Local $RET = DllCall ( "ntdll.dll" , "int" , "NtDeleteValueKey" , "hwnd" , $HANDLE2 , "ptr" , DllStructGetPtr ( $SUS ) )
			If Not STATUS_SUCCESS ( $RET [ 0 ] ) Then
				Return SetError ( 1 , 0 , "Error in Deleting Value: " & Hex ( $RET [ 0 ] , 8 ) )
			EndIf
			_NTFLUSH ( $HANDLE2 )
			$CHECK = True
		EndIf
		$INDEX += 1
	WEnd
	If $CHECK Then
		Return True
	Else
		_NTCLOSE ( $HANDLE )
		Return False
	EndIf
EndFunc
Func DELETEVALUE ( )
	$FIX = StringRegExpReplace ( $FIX , "\s*\|\s*" , "|" )
	$AKEY = StringRegExpReplace ( $FIX , "(?i)delete\s*value:\s*(.+)\|.*" , "$1" )
	$AKEY = StringRegExpReplace ( $AKEY , "(^\[|^""|^;|;$|""$|\]$)" , "" )
	$VALUE = StringRegExpReplace ( $FIX , "(?i).+?\|(.*)" , "$1" )
	If $VALUE = """""" Then $VALUE = ""
	If $BOOTM = "Recovery" Then $AKEY = _RMTOR ( $AKEY )
	DELVALUE ( $AKEY , $VALUE )
EndFunc
Func DELJUNCTIONSH ( $FOLDER )
	If _REPARSEPOINT ( $FOLDER ) Then
		_DELETEREPARSEPOINT ( $FOLDER , True )
		$FSUTIL = $SYSTEMDIR & "\fsutil.exe"
		If $BOOTM <> "Recovery" And _REPARSEPOINT ( $FOLDER ) Then RunWait ( @ComSpec & " /c " & $FSUTIL & " reparsepoint delete """ & $FOLDER & """" , "" , @SW_HIDE )
		If _REPARSEPOINT ( $FOLDER ) Then
			FileWrite ( $HFIXLOG , """" & $FOLDER & """" & " => " & $REP2 & " " & $NDELETED & "." & @CRLF )
		Else
			If FILEACCN ( $FOLDER ) Then _SETDEFAULTFILEACCESS ( $FOLDER )
			FileWrite ( $HFIXLOG , """" & $FOLDER & """" & " =>" & $REP1 & " " & $DONE & "." & @CRLF )
		EndIf
	Else
		If FILEACCN ( $FOLDER ) Then _SETDEFAULTFILEACCESS ( $FOLDER )
	EndIf
EndFunc
Func DELKEY ( $OKEY = "" , $RES = "" )
	If Not $OKEY Then
		If StringRegExp ( $FIX , "(?i)^\[-HK" ) Then
			$OKEY = StringRegExpReplace ( $FIX , "\[-(.+)\]" , "$1" )
		Else
			$OKEY = StringRegExpReplace ( $FIX , "(?i)delete\s*key:\s*(.+)" , "$1" )
			$OKEY = StringRegExpReplace ( $OKEY , "(?:\[|"")*(.+?)(""|\])*$" , "$1" )
		EndIf
		$OKEY = StringRegExpReplace ( $OKEY , "\\$" , "" )
	EndIf
	$KEYASIS = $OKEY
	If $BOOTM = "Recovery" Then
		$OKEY = _RMTOR ( $OKEY )
		$KEYASIS = _RMTON ( $KEYASIS )
	EndIf
	If RegDelete ( $OKEY ) = 1 Then Return FileWrite ( $HFIXLOG , $KEYASIS & " => " & $DELETED & @CRLF )
	$FULLKEY = _HKEYTRANS ( $OKEY )
	$STARTKEY = _STARTKEY ( $OKEY )
	$RET = _HKEYCREATE ( $FULLKEY )
	$ERR = @error
	If $RET = + 3221225506 Then
		_UNLOCKPARANDKEY ( $OKEY )
		If _HKEY ( $FULLKEY ) = + 3221225524 Then
			$WAR = $NFOUND
			If $RES Then $WAR = $DELETED
			If Not _INVALID ( $STARTKEY , $KEYASIS ) Then Return FileWrite ( $HFIXLOG , """" & $KEYASIS & """ => " & $WAR & @CRLF )
		EndIf
		$RET = _HKEYCREATE ( $FULLKEY )
	EndIf
	If $ERR And $RET <> 2 And $RET <> 1 Then
		Switch $RET
		Case + 3221225506
			FileWrite ( $HFIXLOG , $KEYASIS & " => " & $NDELETED & ". " & $NOACC & "." & @CRLF )
			If Not $REBOOTED Then FileWrite ( $C & "\frst\keysRem" , $KEYASIS & @CRLF )
		Case + 3221225524 Or + 3221225523 Or + 3221225530
			NFOUND ( $KEYASIS )
		Case + 3221225531
			FileWrite ( $HFIXLOG , $KEYASIS & " => " & $NDELETED & ".: incorrect path. " & @CRLF )
	Case Else
			$RET = "0x" & Hex ( $RET , 8 )
			FileWrite ( $HFIXLOG , $KEYASIS & " => " & $NDELETED & ". ErrorCode1: " & $RET & @CRLF )
			If StringRegExp ( $RET , "0x000000(01|02|3F)$" ) Then
				If Not $REBOOTED Then FileWrite ( $C & "\frst\keysRem" , $KEYASIS & @CRLF )
			EndIf
		EndSwitch
	Else
		Switch $RET
		Case 2
			$HKEY = _HKEY ( $FULLKEY , 1 )
			If Not @error And IsPtr ( $HKEY ) Then
				$RET = _LISTRL ( $HKEY )
				_NTDELETEKEY ( $HKEY )
				If Not @error Then Return DELETED ( $KEYASIS )
				If $RET Then
					_NTCLOSE ( $HKEY )
					Return FileWrite ( $HFIXLOG , $KEYASIS & " => " & $NDELETED & " " & $REGB & " " & $SYMLINK0 & ", " & $KEYY & " " & $PROT0 & "." & @CRLF )
				EndIf
			EndIf
			__REGDELETE ( $OKEY )
			$HKEY = _HKEY ( $FULLKEY , 1 )
			If Not @error And IsPtr ( $HKEY ) Then
				_NTDELETEKEY ( $HKEY )
				If Not @error Then Return DELETED ( $KEYASIS )
				_NTCLOSE ( $HKEY )
			EndIf
			FileWrite ( $HFIXLOG , $KEYASIS & " => " & $NDELETED & ", " & $KEYY & " " & $PROT0 & @CRLF )
			If Not $REBOOTED Then FileWrite ( $C & "\frst\keysRem" , $KEYASIS & @CRLF )
		Case 1
			$WAR = $NFOUND
			If $RES Then $WAR = $DELETED
			If Not _INVALID ( $STARTKEY , $KEYASIS ) Then FileWrite ( $HFIXLOG , $KEYASIS & " => " & $WAR & @CRLF )
	Case Else
			If $RET = + 3221225506 Then $RET = $NOACC
			FileWrite ( $HFIXLOG , $KEYASIS & " => " & $NDELETED & ". ErrorCode2: " & $RET & @CRLF )
		EndSwitch
	EndIf
EndFunc
Func DELKEYS ( $OKEY , ByRef $ARR )
	$KEYASIS = $OKEY
	$OKEY = _RMTOR ( $OKEY )
	$KEYASIS = _RMTON ( $KEYASIS )
	$FULLKEY = _HKEYTRANS ( $OKEY )
	$STARTKEY = _STARTKEY ( $OKEY )
	$RET = _HKEYCREATE ( $FULLKEY )
	$ERR = @error
	If $RET = + 3221225506 Then
		_UNLOCKPARANDKEY ( $OKEY )
		$RET = _HKEYCREATE ( $FULLKEY )
	EndIf
	If $ERR Then
		Switch $RET
		Case + 3221225506
			_ARRAYADD ( $ARR , $KEYASIS & " => " & $NDELETED & ". " & $NOACC & "." , 0 , "||||" )
			If Not $REBOOTED Then FileWrite ( $C & "\frst\keysRem" , $KEYASIS & @CRLF )
	Case Else
			$RET = "0x" & Hex ( $RET , 8 )
			_ARRAYADD ( $ARR , $KEYASIS & " => " & $NDELETED & ". ErrorCode(1): " & $RET & @CRLF , 0 , "||||" )
		EndSwitch
	Else
		Switch $RET
		Case 2
			$HKEY = _HKEY ( $FULLKEY , 1 )
			If Not @error And IsPtr ( $HKEY ) Then
				$RET = _LISTRL ( $HKEY )
				_NTDELETEKEY ( $HKEY )
				If Not @error Then Return _ARRAYADD ( $ARR , """" & $KEYASIS & """ => " & $DELETED , 0 , "||||" )
				If $RET Then
					_NTCLOSE ( $HKEY )
					Return _ARRAYADD ( $ARR , $KEYASIS & " => " & $NDELETED & " " & $REGB & " " & $SYMLINK0 & ", " & $KEYY & " " & $PROT0 & "." , 0 , "||||" )
				EndIf
			EndIf
			__REGDELETE ( $OKEY )
			$HKEY = _HKEY ( $FULLKEY , 1 )
			If Not @error And IsPtr ( $HKEY ) Then
				_NTDELETEKEY ( $HKEY )
				If Not @error Then Return _ARRAYADD ( $ARR , """" & $KEYASIS & """ => " & $DELETED , 0 , "||||" )
				_NTCLOSE ( $HKEY )
			EndIf
			_ARRAYADD ( $ARR , $KEYASIS & " => " & $NDELETED & ", " & $KEYY & " " & $PROT0 , 0 , "||||" )
		Case 1
			If Not _INVALID ( $STARTKEY , $KEYASIS ) Then _ARRAYADD ( $ARR , $KEYASIS & " => " & $KEYY & " " & $DELETED , 0 , "||||" )
	Case Else
			_ARRAYADD ( $ARR , $KEYASIS & " => " & $NDELETED & ". ErrorCode(2): " & $RET , 0 , "||||" )
		EndSwitch
	EndIf
EndFunc
Func DELSERVICE ( )
	$SKEY = StringRegExpReplace ( $FIX , "(?i)^[SRU]\d ([^;]+);.*" , "$1" )
	Select
	Case $SKEY = "Themes"
		$KEY = "HKLM\" & $SYSTEM & $BOOTSYSTEM & $DEF & "\Services\Themes"
		DELVALUE ( $KEY , "DependOnService" )
Case Else
		$KEY = "HKLM\" & $SYSTEM & $BOOTSYSTEM & $DEF & "\Services\" & $SKEY
		If Not VAR ( $KEY ) Then Return FileWrite ( $HFIXLOG , $SKEY & " => " & $SERV & " " & $NFOUND & "." & @CRLF )
		If $BOOTM <> "Recovery" And _SRVSTAT ( $SKEY ) = "R" Then
			_STOPSERVICE ( $SKEY )
			If Not @error Then
				If _SRVSTAT ( $SKEY ) <> "S" Then Sleep ( 2500 )
				If _SRVSTAT ( $SKEY ) <> "S" Then Sleep ( 2500 )
			EndIf
			If _SRVSTAT ( $SKEY ) = "S" Then
				FileWrite ( $HFIXLOG , $SKEY & " => " & $STOPS & "." & @CRLF )
			Else
				FileWrite ( $HFIXLOG , $SKEY & " => " & $NSTOPS & "." & @CRLF )
			EndIf
		EndIf
		DELKEY ( $KEY )
		If Not VAR ( $KEY ) Then
			If $BOOTM <> "Recovery" And _SRVSTAT ( $SKEY ) = "R" Then FileWrite ( $C & "\FRST\re" , "R" )
			FileWrite ( $HFIXLOG , $SKEY & " => " & $SERV & " " & $DELETED & @CRLF )
		EndIf
		If $SKEY = "iThemes5" Then
			$KEY = "HKLM\" & $SYSTEM & $BOOTSYSTEM & $DEF & "\Services\Themes"
			RegRead ( $KEY , "DependOnService" )
			If Not @error Then DELVALUE ( $KEY , "DependOnService" )
		EndIf
		LUFILDEL ( $SKEY )
	EndSelect
EndFunc
Func DELUPOLICIES ( )
	Local $USER
	$VAL = StringRegExpReplace ( $FIX , "(?i).+\\Software\\Policies\\...\\system: \[(.*)\] .*" , "$1" )
	$KEY = "HKLM\Software\Policies\Microsoft\Windows\System"
	If StringInStr ( $FIX , "HKU\" ) Then
		$USER = StringRegExpReplace ( $FIX , "(?i)HKU\\(.+?)\\Software\\Policies\\...\\system:.*" , "$1" )
		RELOAD ( $USER )
		$KEY = "HKU\" & $USER & "\Software\Policies\Microsoft\Windows\System"
	EndIf
	DELVALUE ( $KEY , $VAL )
	If StringInStr ( $FIX , "HKU\" ) Then REUNLOAD ( $USER )
EndFunc
Func ENVHIJFIX ( )
	$VAL = StringRegExpReplace ( $FIX , "(?i).+Environment: \[(.*)\] .*" , "$1" )
	$KEY = StringRegExpReplace ( $FIX , "(?i)(.+Environment):.*" , "$1" )
	$USER = StringRegExpReplace ( $FIX , "(?i)HKU\\([^\\+)\\.+" , "$1" )
	RELOAD ( $USER )
	DELVALUE ( $KEY , $VAL )
	REUNLOAD ( $USER )
EndFunc
Func DELVALUE ( $AKEY , $VALUE )
	If $BOOTM <> "Recovery" Then KILLDLL ( )
	If StringInStr ( $VALUE , "<*>" ) Then Return DELVALUEINVALID ( $AKEY , $VALUE )
	$KEY = $AKEY
	If $BOOTM = "Recovery" Then $AKEY = _RMTON ( $AKEY )
	If RegDelete ( $KEY , $VALUE ) = 1 Then Return DELETED ( $AKEY & "\\" & $VALUE )
	$RET = _REGOPENKEYEX3 ( $KEY , 0 , 2 )
	If @error Then
		If $RET = 5 Then
			_SETREGACE ( $KEY )
			If RegDelete ( $KEY , $VALUE ) = 1 Then Return DELETED ( $AKEY & "\\" & $VALUE )
			$RET = _REGOPENKEYEX3 ( $KEY , 0 , 2 )
			If @error Then
				If $RET = 5 Then Return FileWrite ( $HFIXLOG , $AKEY & " => " & $NOACC & @CRLF )
				Return NDELETED ( $AKEY & "\\" & $VALUE )
			EndIf
		EndIf
		If $RET = 2 Then Return NFOUND ( $AKEY )
		FileWrite ( $HFIXLOG , $AKEY & " => " & $ERR0 & " = " & $RET & @CRLF )
	Else
		$RET1 = DllCall ( "advapi32.dll" , "long" , "RegDeleteValueW" , "handle" , $RET , "wstr" , $VALUE )
		Switch $RET1 [ 0 ]
		Case 0
			DELETED ( $AKEY & "\\" & $VALUE )
		Case 2
			NFOUND ( $AKEY & "\\" & $VALUE )
	Case Else
			FileWrite ( $HFIXLOG , ( $AKEY & "\\" & $VALUE ) & " => " & $ERR0 & " = " & $RET1 [ 0 ] & @CRLF )
		EndSwitch
		If $RET Then _REGCLOSE ( $RET )
	EndIf
EndFunc
Func DELVALUEINVALID ( $KEY , $VALUE )
	$AKEY = $KEY
	If $BOOTM = "Recovery" Then $AKEY = _RMTON ( $AKEY )
	$FULLKEY = _HKEYTRANS ( $KEY )
	$RET = DELETEVAL ( $FULLKEY , $KEY )
	If @error Then Return FileWrite ( $HFIXLOG , $AKEY & "\\" & $VALUE & " => " & $VAL0 & " " & $NDELETED & ". " & $RET & @CRLF )
	If $RET Then Return DELETED ( $AKEY & "\\" & $VALUE )
	NFOUND ( $AKEY & "\\" & $VALUE )
EndFunc
Func DEVICES ( )
	Local $OBJWMISERVICE , $DEVCOLITEMS
	GUICtrlSetData ( $LABEL1 , $SCANB & " " & $DEVICE1 )
	$OBJWMISERVICE = ObjGet ( "winmgmts:{impersonationLevel=impersonate}!\\.\root\cimv2" )
	If Not IsObj ( $OBJWMISERVICE ) Then Return
	$DEVCOLITEMS = $OBJWMISERVICE .ExecQuery ( "Select * from Win32_PnPEntity" )
	If Not IsObj ( $DEVCOLITEMS ) Then Return
	For $OBJECT In $DEVCOLITEMS
		Local $NAME = $OBJECT .Name
		Local $DESCRIP = $OBJECT .description
		Local $CLASSGUID = $OBJECT .classguid
		Local $COMP = $OBJECT .Manufacturer
		Local $SERVICE = $OBJECT .service
		Local $CODE , $CODEMSG
		If $OBJECT .ConfigManagerErrorCode = 0 Then
			$CODE = ""
			$CODEMSG = ""
		EndIf
		If $OBJECT .ConfigManagerErrorCode = 1 Then
			$CODE = ": This device is not configured correctly. (Code1)"
			$CODEMSG = "You may be prompted to provide the path of the driver. Windows may have the driver built-in, or may still have the driver files installed from the last time that you set up the device. If you are asked for the driver and you do not have it, you can try to download the latest driver from the hardware vendors Web site." & @CRLF & "In the device properties dialog box, click the ""Driver"" tab, and then click ""Update Driver"" to start the ""Hardware Update Wizard"". Follow the instructions to update the driver. If updating the driver does not work, see your hardware documentation for more information."
		EndIf
		If $OBJECT .ConfigManagerErrorCode = 3 Then
			$CODE = ": The driver for this device might be corrupted, or your system may be running low on memory or other resources. (Code3)"
			$CODEMSG = "If the driver is corrupted, uninstall the driver and scan for new hardware to install the driver again. To scan for new hardware, click on the ""Action"" menu in Device Manager, and then select ""Scan for hardware changes""." & @CRLF & "If your computer does not have enough memory to run the device, you can close some applications to make memory available. To check memory and system resources, right-click ""My Computer"", click ""Properties"", click the ""Advanced"" tab, and then click ""Settings"" under ""Performance""." & @CRLF & "You may need to install additional random access memory (RAM)." & @CRLF & "On the ""General Properties"" tab of the device, click ""Troubleshoot"" to start the troubleshooting wizard."
		EndIf
		If $OBJECT .ConfigManagerErrorCode = 10 Then
			$CODE = ": This device cannot start. (Code10)"
			$CODEMSG = "Device failed to start. Click ""Update Driver"" to update the drivers for this device." & @CRLF & "On the ""General Properties"" tab of the device, click ""Troubleshoot"" to start the troubleshooting wizard."
		EndIf
		If $OBJECT .ConfigManagerErrorCode = 12 Then
			$CODE = ": This device cannot find enough free resources that it can use. If you want to use this device, you will need to disable one of the other devices on this system. (Code12)"
			$CODEMSG = "Two devices have been assigned the same input/output (I/O) ports, the same interrupt, or the same Direct Memory Access channel (either by the BIOS, the operating system, or a combination of the two). This error message can also appear if the BIOS did not allocate enough resources to the device (for example, if a universal serial bus (USB) controller does not get an interrupt from the BIOS because of a corrupt Multiprocessor System (MPS) table)." & @CRLF & "You can use Device Manager to determine where the conflict is and disable the conflicting device." & @CRLF & "On the ""General Properties"" tab of the device, click ""Troubleshoot"" to start the troubleshooting wizard."
		EndIf
		If $OBJECT .ConfigManagerErrorCode = 14 Then
			$CODE = ": This device cannot work properly until you restart your computer. (Code14)"
			$CODEMSG = "Restart your computer."
		EndIf
		If $OBJECT .ConfigManagerErrorCode = 16 Then
			$CODE = ": Windows cannot identify all the resources this device uses. (Code 16)"
			$CODEMSG = "The device is only partially configured." & @CRLF & "To specify additional resources for this device, click the ""Resources"" tab in Device Manager. If there is a resource with a question mark next to it in the list of resources assigned to the device, select that resource to assign it to the device. If the resource cannot be changed, click ""Change Settings"". If ""Change Settings"" is unavailable, try clearing the ""Use automatic settings"" check box to make it available. If this is not a Plug and Play device, check the hardware documentation for more information." & @CRLF & "On the ""General Properties"" tab of the device, click ""Troubleshoot"" to start the troubleshooting wizard."
		EndIf
		If $OBJECT .ConfigManagerErrorCode = 18 Then
			$CODE = ": Reinstall the drivers for this device. (Code 18)"
			$CODEMSG = "The drivers for this device must be reinstalled." & @CRLF & " Click ""Update Driver"", which starts the Hardware Update wizard." & @CRLF & "Alternately, uninstall the driver, and then click ""Scan for hardware changes"" to reload the drivers."
		EndIf
		If $OBJECT .ConfigManagerErrorCode = 19 Then
			$CODE = ": Windows cannot start this hardware device because its configuration information (in the registry) is incomplete or damaged. (Code 19)"
			$CODEMSG = "A registry problem was detected." & @CRLF & " This can occur when more than one service is defined for a device, if there is a failure opening the service subkey, or if the driver name cannot be obtained from the service subkey. Try these options:" & @CRLF & "On the ""General Properties"" tab of the device, click ""Troubleshoot"" to start the troubleshooting wizard." & @CRLF & "Click ""Uninstall"", and then click ""Scan for hardware changes"" to load a usable driver."
		EndIf
		If $OBJECT .ConfigManagerErrorCode = 21 Then
			$CODE = ": Windows is removing this device. (Code 21)"
			$CODEMSG = "Wait several seconds, and then press the F5 key to update the Device Manager view." & @CRLF & "If that does not resolve the problem, restart your computer. "
		EndIf
		If $OBJECT .ConfigManagerErrorCode = 22 Then
			$CODE = ": This device is disabled. (Code 22)"
			$CODEMSG = "In Device Manager, click ""Action"", and then click ""Enable Device"". This starts the Enable Device wizard. Follow the instructions."
		EndIf
		If $OBJECT .ConfigManagerErrorCode = 24 Then
			$CODE = ": This device is not present, is not working properly, or does not have all its drivers installed. (Code 24)"
			$CODEMSG = "The device is installed incorrectly. The problem could be a hardware failure, or a new driver might be needed." & @CRLF & "Devices stay in this state if they have been prepared for removal." & @CRLF & "After you remove the device, this error disappears.Remove the device, and this error should be resolved."
		EndIf
		If $OBJECT .ConfigManagerErrorCode = 28 Then
			$CODE = ": The drivers for this device are not installed. (Code 28)"
			$CODEMSG = "To install the drivers for this device, click ""Update Driver"", which starts the Hardware Update wizard."
		EndIf
		If $OBJECT .ConfigManagerErrorCode = 29 Then
			$CODE = ": This device is disabled because the firmware of the device did not give it the required resources. (Code 29)"
			$CODEMSG = "Enable the device in the BIOS of the device."
		EndIf
		If $OBJECT .ConfigManagerErrorCode = 31 Then
			$CODE = ": This device is not working properly because Windows cannot load the drivers required for this device. (Code 31)"
			$CODEMSG = "Update the driver"
		EndIf
		If $OBJECT .ConfigManagerErrorCode = 32 Then
			$CODE = ": A driver (service) for this device has been disabled. An alternate driver may be providing this functionality (Code 32)"
			$CODEMSG = "The start type for this driver is set to disabled in the registry." & @CRLF & "Uninstall the driver from Device Manager, and then scan for new hardware to install the driver again. If this does not work, you might have to change the device start type parameter in the registry."
		EndIf
		If $OBJECT .ConfigManagerErrorCode = 33 Then
			$CODE = ": Windows cannot determine which resources are required for this device. (Code 33)"
			$CODEMSG = "The translator that determines the kinds of resources that are required by the device has failed." & @CRLF & "Configure the hardware. If configuring the hardware does not work, you might have to replace it."
		EndIf
		If $OBJECT .ConfigManagerErrorCode = 34 Then
			$CODE = ": Windows cannot determine the settings for this device. Consult the documentation that came with this device and use the Resource tab to set the configuration. (Code 34)"
			$CODEMSG = "The device requires manual configuration. See the hardware documentation or contact the hardware vendor for instructions on manually configuring the device. After you configure the device itself, you can use the ""Resources"" tab in Device Manager to configure the resource settings in Windows."
		EndIf
		If $OBJECT .ConfigManagerErrorCode = 35 Then
			$CODE = ": Your computer's system firmware does not include enough information to properly configure and use this device. To use this device, contact your computer manufacturer to obtain a firmware or BIOS update. (Code 35)"
			$CODEMSG = "The Multiprocessor System (MPS) table, which stores the resource assignments for the BIOS, is missing an entry for your device and needs to be updated." & @CRLF & "Obtain a new BIOS from the system vendor."
		EndIf
		If $OBJECT .ConfigManagerErrorCode = 36 Then
			$CODE = ": This device is requesting a PCI interrupt but is configured for an ISA interrupt (or vice versa). Please use the computer's system setup program to reconfigure the interrupt for this device. (Code 36)"
			$CODEMSG = "The interrupt request (IRQ) translation failed. Change the settings for the IRQ reservations." & @CRLF & "This content is designed for an advanced computer user." & @CRLF & "Change the settings for IRQ reservations." & @CRLF & "For more information about how to change BIOS settings, see the hardware documentation." & @CRLF & "You can also try to use the BIOS setup tool to change the settings for IRQ reservations (if such options exist). The BIOS might have options to reserve certain IRQs for peripheral component interconnect (PCI) or ISA devices. "
		EndIf
		If $OBJECT .ConfigManagerErrorCode = 37 Then
			$CODE = ": Windows cannot initialize the device driver for this hardware. (Code 37)"
			$CODEMSG = "The driver returned failure from its DriverEntry routine. Uninstall the driver, and then click ""Scan for hardware changes"" to reinstall or upgrade the driver."
		EndIf
		If $OBJECT .ConfigManagerErrorCode = 38 Then
			$CODE = ": Windows cannot load the device driver for this hardware because a previous instance of the device driver is still in memory. (Code 38)"
			$CODEMSG = "The driver could not be loaded because a previous instance is still loaded." & @CRLF & "Restart the computer."
		EndIf
		If $OBJECT .ConfigManagerErrorCode = 39 Then
			$CODE = ": Windows cannot load the device driver for this hardware. The driver may be corrupted or missing. (Code 39)"
			$CODEMSG = "Reasons for this error include a driver that is not present; a binary file that is corrupt; a file I/O problem, or a driver that references an entry point in another binary file that could not be loaded." & @CRLF & "Uninstall the driver, and then click ""Scan for hardware changes"" to reinstall or upgrade the driver."
		EndIf
		If $OBJECT .ConfigManagerErrorCode = 40 Then
			$CODE = ": Windows cannot access this hardware because its service key information in the registry is missing or recorded incorrectly. (Code 40)"
			$CODEMSG = "Information in the registry's service subkey for the driver is invalid. Uninstall the driver, and then click Scan for hardware changes to load the driver again. "
		EndIf
		If $OBJECT .ConfigManagerErrorCode = 41 Then
			$CODE = ": Windows successfully loaded the device driver for this hardware but cannot find the hardware device. (Code 41)"
			$CODEMSG = "A driver was loaded but Windows cannot find the device. This happens when Windows does not detect a non-Plug and Play device." & @CRLF & "If the device was removed, uninstall the driver, install the device, and then click ""Scan for hardware changes"" to reinstall the driver. If the hardware was not removed, obtain a new or updated driver for the device." & @CRLF & "If the device is a non-Plug and Play device, a newer version of the driver might be needed. To install non-Plug and Play devices, use the Add Hardware wizard." & @CRLF & "Click ""Performance and Maintenance"" on ""Control Panel"", click ""System"", and on the ""Hardware"" tab, click ""Add Hardware Wizard""."
		EndIf
		If $OBJECT .ConfigManagerErrorCode = 42 Then
			$CODE = ": Bus driver has created two devices with the same names. (Code 42)"
			$CODEMSG = "Restart the computer."
		EndIf
		If $OBJECT .ConfigManagerErrorCode = 43 Then
			$CODE = ": Windows has stopped this device because it has reported problems. (Code 43)"
			$CODEMSG = "One of the drivers controlling the device notified the operating system that the device failed in some manner. For more information about how to diagnose the problem, see the hardware documentation. "
		EndIf
		If $OBJECT .ConfigManagerErrorCode = 44 Then
			$CODE = ": An application or service has shut down this hardware device. (Code 44)"
			$CODEMSG = "Restart the computer."
		EndIf
		If $OBJECT .ConfigManagerErrorCode = 45 Then
			$CODE = ": Currently, this hardware device is not connected to the computer. (Code 45)."
			$CODEMSG = "The device is not present or was previously attached to the computer." & @CRLF & "To fix this problem, reconnect this hardware device to the computer." & @CRLF & "If Device Manager is started with the environment variable DEVMGR_SHOW_NONPRESENT_DEVICES set to 1 (which means show these devices), then any previously attached (NONPRESENT) devices are displayed in the device list and assigned this error code."
		EndIf
		If $OBJECT .ConfigManagerErrorCode = 46 Then
			$CODE = ": Windows cannot gain access to this hardware device because the operating system is in the process of shutting down (Code 46)."
			$CODEMSG = "The device is not available because the system is shutting down. When computer restarts the device should function as normal."
		EndIf
		If $OBJECT .ConfigManagerErrorCode = 47 Then
			$CODE = ": Windows cannot use this hardware device because it has been prepared for safe removal, but it has not been removed from the computer. (Code 47)"
			$CODEMSG = "Unplug the device, and then plug it in again. Alternately, restart the computer to make the device available."
		EndIf
		If $OBJECT .ConfigManagerErrorCode = 48 Then
			$CODE = ": The software for this device has been blocked from starting because it is known to have problems with Windows. Contact the hardware vendor for a new driver. (Code 48)"
			$CODEMSG = "Download the latest drivers from the manufacturer, uninstall the current driver, and then install the latest drivers."
		EndIf
		If $OBJECT .ConfigManagerErrorCode = 49 Then
			$CODE = ": Windows cannot start new hardware devices because the system hive is too large (exceeds the Registry Size Limit). (Code 49) "
			$CODEMSG = "Uninstall any un-used hardware devices."
		EndIf
		If $CODE <> "" Then FileWrite ( $HADDITION , "Name: " & $NAME & @CRLF & "Description: " & $DESCRIP & @CRLF & "Class Guid: " & $CLASSGUID & @CRLF & "Manufacturer: " & $COMP & @CRLF & "Service: " & $SERVICE & @CRLF & "Problem: " & $CODE & @CRLF & "Resolution: " & $CODEMSG & @CRLF & @CRLF )
	Next
EndFunc
Func DEVOBJ ( $OBJWMI )
	Local $SHAD
	$OBJWMISERVICE1 = $OBJWMI .ExecQuery ( "SELECT * FROM Win32_ShadowCopy" )
	If Not IsObj ( $OBJWMISERVICE1 ) Then Return
	For $OBJITEM In $OBJWMISERVICE1
		$SHAD = $OBJITEM .DeviceObject
	Next
	Return $SHAD
EndFunc
Func DISABLE ( )
	Local $RET , $VAL
	$VAL = StringRegExpReplace ( $FIX , "(?i)DisableService:[ ]*(.+)" , "$1" )
	RegRead ( "HKLM\" & $SYSTEM & $BOOTSYSTEM & $DEF & "\Services\" & $VAL , "Start" )
	Select
	Case Not @error
		$RET = RegWrite ( "HKLM\" & $SYSTEM & $BOOTSYSTEM & $DEF & "\Services\" & $VAL , "Start" , "REG_DWORD" , "4" )
		If $RET = 1 Then FileWrite ( $HFIXLOG , $VAL & " => " & $DISS & @CRLF )
		If $RET = 0 Then FileWrite ( $HFIXLOG , $VAL & " => " & $NDISS & @CRLF )
	Case @error > 1
		NFOUND ( $VAL )
	Case @error = + 4294967295
		FileWrite ( $HFIXLOG , $VAL & " => \\Start value could not be opened" & @CRLF )
	EndSelect
EndFunc
Func DISALLOWRUNFIX ( )
	$USER = StringRegExpReplace ( $FIX , "(?i)HKU\\(.+?)\\.+\\Policies\\Explorer\\DisallowRun:.*" , "$1" )
	RELOAD ( $USER )
	$KEY = "HKU\" & $USER & "\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\DisallowRun"
	$VAL = StringRegExpReplace ( $FIX , "(?i)HKU\\.+\\Policies\\Explorer\\DisallowRun: \[(.*)\] .*" , "$1" )
	DELVALUE ( $KEY , $VAL )
	REUNLOAD ( $USER )
EndFunc
Func DLLS ( )
	If Not FileExists ( $FILE ) Then Return FileWrite ( @TempDir & "\dlls" , $FILE & " " & $MISS & " <==== " & $UPD1 & @CRLF )
	$FATT = FileGetAttrib ( $FILE )
	$FATT = StringRegExpReplace ( $FATT , "A" , "" )
	If _REPARSEPOINT ( $FILE ) Then $FATT = $FATT & "L"
	$ATT = StringFormat ( "%05s" , $FATT )
	$ATTS = StringRegExpReplace ( $ATT , "0" , "_" )
	$SIZE = FileGetSize ( $FILE )
	$SIZES = StringFormat ( "%09u" , $SIZE )
	$DATECR = FILETIME ( $FILE , 1 )
	$DATEMO = FILETIME ( $FILE )
	$VER = FileGetVersion ( $FILE , "CompanyName" )
	If Not $VER Then $VER = "MD5:" & MD5 ( $FILE )
	FileWrite ( @TempDir & "\dlls" , "[" & $DATECR & "] - [" & $DATEMO & "] - " & $SIZES & " " & $ATTS & " (" & $VER & ") " & $FILE & @CRLF )
EndFunc
Func DRIVERS32 ( ByRef $ARR , $WOW = "" )
	$DR32 = ""
	If $WOW Then
		$FULLKEY = "HKLM\" & $SOFTWARE & "\WOW6432Node\Microsoft\Windows NT\CurrentVersion\Drivers32"
		$SYSTEM32 = "SysWOW64"
		$DR32 = "-x32"
	Else
		$SYSTEM32 = "System32"
		$FULLKEY = "HKLM\" & $SOFTWARE & "\Microsoft\Windows NT\CurrentVersion\Drivers32"
	EndIf
	$HKEY = _REGOPENKEYEX3 ( $FULLKEY )
	If @error Or $HKEY = 0 Then Return
	$ARRAYNAME = _LISTVAL ( $HKEY )
	For $V = 0 To UBound ( $ARRAYNAME ) + 4294967295
		$FILE = $ARRAYNAME [ $V ] [ 1 ]
		Select
		Case $ARRAYNAME [ $V ] [ 0 ] = "MSVideo"
			If $ARRAYNAME [ $V ] [ 1 ] = "vfwwdm32.dll" Then ContinueLoop
		Case $ARRAYNAME [ $V ] [ 0 ] = "wavemapper"
			If $ARRAYNAME [ $V ] [ 1 ] = "msacm32.drv" Then ContinueLoop
		Case $ARRAYNAME [ $V ] [ 0 ] = "midimapper"
			If $ARRAYNAME [ $V ] [ 1 ] = "midimap.dll" Then ContinueLoop
		Case $ARRAYNAME [ $V ] [ 0 ] = "MSVideo8"
			If $ARRAYNAME [ $V ] [ 1 ] = "VfWWDM32.dll" Then ContinueLoop
		Case $ARRAYNAME [ $V ] [ 0 ] = "msacm.imaadpcm"
			If $ARRAYNAME [ $V ] [ 1 ] = "imaadp32.acm" Then ContinueLoop
		Case $ARRAYNAME [ $V ] [ 0 ] = "msacm.l3acm"
			If StringRegExp ( $ARRAYNAME [ $V ] [ 1 ] , "(?i)^(.:\\Windows\\(System32|SysWOW64)\\|)l3codeca.acm$" ) Then ContinueLoop
		Case $ARRAYNAME [ $V ] [ 0 ] = "msacm.l3acmp"
			If StringRegExp ( $ARRAYNAME [ $V ] [ 1 ] , "(?i)^(.:\\Windows\\(System32|SysWOW64)\\|)l3codecp.acm$" ) Then ContinueLoop
		Case $ARRAYNAME [ $V ] [ 0 ] = "msacm.l3codecp"
			If StringRegExp ( $ARRAYNAME [ $V ] [ 1 ] , "(?i)^(.:\\Windows\\SysWOW64\\|)l3codecp.acm$" ) Then ContinueLoop
		Case $ARRAYNAME [ $V ] [ 0 ] = "msacm.msadpcm"
			If $ARRAYNAME [ $V ] [ 1 ] = "msadp32.acm" Then ContinueLoop
		Case $ARRAYNAME [ $V ] [ 0 ] = "msacm.msg711"
			If $ARRAYNAME [ $V ] [ 1 ] = "msg711.acm" Then ContinueLoop
		Case $ARRAYNAME [ $V ] [ 0 ] = "msacm.msgsm610"
			If $ARRAYNAME [ $V ] [ 1 ] = "msgsm32.acm" Then ContinueLoop
		Case $ARRAYNAME [ $V ] [ 0 ] = "vidc.mrle"
			If $ARRAYNAME [ $V ] [ 1 ] = "msrle32.dll" Then ContinueLoop
		Case $ARRAYNAME [ $V ] [ 0 ] = "vidc.msvc"
			If $ARRAYNAME [ $V ] [ 1 ] = "msvidc32.dll" Then ContinueLoop
		Case $ARRAYNAME [ $V ] [ 0 ] = "vidc.cvid"
			If $ARRAYNAME [ $V ] [ 1 ] = "iccvid.dll" Then ContinueLoop
		Case $ARRAYNAME [ $V ] [ 0 ] = "msacm.siren"
			If $ARRAYNAME [ $V ] [ 1 ] = "sirenacm.dll" Then ContinueLoop
		Case $ARRAYNAME [ $V ] [ 0 ] = "vidc.tsc2"
			If $WOW Then
				$VAL = "32"
			Else
				$VAL = "64"
			EndIf
			If StringRegExp ( $ARRAYNAME [ $V ] [ 1 ] , "(?i)\\WINDOWS\\SysWOW64\\tsc2_codec" & $VAL & ".dll$" ) Then ContinueLoop
		Case $ARRAYNAME [ $V ] [ 0 ] = "vidc.tscc"
			$VAL = "tsccvid"
			If Not $WOW Then $VAL = $VAL & "64"
			If StringRegExp ( $ARRAYNAME [ $V ] [ 1 ] , "(?i)\\WINDOWS\\SysWOW64\\" & $VAL & ".dll" ) Then ContinueLoop
		Case StringRegExp ( $ARRAYNAME [ $V ] [ 0 ] , "(?i)^(vidc.uyvy|vidc.yuy2|vidc.yvyu)$" )
			If $ARRAYNAME [ $V ] [ 1 ] = "msyuv.dll" Then ContinueLoop
		Case $ARRAYNAME [ $V ] [ 0 ] = "vidc.yvu9"
			If $ARRAYNAME [ $V ] [ 1 ] = "tsbyuv.dll" Then ContinueLoop
		Case StringRegExp ( $ARRAYNAME [ $V ] [ 0 ] , "(?i)^(aux\d?|midi\d?|mixer\d?|wave\d?)$" )
			If $ARRAYNAME [ $V ] [ 1 ] = "wdmaud.drv" Then ContinueLoop
		Case StringRegExp ( $ARRAYNAME [ $V ] [ 0 ] , "(?i)^(vidc.i420|vidc.iyuv)$" )
			If $ARRAYNAME [ $V ] [ 1 ] = "iyuv_32.dll" Then ContinueLoop
		EndSelect
		If $WOW Then
			AAAAFPWOW ( )
		Else
			AAAAFP ( )
		EndIf
		If FileExists ( $FILE ) Then
			_ARRAYADD ( $ARR , "HKLM\...\Drivers32: [" & $ARRAYNAME [ $V ] [ 0 ] & "] => " & $FILE & " [" & $SIZE & " " & $CDATE & "]" & $COMPANY , 0 , "||||" )
		Else
			If $ARRAYNAME [ $V ] [ 1 ] = "" Or StringRegExp ( $ARRAYNAME [ $V ] [ 1 ] , "\A[ ]+\Z" ) Then $ARRAYNAME [ $V ] [ 1 ] &= "[X]"
			_ARRAYADD ( $ARR , "HKLM\...\Drivers32" & $DR32 & ": [" & $ARRAYNAME [ $V ] [ 0 ] & "] => " & $ARRAYNAME [ $V ] [ 1 ] , 0 , "||||" )
		EndIf
	Next
	If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
	$ARRAYNAME = ""
EndFunc
Func DRIVERS32FIX ( )
	If StringInStr ( $FIX , "Drivers32-x32" ) Then
		$KEY = "HKLM\" & $SOFTWARE & "\WOW6432Node\Microsoft\Windows NT\CurrentVersion\Drivers32"
		$SYSTEM32 = "SysWOW64"
	Else
		$KEY = "HKLM\" & $SOFTWARE & "\Microsoft\Windows NT\CurrentVersion\Drivers32"
		$SYSTEM32 = "System32"
	EndIf
	$NAME = StringRegExpReplace ( $FIX , ".+?\\Drivers32(|-x32):\s*\[([^]]*)\].+" , "$2" )
	Select
	Case StringRegExp ( $NAME , "(?i)^(aux\d?|midi\d?|mixer\d?|wave\d?)$" )
		RESTOREVAL ( $KEY , $NAME , "REG_SZ" , "wdmaud.drv" )
	Case $NAME = "midimapper"
		RESTOREVAL ( $KEY , $NAME , "REG_SZ" , "midimap.dll" )
	Case $NAME = "MSVideo8"
		RESTOREVAL ( $KEY , $NAME , "REG_SZ" , "VfWWDM32.dll" )
	Case $NAME = "msacm.imaadpcm"
		RESTOREVAL ( $KEY , $NAME , "REG_SZ" , "imaadp32.acm" )
	Case $NAME = "msacm.l3acm" Or $NAME = "msacm.l3codecp"
		RESTOREVAL ( $KEY , $NAME , "REG_SZ" , $C & "\Windows\" & $SYSTEM32 & "\l3codeca.acm" )
	Case $NAME = "msacm.l3acmp"
		RESTOREVAL ( $KEY , $NAME , "REG_SZ" , $C & "\Windows\" & $SYSTEM32 & "\l3codecp.acm" )
	Case $NAME = "msacm.msadpcm"
		RESTOREVAL ( $KEY , $NAME , "REG_SZ" , "msadp32.acm" )
	Case $NAME = "msacm.msg711"
		RESTOREVAL ( $KEY , $NAME , "REG_SZ" , "msg711.acm" )
	Case $NAME = "msacm.msgsm610"
		RESTOREVAL ( $KEY , $NAME , "REG_SZ" , "msgsm32.acm" )
	Case StringRegExp ( $NAME , "(?i)^(vidc.i420|vidc.iyuv)$" )
		RESTOREVAL ( $KEY , $NAME , "REG_SZ" , "iyuv_32.dll" )
	Case $NAME = "vidc.mrle"
		RESTOREVAL ( $KEY , $NAME , "REG_SZ" , "msrle32.dll" )
	Case $NAME = "vidc.msvc"
		RESTOREVAL ( $KEY , $NAME , "REG_SZ" , "msvidc32.dll" )
	Case $NAME = "vidc.pDAD"
		RESTOREVAL ( $KEY , $NAME , "REG_SZ" , "prodad-codec.dll" )
	Case $NAME = "vidc.tsc2"
		If $SYSTEM32 = "SysWOW64" Then
			$VAL = "32"
		Else
			$VAL = "64"
		EndIf
		RESTOREVAL ( $KEY , $NAME , "REG_SZ" , $C & "\WINDOWS\SysWOW64\tsc2_codec" & $VAL & ".dll" )
	Case $NAME = "vidc.tscc"
		$VAL = "tsccvid"
		If $SYSTEM32 = "System32" Then $VAL = $VAL & "64"
		RESTOREVAL ( $KEY , $NAME , "REG_SZ" , $C & "\WINDOWS\SysWOW64\" & $VAL & ".dll" )
	Case StringRegExp ( $NAME , "(?i)^(vidc.uyvy|vidc.yuy2|vidc.yvyu)$" )
		RESTOREVAL ( $KEY , $NAME , "REG_SZ" , "msyuv.dll" )
	Case $NAME = "vidc.yvu9"
		RESTOREVAL ( $KEY , $NAME , "REG_SZ" , "tsbyuv.dll" )
	Case $NAME = "wavemapper"
		RESTOREVAL ( $KEY , $NAME , "REG_SZ" , "msacm32.drv" )
	Case $NAME = "msacm.siren"
		RESTOREVAL ( $KEY , $NAME , "REG_SZ" , "sirenacm.dll" )
Case Else
		DELVALUE ( $KEY , $NAME )
	EndSelect
EndFunc
Func DRIVERS32U ( ByRef $ARR )
	For $U = 1 To UBound ( $USERREG ) + 4294967295
		$FULLKEY = "HKU\" & $USERREG [ $U ] & "\Software\Microsoft\Windows NT\CurrentVersion\Drivers32"
		$HKEY = _REGOPENKEYEX3 ( $FULLKEY )
		If @error Or $HKEY = 0 Then ContinueLoop
		$ARRAYNAME = _LISTVAL ( $HKEY )
		For $V = 0 To UBound ( $ARRAYNAME ) + 4294967295
			$FILE = $ARRAYNAME [ $V ] [ 1 ]
			AAAAFP ( )
			If FileExists ( $FILE ) Then
				_ARRAYADD ( $ARR , "HKU\" & $USERREG [ $U ] & "\...\Drivers32: [" & $ARRAYNAME [ $V ] [ 0 ] & "] => " & $FILE & " [" & $SIZE & " " & $CDATE & "]" & $COMPANY , 0 , "||||" )
			Else
				If $ARRAYNAME [ $V ] [ 1 ] = "" Or StringRegExp ( $ARRAYNAME [ $V ] [ 1 ] , "\A[ ]+\Z" ) Then $ARRAYNAME [ $V ] [ 1 ] &= "[X]"
				_ARRAYADD ( $ARR , "HKU\" & $USERREG [ $U ] & "\...\Drivers32: [" & $ARRAYNAME [ $V ] [ 0 ] & "] => " & $ARRAYNAME [ $V ] [ 1 ] , 0 , "||||" )
			EndIf
		Next
		$ARRAYNAME = ""
	Next
	If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
EndFunc
Func DRIVERS32UFIX ( )
	$USER = StringRegExpReplace ( $FIX , "HKU\\(.+?)\\.+" , "$1" )
	$KEY = "HKU\" & $USER & "\Software\Microsoft\Windows NT\CurrentVersion\Drivers32"
	$NAME = StringRegExpReplace ( $FIX , ".+?\\Drivers32:\s*\[([^]]*)\].+" , "$1" )
	DELVALUE ( $KEY , $NAME )
EndFunc
Func DUM ( )
	Local $PATH
	$PATH = StringRegExpReplace ( $FIX , "(?i)CreateDummy:\s*(.+)\s*$" , "$1" )
	If FileExists ( $PATH ) Then
		If StringRegExp ( FileGetAttrib ( $PATH ) , "(?i)S|R|H" ) Then FileSetAttrib ( $PATH , "-RSH" )
		If StringInStr ( FileGetAttrib ( $PATH ) , "D" ) Then
			If _BLACK ( $PATH ) Then Return FileWrite ( $HFIXLOG , $PATH & " => " & $NREMOV & @CRLF )
			DirRemove ( $PATH , 1 )
		Else
			FileDelete ( $PATH )
		EndIf
	EndIf
	If FileExists ( $PATH ) Then
		FileWrite ( $HFIXLOG , $PATH & " already exists. Could not make dummy." & @CRLF )
	Else
		DirCreate ( $PATH )
		If StringRegExp ( FileGetAttrib ( $PATH ) , "(?i)S|R|H" ) Then FileSetAttrib ( $PATH , "+RSH" )
		_DENYE ( $PATH )
		If FileExists ( $PATH ) Then FileWrite ( $HFIXLOG , $PATH & " => " & $DUMMY & @CRLF )
	EndIf
EndFunc
Func EDGE ( )
	GUICtrlSetData ( $LABEL1 , $SCANB & " Edge: " )
	Local $EDGE [ 1 ] , $ITS
	$DD = RegRead ( "HKCU\Software\Classes\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppContainer\Storage\microsoft.microsoftedge_8wekyb3d8bbwe\MicrosoftEdge\Main" , "Default Download Directory" )
	If Not @error Then _ARRAYADD ( $EDGE , "DownloadDir: " & $DD , 0 , "|||" )
	For $U = 1 To UBound ( $USERREG ) + 4294967295
		$KEY = ""
		$UKEY = "HKU\" & $USERREG [ $U ] & "\Software\Classes\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppContainer\Storage"
		$HKEY = _REGOPENKEYEX3 ( $UKEY , 1 )
		If Not @error And IsPtr ( $HKEY ) Then
			$E = 0
			While 1
				$SUB = __REGENUMKEY ( $HKEY , $E )
				If @error Then ExitLoop
				If StringInStr ( $SUB , "microsoft.microsoftedge_" ) Then
					$KEY = $UKEY & "\" & $SUB & "\MicrosoftEdge"
					ExitLoop
				EndIf
				$E += 1
			WEnd
		EndIf
		$RET = RegRead ( $KEY & "\Main" , "HomeButtonPage" )
		If Not @error Then
			$RET = StringRegExpReplace ( $RET , "(?i)http(s|):" , "hxxp\1:" )
			_ARRAYADD ( $EDGE , "Edge HomeButtonPage: HKU\" & $USERREG [ $U ] & " -> " & $RET , 0 , "||||" )
		EndIf
		$RET = RegRead ( $KEY & "\ContinuousBrowsing" , "Enabled" )
		If $RET Then _ARRAYADD ( $EDGE , "Edge Session Restore: HKU\" & $USERREG [ $U ] & " -> " & $INTERNET2 , 0 , "||||" )
	Next
	For $U = 1 To UBound ( $USERREG ) + 4294967295
		$ITS = EDGENOTI ( $USERREG [ $U ] )
		If $ITS Then _ARRAYADD ( $EDGE , "Edge Notifications: HKU\" & $USERREG [ $U ] & " -> " & $ITS , 0 , "|||" )
	Next
	$KEY = "HKCU\SOFTWARE\Classes\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppContainer\Storage\microsoft.microsoftedge_8wekyb3d8bbwe\MicrosoftEdge\ExtensionsStore\datastore\Config\"
	$HKEY = _REGOPENKEYEX3 ( $KEY , 1 )
	If Not @error And IsPtr ( $HKEY ) Then
		$E = + 4294967295
		While 1
			$E += 1
			$EXT = __REGENUMKEY ( $HKEY , $E )
			If @error Then ExitLoop
			$EXNAME1 = RegRead ( $KEY & $EXT & "\LocalizedMessages" , "name" )
			If @error Then
				$EXNAME1 = RegRead ( $KEY & $EXT & "\LocalizedMessages" , "extensionName" )
			EndIf
			$EXPATH = RegRead ( $KEY & $EXT , "Path" )
			If @error Then
				If Not $EXNAME1 Then $EXNAME1 = $FF1
				_ARRAYADD ( $EDGE , "Edge Extension: (" & $EXNAME1 & ") -> " & $EXT & " => " & $PAD & " " & $NFOUND , 0 , "|||" )
				ContinueLoop
			EndIf
			If StringInStr ( $EXPATH , "\Assets\" ) Then
				$EXPATH1 = $EXPATH
			Else
				$EXPATH1 = StringRegExpReplace ( $EXPATH , "(.+)\\.+" , "$1" )
			EndIf
			If Not FileExists ( $EXPATH1 ) Then
				If Not $EXNAME1 Then $EXNAME1 = $FF1
				_ARRAYADD ( $EDGE , "Edge Extension: (" & $EXNAME1 & ") -> " & $EXT & " => " & $EXPATH1 & " [" & $NFOUND & "]" , 0 , "|||" )
				ContinueLoop
			EndIf
			If GUICtrlRead ( $CHECKBOX11 ) = 1 And StringRegExp ( $EXPATH1 , "(?i)Windows\\SystemApps\\[^\\]+\\Assets\\(BookViewer|HostExtensions\\(AutoFormFill|LearningTools|PinJSAPI))" ) Then ContinueLoop
			If Not $EXNAME1 Then
				$ARR = _FILELISTTOARRAY ( $EXPATH , "manifest*.json" , 1 , True )
				If IsArray ( $ARR ) Then $EXNAME1 = CHROMEEXNAME ( $ARR [ 1 ] )
				If Not $EXNAME1 Then $EXNAME1 = $FF1
			EndIf
			$DATECR = FILETIMECM ( $EXPATH1 )
			_ARRAYADD ( $EDGE , "Edge Extension: (" & $EXNAME1 & ") -> " & $EXT & " => " & $EXPATH1 & " [" & $DATECR & "]" , 0 , "|||" )
		WEnd
	EndIf
	If FileExists ( @LocalAppDataDir & "\Microsoft\Edge\User Data" ) Then EDGE1 ( $EDGE )
	If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
	Return $EDGE
EndFunc
Func EDGE1 ( ByRef $CHROME )
	Local $KEYWORD , $NAME , $SEARCHURL , $SUGGESTURL , $REGEX , $PATH , $COMP , $NEWTABURL , $PREFERENCES , $REGEX1 , $FILEARRAY , $CL , $DATECR , $CUR , $ARR , $MS , $DATEC , $P , $SUBK , $DATA
	GUICtrlSetData ( $LABEL1 , $SCANB & " Edge: Preferences" )
	$HREAD = FileOpen ( @LocalAppDataDir & "\Microsoft\Edge\User Data\Local State" , 256 )
	$PROFILE = FileRead ( $HREAD )
	FileClose ( $HREAD )
	$PROFILE = StringRegExp ( $PROFILE , """last_used"":\s*""(.+?)""" , 1 )
	$FARRAY = _FILELISTTOARRAYREC ( $PROGRAMFILES86 & "\Microsoft\Edge\Application" , "resources.pak||SetupMetrics;default_apps;Locales;WidevineCdm" , 1 , 1 , 0 , 2 )
	If UBound ( $FARRAY ) > 1 Then
		$HREAD = FileOpen ( $FARRAY [ 1 ] , 16 )
		$READ = FileRead ( $HREAD )
		FileClose ( $HREAD )
		Select
		Case StringRegExp ( $READ , "(64656661756C745F7365617263685F656E67696E655F6E616D65|64656661756C745F7365617263685F656E67696E655F6B6579776F726473)(20)*3D|363722E737263(20)*3D(20)*2768747470(73|)3A2F2F" )
			If StringRegExp ( $READ , "363722E737263(20)*3D(20)*2768747470(73|)3A2F2F" ) Then
				$URL = StringRegExp ( $READ , "7363722E737263(?:20)*3D(?:20)*27(68747470(?:73|)3A2F2F.+?)2F" , 1 )
				If IsArray ( $URL ) Then
					$URL = BinaryToString ( "0x" & $URL [ 0 ] )
					_ARRAYADD ( $CHROME , "Edge res: " & $INFEC & " resources.pak (" & $URL & "). " & $REINS & " <==== " & $UPD1 , 0 , "||||" )
				EndIf
			Else
				_ARRAYADD ( $CHROME , "Edge res: " & $INFEC & " resources.pak (search_engine). " & $REINS & " <==== " & $UPD1 , 0 , "||||" )
			EndIf
	Case Else
			$RET = StringRegExp ( $READ , "457874656E73696F6E53657474696E67733A(?:20)*457874656E73696F6E53657474696E6773(.+?)77696E646F772E6164644576656E744C697374656E657228276C6F6164" , 1 )
			If IsArray ( $RET ) Then
				$RET = BinaryToString ( "0x" & $RET [ 0 ] )
				If StringInStr ( $RET , "remove" ) Then _ARRAYADD ( $CHROME , "Edge res: " & $INFEC & " resources.pak (Adware script). " & $REINS & " <==== " & $UPD1 , 0 , "||||" )
			EndIf
		EndSelect
		$READ = ""
	EndIf
	If IsArray ( $PROFILE ) Then
		$PROFILE = $PROFILE [ 0 ]
		_ARRAYADD ( $CHROME , "Edge DefaultProfile: " & $PROFILE , 0 , "||||" )
	EndIf
	GUICtrlSetData ( $LABEL1 , $SCANB & " Edge: Extensions" )
	$ARRFOLD = _FILELISTTOARRAYREC ( @LocalAppDataDir & "\Microsoft\Edge\User Data" , "*" , 2 , 0 , 0 , 2 )
	For $N = 1 To UBound ( $ARRFOLD ) + 4294967295
		If Not FileExists ( $ARRFOLD [ $N ] & "\secure preferences" ) Then ContinueLoop
		$PROFILE = StringRegExpReplace ( $ARRFOLD [ $N ] , ".+\\(.+)" , "$1" ) & " -> "
		$ATT = ""
		If Not StringRegExp ( StringRegExpReplace ( $ARRFOLD [ $N ] , ".+\\(.+)" , "$1" ) , "(?i)^(Default|Profile \d+|(Guest|System) Profile|Backup Default)$" ) Then $ATT = " <==== " & $UPD1
		$DATECR = FILETIMECM ( $ARRFOLD [ $N ] )
		_ARRAYADD ( $CHROME , "Edge Profile: " & $ARRFOLD [ $N ] & " [" & $DATECR & "]" & $ATT , 0 , "||||" )
		$HREAD = FileOpen ( $ARRFOLD [ $N ] & "\Preferences" , 256 )
		$PREFERENCES = FileRead ( $HREAD )
		$PATH = StringRegExp ( $PREFERENCES , "(?i)""download""\s*[^""]+""default_directory""\s*:\s*""([^""]*)""" , 1 )
		If IsArray ( $PATH ) Then _ARRAYADD ( $CHROME , "Edge DownloadDir: " & $PROFILE & StringRegExpReplace ( $PATH [ 0 ] , "\\\\" , "\\" ) , 0 , "||||" )
		$HREAD = FileOpen ( $ARRFOLD [ $N ] & "\secure preferences" , 256 )
		$SECPREFERENCES = FileRead ( $HREAD )
		FileClose ( $HREAD )
		CHROMENOTI ( $PREFERENCES , $CHROME , $PROFILE , "Edge Notifications: " )
		Switch $SECPREFERENCES
		Case ""
			If FileExists ( $ARRFOLD [ $N ] & "\secure preferences" ) Then _ARRAYADD ( $CHROME , "Error reading preferences. Please check ""Secure Preferences"" file for possible corruption. <==== " & $UPD1 )
	Case Else
			$PATH = StringRegExp ( $SECPREFERENCES , """homepage""\s*:\s*""([^""]*?(?:[a-z]|\.)+.*?)""" , 1 )
			If IsArray ( $PATH ) Then _ARRAYADD ( $CHROME , "Edge HomePage: " & $PROFILE & $PATH [ 0 ] , 0 , "||||" )
			$PATH = StringRegExp ( $SECPREFERENCES , "(?i)""urls_to_restore_on_startup""\s*:\s*\[\s*(""[^]]*"")" , 1 )
			If IsArray ( $PATH ) Then _ARRAYADD ( $CHROME , "Edge RestoreOn " & $PROFILE & $PATH [ 0 ] , 0 , "||||" )
			$PATH = StringRegExp ( $SECPREFERENCES , "(?i)""startup_urls""\s*:\s*\[\s*(""[^]]*?)\]" , 1 )
			If IsArray ( $PATH ) Then _ARRAYADD ( $CHROME , "Edge StartupUrls: " & $PROFILE & $PATH [ 0 ] , 0 , "||||" )
			$PATH = StringRegExp ( $PREFERENCES , "(?i)""newtab""\s*:\s*\[\s*\{?\s*(""[^]]*?)\}?\]" , 1 )
			If IsArray ( $PATH ) Then
				$PATH = $PATH [ 0 ]
				$PATH = StringRegExpReplace ( $PATH , "(?i)""active"":true,""entry""" , " Active" )
				$PATH = StringRegExpReplace ( $PATH , "(?i)""active"":false,""entry""" , " Not-active" )
				$PATH = StringRegExpReplace ( $PATH , "(?i)\{|\}" , "" )
				_ARRAYADD ( $CHROME , "Edge NewTab: " & $PROFILE & $PATH , 0 , "||||" )
			EndIf
			$SEARCHURL = StringRegExp ( $SECPREFERENCES , ",\s*""(?:search_|)url""\s*:\s*""([^""]*?(?:[a-z]|\.)+.*?)""" , 1 )
			If IsArray ( $SEARCHURL ) Then
				If GUICtrlRead ( $CHECKBOX11 ) = 1 Then
					If Not StringRegExp ( $SEARCHURL [ 0 ] , "(?)\{google:baseURL\}.+={inputEncoding}$|{bing:baseURL}.+{bing:cvid}$" ) Then _ARRAYADD ( $CHROME , "Edge DefaultSearchURL: " & $PROFILE & $SEARCHURL [ 0 ] , 0 , "||||" )
				Else
					_ARRAYADD ( $CHROME , "Edge DefaultSearchURL: " & $PROFILE & $SEARCHURL [ 0 ] , 0 , "||||" )
				EndIf
			EndIf
			$RET = StringRegExp ( $SECPREFERENCES , ",\s*""keyword""\s*:\s*""([^""]*?(?:[a-z]|\.)+.*?)""" , 1 )
			If IsArray ( $RET ) Then
				If GUICtrlRead ( $CHECKBOX11 ) = 1 Then
					If Not StringRegExp ( $RET [ 0 ] , "(?i)google\.(com|[a-z][a-z])$|bing\.(com|[a-z][a-z])$" ) Then _ARRAYADD ( $CHROME , "Edge DefaultSearchKeyword: " & $PROFILE & $RET [ 0 ] , 0 , "||||" )
				Else
					_ARRAYADD ( $CHROME , "Edge DefaultSearchKeyword: " & $PROFILE & $RET [ 0 ] , 0 , "||||" )
				EndIf
			EndIf
			$NEWTABURL = StringRegExp ( $SECPREFERENCES , "(?i)""new_tab_url""\s*:\s*""([^""]*)""" , 1 )
			If IsArray ( $NEWTABURL ) Then
				If $NEWTABURL [ 0 ] <> "" Then
					If GUICtrlRead ( $CHECKBOX11 ) = 1 Then
						If Not StringRegExp ( $NEWTABURL [ 0 ] , "(?)\{google:baseURL\}.+={inputEncoding}$|{bing:baseURL}chrome/newtab$" ) Then _ARRAYADD ( $CHROME , "Edge DefaultNewTabURL: " & $PROFILE & $NEWTABURL [ 0 ] , 0 , "||||" )
					Else
						_ARRAYADD ( $CHROME , "Edge DefaultNewTabURL: " & $PROFILE & $NEWTABURL [ 0 ] , 0 , "||||" )
					EndIf
				EndIf
			EndIf
			$SUGGESTURL = StringRegExp ( $SECPREFERENCES , "(?i)\s*""suggest(?:ions|)_url""\s*:\s*""([^""]*)""" , 1 )
			If IsArray ( $SUGGESTURL ) Then
				If $SUGGESTURL [ 0 ] Then
					If GUICtrlRead ( $CHECKBOX11 ) = 1 Then
						If Not StringRegExp ( $SUGGESTURL [ 0 ] , "(?i){google:baseSuggestURL}.+={google:suggestAPIKeyParameter}$|{bing:baseURL}.+{bing:flights}$" ) Then _ARRAYADD ( $CHROME , "Edge DefaultSuggestURL: " & $PROFILE & $SUGGESTURL [ 0 ] , 0 , "||||" )
					Else
						_ARRAYADD ( $CHROME , "Edge DefaultSuggestURL: " & $PROFILE & $SUGGESTURL [ 0 ] , 0 , "||||" )
					EndIf
				EndIf
			EndIf
			$RET = StringRegExp ( $SECPREFERENCES , """restore_on_startup""\s*:\s*(\d)(}|,)" , 1 )
			If IsArray ( $RET ) And $RET [ 0 ] = 1 Then _ARRAYADD ( $CHROME , "Edge Session Restore: " & $PROFILE & $INTERNET2 , 0 , "||||" )
		EndSwitch
		EDGEEX ( $ARRFOLD [ $N ] , $CHROME )
	Next
	CHROMEHKLM ( "HKLM\SOFTWARE\Microsoft\Edge\Extensions" , $CHROME , "Edge" )
	For $U = 1 To UBound ( $USERREG ) + 4294967295
		CHROMEHKLM ( "HKU\" & $USERREG [ $U ] & "\SOFTWARE\Microsoft\Edge\Extensions" , $CHROME , "Edge" )
	Next
	CHROMEHKLM ( "HKLM\SOFTWARE\Wow6432Node\Microsoft\Edge\Extensions" , $CHROME , "Edge" )
	$HKEY = _REGOPENKEYEX3 ( "HKLM\SOFTWARE\Clients\StartMenuInternet" , 1 )
	If Not @error And IsPtr ( $HKEY ) Then
		$P = 0
		While 1
			$OPERABRO = __REGENUMKEY ( $HKEY , $P )
			If @error Then ExitLoop
			If StringInStr ( $OPERABRO , "Edge" ) Then
				$BROWSER = $OPERABRO
				BROWSERSTART ( $BROWSER , $CHROME , "HKLM" )
			EndIf
			$P += 1
		WEnd
	EndIf
	If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
	EDGEHTML ( $CHROME )
	$WL = "|docs.crx;drive.crx;gmail.crx;youtube.crx"
	If GUICtrlRead ( $CHECKBOX11 ) = 4 Then $WL = ""
	$ARR = _FILELISTTOARRAYREC ( $PROGRAMFILES86 & "\Microsoft\Edge\Application" , "*.crx" & $WL , 1 + 16 , 1 , 0 , 2 )
	For $I = 1 To UBound ( $ARR ) + 4294967295
		$DATECR = FILETIMECM ( $ARR [ $I ] )
		_ARRAYADD ( $CHROME , "Edge crx: " & $ARR [ $I ] & " [" & $DATECR & "]" , 0 , "||||" )
	Next
EndFunc
Func EDGEEX ( $FILE , ByRef $ARRCHROM )
	$HREAD = FileOpen ( $FILE & "\Preferences" , 256 )
	$PREFERENCES = FileRead ( $HREAD )
	FileClose ( $HREAD )
	$HREAD = FileOpen ( $FILE & "\secure preferences" , 256 )
	$SECPREFERENCES = FileRead ( $HREAD )
	FileClose ( $HREAD )
	$EXTFOLDERALL = $FILE & "\Extensions"
	$FILEARRAY = _FILELISTTOARRAYREC ( $EXTFOLDERALL , "*|TEMP" , 2 , 0 , 0 , 0 )
	For $I = 1 To UBound ( $FILEARRAY ) + 4294967295
		$UPURL = ""
		$NAME = CHROMEEXNAME0 ( $PREFERENCES , $FILEARRAY [ $I ] )
		If Not $NAME Then $NAME = CHROMEEXNAME0 ( $SECPREFERENCES , $FILEARRAY [ $I ] )
		If Not $NAME Then
			$PATH = _FILELISTTOARRAY ( $EXTFOLDERALL & "\" & $FILEARRAY [ $I ] , "*" , 2 , True )
			If IsArray ( $PATH ) Then
				$RET = FileRead ( $PATH [ 1 ] & "\manifest.json" )
				If Not $UPURL Then
					$UPURL = StringRegExp ( $RET , "(?i)""update_url""\s*:\s*""(.+?)""" , 1 )
					If IsArray ( $UPURL ) Then $UPURL = $UPURL [ 0 ]
				EndIf
				$NAME = CHROMEEXNAME ( $PATH [ 1 ] )
			EndIf
		EndIf
		If Not $UPURL Then
			$PATH = _FILELISTTOARRAY ( $EXTFOLDERALL & "\" & $FILEARRAY [ $I ] , "*" , 2 , True )
			If IsArray ( $PATH ) Then
				$RET = FileRead ( $PATH [ 1 ] & "\manifest.json" )
				If Not $UPURL Then
					$UPURL = StringRegExp ( $RET , "(?i)""update_url""\s*:\s*""(.+?)""" , 1 )
					If IsArray ( $UPURL ) Then $UPURL = $UPURL [ 0 ]
				EndIf
			EndIf
		EndIf
		$NAME = CONV ( $NAME )
		$DATECR = FILETIMECM ( $EXTFOLDERALL & "\" & $FILEARRAY [ $I ] )
		If $UPURL And Not StringRegExp ( $UPURL , "(?i)http(|s)://(edge\.microsoft\.com|extensionwebstorebase.edgesv.net|clients2\.google\.com)/" ) Then
			$UPURL = " [UpdateUrl:" & $UPURL & "] <==== " & $UPD1
		Else
			$UPURL = ""
		EndIf
		_ARRAYADD ( $ARRCHROM , "Edge Extension: (" & $NAME & ") - " & $EXTFOLDERALL & "\" & $FILEARRAY [ $I ] & " [" & $DATECR & "]" & $UPURL , 0 , "|||" )
	Next
	$EXT = StringRegExp ( $SECPREFERENCES , """path"":\s*""(.+?)""" , 3 )
	For $E = 0 To UBound ( $EXT ) + 4294967295
		$UPURL = ""
		If StringRegExp ( $EXT [ $E ] , "(?i)[c-z]:\\" ) And Not StringRegExp ( $EXT [ $E ] , "(?i)\\chrome\\.+\\resources" ) And Not StringRegExp ( $EXT [ $E ] , "(?i)User Data\\\\(Default|Profile \d+)\\\\Extensions" ) Then
			$EXT [ $E ] = StringRegExpReplace ( $EXT [ $E ] , "\\\\" , "\\" )
			If FileExists ( $EXT [ $E ] & "\manifest.json" ) Then
				$RET = FileRead ( $EXT [ $E ] & "\manifest.json" )
				$UPURL = StringRegExp ( $RET , "(?i)""update_url""\s*:\s*""(.+?)""" , 1 )
				If IsArray ( $UPURL ) Then $UPURL = $UPURL [ 0 ]
				If $UPURL And Not StringRegExp ( $UPURL , "(?i)http(|s)://(edge\.microsoft\.com|extensionwebstorebase.edgesv.net|clients2\.google\.com)/" ) Then
					$UPURL = " [UpdateUrl:" & $UPURL & "] <==== " & $UPD1
				Else
					$UPURL = ""
				EndIf
				$NAME = CHROMEEXNAME ( $EXT [ $E ] )
				$DATECR = FILETIMECM ( $EXT [ $E ] )
				_ARRAYADD ( $ARRCHROM , "Edge Extension: (" & $NAME & ") - " & $EXT [ $E ] & " [" & $DATECR & "]" & $UPURL , 0 , "|||" )
			EndIf
		EndIf
	Next
EndFunc
Func EDGEFIX ( )
	$ARRAYPRO = ProcessList ( )
	For $I = 1 To UBound ( $ARRAYPRO ) + 4294967295
		If StringRegExp ( $ARRAYPRO [ $I ] [ 0 ] , "(?i)(MicrosoftEdge|MicrosoftEdgeCP|browser_broker|msedge)\.exe" ) Then
			ProcessClose ( $ARRAYPRO [ $I ] [ 1 ] )
		EndIf
	Next
	If StringInStr ( $FIX , "HKLM\SOFTWARE\Policies\Microsoft\Edge:" ) Then Return DELKEY ( "HKLM\SOFTWARE\Policies\Microsoft\Edge" )
	If StringInStr ( $FIX , "SOFTWARE\Policies\Microsoft\Edge:" ) Then
		$USER = StringRegExpReplace ( $FIX , "(?i)HKU\\([^\\]+)\\.+" , "$1" )
		Return DELKEY ( "HKU\" & $USER & "\SOFTWARE\Policies\Microsoft\Edge" )
	EndIf
	If StringRegExp ( $FIX , "Edge (HKLM(-x32|)|HKU)\\" ) And StringInStr ( $FIX , "\Extension" ) Then
		$SUB = StringRegExpReplace ( $FIX , ".+? \[(.+?)\].*" , "$1" )
		If StringInStr ( $FIX , "Edge HKLM\" ) Then DELKEY ( "HKLM\SOFTWARE\Microsoft\Edge\Extensions" & "\" & $SUB )
		If StringInStr ( $FIX , "Edge HKU\" ) Then
			$USER = StringRegExpReplace ( $FIX , "Edge HKU\\(.+?)\\.+" , "$1" )
			DELKEY ( "HKU\" & $USER & "\SOFTWARE\Microsoft\Edge\Extensions" & "\" & $SUB )
		EndIf
		If StringInStr ( $FIX , "Edge HKLM-x32" ) Then DELKEY ( "HKLM\SOFTWARE\Wow6432Node\Microsoft\Edge\Extensions" & "\" & $SUB )
		If Not StringRegExp ( $FIX , "<.+>" ) And StringRegExp ( $FIX , "(?i)[c-z]:\\" ) And StringRegExp ( $FIX , "\[.*\]$" ) Then
			$FILEP = StringRegExpReplace ( $FIX , ".+ \[.+\] - (.+) \[.*\]" , "$1" )
		Else
			Return 1
		EndIf
		If Not FileExists ( $FILEP ) Then
			NFOUND ( $FILEP )
		Else
			$ATT = FileGetAttrib ( $FILEP )
			If StringInStr ( $ATT , "D" ) Then
				MOVEDIR ( $FILEP )
			Else
				MOVEFILENORMAL ( $FILEP )
			EndIf
		EndIf
	EndIf
	If StringRegExp ( $FIX , "(?i)HomeButtonPage:|Restore: HKU|Notifications: HKU|Extension:.+->" ) Then
		Select
		Case StringRegExp ( $FIX , "HomeButtonPage:|Restore: HKU" )
			$USER = StringRegExpReplace ( $FIX , ".*(?:HomeButtonPage|Restore): HKU\\(.+?) ->.*" , "$1" )
			$KEY = "HKU\" & $USER & "\Software\Classes\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppContainer\Storage\microsoft.microsoftedge_8wekyb3d8bbwe\MicrosoftEdge"
			If StringInStr ( $FIX , "HomeButtonPage:" ) Then Return DELVALUE ( $KEY & "\Main" , "HomeButtonPage" )
			If StringInStr ( $FIX , "Restore: HKU" ) Then DELKEY ( $KEY & "\ContinuousBrowsing" )
		Case StringInStr ( $FIX , "Notifications: HKU" )
			$USER = StringRegExpReplace ( $FIX , ".+s: HKU\\(.+) ->.*" , "$1" )
			If Not EDGENOTI ( $USER ) Then Return NFOUND ( "Edge Notifications:" )
			$KEY = "HKU\" & $USER & "\Software\Classes\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppContainer\Storage\microsoft.microsoftedge_8wekyb3d8bbwe\MicrosoftEdge\Notifications\Domains"
			$HKEY = _REGOPENKEYEX3 ( $KEY )
			If @error Or $HKEY = 0 Then NDELETED ( "Edge Notifications:" )
			$ARRNAME = _LISTVAL ( $HKEY )
			If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
			For $V = 0 To UBound ( $ARRNAME ) + 4294967295
				RegDelete ( $KEY , $ARRNAME [ $V ] [ 0 ] )
			Next
			If Not EDGENOTI ( $USER ) Then
				DELETED ( "Edge Notifications:" )
			Else
				NDELETED ( "Edge Notifications:" )
			EndIf
		Case StringRegExp ( $FIX , "Extension:.+->" )
			$KEY = StringRegExpReplace ( $FIX , ".+-> (.+?) =>.*" , "$1" )
			DELKEY ( "HKCU\Software\Classes\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppContainer\Storage\microsoft.microsoftedge_8wekyb3d8bbwe\MicrosoftEdge\ExtensionsStore\datastore\Config\" & $KEY )
			$FILEP = StringRegExp ( $FIX , "(?i)=> (.+) \[\d" , 1 )
			If IsArray ( $FILEP ) And Not _BLACK ( $FILEP [ 0 ] ) Then MOVEDIR ( $FILEP [ 0 ] )
		EndSelect
		Return
	EndIf
	If StringRegExp ( $FIX , "(?i)(HomePage|StartupUrls|DefaultSearchKeyword|RestoreOnStartup|NewTab|DefaultSearchURL|DefaultSuggestURL|DefaultNewTabURL|Session Restore|crx|Notifications):" ) Then
		$PROFILE = StringRegExpReplace ( $FIX , "Edge .+?: (.+?) ->.*" , "$1" )
		$PATH = @LocalAppDataDir & "\Microsoft\Edge\User Data\" & $PROFILE & "\preferences"
		$PATHSEC = @LocalAppDataDir & "\Microsoft\Edge\User Data\" & $PROFILE & "\Secure Preferences"
		$HREAD = FileOpen ( $PATH , 256 )
		$PREFERENCES = FileRead ( $HREAD )
		FileClose ( $HREAD )
		$HREAD = FileOpen ( $PATHSEC , 256 )
		$SECPREFERENCES = FileRead ( $PATHSEC )
		FileClose ( $HREAD )
		$HPREF = FileOpen ( @TempDir & "\preferences00" , 2 + 256 )
		$HSECPREF = FileOpen ( @TempDir & "\Secure Preferences00" , 2 + 256 )
		Select
		Case StringInStr ( $FIX , "StartupUrls:" )
			If Not StringRegExp ( $SECPREFERENCES , "(?i)""startup_urls""\s*:\s*\[" ) Then Return NFOUND ( "Edge StartupUrls" )
			$SECPREFERENCES = StringRegExpReplace ( $SECPREFERENCES , "(?is)\s*""startup_urls""\s*:\s*\[[^]]*?\]\s*\R*" , "" )
			FileWrite ( $HSECPREF , $SECPREFERENCES )
			FileClose ( $HSECPREF )
			FileMove ( @TempDir & "\secure preferences00" , $PATHSEC , 1 )
			DELETED ( "Edge StartupUrls" )
		Case StringInStr ( $FIX , "DefaultSearchKeyword:" )
			If Not StringRegExp ( $SECPREFERENCES , ",\s*""keyword""\s*:\s*""[^""]*?(?:[a-z]|\.)+.*?""" ) Then Return NFOUND ( "Edge DefaultSearchKeyword" )
			$SECPREFERENCES = StringRegExpReplace ( $SECPREFERENCES , ",\s*""keyword""\s*:\s*""[^""]*?(?:[a-z]|\.)+.*?"",?\R*" , "" )
			FileWrite ( $HSECPREF , $SECPREFERENCES )
			FileClose ( $HSECPREF )
			FileMove ( @TempDir & "\secure preferences00" , $PATHSEC , 1 )
			DELETED ( "Edge DefaultSearchKeyword" )
		Case StringInStr ( $FIX , "HomePage:" )
			If Not StringRegExp ( $SECPREFERENCES , """homepage""\s*:\s*""[^""]*?(?:[a-z]|\.)+.*?""" ) Then Return NFOUND ( "Edge HomePage" )
			$SECPREFERENCES = StringRegExpReplace ( $SECPREFERENCES , "\s*""homepage""\s*:\s*""[^""]*?(?:[a-z]|\.)+.*?"",?\R*" , "" )
			FileWrite ( $HSECPREF , $SECPREFERENCES )
			FileClose ( $HSECPREF )
			FileMove ( @TempDir & "\secure preferences00" , $PATHSEC , 1 )
			DELETED ( "Edge HomePage" )
		Case StringInStr ( $FIX , "RestoreOn" )
			If Not StringRegExp ( $SECPREFERENCES , "(?i)""urls_to_restore_on_startup"":" ) Then Return NFOUND ( "RestoreOnStartup" )
			$SECPREFERENCES = StringRegExpReplace ( $SECPREFERENCES , "(?is)\s*""urls_to_restore_on_startup""\s*:\s*\[[^]]*?\]\s*\R*" , "" )
			FileWrite ( $HSECPREF , $SECPREFERENCES )
			FileClose ( $HSECPREF )
			FileMove ( @TempDir & "\secure preferences00" , $PATHSEC , 1 )
			DELETED ( "Edge RestoreOnStartup" )
		Case StringInStr ( $FIX , "Notifications:" )
			$READ1 = StringRegExp ( $PREFERENCES , "(?i),""notifications"":\{\}," , 1 )
			If IsArray ( $READ1 ) Then Return NFOUND ( "Edge Notifications:" )
			$READ1 = StringRegExp ( $PREFERENCES , "(?i),""notifications"":\{.+?\}\}," , 1 )
			If Not IsArray ( $READ1 ) Then Return NFOUND ( "Edge Notifications:" )
			$PREFERENCES = StringRegExpReplace ( $PREFERENCES , "(?is),""notifications"":\{(.+?)\}\}," , ",""notifications"":\{\}," )
			FileWrite ( $HPREF , $PREFERENCES )
			FileClose ( $HPREF )
			FileMove ( @TempDir & "\preferences00" , $PATH , 1 )
			DELETED ( "Edge Notifications" )
		Case StringInStr ( $FIX , "NewTab:" )
			If Not StringRegExp ( $PREFERENCES , "(?i)""Edge_url_overrides""\s*:" ) Then Return NFOUND ( "NewTab" )
			$PREFERENCES = StringRegExpReplace ( $PREFERENCES , "(?is)\s*""Edge_url_overrides""\s*:.+?,""newtab""[^]]*\]\},?\s*\R*" , "" )
			FileWrite ( $HPREF , $PREFERENCES )
			FileClose ( $HPREF )
			FileMove ( @TempDir & "\preferences00" , $PATH , 1 )
			DELETED ( "Edge NewTab" )
		Case StringInStr ( $FIX , "DefaultSearchURL:" )
			If Not StringRegExp ( $SECPREFERENCES , ",\s*""(?:search_|)url""\s*:\s*""[^""]*?(?:[a-z]|\.)+.*?""" ) Then Return NFOUND ( "Edge DefaultSearchURL" )
			$SECPREFERENCES = StringRegExpReplace ( $SECPREFERENCES , ",\s*""(?:search_|)url""\s*:\s*""[^""]*?(?:[a-z]|\.)+.*?"",?\R*" , "" )
			FileWrite ( $HSECPREF , $SECPREFERENCES )
			FileClose ( $HSECPREF )
			FileMove ( @TempDir & "\secure preferences00" , $PATHSEC , 1 )
			DELETED ( "Edge DefaultSearchURL" )
		Case StringInStr ( $FIX , "DefaultSuggestURL:" )
			If Not StringRegExp ( $SECPREFERENCES , "\s*""suggest(?:ions|)_url""\s*:\s*""[^""]*?(?:[a-z]|\.)+.*?""" ) Then Return NFOUND ( "Edge DefaultSuggestURL" )
			$SECPREFERENCES = StringRegExpReplace ( $SECPREFERENCES , "\s*""suggest(?:ions|)_url""\s*:\s*""[^""]*?(?:[a-z]|\.)+.*?"",?\R*" , "" )
			FileWrite ( $HSECPREF , $SECPREFERENCES )
			FileClose ( $HSECPREF )
			FileMove ( @TempDir & "\secure preferences00" , $PATHSEC , 1 )
			DELETED ( "Edge DefaultSuggestURL" )
		Case StringInStr ( $FIX , "DefaultNewTabURL:" )
			If Not StringRegExp ( $SECPREFERENCES , "(?i)""new_tab_url""\s*:" ) Then Return NFOUND ( "Edge DefaultNewTabURL" )
			$SECPREFERENCES = StringRegExpReplace ( $SECPREFERENCES , "(?is)\s*""new_tab_url""\s*:\s*"".*?"",?\s*\R*" , "" )
			FileWrite ( $HSECPREF , $SECPREFERENCES )
			FileClose ( $HSECPREF )
			FileMove ( @TempDir & "\secure preferences00" , $PATHSEC , 1 )
			DELETED ( "Edge DefaultNewTabURL" )
		Case StringInStr ( $FIX , "Session Restore:" )
			$RET = StringRegExp ( $SECPREFERENCES , """restore_on_startup""\s*:\s*(\d)(}|,)" , 1 )
			If Not IsArray ( $RET ) Or $RET [ 0 ] <> 1 Then Return NFOUND ( "Edge Session Restore:" )
			If StringRegExp ( $SECPREFERENCES , """restore_on_startup""\s*:\s*(\d)," ) Then $SECPREFERENCES = StringRegExpReplace ( $SECPREFERENCES , "(?is)""restore_on_startup""\s*:\s*\d," , """restore_on_startup"":5," )
			If StringRegExp ( $SECPREFERENCES , """restore_on_startup""\s*:\s*(\d)}" ) Then $SECPREFERENCES = StringRegExpReplace ( $SECPREFERENCES , "(?is)""restore_on_startup""\s*:\s*\d}" , """restore_on_startup"":5}" )
			FileWrite ( $HSECPREF , $SECPREFERENCES )
			FileClose ( $HSECPREF )
			FileMove ( @TempDir & "\secure preferences00" , $PATHSEC , 1 )
			DELETED ( "Edge Session Restore" )
		Case StringRegExp ( $FIX , "Edge crx:" )
			$FILEP = StringRegExpReplace ( $FIX , "(?i).*([A-Z]:\\.+?) \[.*\]" , "$1" )
			If FileExists ( $FILEP ) Then
				Return MOVEDIR ( $FILEP )
			Else
				NFOUND ( $FILEP )
			EndIf
		EndSelect
		Return 1
	EndIf
	If StringInStr ( $FIX , "Profile:" ) Then
		$FILEP = StringRegExpReplace ( $FIX , "(?i).*([A-Z]:\\.+?) \[.*" , "$1" )
		Return MOVEDIR ( $FILEP )
	EndIf
EndFunc
Func EDGEHTML ( ByRef $CHROME )
	$E = + 4294967295
	While 1
		$E += 1
		$USER = __REGENUMKEY ( 2147483651 , $E )
		If @error Then ExitLoop
		If StringRegExp ( $USER , "(^(S-1-5-18|_Classes)" ) Then ContinueLoop
		$HKEY = _REGOPENKEYEX3 ( "HKU\" & $USER & "\SOFTWARE\Clients\StartMenuInternet\EdgeHTML" , 1 )
		If @error Or $HKEY = 0 Then ContinueLoop
		$VDATA = RegRead ( "HKU\" & $USER & "\SOFTWARE\Clients\StartMenuInternet\EdgeHTML\shell\open\command" , "" )
		$FILE = $VDATA
		$COMPANY = ""
		AAAAFP ( )
		If FileExists ( $FILE ) Then
			$VDATA = $FILE
		EndIf
		_ARRAYADD ( $CHROME , "HKU\" & $USER & "\...\StartMenuInternet\EdgeHTML: -> " & $VDATA & $COMPANY , 0 , "||||" )
	WEnd
	If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
EndFunc
Func EDGENOTI ( $USER )
	$KEY = "HKU\" & $USER & "\Software\Classes\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppContainer\Storage\microsoft.microsoftedge_8wekyb3d8bbwe\MicrosoftEdge\Notifications\Domains"
	$HKEY = _REGOPENKEYEX3 ( $KEY )
	If @error Or $HKEY = 0 Then Return
	$ARRNAME = _LISTVAL ( $HKEY )
	$ITEMS = ""
	For $V = 0 To UBound ( $ARRNAME ) + 4294967295
		If $ARRNAME [ $V ] [ 1 ] = 1 Then $ITEMS &= $ARRNAME [ $V ] [ 0 ] & "; "
	Next
	If $ITEMS Then $ITEMS = StringTrimRight ( $ITEMS , 2 )
	If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
	Return $ITEMS
EndFunc
Func EMPTY_FILE ( $PATH )
	If Not FileExists ( $PATH ) Then Return False
	GUICtrlSetData ( $LABEL1 , $DELTEMP0 & ": " & $PATH )
	_FILEDELETE ( $PATH )
	If FileExists ( $PATH ) Then FileMove ( $PATH , $C & "\FRST\Temp" , 1 )
	If FileExists ( $PATH ) Then
		MOVEFILEONREBOOT ( $PATH , "" )
	EndIf
EndFunc
Func EMPTY_FOLFILES ( $PATH , $SEARCH )
	If Not FileExists ( $PATH ) Then Return False
	GUICtrlSetData ( $LABEL1 , $DELTEMP0 & ": " & $PATH )
	$ARRQM = _FILELISTTOARRAYREC ( $PATH , $SEARCH , 1 + 16 , 0 , 0 , 2 )
	For $M = 1 To UBound ( $ARRQM ) + 4294967295
		EMPTY_FILE ( $ARRQM [ $M ] )
	Next
EndFunc
Func EMPTYFOL ( $PATH )
	If Not FileExists ( $PATH ) Then Return 1
	GUICtrlSetData ( $LABEL1 , $DELTEMP0 & ": " & $PATH )
	If _CREATEFILE ( $PATH , 268435456 ) Then _GRANTE ( $PATH , 1 , 0 )
	$SUBFOLDERS = _GETALLSUBFOLDERSSHORT ( $PATH )
	If IsArray ( $SUBFOLDERS ) Then
		_ARRAYREVERSE ( $SUBFOLDERS , 1 )
		For $E = 1 To UBound ( $SUBFOLDERS ) + 4294967295
			DirRemove ( $SUBFOLDERS [ $E ] , 1 )
			If FileExists ( $SUBFOLDERS [ $E ] ) And _BBBBKP ( $SUBFOLDERS [ $E ] ) Then DirRemove ( $SUBFOLDERS [ $E ] , 1 )
			If FileExists ( $SUBFOLDERS [ $E ] ) Then EMPTYFOL0 ( $SUBFOLDERS [ $E ] )
		Next
	EndIf
	$AARREST = _FILELISTTOARRAYREC ( $PATH , "*" , 1 + 16 , 0 , 0 , 2 )
	For $E = 1 To UBound ( $AARREST ) + 4294967295
		_FILEDELETE ( $AARREST [ $E ] )
		If FileExists ( $AARREST [ $E ] ) Then FileMove ( $AARREST [ $E ] , $C & "\FRST\Temp" , 1 )
		If FileExists ( $AARREST [ $E ] ) Then MOVEFILEONREBOOT ( $AARREST [ $E ] , "" )
	Next
EndFunc
Func EMPTYFOL0 ( $PATH )
	Local $ARRMOR [ 1 ]
	If _CREATEFILE ( $PATH , 268435456 ) Then
		_GRANTE ( $PATH , 1 , 0 )
		DirRemove ( $PATH , 1 )
		If Not FileExists ( $PATH ) Then Return
	EndIf
	$AARREST = _FILELISTTOARRAYREC ( $PATH , "*" , 0 , 1 , 0 , 2 )
	If Not IsArray ( $AARREST ) Then Return
	_ARRAYREVERSE ( $AARREST , 1 )
	For $T = 1 To UBound ( $AARREST ) + 4294967295
		If _REPARSEPOINT ( $AARREST [ $T ] ) Then
			_DELETEREPARSEPOINT ( $AARREST [ $T ] , True )
			$FSUTIL = $SYSTEMDIR & "\fsutil.exe"
			If _REPARSEPOINT ( $AARREST [ $T ] ) And $BOOTM <> "Recovery" Then RunWait ( @ComSpec & " /c " & $FSUTIL & " reparsepoint delete """ & $AARREST [ $T ] & """" , "" , @SW_HIDE )
		ElseIf Not StringRegExp ( FileGetAttrib ( $AARREST [ $T ] ) , "D" ) Then
			If CHKFILE ( $PATH , 2147483648 ) <> 32 Then
				_FILEDELETE ( $AARREST [ $T ] )
				If FileExists ( $AARREST [ $T ] ) Then FileMove ( $AARREST [ $T ] , $C & "\FRST\Temp" , 1 )
			EndIf
			If FileExists ( $AARREST [ $T ] ) Then _ARRAYADD ( $ARRMOR , $AARREST [ $T ] , 0 , "||||" )
		ElseIf StringRegExp ( FileGetAttrib ( $AARREST [ $T ] ) , "D" ) Then
			$MOR = 1
			For $M = 1 To UBound ( $ARRMOR ) + 4294967295
				If StringInStr ( $ARRMOR [ $M ] , $AARREST [ $T ] ) Then
					$MOR = ""
					ExitLoop
				EndIf
			Next
			If $MOR Then
				DirRemove ( $AARREST [ $T ] , 1 )
				If FileExists ( $AARREST [ $T ] ) Then
					_UNLOCKALLCHILD ( $PATH )
					DirRemove ( $AARREST [ $T ] , 1 )
				EndIf
			EndIf
		EndIf
	Next
	For $M = 1 To UBound ( $ARRMOR ) + 4294967295
		MOVEFILEONREBOOT ( $ARRMOR [ $M ] , "" )
	Next
EndFunc
Func EMPTYHISTORY ( $HISTORY )
	If Not FileExists ( $HISTORY ) Then Return False
	GUICtrlSetData ( $LABEL1 , $DELTEMP0 & ": " & $HISTORY )
	$AARHIST = _FILELISTTOARRAYREC ( $HISTORY , "*" , 1 + 16 , 1 , 1 , 2 )
	For $I = 1 To UBound ( $AARHIST ) + 4294967295
		If $AARHIST [ $I ] <> "desktop.ini" Then EMPTY_FILE ( $AARHIST [ $I ] )
	Next
EndFunc
Func EMPTYPATH ( $AVAL )
	$AVAL = StringRegExpReplace ( $AVAL , "%.+?%(.+)" , "$1" )
	$AVAL = StringRegExpReplace ( $AVAL , ".:\\[^\\]+\\[^\\]+(\\.+)" , "$1" )
	Return $AVAL
EndFunc
Func EMPTYTEMP ( )
	GUICtrlSetData ( $LABEL1 , $DELTEMP0 & ", " & $PW0 )
	DirCreate ( $C & "\FRST\Temp" )
	KILLDLL ( )
	$ARRAYPRO = ProcessList ( )
	For $I = 1 To UBound ( $ARRAYPRO ) + 4294967295
		If StringRegExp ( $ARRAYPRO [ $I ] [ 0 ] , "(?i)(iexplore|firefox|chrome|MicrosoftEdge|MicrosoftEdgeCP|browser_broker|msedge|brave|vivaldi|browser)\.exe" ) Then
			ProcessClose ( $ARRAYPRO [ $I ] [ 1 ] )
		EndIf
	Next
	FileWrite ( $HFIXLOG , @CRLF & "=========== EmptyTemp: ==========" & @CRLF & @CRLF )
	If FLUSHDNS ( ) Then FileWrite ( $HFIXLOG , "FlushDNS => " & $DONE & @CRLF )
	$PATHDL = @AppDataCommonDir & "\Microsoft\Network\Downloader"
	$SIZE0 = DirGetSize ( $PATHDL )
	EMPTY_FOLFILES ( $PATHDL , "qmgr*.dat" )
	EMPTY_FOLFILES ( $PATHDL , "qmgr.db" )
	$TSIZE = $SIZE0 - DirGetSize ( $PATHDL )
	FileWrite ( $HFIXLOG , "BITS transfer queue => " & $TSIZE & " B" & @CRLF )
	$SIZE1 = 0
	$SIZE2 = 0
	For $U = 1 To UBound ( $USERREG ) + 4294967295
		If StringRegExp ( $USERREG [ $U ] , "S-1-5-\d{2}-\d{3,}" ) Then
			$VALUE1 = RegRead ( "HKU\" & $USERREG [ $U ] & "\Software\Microsoft\Windows\CurrentVersion\Internet Settings\5.0\Cache\Extensible Cache\DOMStore" , "CachePath" )
			Select
			Case $VALUE1 <> ""
				$DOMSTORE1 = EMPTYPATH ( $VALUE1 )
		Case Else
				$DOMSTORE1 = "\AppData\Local\Microsoft\Internet Explorer\DOMStore"
				If $OSNUM < 6 Then $DOMSTORE1 = "\Local Settings\Application Data\Microsoft\Internet Explorer\DOMStore"
				RegWrite ( "HKU\" & $USERREG [ $U ] & "\Software\Microsoft\Windows\CurrentVersion\Internet Settings\5.0\Cache\Extensible Cache\DOMStore" , "CachePath" , "REG_EXPAND_SZ" , "%USERPROFILE%" & $DOMSTORE1 )
			EndSelect
			$SIZE1 += DirGetSize ( @UserProfileDir & $DOMSTORE1 )
			EMPTYFOL ( @UserProfileDir & $DOMSTORE1 )
			$SIZE2 += DirGetSize ( @UserProfileDir & $DOMSTORE1 )
			If $OSNUM > 5.2 Then
				$VALUE1 = RegRead ( "HKU\" & $USERREG [ $U ] & "\Software\Microsoft\Windows\CurrentVersion\Internet Settings\5.0\LowCache\Extensible Cache\DOMStore" , "CachePath" )
				Select
				Case $VALUE1 <> ""
					$DOMSTORE2 = EMPTYPATH ( $VALUE1 )
			Case Else
					$DOMSTORE2 = "\AppData\LocalLow\Microsoft\Internet Explorer\DOMStore"
					RegWrite ( "HKU\" & $USERREG [ $U ] & "\Software\Microsoft\Windows\CurrentVersion\Internet Settings\5.0\LowCache\Extensible Cache\DOMStore" , "CachePath" , "REG_EXPAND_SZ" , "%USERPROFILE%" & $DOMSTORE2 )
				EndSelect
				$SIZE1 += DirGetSize ( @UserProfileDir & $DOMSTORE2 )
				EMPTYFOL ( @UserProfileDir & $DOMSTORE2 )
				$SIZE2 += DirGetSize ( @UserProfileDir & $DOMSTORE2 )
			EndIf
		EndIf
	Next
	$THUMBCACHE = @LocalAppDataDir & "\Microsoft\Windows\Explorer"
	$SIZE1 += DirGetSize ( $THUMBCACHE )
	EMPTY_FOLFILES ( $THUMBCACHE , "thumbcache*" )
	EMPTY_FOLFILES ( $THUMBCACHE , "iconcache*" )
	$SIZE2 += DirGetSize ( $THUMBCACHE )
	$SIZE1 += FileGetSize ( @LocalAppDataDir & "\Microsoft\Internet Explorer\frameiconcache.dat" )
	EMPTY_FILE ( @LocalAppDataDir & "\Microsoft\Internet Explorer\frameiconcache.dat" )
	$SIZE2 += FileGetSize ( @LocalAppDataDir & "\Microsoft\Internet Explorer\frameiconcache.dat" )
	$SIZE1 += FileGetSize ( @LocalAppDataDir & "\IconCache.db" )
	EMPTY_FILE ( @LocalAppDataDir & "\IconCache.db" )
	$SIZE2 += FileGetSize ( @LocalAppDataDir & "\IconCache.db" )
	Local $MISC [ 4 ] = [ @LocalAppDataDir & "\Microsoft\Windows\AppCache" , @LocalAppDataDir & "\Microsoft\Internet Explorer\Recovery" , @LocalAppDataDir & "\Microsoft\Feeds Cache" , @UserProfileDir & "\AppData\LocalLow\Microsoft\Windows\AppCache" ]
	For $I = 0 To UBound ( $MISC ) + 4294967295
		If Not FileExists ( $MISC [ $I ] ) Then ContinueLoop
		$SIZE1 += DirGetSize ( $MISC [ $I ] )
		EMPTYFOL ( $MISC [ $I ] )
		$SIZE2 += DirGetSize ( $MISC [ $I ] )
	Next
	$MISC = ""
	$SIZE0 = $SIZE1 - $SIZE2
	If $SIZE0 > 0 Then $TSIZE += $SIZE0
	FileWrite ( $HFIXLOG , "DOMStore, IE Recovery, AppCache, Feeds Cache, Thumbcache, IconCache => " & $SIZE0 & " B" & @CRLF )
	$SIZE1 = 0
	$SIZE2 = 0
	$JAVACACHE = @LocalAppDataDir & "\Low\Sun\Java\Deployment\cache"
	$DISCORD = @AppDataDir & "\discord"
	If $OSNUM < 6 Then $JAVACACHE = @LocalAppDataDir & "\Sun\Java\Deployment\cache"
	Local $ARRTEMP [ ] = [ @LocalAppDataDir & "\Steam\htmlcache" , $JAVACACHE , @LocalAppDataDir & "\LocalLow\Sun\Java\Deployment\cache" , @AppDataDir & "\LocalLow\Sun\Java\Deployment\cache" , $DISCORD & "\Cache" , $DISCORD & "\code cache" , $DISCORD & "\gpucache" ]
	For $I = 0 To UBound ( $ARRTEMP ) + 4294967295
		$SIZE1 += DirGetSize ( $ARRTEMP [ $I ] )
		EMPTYFOL ( $ARRTEMP [ $I ] )
		$SIZE2 += DirGetSize ( $ARRTEMP [ $I ] )
	Next
	$ARRTEMP = ""
	Local $HTTP [ 2 ] = [ "C:\Windows\ServiceState\WinHttpAutoProxySvc\Data" , "C:\Windows\ServiceProfiles\LocalService\winhttp" ]
	For $I = 0 To UBound ( $HTTP ) + 4294967295
		$SIZE1 += DirGetSize ( $HTTP [ $I ] )
		EMPTY_FOLFILES ( $HTTP [ $I ] , "*.cache" )
		$SIZE2 += DirGetSize ( $HTTP [ $I ] )
	Next
	$SIZE0 = $SIZE1 - $SIZE2
	If $SIZE0 > 0 Then $TSIZE += $SIZE0
	FileWrite ( $HFIXLOG , "Java, Discord, Steam htmlcache, WinHttpAutoProxySvc/winhttp *.cache => " & $SIZE0 & " B" & @CRLF )
	$SIZE1 = 0
	$SIZE2 = 0
	Local $ARRTEMP2 [ 4 ] = [ $WINDOWSDIR & "\Temp" , @SystemDir & "\Temp" , @SystemDir & "\dllcache\Temp" , @SystemDir & "\Drivers\Temp" ]
	For $I = 0 To UBound ( $ARRTEMP2 ) + 4294967295
		If Not FileExists ( $ARRTEMP2 [ $I ] ) Then ContinueLoop
		$SIZE1 += DirGetSize ( $ARRTEMP2 [ $I ] )
		EMPTYFOL ( $ARRTEMP2 [ $I ] )
		$SIZE2 += DirGetSize ( $ARRTEMP2 [ $I ] )
	Next
	$ARRTEMP2 = ""
	$XP = ""
	If $OSNUM < 6 Then $XP = "dllcache/"
	$SIZE0 = $SIZE1 - $SIZE2
	If $SIZE0 > 0 Then $TSIZE += $SIZE0
	FileWrite ( $HFIXLOG , "Windows/system/" & $XP & "drivers => " & $SIZE0 & " B" & @CRLF )
	$SIZE1 = 0
	$SIZE2 = 0
	$EDGE = _FILELISTTOARRAYREC ( @LocalAppDataDir & "\Packages" , "Microsoft.MicrosoftEdge_*" , 2 + 16 , 0 , 0 , 2 )
	If IsArray ( $EDGE ) Then
		$EDGEPATH = $EDGE [ 1 ] & "\AC\MicrosoftEdge"
		Local $ARREDGE [ 6 ] = [ $EDGEPATH & "\Cache" , $EDGEPATH & "\History" , $EDGEPATH & "\Cookies" , $EDGEPATH & "\User\Default\AppCache" , $EDGEPATH & "\User\Default\DownloadHistory" , $EDGEPATH & "\User\Default\Recovery\Active" ]
		For $I = 0 To UBound ( $ARREDGE ) + 4294967295
			If Not FileExists ( $ARREDGE [ $I ] ) Then ContinueLoop
			$SIZE1 += DirGetSize ( $ARREDGE [ $I ] )
			EMPTYFOL ( $ARREDGE [ $I ] )
			$SIZE2 += DirGetSize ( $ARREDGE [ $I ] )
		Next
		$ARREDGE = ""
		$EDGEPATH = $EDGE [ 1 ] & "\AC"
		$FOL = _FILELISTTOARRAYREC ( $EDGEPATH , "#!*" , 2 + 16 , 0 , 0 , 2 )
		For $U = 1 To UBound ( $FOL ) + 4294967295
			$PATH = $FOL [ $U ] & "\Temp"
			$SIZE1 += DirGetSize ( $PATH )
			EMPTYFOL ( $PATH )
			$SIZE2 += DirGetSize ( $PATH )
			$PATH = $FOL [ $U ] & "\MicrosoftEdge\Cache"
			$SIZE1 += DirGetSize ( $PATH )
			EMPTYFOL ( $PATH )
			$SIZE2 += DirGetSize ( $PATH )
			$PATH = $FOL [ $U ] & "\MicrosoftEdge\History"
			$SIZE1 += DirGetSize ( $PATH )
			EMPTYFOL ( $PATH )
			$SIZE2 += DirGetSize ( $PATH )
			$PATH = $FOL [ $U ] & "\MicrosoftEdge\Cookies"
			$SIZE1 += DirGetSize ( $PATH )
			EMPTYFOL ( $PATH )
			$SIZE2 += DirGetSize ( $PATH )
			$PATH = $FOL [ $U ] & "\MicrosoftEdge\User\Default\AppCache"
			$SIZE1 += DirGetSize ( $PATH )
			EMPTYFOL ( $PATH )
			$SIZE2 += DirGetSize ( $PATH )
			$PATH = $FOL [ $U ] & "\MicrosoftEdge\User\Default\DOMStore"
			$SIZE1 += DirGetSize ( $PATH )
			EMPTYFOL ( $PATH )
			$SIZE2 += DirGetSize ( $PATH )
		Next
	EndIf
	$FOL = ""
	$SIZE0 = $SIZE1 - $SIZE2
	If $SIZE0 > 0 Then $TSIZE += $SIZE0
	FileWrite ( $HFIXLOG , "Edge => " & $SIZE0 & " B" & @CRLF )
	Local $BRO [ ] = [ "Chrome" , "Brave" , "Vivaldi" , "Yandex" ]
	Local $USERDATA [ ] = [ @LocalAppDataDir & "\Google\Chrome\User Data" , @LocalAppDataDir & "\BraveSoftware\Brave-Browser\User Data" , @LocalAppDataDir & "\Vivaldi\User Data" , @LocalAppDataDir & "\Yandex\YandexBrowser\User Data" ]
	For $R = 0 To UBound ( $BRO ) + 4294967295
		If Not FileExists ( $USERDATA [ $R ] ) Then ContinueLoop
		$SIZE1 = 0
		$SIZE2 = 0
		$ARRCHROMEFILE = _FILELISTTOARRAYREC ( $USERDATA [ $R ] , "Cookies;History;Archived History;Visited Links;Current Tabs;Current Session" , 1 + 16 , 1 , 0 , 2 )
		For $M = 1 To UBound ( $ARRCHROMEFILE ) + 4294967295
			$SIZE1 += FileGetSize ( $ARRCHROMEFILE [ $M ] )
			EMPTY_FILE ( $ARRCHROMEFILE [ $M ] )
			$SIZE2 += FileGetSize ( $ARRCHROMEFILE [ $M ] )
		Next
		$SCACHE = $USERDATA [ $R ] & "\ShaderCache\GPUCache"
		$SIZE1 += DirGetSize ( $SCACHE )
		EMPTYFOL ( $SCACHE )
		$SIZE2 += DirGetSize ( $SCACHE )
		$ARRFOLD = _FILELISTTOARRAYREC ( $USERDATA [ $R ] , "Default;Profile*" , 2 + 16 , 0 , 0 , 2 )
		For $N = 1 To UBound ( $ARRFOLD ) + 4294967295
			$SIZE1 += DirGetSize ( $ARRFOLD [ $N ] )
			EMPTYFOL ( $ARRFOLD [ $N ] & "\Cache" )
			EMPTYFOL ( $ARRFOLD [ $N ] & "\GPUCache" )
			EMPTYFOL ( $ARRFOLD [ $N ] & "\Service Worker" )
			EMPTYFOL ( $ARRFOLD [ $N ] & "\JumpListIcons" )
			EMPTYFOL ( $ARRFOLD [ $N ] & "\JumpListIconsOld" )
			$AARJOUR = _FILELISTTOARRAYREC ( $ARRFOLD [ $N ] , "*-journal" , 1 + 16 , 1 , 0 , 2 )
			For $J = 1 To UBound ( $AARJOUR ) + 4294967295
				EMPTY_FILE ( $AARJOUR [ $J ] )
			Next
			REMFOLARR ( $ARRFOLD [ $N ] & "\IndexedDB" , "https_*.indexeddb.leveldb;http_*.indexeddb.leveldb" )
			$SIZE2 += DirGetSize ( $ARRFOLD [ $N ] )
		Next
		$SIZE0 = $SIZE1 - $SIZE2
		If $SIZE0 > 0 Then $TSIZE += $SIZE0
		FileWrite ( $HFIXLOG , $BRO [ $R ] & " => " & $SIZE0 & " B" & @CRLF )
	Next
	$ARRFOLD = ""
	$PROFILES = @LocalAppDataDir & "\MOZILLA\FIREFOX\PROFILES"
	$SIZE1 = DirGetSize ( $PROFILES )
	EMPTYFOL ( $PROFILES )
	$SIZE2 = DirGetSize ( $PROFILES )
	$PROFILE = @AppDataDir & "\MOZILLA\FIREFOX\PROFILES"
	$ARRCOOK = _FILELISTTOARRAYREC ( $PROFILE , "*" , 2 + 16 , 0 , 0 , 2 )
	If IsArray ( $ARRCOOK ) Then
		$SIZE1 += DirGetSize ( $PROFILE )
		For $F = 1 To UBound ( $ARRCOOK ) + 4294967295
			EMPTY_FILE ( $ARRCOOK [ $F ] & "\sessionstore.js" )
			EMPTY_FILE ( $ARRCOOK [ $F ] & "\sessionstore.bak" )
			EMPTY_FILE ( $ARRCOOK [ $F ] & "\cookies.sqlite" )
			EMPTY_FILE ( $ARRCOOK [ $F ] & "\webappsstore.sqlite" )
			EMPTY_FILE ( $ARRCOOK [ $F ] & "\Serviceworker.txt" )
			REMFOLARR ( $ARRCOOK [ $F ] & "\storage\default" , "https+++*;http+++*" )
			$_HSQ = _SQLITEO ( $ARRCOOK [ $F ] & "\places.sqlite" )
			If @error Or Not $_HSQ Then ContinueLoop
			_SQLITE_EXEC ( $_HSQ , "DELETE FROM moz_historyvisits; DELETE FROM moz_places WHERE foreign_count = 0; UPDATE moz_places SET visit_count = 0; UPDATE moz_places SET frecency = -1;" )
			_SQLITECL ( $_HSQ )
		Next
		$SIZE2 += DirGetSize ( $PROFILE )
	EndIf
	$ARRCOOK = ""
	$SIZE0 = $SIZE1 - $SIZE2
	If $SIZE0 > 0 Then $TSIZE += $SIZE0
	FileWrite ( $HFIXLOG , "Firefox => " & $SIZE0 & " B" & @CRLF )
	$OPERAC = @LocalAppDataDir & "\Opera Software\Opera Stable\Cache"
	$SIZE1 = DirGetSize ( $OPERAC )
	EMPTYFOL ( $OPERAC )
	$SIZE2 = DirGetSize ( $OPERAC )
	$OPERAJOUR = @AppDataDir & "\Opera Software\Opera Stable"
	$SIZE1 += DirGetSize ( $OPERAJOUR )
	$ARROPERAFILE = _FILELISTTOARRAYREC ( $OPERAJOUR , "Cookies;History;*-journal" , 1 + 16 , 1 , 0 , 2 )
	For $M = 1 To UBound ( $ARROPERAFILE ) + 4294967295
		EMPTY_FILE ( $ARROPERAFILE [ $M ] )
	Next
	$ARROPERAFILE = ""
	$ARROPERAFOL = _FILELISTTOARRAYREC ( $OPERAJOUR , "GPUCache;Jump List Icons;Jump List IconsOld;Local Storage" , 2 + 16 , 1 , 0 , 2 )
	For $M = 1 To UBound ( $ARROPERAFOL ) + 4294967295
		EMPTYFOL ( $ARROPERAFOL [ $M ] )
	Next
	$ARROPERAFOL = ""
	REMFOLARR ( $OPERAJOUR & "\IndexedDB" , "https_*.indexeddb.leveldb;http_*.indexeddb.leveldb" )
	$SIZE2 += DirGetSize ( $OPERAJOUR )
	$SIZE0 = $SIZE1 - $SIZE2
	If $SIZE0 > 0 Then $TSIZE += $SIZE0
	FileWrite ( $HFIXLOG , "Opera => " & $SIZE0 & " B" & @CRLF )
	$VALUE1 = RegRead ( "HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders" , "Cache" )
	$VALUE2 = RegRead ( "HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders" , "Cache" )
	Select
	Case $VALUE1 <> ""
		$TEMPINTERNET = EMPTYPATH ( $VALUE1 )
	Case $VALUE2 <> ""
		$TEMPINTERNET = EMPTYPATH ( $VALUE2 )
Case Else
		$TEMPINTERNET = "\AppData\Local\Microsoft\Windows\Temporary Internet Files"
		If $OSNUM < 6 Then $TEMPINTERNET = "\Local Settings\Temporary Internet Files"
		RegWrite ( "HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders" , "Cache" , "REG_EXPAND_SZ" , "%USERPROFILE%" & $TEMPINTERNET )
	EndSelect
	$VALUE1 = RegRead ( "HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders" , "Cookies" )
	$VALUE2 = RegRead ( "HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders" , "Cookies" )
	Select
	Case $VALUE1 <> ""
		$COOKIES = EMPTYPATH ( $VALUE1 )
	Case $VALUE2 <> ""
		$COOKIES = EMPTYPATH ( $VALUE2 )
Case Else
		$COOKIES = "\AppData\Roaming\Microsoft\Windows\Cookies"
		If $OSNUM < 6 Then $COOKIES = "\Cookies"
		RegWrite ( "HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders" , "Cookies" , "REG_EXPAND_SZ" , "%USERPROFILE%" & $COOKIES )
	EndSelect
	$VALUE1 = RegRead ( "HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders" , "History" )
	$VALUE2 = RegRead ( "HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders" , "History" )
	Select
	Case $VALUE1 <> ""
		$HISTORY = EMPTYPATH ( $VALUE1 )
	Case $VALUE2 <> ""
		$HISTORY = EMPTYPATH ( $VALUE2 )
Case Else
		$HISTORY = "\AppData\Local\Microsoft\Windows\History"
		If $OSNUM < 6 Then $HISTORY = "\Local Settings\History"
		RegWrite ( "HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders" , "History" , "REG_EXPAND_SZ" , "%USERPROFILE%" & $HISTORY )
	EndSelect
	$VALUE1 = RegRead ( "HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders" , "Recent" )
	$VALUE2 = RegRead ( "HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders" , "Recent" )
	Select
	Case $VALUE1 <> ""
		$RECENT = EMPTYPATH ( $VALUE1 )
	Case $VALUE2 <> ""
		$RECENT = EMPTYPATH ( $VALUE2 )
Case Else
		$RECENT = "\AppData\Roaming\Microsoft\Windows\Recent"
		If $OSNUM < 6 Then $RECENT = "\Recent"
		RegWrite ( "HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders" , "Recent" , "REG_EXPAND_SZ" , "%USERPROFILE%" & $RECENT )
	EndSelect
	$TEMPDIR = StringRegExpReplace ( FileGetLongName ( @TempDir ) , ".:\\.+?\\.+?(\\.+)$" , "$1" )
	$USERPROFILE = StringRegExpReplace ( FileGetLongName ( @UserProfileDir ) , "\\" , "\\\\" )
	$LOCALAPPDATADIR = StringRegExpReplace ( FileGetLongName ( @LocalAppDataDir ) , $USERPROFILE , "" )
	$APPDATADIR = StringRegExpReplace ( FileGetLongName ( @AppDataDir ) , $USERPROFILE , "" )
	$USERS = GETPROFILES ( )
	$SIZE1 = 0
	$SIZE2 = 0
	FileWrite ( $HFIXLOG , @CRLF & "Temp, IE cache, history, cookies, recent:" & @CRLF )
	For $U = 1 To UBound ( $USERS ) + 4294967295
		$LOCALLOW = $USERS [ $U ] & "\AppData\LocalLow\Temp"
		$SIZE1 += DirGetSize ( $LOCALLOW )
		EMPTYFOL ( $LOCALLOW )
		$SIZE2 += DirGetSize ( $LOCALLOW )
		$TEMPPATH = $USERS [ $U ] & $TEMPDIR
		$SIZE1 += DirGetSize ( $TEMPPATH )
		EMPTYFOL ( $TEMPPATH )
		$SIZE2 += DirGetSize ( $TEMPPATH )
		$IETEMP = $USERS [ $U ] & $TEMPINTERNET
		$SIZE1 += DirGetSize ( $IETEMP )
		EMPTYFOL ( $IETEMP )
		$SIZE2 += DirGetSize ( $IETEMP )
		$COOKISPATH = $USERS [ $U ] & $COOKIES
		$SIZE1 += DirGetSize ( $COOKISPATH )
		EMPTYFOL ( $COOKISPATH )
		$SIZE2 += DirGetSize ( $COOKISPATH )
		$RECENTPATH = $USERS [ $U ] & $RECENT
		$SIZE1 += DirGetSize ( $RECENTPATH )
		EMPTYFOL ( $RECENTPATH )
		$SIZE2 += DirGetSize ( $RECENTPATH )
		$HISTORYPATH = $USERS [ $U ] & $HISTORY
		$SIZE1 += DirGetSize ( $HISTORYPATH )
		EMPTYHISTORY ( $HISTORYPATH )
		$SIZE2 += DirGetSize ( $HISTORYPATH )
		$SIZE0 = $SIZE1 - $SIZE2
		If $SIZE0 > 0 Then $TSIZE += $SIZE0
		$USER = StringRegExpReplace ( $USERS [ $U ] , ".+\\(.+)" , "$1" )
		If StringInStr ( $USERS [ $U ] , "SysWOW64" ) Then $USER = $USER & "32"
		FileWrite ( $HFIXLOG , $USER & " => " & $SIZE0 & " B" & @CRLF )
	Next
	RegWrite ( "HKLM\Software\Microsoft\Windows\CurrentVersion\RunOnce" , "*EmptyTemp" , "REG_SZ" , "cmd /c rd /q/s " & $C & "\FRST\Temp" )
	$SIZE1 = 0
	$SIZE2 = 0
	$RET = _WINAPI_SHELLQUERYRECYCLEBIN ( $C )
	If IsArray ( $RET ) Then $SIZE1 = $RET [ 0 ]
	_WINAPI_SHELLEMPTYRECYCLEBIN ( $C , $SHERB_NO_UI )
	$RET = _WINAPI_SHELLQUERYRECYCLEBIN ( $C )
	If IsArray ( $RET ) Then $SIZE2 = $RET [ 0 ]
	$SIZE0 = $SIZE1 - $SIZE2
	If $SIZE0 > 0 Then $TSIZE += $SIZE0
	FileWrite ( $HFIXLOG , @CRLF & "RecycleBin => " & $SIZE0 & " B" & @CRLF )
	FileWrite ( $HFIXLOG , "EmptyTemp: => " & CONVERTSIZE ( $TSIZE ) & " " & $DELTEMP1 & @CRLF & @CRLF & "================================" & @CRLF )
EndFunc
Func ENUMSAFE ( $STARTKEY )
	Local $I , $V , $KEY , $ARRAYNAME
	$HKEY = _REGOPENKEYEX3 ( $STARTKEY )
	If @error Or $HKEY = 0 Then Return
	$I = 0
	While 1
		$KEY = __REGENUMKEY ( $HKEY , $I )
		If @error Then ExitLoop
		$HKEY1 = _REGOPENKEYEX3 ( $STARTKEY & "\" & $KEY )
		If Not @error And IsPtr ( $HKEY1 ) Then
			$ARRAYNAME = _LISTVAL ( $HKEY1 )
			If UBound ( $ARRAYNAME ) > 0 Then
				For $V = 0 To UBound ( $ARRAYNAME ) + 4294967295
					$ATTEN = ""
					If StringRegExp ( $STARTKEY & "\" & $KEY , "(?i)(Minimal|Network)\\(PCProtect|pcwatch|cmwr|cmwf|MyOSProtect)" ) Then $ATTEN = " <==== " & $UPD1
					Select
					Case StringRegExp ( $STARTKEY & "\" & $KEY , "(?i)\\(Minimal|Network)\\((ExecutionContext|netadaptercx|HidSpiCx|nvdimm|usbaudio|HdAudBus|HdAudAddService|uefi|SpbCx|iai2c|Ahcache|BasicDisplay|BasicRender|dxgkrnl|FsDepends|iaioi2c|dmio|dmload|dmboot|sermouse|vga|vgasave|volmgr|volmgrx|SerCx2)\.sys|TextInputManagementService|NgcCtnrSvc|NgcSvc|MsQuic|hvsifltr|WmsSelfHealing|Wms|CBDHSvc|WinQuic|AudioSrv|AudioEndpointBuilder|UserManager|TileDataModelSvc|StateRepository|CoreMessagingRegistrar|Wdf01000|BrokerInfrastructure|DeviceInstall|SystemEventsBroker|LSM|AppInfo|AppMgmt|CryptSvc|VDS|DcomLaunch|EFS|EventLog|HelpSvc|KeyIso|MsMpSvc|Netlogon|NTDS|PlugPlay|Power|ProfSvc|RpcEptMapper|RpcSs|sacsvr|SWPRV|TabletInputService|TBS|TrustedInstaller|WinDefend|WinMgmt|vmms|WudfSvc|dmadmin|dmserver|SRService|System Bus Extender|Base|Boot Bus Extender|Boot file system|File system|Filter|PCI Configuration|PNP Filter|Primary disk|SCSI Class|WudfPf|WudfRd|NetSetupSvc|cdd.dll|WinHttpAutoProxySvc)" ) And StringRegExp ( $ARRAYNAME [ $V ] [ 1 ] , "(?i)Service|Driver|Driver Group" )
						ContinueLoop
					Case StringRegExp ( $STARTKEY & "\" & $KEY , "(?i)\\(Minimal|Network)\\sr.sys" ) And StringRegExp ( $ARRAYNAME [ $V ] [ 1 ] , "(?i)FSFilter System Recovery" )
						ContinueLoop
					Case StringRegExp ( $STARTKEY & "\" & $KEY , "(?i)\\(Minimal|Network)\\{(13cfe1b1-6b17-424c-ac3f-16ace8733898|4D36E96C-E325-11CE-BFC1-08002BE10318|F2E7DD72-6468-4E36-B6F1-6488F42C1B52|5099944A-F6B9-4057-A056-8C550228544C|53966cb1-4d46-4166-bf23-c522403cd495|36FC9E60-C465-11CF-8056-444553540000|9DA2B80F-F89F-4A49-A5C2-511B085B9E8A|A0A588A4-C46F-4B37-B7EA-C82FE89870C6|(4D36E965|4D36E967|4D36E969|4D36E96A|4D36E96B|4D36E96F|4D36E977|4D36E97D|4D36E97B|4D36E980)-E325-11CE-BFC1-08002BE10318|533C5B84-EC70-11D2-9505-00C04F79DEAF|(6BDD1FC1-810F|71A27CDD-812A)-11D0-BEC7-08002BE2092F|745A17A0-74D3-11D0-B6FE-00A0C90F57DA|D48179BE-EC20-11D1-B6B8-00C04FA372A7|D94EE5D8-D189-4994-83D2-F68D7D41B0E6)}" ) And StringRegExp ( $ARRAYNAME [ $V ] [ 1 ] , "(?i)I3C devices|ScmDisk|Universal Serial Bus controllers|CD-ROM Drive|DiskDrive|Standard floppy disk controller|Hdc|Keyboard|Mouse|PCMCIA Adapters|SCSIAdapter|System|Floppy disk drive|Volume shadow copy|IEEE 1394 Bus host controllers|Volume|Human Interface Devices|SBP2 IEEE 1394 Devices|SecurityDevices|Enhanced Storage Devices|SDA Standard Compliant SD Host Controller|1$|Memory|Firmware|Media" )
						ContinueLoop
					Case StringRegExp ( $STARTKEY & "\" & $KEY , "(?i)\\Network\\(AFD|BFE|Browser|Dhcp|DnsCache|Dot3Svc|Eaphost|IKEEXT|LanmanServer|LanmanWorkstation|Wcmsvc|LmHosts|Messenger|MPSSvc|NativeWifiP|Ndisuio|NetBIOS|NetBT|NetMan|netprofm|NlaSvc|Nsi|PolicyAgent|rdsessmgr|SCardSvr|SharedAccess|Tcpip|VaultSvc|Wlansvc|ipnat.sys|bowser|dfsc|mrxsmb10|mrxsmb20|mrxsmb|MPSDrv|ndiscap|nsiproxy.sys|rdbss|rdpencdd.sys|SmartcardSimulator|VirtualSmartcardReader|WudfUsbccidDriver|NDIS|NDIS Wrapper|NetBIOSGroup|NetDDEGroup|Network|NetworkProvider|PNP_TDI|Streams Drivers|TDI|ip6fw.sys|NtLmSsp|rdpcdd.sys|rdpdd.sys|rdpwd.sys|tdpipe.sys|tdtcp.sys|termservice|WZCSVC)" ) And StringRegExp ( $ARRAYNAME [ $V ] [ 1 ] , "(?i)Service|Driver|Driver Group" )
						ContinueLoop
					Case StringRegExp ( $STARTKEY & "\" & $KEY , "(?i)\\Network\\\{((4D36E972|4D36E973|4D36E974|4D36E975)-E325-11CE-BFC1-08002BE10318|50DD5230-BA8A-11D1-BF5D-0000F805F530)\}" ) And StringRegExp ( $ARRAYNAME [ $V ] [ 1 ] , "(?i)Net|NetClient|NetService|NetTrans|Smart card readers" )
						ContinueLoop
					EndSelect
					_ARRAYADD ( $ARRSAFE , $STARTKEY & "\" & $KEY & " => """ & $ARRAYNAME [ $V ] [ 0 ] & """=""" & $ARRAYNAME [ $V ] [ 1 ] & """" & $ATTEN , 0 , "||||" )
				Next
				$ARRAYNAME = ""
			EndIf
		EndIf
		ENUMSAFE ( $STARTKEY & "\" & $KEY )
		$I += 1
	WEnd
	If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
EndFunc
Func EVENTS ( )
	GUICtrlSetData ( $LABEL1 , $SCANB & " events, " & $PW0 )
	MAINAPP ( )
	MAINSYS ( )
	WINDEF ( )
	CODEINTEGRITY ( )
	GUICtrlSetData ( $LABEL1 , "" )
EndFunc
Func EVENTS1 ( )
	If _SRVSTAT ( "eventlog" ) = "R" Then
		EVENTS ( )
	Else
		GUICtrlSetData ( $LABEL1 , "Attempting to start eventlog, " & $PW0 )
		$SC = @SystemDir & "\sc.exe"
		RunWait ( @ComSpec & " /c " & $SC & " config eventlog start= auto" , "" , @SW_HIDE )
		_SERVICE_START ( "eventlog" )
		Sleep ( 5000 )
		If _SRVSTAT ( "eventlog" ) = "R" Then
			EVENTS ( )
		Else
			FileWrite ( $HADDITION , @CRLF & "==================== " & $EVENTS1 & ": ========================" & @CRLF & @CRLF & $EVENTS2 & @CRLF & @CRLF )
			$NET = @SystemDir & "\net.exe"
			$READ = CMDRUN ( $NET & " start eventlog" )
			FileWrite ( $HADDITION , $READ )
		EndIf
	EndIf
EndFunc
Func EXEASS ( ByRef $EXEARR )
	If $BOOTM = "Recovery" Then FileWrite ( $FRSTLOG , @CRLF & "==================== " & $ASS & " (" & $WLISTED & ") =============" & @CRLF & @CRLF )
	Local $RUN1
	$RUN1 = RegRead ( "HKLM\" & $SOFTWARE & "\Classes\.exe" , "" )
	If $RUN1 <> "exefile" Then
		$RET = RegRead ( "HKLM\" & $SOFTWARE & "\Classes\" & $RUN1 & "\shell\open\command" , "" )
		_ARRAYADD ( $EXEARR , "HKLM\...\.exe: " & $RUN1 & " => " & $RET & " <==== " & $UPD1 , 0 , "||||" )
	EndIf
	$RUN1 = RegRead ( "HKLM\" & $SOFTWARE & "\Classes\exefile\DefaultIcon" , "" )
	If $RUN1 <> "%1" Then _ARRAYADD ( $EXEARR , "HKLM\...\exefile\DefaultIcon: " & $RUN1 & " <==== " & $UPD1 , 0 , "||||" )
	$RUN1 = RegRead ( "HKLM\" & $SOFTWARE & "\Classes\exefile\shell\open\command" , "" )
	If $RUN1 <> """%1"" %*" Then _ARRAYADD ( $EXEARR , "HKLM\...\exefile\shell\open\command: " & $RUN1 & " <==== " & $UPD1 , 0 , "||||" )
	$RUN1 = RegRead ( "HKLM\" & $SOFTWARE & "\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.exe" , "" )
	If $RUN1 <> "" Then _ARRAYADD ( $EXEARR , "HKLM\...\Explorer\FileExts\.exe: " & $RUN1 , 0 , "||||" )
	If UBound ( $EXEARR ) < 2 Then Return
	If $BOOTM = "Recovery" Then _FILEWRITEFROMARRAY ( $FRSTLOG , $EXEARR , 1 )
EndFunc
Func FCHECKFIX ( )
	$FILEP = StringRegExpReplace ( $FIX , "FCheck:\s(.+?) \[.+" , "$1" )
	If Not FileExists ( $FILEP ) Then Return NFOUND ( $FILEP )
	If StringInStr ( FileGetAttrib ( $FILEP ) , "D" ) Then
		MOVEDIR ( $FILEP )
	Else
		MOVEFILER ( $FILEP )
	EndIf
EndFunc
Func FFMOVE ( )
	$FILEP = StringRegExpReplace ( $FIX , "^""|""$" , "" )
	$FILEP = StringRegExpReplace ( $FILEP , "/" , "\\" )
	If StringRegExp ( $FIX , "(?i)\A\d{4}-\d{2}-\d{2}.+" ) Then $FILEP = StringRegExpReplace ( $FIX , "(?i)\A\d{4}-\d{2}-\d{2}.+(" & $C & "\\.+)" , "$1" )
	$FILEP = StringRegExpReplace ( $FILEP , "\\$" , "" )
	$RET = StringRegExpReplace ( $FILEP , ".+\\(.+)" , "$1" )
	If StringInStr ( $RET , "*" ) Then Return FFMOVEWILD ( $FILEP , $RET )
	If Not FileExists ( "\\?\" & $FILEP ) Or StringInStr ( $RET , "?" ) Then Return NFOUND ( $FILEP )
	If StringInStr ( FileGetAttrib ( "\\?\" & $FILEP ) , "D" ) And _BLACK ( $FILEP ) Then Return FileWrite ( $HFIXLOG , """" & $FILEP & """ => " & $WARN & ": " & $FIX13 & @CRLF )
	If _REPARSEPOINT ( "\\?\" & $FILEP ) Then
		FileWrite ( $HFIXLOG , $SYMLINK0 & " " & $FOUND1 & ": """ & $FILEP & """ => """ & _GETREPARSETARGET ( $FILEP ) & """" & @CRLF )
		If _DELETEREPARSEPOINT ( $FILEP , True ) = 1 Then
			FileWrite ( $HFIXLOG , """" & $FILEP & """ => " & $SYMLINK0 & " " & $DELETED & @CRLF )
		Else
			Return FileWrite ( $HFIXLOG , """" & $FILEP & """ => " & $SYMLINK0 & "" & $NDELETED & "." & @CRLF )
		EndIf
	Else
		$ATT = FileGetAttrib ( $FILEP )
		If StringInStr ( $ATT , "D" ) Then
			MOVEDIR ( $FILEP )
		Else
			MOVEFILER ( $FILEP )
		EndIf
	EndIf
EndFunc
Func FFMOVEWILD ( $FILEP , $RET )
	$FOLDER = StringRegExpReplace ( $FILEP , "(.+)\\.+" , "$1" )
	FileWrite ( $HFIXLOG , @CRLF & "=========== """ & $FILEP & """ ==========" & @CRLF & @CRLF )
	$FILESI = _FILELISTTOARRAYREC ( $FOLDER , $RET , 1 , 0 , 0 , 2 )
	If IsArray ( $FILESI ) Then
		For $D = 1 To UBound ( $FILESI ) + 4294967295
			If _REPARSEPOINT ( $FILESI [ $D ] ) Then
				FileWrite ( $HFIXLOG , $SYMLINK0 & " " & $FOUND1 & ": """ & $FILESI [ $D ] & """ => """ & _GETREPARSETARGET ( $FILESI [ $D ] ) & """" & @CRLF )
				If _DELETEREPARSEPOINT ( $FILESI [ $D ] , True ) = 1 Then
					FileWrite ( $HFIXLOG , """" & $FILESI [ $D ] & """ => " & $SYMLINK0 & " " & $DELETED & @CRLF )
				Else
					Return FileWrite ( $HFIXLOG , """" & $FILESI [ $D ] & """ => " & $SYMLINK0 & "" & $NDELETED & "." & @CRLF )
				EndIf
				If Not FileExists ( $FILESI [ $D ] ) Then ContinueLoop
			EndIf
			MOVEFILER ( $FILESI [ $D ] )
		Next
	Else
		FileWrite ( $HFIXLOG , $NFOUND & @CRLF )
	EndIf
	FileWrite ( $HFIXLOG , @CRLF & "========= " & $END & " -> """ & $FILEP & """ ========" & @CRLF & @CRLF )
EndFunc
Func FILE ( )
	FileWrite ( $HFIXLOG , @CRLF & "========================= " & $FIX & " ========================" & @CRLF & @CRLF )
	$FILEPS = StringRegExpReplace ( $FIX , "(?i)File:\s*(.+)" , "$1" )
	$PATHS = StringSplit ( $FILEPS , ";" )
	If Not IsArray ( $PATHS ) Then Return FileWrite ( $HFIXLOG , "File: Error reading paths" & @CRLF )
	$Q = UBound ( $PATHS ) + 4294967295
	For $P = 1 To $Q
		If $Q > 4 And IsInt ( $P / 4 ) Then Sleep ( 60000 )
		Local $VERCN = "" , $VERFV = "" , $VERON = "" , $VERIN = "" , $VERDES = "" , $VERPN = "" , $VERCR = "" , $FILESI = "" , $VERPV = ""
		$PATHS [ $P ] = StringRegExpReplace ( $PATHS [ $P ] , "^\s*|\s*$" , "" )
		$PATHS [ $P ] = StringRegExpReplace ( $PATHS [ $P ] , "^""|""$" , "" )
		$FILEP1 = $PATHS [ $P ]
		If Not FileExists ( $PATHS [ $P ] ) Then
			NFOUND ( $FILEP1 )
			ContinueLoop
		EndIf
		$DATECR = FILETIME ( $FILEP1 , 1 )
		$DATEMO = FILETIME ( $FILEP1 )
		If $CRYPT Then
			If _CHECKSIG ( $FILEP1 ) = 11 Then
				$FILESI = $FILESIG & @CRLF
			Else
				$FILESI = $FILENS & @CRLF
			EndIf
		EndIf
		$FATT = FileGetAttrib ( $FILEP1 )
		If _REPARSEPOINT ( $FILEP1 ) Then $FATT = $FATT & "L"
		$ATT = StringFormat ( "%05s" , $FATT )
		$ATTS = StringRegExpReplace ( $ATT , "0" , "-" )
		$SIZE = _FILEGETSIZE ( $FILEP1 )
		$SIZES = StringFormat ( "%09u" , $SIZE )
		$HASH = MD5 ( $FILEP1 )
		If Not $HASH Or $HASH = "d41d8cd98f00b204e9800998ecf8427e" Then
			$JOT = "0-byte"
			$HASH = $HASH & FILEACC ( $FILEP1 )
		Else
			$JOT = _JOTTISEARCH ( $HASH , $APIK )
			If Not $JOT Then $JOT = _JOTTITSCAN ( $PATHS [ $P ] , $APIK )
		EndIf
		$RET = _GETFILEPRO ( $FILEP1 )
		If IsArray ( $RET ) Then
			$VERCN = $RET [ 1 ] [ 2 ]
			$VERDES = $RET [ 1 ] [ 3 ]
			$VERFV = $RET [ 1 ] [ 4 ]
			$VERIN = $RET [ 1 ] [ 5 ]
			$VERCR = $RET [ 1 ] [ 6 ]
			$VERON = $RET [ 1 ] [ 8 ]
			$VERPN = $RET [ 1 ] [ 9 ]
			$VERPV = $RET [ 1 ] [ 10 ]
		EndIf
		$OWNER = _CHECKSIG ( $FILEP1 , 1 )
		If Not @error And $OWNER Then $VERCN = $OWNER & " -> " & $VERCN
		$CATP = _CHECKSIG ( $FILEP1 , 2 )
		If _REPARSEPOINT ( $FILEP1 ) Then
			$FILEP2 = _GETREPARSETARGET ( $FILEP1 )
			$FILEP1 = $FILEP1 & " [symlink -> " & $FILEP2 & "]"
		EndIf
		If $CATP Then $FILEP1 = $FILEP1 & @CRLF & "Catalog: " & $CATP
		FileWrite ( $HFIXLOG , $FILEP1 & @CRLF & $FILESI & "MD5: " & $HASH & @CRLF & $CREAMOD & ": " & $DATECR & " - " & $DATEMO & @CRLF & $SZ0 & ": " & $SIZES & @CRLF & $ATT0 & ": " & $ATTS & @CRLF & $COMP0 & ": " & $VERCN & @CRLF & $INT0 & " " & $NAME0 & ": " & $VERIN & @CRLF & $OR0 & " " & $NAME0 & ": " & $VERON & @CRLF & $PROD0 & ": " & $VERPN & @CRLF & $DES0 & ": " & $VERDES & @CRLF & $FIL0 & " " & $SCAN0 & ": " & $VERFV & @CRLF & $PROD0 & " " & $SCAN0 & ": " & $VERPV & @CRLF & $COPR0 & ": " & $VERCR & @CRLF & "Virusscan: " & $JOT & @CRLF & @CRLF )
	Next
	FileWrite ( $HFIXLOG , "====== " & $END & " " & $OF & " File: ======" & @CRLF & @CRLF )
EndFunc
Func FILEACC ( $FPATH = $FILE )
	If _CREATEFILE ( $FPATH ) Then Return " <==== " & $UPD1 & " (" & $NOACC & ")"
	If _CREATEFILE ( StringRegExpReplace ( $FPATH , "(.+)\\.+" , "$1" ) ) Then Return " <==== " & $UPD1 & " (" & $NOACC & ")"
	If CHKFILE ( $FPATH , 2147483648 ) = 32 Then Return " <==== " & $UPD1 & " (" & $INUSE & ")"
	If _REPARSEPOINT ( $FPATH ) Then
		$FPATH = _GETREPARSETARGET ( $FPATH )
		Return " [symlink -> " & $FPATH & "]"
	EndIf
	Return " <==== " & $UPD1 & " (" & $ZBYTE & " " & $FDIR & ")"
EndFunc
Func FILEACCN ( $PATH )
	$RET = _GETSECDES ( $PATH )
	If StringInStr ( $RET , "(D;" ) Or Not StringRegExp ( $RET , "(?i)A;.*?(GA|FA);;;BA|\(A;;FA;;;WD\)" ) Then Return True
EndFunc
Func FILEFOLDER ( )
	GUICtrlSetData ( $LABEL1 , $SCANB & " " & $FIL1 & ": " )
	Global $ARRAY1C [ 1 ] = [ @CRLF ] , $ARRAY1M [ 1 ] = [ @CRLF ] , $ADS000 [ 1 ] = [ @CRLF ] , $UNSIG [ 1 ] , $LOCKED [ 1 ]
	FileClose ( $FRSTLOG )
	$FRSTLOG = FileOpen ( @ScriptDir & "\FRST.txt" , 256 + 1 )
	$USERSDIR = StringRegExpReplace ( @UserProfileDir , "(?i)(.+)\\.+" , "$1" )
	If $BOOTM = "recovery" Then $USERSDIR = $C & "\users"
	Local $DIRS [ ] = [ $C , $SYSTEMDIR , $PROGRAMFILES , $PROGRAMFILES86 , $WINDOWSDIR , $WINDOWSDIR86 , $SYSTEMDIR & "\config" , $SYSTEMDIR & "\Drivers" , $WINDOWSDIR86 & "\Drivers" , $SYSTEMDIR & "\Drivers\etc" , $WINDOWSDIR & "\Tasks" , $SYSTEMDIR & "\Tasks" , $WINDOWSDIR & "\Minidump" , $USERSDIR , $PROGRAMFILES & "\Common Files" , $WINDOWSDIR & "\Profiles" , $SYSTEMDIR & "\spool\prtprocs\x64" , $SYSTEMDIR & "\spool\prtprocs\w32x86" ]
	For $F = 0 To UBound ( $DIRS ) + 4294967295
		GETFILELIST ( $DIRS [ $F ] )
	Next
	If $BOOTM <> "Recovery" Then
		$USERPROFILE = StringRegExpReplace ( FileGetLongName ( @UserProfileDir ) , "\\" , "\\\\" )
		$STARTUPMENUFULL = FileGetLongName ( @StartMenuDir )
		$STARTUPMENU = StringRegExpReplace ( $STARTUPMENUFULL , $USERPROFILE & "(\\.+)" , "$1" )
		$DOCUMENTSFULL = FileGetLongName ( @MyDocumentsDir )
		$DOCUMENTS = StringRegExpReplace ( $DOCUMENTSFULL , $USERPROFILE & "(\\.+)" , "$1" )
		$APPDATAFULL = FileGetLongName ( @AppDataDir )
		$APPDATA = StringRegExpReplace ( $APPDATAFULL , $USERPROFILE & "(\\.+)" , "$1" )
		$LOCALFULL = FileGetLongName ( @LocalAppDataDir )
		$LOCAL = StringRegExpReplace ( $LOCALFULL , $USERPROFILE & "(\\.+)" , "$1" )
		$DESKTOPFULL = FileGetLongName ( @DesktopDir )
		$DESKTOP = StringRegExpReplace ( $DESKTOPFULL , $USERPROFILE & "(\\.+)" , "$1" )
		$PROGRAMDIRFULL = FileGetLongName ( @ProgramsDir )
		$PROGRAMSDIR = StringRegExpReplace ( $PROGRAMDIRFULL , $USERPROFILE & "(\\.+)" , "$1" )
	EndIf
	For $P = 1 To UBound ( $ALLUSERS ) + 4294967295
		$FOLDER = $ALLUSERS [ $P ]
		If $BOOTM <> "Recovery" And StringRegExp ( $ALLUSERS [ $P ] , "(?i)\\ProgramData$" ) Then $FOLDER = @AppDataCommonDir
		GETFILELIST ( $FOLDER )
		$FOLDER = $ALLUSERS [ $P ] & "\Desktop"
		If $BOOTM <> "Recovery" Then $FOLDER = $ALLUSERS [ $P ] & $DESKTOP
		GETFILELIST ( $FOLDER )
		GETFILELIST ( $ALLUSERS [ $P ] & "\Downloads" )
		GETFILELIST ( $ALLUSERS [ $P ] & "\AppData" )
		$FOLDER = $ALLUSERS [ $P ] & "\AppData\Roaming"
		If $BOOTM <> "Recovery" Then
			$FOLDER = $ALLUSERS [ $P ] & $APPDATA
			If StringRegExp ( $ALLUSERS [ $P ] , "(?i)\\All Users$" ) Then $FOLDER = @AppDataCommonDir
		EndIf
		GETFILELIST ( $FOLDER )
		GETFILELIST ( $ALLUSERS [ $P ] & "\AppData\Roaming\Microsoft" )
		$FOLDER = $ALLUSERS [ $P ] & "\AppData\Local"
		If $BOOTM <> "Recovery" Then $FOLDER = $ALLUSERS [ $P ] & $LOCAL
		GETFILELIST ( $FOLDER )
		GETFILELIST ( $ALLUSERS [ $P ] & "\AppData\LocalLow" )
		GETFILELIST ( $ALLUSERS [ $P ] & "\AppData\Local\Apps" )
		$FOLDER = $ALLUSERS [ $P ] & "\Documents"
		If $BOOTM <> "Recovery" Then
			$FOLDER = $ALLUSERS [ $P ] & $DOCUMENTS
			If StringInStr ( $ALLUSERS [ $P ] , "\\All Users$" ) Then $FOLDER = @DocumentsCommonDir
		EndIf
		GETFILELIST ( $FOLDER )
		If $BOOTM <> "Recovery" Then
			$FOLDER = $ALLUSERS [ $P ] & $STARTUPMENU
			If StringRegExp ( $ALLUSERS [ $P ] , "(?i)\\(All Users|ProgramData)$" ) Then $FOLDER = @StartMenuCommonDir
			GETFILELIST ( $FOLDER )
		EndIf
		If $BOOTM <> "Recovery" Then
			$FOLDER = $ALLUSERS [ $P ] & $PROGRAMSDIR
			If StringRegExp ( $ALLUSERS [ $P ] , "(?i)\\(All Users|ProgramData)$" ) Then $FOLDER = @ProgramsCommonDir
			GETFILELIST ( $FOLDER )
		EndIf
	Next
	_ARRAYDELETE ( $ARRAY1C , 0 )
	_ARRAYSORT ( $ARRAY1C , 1 )
	$DAYSOLD = $1MONT
	If GUICtrlRead ( $CHECKBOX14 ) = 1 Then $DAYSOLD = $3MONT
	FileWrite ( $FRSTLOG , @CRLF & "==================== " & $DAYSOLD & " (" & $CREATED & ") (" & WL ( $CHECKBOX15 ) & ") =========" & @CRLF )
	FileWrite ( $FRSTLOG , @CRLF & "(" & $FILFOL & ".)" & @CRLF & @CRLF )
	_FILEWRITEFROMARRAY ( $FRSTLOG , $ARRAY1C )
	$ARRAY1C = ""
	_ARRAYDELETE ( $ARRAY1M , 0 )
	_ARRAYSORT ( $ARRAY1M , 1 )
	FileWrite ( $FRSTLOG , @CRLF & "==================== " & $DAYSOLD & " (" & $MODIFIED & ") ==================" & @CRLF )
	FileWrite ( $FRSTLOG , @CRLF & "(" & $FILFOL & ".)" & @CRLF & @CRLF )
	_FILEWRITEFROMARRAY ( $FRSTLOG , $ARRAY1M )
	$ARRAY1M = ""
	$RET = ""
	If $BOOTM <> "recovery" Then $RET = ZBFILESINDIR ( )
	If UBound ( $RET ) > 1 Then
		FileWrite ( $FRSTLOG , @CRLF & "==================== " & $FILESR & " ========" & @CRLF & @CRLF )
		_FILEWRITEFROMARRAY ( $FRSTLOG , $RET , 1 )
	EndIf
	If UBound ( $LOCKED ) > 1 Then
		FileWrite ( $FRSTLOG , @CRLF & "==================== FLock ==============================" & @CRLF & @CRLF )
		_FILEWRITEFROMARRAY ( $FRSTLOG , $LOCKED , 1 )
	EndIf
	If UBound ( $UNSIG ) > 1 Then
		FileWrite ( $FRSTLOG , @CRLF & "==================== SigCheckExt =========================" & @CRLF & @CRLF )
		_FILEWRITEFROMARRAY ( $FRSTLOG , $UNSIG , 1 )
	EndIf
	$FCHECK = ZB ( )
	$APP = StringRegExpReplace ( @AppDataDir , ".:\\" , "" )
	Local $ARRBAD [ ] = [ "ProgramData\steam.jpg" , "Windows\System32\config\systemprofile\AppData\Roaming\Google\Libs\WR64.sys" , $APP & "\Google\Libs\WR64.sys" , "Program Files\Google\Libs\WR64.sys" , "Windows\temp\slqmanagement\assm.exe" , "Windows\msfte.dll" , "Windows\system32\msfte.dll" , "Windows\Microsoft.NET\Framework\VERSION.dll" , "Windows\Microsoft.NET\Framework\ntsync.exe" , "Windows\servicing\MsMpEngs.exe" , "Windows\servicing\Skype.exe" , "Windows\servicing\OneDrive.exe" , "Windows\System32\WinMonitor.exe" , "Windows\System32\libs.exe" , "Program Files\Mozilla Firefox\wtsapi32.dll" , "Program Files\Google\Chrome\Application\wtsapi32.dll" , "Program Files\Google\Chrome\Application\winhttp.dll" , "Program Files\Google\Chrome\Application\winhttp.dll" , "Windows\System\oci.dll" , "Windows\System32\oci.dll" ]
	For $B = 0 To UBound ( $ARRBAD ) + 4294967295
		If FileExists ( $C & "\" & $ARRBAD [ $B ] ) Then _ARRAYADD ( $FCHECK , $C & "\" & $ARRBAD [ $B ] , 0 , "||||" )
	Next
	If FileExists ( "Windows\system32\TSMSISrv.dll" ) And Not StringInStr ( $SVERSION , "Server" ) Then _ARRAYADD ( $FCHECK , $C & "\" & $ARRBAD [ $B ] , 0 , "||||" )
	If FileExists ( $C & "\Program Files\Microsoft sql server" ) Then
		$FARR = _FILELISTTOARRAYREC ( $C & "\Program Files\Microsoft sql server" , "mssql*" , 0 , 0 , 0 , 2 )
		For $A = 1 To UBound ( $FARR ) + 4294967295
			If FileExists ( $FARR [ $A ] & "\mssql\data\sqlmanagement\assm.exe" ) Then _ARRAYADD ( $FCHECK , $FARR [ $A ] & "\mssql\data\sqlmanagement\assm.exe" , 0 , "||||" )
		Next
	EndIf
	If UBound ( $FCHECK ) > 1 Then
		FileWrite ( $FRSTLOG , @CRLF & "==================== FCheck ================================" & @CRLF & @CRLF & "(" & $FILFOL & ".)" & @CRLF & @CRLF )
		For $B = 1 To UBound ( $FCHECK ) + 4294967295
			If StringInStr ( $FCHECK [ $B ] , "<=" ) Then
				FileWrite ( $FRSTLOG , "FCheck: " & $FCHECK [ $B ] & @CRLF )
			Else
				FileWrite ( $FRSTLOG , "FCheck: " & $FCHECK [ $B ] & " [" & FILETIMECM ( $FCHECK [ $B ] ) & "] <==== " & $UPD1 & @CRLF )
			EndIf
		Next
	EndIf
EndFunc
Func FILENAMEONLY ( $FILENAME , $WORDIR = "" )
	Local $PATHU
	If Not StringInStr ( $FILENAME , "." ) Then $FILENAME = $FILENAME & ".exe"
	$PATH = RegRead ( "HKLM\" & $SOFTWARE & "\Microsoft\Windows\CurrentVersion\App Paths\" & $FILENAME , "" )
	If Not @error Then $PATH = StringRegExpReplace ( $PATH , "(.+)\\.+" , "$1" )
	If $BOOTM = "Recovery" Then
		$PATHARRAY = RegRead ( "HKLM\" & $SYSTEM & $BOOTSYSTEM & $DEF & "\Control\Session Manager\Environment" , "path" )
	Else
		$PATHU = RegRead ( "HKCU\" & $SOFTWARE & "\Microsoft\Windows\CurrentVersion\App Paths\" & $FILENAME , "" )
		If Not @error Then $PATHU = StringRegExpReplace ( $PATHU , "(.+)\\.+" , "$1" )
		$PATHARRAY = EnvGet ( "path" )
	EndIf
	$PATHARRAY = StringRegExpReplace ( $PATHARRAY , ";+$|\s+$" , "" )
	$PATHARRAY = StringSplit ( $PATHARRAY , ";" )
	If $PATH Then _ARRAYINSERT ( $PATHARRAY , 1 , $PATH )
	If $PATHU Then _ARRAYINSERT ( $PATHARRAY , 1 , $PATHU )
	If $WORDIR Then _ARRAYINSERT ( $PATHARRAY , 1 , $WORDIR )
	For $I = 1 To UBound ( $PATHARRAY ) + 4294967295
		$PATH1 = StringRegExpReplace ( $PATHARRAY [ $I ] , "(?i)%Systemroot%" , $C & "\\Windows" )
		If FileExists ( $PATH1 & "\" & $FILENAME ) Then
			$FILE = $PATH1 & "\" & $FILENAME
			ExitLoop
		EndIf
	Next
	If Not FileExists ( $FILE ) Then
		$FILENAME = $C & "\Windows\SysWOW64\" & $FILENAME
		If FileExists ( $FILENAME ) Then $FILE = $FILENAME
	EndIf
EndFunc
Func FILENAMEONLY86 ( $FILENAME , $WORDIR = "" )
	Local $PATHU
	If Not StringInStr ( $FILENAME , "." ) Then $FILENAME = $FILENAME & ".exe"
	$PATH = RegRead ( "HKLM\" & $SOFTWARE & "\Microsoft\Windows\CurrentVersion\App Paths\" & $FILENAME , "" )
	If Not @error Then $PATH = StringRegExpReplace ( $PATH , "(.+)\\.+" , "$1" )
	If $BOOTM = "Recovery" Then
		$PATHARRAY = RegRead ( "HKLM\" & $SYSTEM & $BOOTSYSTEM & $DEF & "\Control\Session Manager\Environment" , "path" )
	Else
		$PATHU = RegRead ( "HKCU\" & $SOFTWARE & "\Microsoft\Windows\CurrentVersion\App Paths\" & $FILENAME , "" )
		If Not @error Then $PATHU = StringRegExpReplace ( $PATHU , "(.+)\\.+" , "$1" )
		$PATHARRAY = EnvGet ( "path" )
	EndIf
	$PATHARRAY = StringRegExpReplace ( $PATHARRAY , ";+$|\s+$" , "" )
	$PATHARRAY = StringSplit ( $PATHARRAY , ";" )
	If $PATH Then _ARRAYINSERT ( $PATHARRAY , 1 , $PATH )
	If $PATHU Then _ARRAYINSERT ( $PATHARRAY , 1 , $PATHU )
	If $WORDIR Then _ARRAYINSERT ( $PATHARRAY , 1 , $WORDIR )
	For $I = 1 To UBound ( $PATHARRAY ) + 4294967295
		$PATH1 = StringRegExpReplace ( $PATHARRAY [ $I ] , "(?i)%Systemroot%\\system32$|" & $C & "\\Windows\\system32$" , $C & "\\Windows\\SysWOW64" )
		$PATH1 = StringRegExpReplace ( $PATH1 , "(?i)%Systemroot%$|" & $C & "\\Windows$" , $C & "\\Windows\\SysWOW64" )
		If FileExists ( $PATH1 & "\" & $FILENAME ) Then
			$FILE = $PATH1 & "\" & $FILENAME
			ExitLoop
		EndIf
	Next
	If Not FileExists ( $FILE ) Then
		$FILENAME = $C & "\Windows\SysWOW64\" & $FILENAME
		If FileExists ( $FILENAME ) Then $FILE = $FILENAME
	EndIf
EndFunc
Func FILESEARCH ( $RET )
	$RET = StringRegExpReplace ( $RET , "\|" , "" )
	$ARRAY = _FILELISTTOARRAYREC ( $C , $RET , 1 + 16 , 1 , 0 , 2 )
	If IsArray ( $ARRAY ) Then FILESEARCHLOG ( $ARRAY )
	If $BOOTM = "Recovery" Then
		$ARRAY = _FILELISTTOARRAYREC ( "X:" , $RET , 1 , 1 , 0 , 2 )
		If IsArray ( $ARRAY ) Then FILESEARCHLOG ( $ARRAY )
	EndIf
EndFunc
Func FILESEARCHALL ( )
	$VAL = StringRegExpReplace ( $FIX , "(?i)SearchAll:\s*(.+)\R*" , "$1" )
	$VAL = StringRegExpReplace ( $VAL , "\*|\?" , "" )
	$VAL = StringRegExpReplace ( $VAL , "(;\s*)+" , ";" )
	$VAL = StringRegExpReplace ( $VAL , "^;|;$" , "" )
	$SVAL = StringRegExpReplace ( $VAL , ";" , "*;*" )
	$SVAL = StringRegExpReplace ( $SVAL , "\|" , "" )
	$SVAL = "*" & $SVAL & "*"
	$ARRAY = _FILELISTTOARRAYREC ( $C , $SVAL , 1 + 16 , 1 , 0 , 2 )
	FileWrite ( @ScriptDir & "\Search.txt" , $FIL0 & ":" & @CRLF & "========" & @CRLF )
	If UBound ( $ARRAY ) > 1 Then
		FILESEARCHLOG ( $ARRAY )
	EndIf
	FileWrite ( @ScriptDir & "\Search.txt" , @CRLF & $FOL0 & ":" & @CRLF & "========" & @CRLF )
	FILESEARCHFOL ( $SVAL )
	$OSERACH = FileOpen ( @ScriptDir & "\Search.txt" , 256 + 1 )
	FileWrite ( $OSERACH , @CRLF & $REGB & ":" & @CRLF & "========" & @CRLF )
	$REGREAD = SEARCHREGE ( $VAL )
	If StringInStr ( $VAL , ";" ) Then
		$REGREAD = StringRegExpReplace ( $REGREAD , "(?m)^\[HK" , "[[[[[HK" )
		$REGREAD = $REGREAD & "[[[["
		$ARR = StringSplit ( $VAL , ";" , 2 )
		For $I = 0 To UBound ( $ARR ) + 4294967295
			FileWrite ( $OSERACH , @CRLF & "===================== " & $SEARCH4 & " """ & $ARR [ $I ] & """ ==========" & @CRLF & @CRLF )
			$REGEXSERCH = StringRegExp ( $REGREAD , "(?is)(\[hk(?:.(?!\[hk))+?" & $ARR [ $I ] & ".+?)(?:\[\[\[\[)" , 3 )
			If IsArray ( $REGEXSERCH ) Then
				_FILEWRITEFROMARRAY ( $OSERACH , $REGEXSERCH )
			EndIf
		Next
	Else
		FileWrite ( $OSERACH , $REGREAD & @CRLF )
	EndIf
	FileClose ( $OSERACH )
EndFunc
Func FILESEARCHFOL ( $VAL )
	$OSERACH = FileOpen ( @ScriptDir & "\Search.txt" , 256 + 1 )
	$ARRAY = _FILELISTTOARRAYREC ( $C , $VAL , 2 + 16 , 1 , 0 , 2 )
	For $I = 1 To UBound ( $ARRAY ) + 4294967295
		$DATECR = FILETIME ( $ARRAY [ $I ] , 1 )
		$DATEMO = FILETIME ( $ARRAY [ $I ] )
		$FATT = FileGetAttrib ( $ARRAY [ $I ] )
		$FATT = StringRegExpReplace ( $FATT , "D" , "" )
		If _REPARSEPOINT ( $ARRAY [ $I ] ) Then $FATT = $FATT & "L"
		$ATT = StringFormat ( "%05s" , $FATT )
		$ATTS = StringRegExpReplace ( $ATT , "0" , "_" )
		FileWrite ( $OSERACH , $DATECR & " - " & $DATEMO & " " & $ATTS & " " & $ARRAY [ $I ] & @CRLF )
	Next
	FileClose ( $OSERACH )
EndFunc
Func FILESEARCHLOG ( $SARRAY )
	$OSERACH1 = FileOpen ( @ScriptDir & "\Search.txt" , 256 + 1 )
	For $S = 1 To UBound ( $SARRAY ) + 4294967295
		$FATT = FileGetAttrib ( $SARRAY [ $S ] )
		$FATT = StringRegExpReplace ( $FATT , "A" , "" )
		If _REPARSEPOINT ( $SARRAY [ $S ] ) Then $FATT = $FATT & "L"
		$ATT = StringFormat ( "%05s" , $FATT )
		$ATTS = StringRegExpReplace ( $ATT , "0" , "_" )
		$SIZE = FileGetSize ( $SARRAY [ $S ] )
		$SIZES = StringFormat ( "%09u" , $SIZE )
		$HASH = MD5 ( $SARRAY [ $S ] )
		$DATECR = FILETIME ( $SARRAY [ $S ] , 1 )
		$DATEMO = FILETIME ( $SARRAY [ $S ] )
		$VER = FileGetVersion ( $SARRAY [ $S ] , "CompanyName" )
		$VER = StringRegExpReplace ( $VER , "\s+" , " " )
		$ATTEN = ""
		If $CRYPT Then
			If _CHECKSIG ( $SARRAY [ $S ] ) = 11 Then
				$ATTEN = " [" & $FILESIG & "]"
			Else
				$ATTEN = " [" & $FILENS & "]"
				If _CREATEFILE ( $SARRAY [ $S ] ) Then
					$ATTEN = " [" & $NOACC & "]"
				Else
					If CHKFILE ( $SARRAY [ $S ] , 2147483648 ) = 32 Then $ATTEN = " [" & $INUSE & "]"
				EndIf
			EndIf
		EndIf
		FileWrite ( $OSERACH1 , $SARRAY [ $S ] & @CRLF & "[" & $DATECR & "][" & $DATEMO & "] " & $SIZES & " " & $ATTS & " (" & $VER & ") " & $HASH & $ATTEN & @CRLF & @CRLF )
	Next
	FileClose ( $OSERACH1 )
EndFunc
Func FILESINDIRCTORY ( )
	FileWrite ( $HFIXLOG , @CRLF & "========================= " & $FIX & " ========================" & @CRLF & @CRLF )
	$FIX = StringRegExpReplace ( $FIX , """" , "" )
	$FOLDER = StringRegExpReplace ( $FIX , "(?i)Filesindirectory:\s*(.+)\\.+" , "$1" )
	GUICtrlSetData ( $LABEL1 , $SCANB & " " & $FIL1 & ": " & $FOLDER )
	If Not FileExists ( $FOLDER ) Then NFOUND ( $FOLDER )
	$PATTERN = StringRegExpReplace ( $FIX , "(?i).+\\(.+)" , "$1" )
	$PATTERN = StringRegExpReplace ( $PATTERN , "\|" , "" )
	$FARR = _FILELISTTOARRAYREC ( $FOLDER , $PATTERN , 1 + 16 , 0 , 0 , 2 )
	For $F = 1 To UBound ( $FARR ) + 4294967295
		If @error Then ExitLoop
		$FILEATT = FileGetAttrib ( $FARR [ $F ] )
		If _REPARSEPOINT ( $FARR [ $F ] ) Then $FILEATT = $FILEATT & "L"
		$ATT = StringFormat ( "%05s" , $FILEATT )
		$ATTS = StringRegExpReplace ( $ATT , "0" , "_" )
		$SIZE = FileGetSize ( $FARR [ $F ] )
		$SIZES = StringFormat ( "%09u" , $SIZE )
		$DATECR = FILETIME ( $FARR [ $F ] , 1 )
		$DATEMO = FILETIME ( $FARR [ $F ] )
		If _CREATEFILE ( $FARR [ $F ] ) Then
			$VER = $NOACC
		Else
			$VER = FileGetVersion ( $FARR [ $F ] , "CompanyName" )
		EndIf
		$VER = StringRegExpReplace ( $VER , "\s+" , " " )
		$HASH = MD5 ( $FARR [ $F ] )
		If StringRegExp ( $FARR [ $F ] , "(?i)\.(dll|exe|sys|mui)$" ) Then
			COMP ( $FARR [ $F ] )
		Else
			$COMPANY = " (" & $VER & ")"
		EndIf
		FileWrite ( $HFIXLOG , $DATECR & " - " & $DATEMO & " - " & $SIZES & " " & $ATTS & " [" & $HASH & "]" & $COMPANY & " " & $FARR [ $F ] & @CRLF )
	Next
	FileWrite ( $HFIXLOG , @CRLF & "====== " & $END & " " & $OF & " Filesindirectory ======" & @CRLF )
EndFunc
Func FILETIME ( $PATH , $CC = 0 )
	$PATH = StringRegExpReplace ( $PATH , "\\\\(?!\?\\)" , "\\" )
	If Not StringInStr ( $PATH , "\\?\" ) Then $PATH = "\\?\" & $PATH
	If $CC Then
		$D = FileGetTime ( $PATH , 1 )
	Else
		$D = FileGetTime ( $PATH )
	EndIf
	If Not IsArray ( $D ) Then Return FILETIME1 ( $PATH , $CC )
	Return $D [ 0 ] & "-" & $D [ 1 ] & "-" & $D [ 2 ] & " " & $D [ 3 ] & ":" & $D [ 4 ]
EndFunc
Func FILETIME1 ( $PATH1 , $CC = 0 )
	$PATH1 = StringRegExpReplace ( $PATH1 , "\\\\(?!\?\\)" , "\\" )
	If Not StringInStr ( $PATH1 , "\\?\" ) Then $PATH1 = "\\?\" & $PATH1
	$HFILE = CREATEFILE ( $PATH1 )
	If @error Or Not $HFILE Then Return ""
	Local $RET = _DATE_TIME_GETFILETIME ( $HFILE )
	CLOSEHANDLE ( $HFILE )
	If Not IsArray ( $RET ) Then Return "0000-00-00 00:00"
	If $CC Then
		$T = _DATE_TIME_FILETIMETOSTR ( $RET [ 0 ] )
	Else
		$T = _DATE_TIME_FILETIMETOSTR ( $RET [ 2 ] )
	EndIf
	Return StringRegExpReplace ( $T , "(\d+)/(\d+)/(\d+) (\d+:\d+):.+" , "$3-$1-$2 $4" )
EndFunc
Func FILETIMECM ( $PATH , $1 = 0 )
	$HFILE = CREATEFILE ( $PATH )
	If @error Or Not $HFILE Then Return
	Local $RET = _DATE_TIME_GETFILETIME ( $HFILE )
	CLOSEHANDLE ( $HFILE )
	If Not IsArray ( $RET ) Then Return "0000-00-00"
	If $1 Then
		$T = _DATE_TIME_FILETIMETOSTR ( $RET [ 0 ] )
	Else
		$T = _DATE_TIME_FILETIMETOSTR ( $RET [ 2 ] )
	EndIf
	Return StringRegExpReplace ( $T , "(\d+)/(\d+)/(\d+) .*" , "$3-$1-$2" )
EndFunc
Func FILTERFIX ( )
	Local $CLSID , $SKEY , $KEY1
	If StringInStr ( $FIX , "Filter: " ) Then
		$SKEY = StringRegExpReplace ( $FIX , "Filter: ([^\{]+) - .+ - .*" , "$1" )
		$KEY = "HKLM\Software\Classes\PROTOCOLS\Filter\" & $SKEY
		If StringRegExp ( $FIX , "\{.+\}" ) Then
			$CLSID = StringRegExpReplace ( $FIX , "[^\{]+(\{.+\}).*" , "$1" )
			$KEY1 = "HKLM\Software\Classes\CLSID\" & $CLSID
		EndIf
	EndIf
	If StringInStr ( $FIX , "Filter-x32: " ) Then
		$SKEY = StringRegExpReplace ( $FIX , "Filter-x32: ([^\{]+) - .+ - .*" , "$1" )
		$KEY = "HKLM\Software\Wow6432Node\Classes\PROTOCOLS\Filter\" & $SKEY
		If StringRegExp ( $FIX , "\{.+\}" ) Then
			$CLSID = StringRegExpReplace ( $FIX , "[^\{]+(\{.+\}).*" , "$1" )
			$KEY1 = "HKLM\Software\Wow6432Node\Classes\CLSID\" & $CLSID
		EndIf
	EndIf
	DELKEY ( $KEY )
	If VAR ( $KEY1 ) Then DELKEY ( $KEY1 )
EndFunc
Func FINAL0 ( )
	GUICtrlSetData ( $LABEL1 , $SCANB & " Extras..." )
	If $BOOTM = "Recovery" Then PART ( )
	LASTBOOT ( )
	If $BOOTM = "Recovery" Then
		If VAR ( "HKLM\999" ) Then RunWait ( @ComSpec & " /c reg unload hklm\999" , "" , @SW_HIDE )
		If VAR ( "HKLM\999" ) Then
			If Not $RESTOREPRI Then _SETPRIV ( "SeRestorePrivilege" , True )
			If Not $BACKUPPRI Then _SETPRIV ( "SeBackupPrivilege" , True )
			$RET = DllCall ( "Advapi32.dll" , "int" , "RegUnLoadKeyW" , "handle" , 2147483650 , "wstr" , "999" )
			If @error Or $RET [ 0 ] Then FileWrite ( $FRSTLOG , "ErrorUnloadSystem: " & $RET [ 0 ] & @CRLF )
		EndIf
		If VAR ( "HKLM\888" ) Then RunWait ( @ComSpec & " /c reg unload hklm\888" , "" , @SW_HIDE )
		If VAR ( "HKLM\888" ) Then
			$RET = DllCall ( "Advapi32.dll" , "int" , "RegUnLoadKeyW" , "handle" , 2147483650 , "wstr" , "888" )
			If @error Or $RET [ 0 ] Then FileWrite ( $FRSTLOG , "ErrorUnloadSoftware: " & $RET [ 0 ] & @CRLF )
		EndIf
	EndIf
	FileWrite ( $FRSTLOG , "==================== " & $END & " " & $OF & " FRST.txt" & " ========================" )
	FileClose ( $FRSTLOG )
	$CDATE = @MDAY & "-" & @MON & "-" & @YEAR & " " & @HOUR & "." & @MIN & "." & @SEC
	FileCopy ( @ScriptDir & "\FRST.txt" , $C & "\FRST\Logs\FRST_" & $CDATE & ".txt" )
EndFunc
Func FINAL ( )
	GUICtrlSetData ( $LABEL1 , $SCANB & ", " & $PW0 )
	If GUICtrlRead ( $CHECKBOX12 ) = 1 Then PART ( )
	GUICtrlDelete ( $PROGRESS )
	GUICtrlSetData ( $BUTTONSCAN , $SCAN )
	GUICtrlSetData ( $LABEL1 , "" )
	If Not $CMD1 Then
		MsgBox ( 262144 + 0 , $FRST , $SCANED & " FRST.txt " & $COMPLETED )
		Run ( "notepad """ & @ScriptDir & "\FRST.txt""" )
	EndIf
	If GUICtrlRead ( $CHECKBOX12 ) = 1 And $BOOTM <> "Recovery" And Not $CMD1 Then
		Sleep ( 1000 )
		MsgBox ( 262144 + 0 , $FRST , "Addition.txt " & $COMPLETED )
		FileClose ( $HADDITION )
		Run ( "notepad """ & @ScriptDir & "\Addition.txt""" )
	EndIf
	If GUICtrlRead ( $CHECKBOX13 ) = 1 And $BOOTM <> "Recovery" And Not $CMD1 Then
		Sleep ( 1000 )
		FileCopy ( @ScriptDir & "\Shortcut.txt" , $C & "\FRST\Logs\Shortcut_" & $CDATE & ".txt" )
		MsgBox ( 262144 + 0 , $FRST , "Shortcut.txt " & $COMPLETED )
		Run ( "notepad """ & @ScriptDir & "\Shortcut.txt""" )
	EndIf
	If $CMD1 Then Exit
EndFunc
Func FINDFOLDER ( )
	GUICtrlSetData ( $LABEL1 , $SEARCH1 & " " & $FOL0 & ", " & $PW0 & "... " )
	$SEARCH = StringRegExpReplace ( $FIX , "(?i)FindFolder:\s*(.+)" , "$1" )
	FileWrite ( $HFIXLOG , "================== FindFolder: """ & $SEARCH & """ ===================" & @CRLF & @CRLF )
	$SEARCH = StringRegExpReplace ( $SEARCH , "\|" , "" )
	$AARRAY = _FILELISTTOARRAYREC ( $C , $SEARCH , 2 , 1 , 0 , 2 )
	If Not IsArray ( $AARRAY ) Then
		FileWrite ( $HFIXLOG , $REGIST8 & @CRLF )
	Else
		For $I = 1 To UBound ( $AARRAY ) + 4294967295
			$DATECR = FILETIME ( $AARRAY [ $I ] , 1 )
			$DATEMO = FILETIME ( $AARRAY [ $I ] )
			$FATT = FileGetAttrib ( $AARRAY [ $I ] )
			$FATT = StringRegExpReplace ( $FATT , "D" , "" )
			If _REPARSEPOINT ( $AARRAY [ $I ] ) Then $FATT = $FATT & "L"
			$ATT = StringFormat ( "%05s" , $FATT )
			$ATTS = StringRegExpReplace ( $ATT , "0" , "_" )
			FileWrite ( $HFIXLOG , $DATECR & " - " & $DATEMO & " " & $ATTS & " " & $AARRAY [ $I ] & @CRLF )
		Next
	EndIf
	FileWrite ( $HFIXLOG , @CRLF & "=== " & $END & " " & $OF & " FindFolder ===" & @CRLF )
	GUICtrlSetData ( $LABEL1 , $FIX1 & " " & $PW0 )
EndFunc
Func FIREFOX ( )
	Global $FFARR [ 1 ]
	GUICtrlSetData ( $LABEL1 , $SCANB & " Firefox: " )
	$PROFS1 = FIREFOXPROFS ( )
	If UBound ( $PROFS1 ) > 1 Then FIREFOXPREF ( $PROFS1 )
	FIREFOXEXTENSION ( @ProgramFilesDir & "\Mozilla Firefox\browser\extensions" )
	FIREFOXEXTENSION ( $PROGRAMFILES86 & "\Mozilla Firefox\browser\extensions" )
	FIREFOXEXTENSION ( @ProgramFilesDir & "\Mozilla Firefox\browser\features" )
	FIREFOXEXTENSION ( $PROGRAMFILES86 & "\Mozilla Firefox\browser\features" )
	FIREFOXEXTENSION ( @ProgramFilesDir & "\Mozilla Firefox\distribution\extensions" )
	FIREFOXEXTENSION ( $PROGRAMFILES86 & "\Mozilla Firefox\distribution\extensions" )
	FIREFOXEXTENSIONREG ( "HKLM" , "Software" )
	FIREFOXEXTENSIONREG ( "HKLM" , "Software\Wow6432Node" )
	For $U = 1 To UBound ( $USERREG ) + 4294967295
		FIREFOXEXTENSIONREG ( "HKU" , "Software" , $USERREG [ $U ] )
	Next
	FIREFOXPLUGINS ( "Plugin" )
	FIREFOXPLUGINS ( "Plugin-x32" )
	For $U = 1 To UBound ( $USERREG ) + 4294967295
		$KEY1 = "HKU\" & $USERREG [ $U ] & "\Software\MozillaPlugins"
		$HKEY = _REGOPENKEYEX3 ( $KEY1 )
		If Not @error And IsPtr ( $HKEY ) Then
			$I = 0
			While 1
				$REGEX = __REGENUMKEY ( $HKEY , $I )
				If @error Then ExitLoop
				$PATH = RegRead ( $KEY1 & "\" & $REGEX , "path" )
				If Not @error Then
					If FileExists ( $PATH ) Then
						COMP ( $PATH )
						$CDATE = " [" & $CDATE & "]"
					Else
						$COMPANY = " [" & $REGIST8 & "]"
						$CDATE = ""
					EndIf
					_ARRAYADD ( $FFARR , "FF Plugin HKU\" & $USERREG [ $U ] & ": " & $REGEX & " -> " & $PATH & $CDATE & $COMPANY , 0 , "||||" )
				EndIf
				$I += 1
			WEnd
		EndIf
	Next
	FIREFOXPLUGIN ( @ProgramFilesDir & "\mozilla firefox\browser\plugins" )
	FIREFOXPLUGIN ( $PROGRAMFILES86 & "\mozilla firefox\browser\plugins" )
	FIREFOXPLUGIN ( @AppDataDir & "\mozilla\plugins" )
	Local $STARTMENUINTERNETFF [ 1 ] = [ 0 ]
	$HKEY = _REGOPENKEYEX3 ( "HKLM\SOFTWARE\Clients\StartMenuInternet" , 1 )
	$P = 0
	While 1
		$OPERABRO = __REGENUMKEY ( $HKEY , $P )
		If @error Then ExitLoop
		If StringInStr ( $OPERABRO , "FIREFOX" ) Then
			$BROWSER = $OPERABRO
			BROWSERSTART ( $BROWSER , $STARTMENUINTERNETFF , "HKLM" )
		EndIf
		$P += 1
	WEnd
	If UBound ( $STARTMENUINTERNETFF ) > 1 Then
		$STARTMENUINTERNETFF [ 1 ] = StringRegExpReplace ( $STARTMENUINTERNETFF [ 1 ] , "(?i)http(s|):" , "hxxp\1:" )
		_ARRAYADD ( $FFARR , $STARTMENUINTERNETFF [ 1 ] , 0 , "||||" )
	EndIf
	If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
	FIREFOXEXT_JS ( @ProgramFilesDir & "\mozilla firefox\defaults\pref" )
	FIREFOXEXT_JS ( $PROGRAMFILES86 & "\mozilla firefox\defaults\pref" )
	FIREFOXEXT_JS ( @ProgramFilesDir & "\mozilla firefox\browser\defaults\preferences" )
	FIREFOXEXT_JS ( $PROGRAMFILES86 & "\mozilla firefox\browser\defaults\preferences" )
	FIREFOXEXT_PROG ( @ProgramFilesDir )
	FIREFOXEXT_PROG ( $PROGRAMFILES86 )
	If UBound ( $FFARR ) < 2 Then Return
	FileClose ( $FRSTLOG )
	$FRSTLOG = FileOpen ( @ScriptDir & "\FRST.txt" , 256 + 1 )
	FileWrite ( $FRSTLOG , @CRLF & "FireFox:" & @CRLF & "========" & @CRLF )
	$FFARR = _ARRAYUNIQUE ( $FFARR , 0 , 0 , 0 , 0 , 1 )
	For $F = 1 To UBound ( $FFARR ) + 4294967295
		$COMP = StringRegExpReplace ( $FFARR [ $F ] , "(?i)http(s|):" , "hxxp\1:" )
		FileWrite ( $FRSTLOG , $COMP & @CRLF )
	Next
	$FFARR = ""
EndFunc
Func FIREFOXEXT_JS ( $PATH )
	$FILESARR = _FILELISTTOARRAYREC ( $PATH , "*.js" , 1 , 0 , 0 , 1 )
	For $E = 1 To UBound ( $FILESARR ) + 4294967295
		$ATT = ""
		$FPATH = $PATH & "\" & $FILESARR [ $E ]
		$DATECR = FILETIMECM ( $FPATH )
		$REGEXREAD = FileRead ( $FPATH )
		If StringRegExp ( $REGEXREAD , "(?i)filename.+cfg'" ) Or StringRegExp ( $REGEXREAD , "(?i)filename.+cfg""" ) Then $ATT = " <==== " & $UPD1 & " (" & $FF2 & ")"
		If StringRegExp ( $FILESARR [ $E ] , "(?i)^!\w{20,}|secure_cert" ) Then $ATT = " <==== " & $UPD1
		If GUICtrlRead ( $CHECKBOX11 ) = 4 Then
			_ARRAYADD ( $FFARR , "FF ExtraCheck: " & $FPATH & " [" & $DATECR & "]" & $ATT , 0 , "||||" )
		Else
			If $FILESARR [ $E ] <> "channel-prefs.js" Then _ARRAYADD ( $FFARR , "FF ExtraCheck: " & $FPATH & " [" & $DATECR & "]" & $ATT , 0 , "||||" )
		EndIf
	Next
EndFunc
Func FIREFOXEXT_PROG ( $PATH )
	If Not FileExists ( $PATH ) Then Return 1
	$FILESARR = _FILELISTTOARRAYREC ( $PATH & "\mozilla firefox" , "*" , 1 , 0 , 0 , 2 )
	For $F = 1 To UBound ( $FILESARR ) + 4294967295
		If StringRegExp ( $FILESARR [ $F ] , "(?i).+\\(.*?cfg|\w{30,})$" ) Then
			$DATEMO = FILETIMECM ( $FILESARR [ $F ] )
			_ARRAYADD ( $FFARR , "FF ExtraCheck: " & $FILESARR [ $F ] & " [" & $DATEMO & "]" & " <==== " & $UPD1 , 0 , "||||" )
		EndIf
	Next
EndFunc
Func FIREFOXEXTENSION ( $FOLDER )
	If Not FileExists ( $FOLDER ) Then Return
	GUICtrlSetData ( $LABEL1 , $SCANB & " Firefox: Extensions" )
	$FILEARRAY = _FILELISTTOARRAYREC ( $FOLDER , "*|staged;staged-xpis;trash" , 0 , 0 , 0 , 2 )
	For $EX = 1 To UBound ( $FILEARRAY ) + 4294967295
		If StringInStr ( FileGetAttrib ( $FILEARRAY [ $EX ] ) , "D" ) Then
			FIREFOXEXTENSIONFOL ( $FILEARRAY [ $EX ] )
		Else
			If StringInStr ( $FILEARRAY [ $EX ] , ".xpi" ) Then FIREFOXEXTENSIONFILE ( $FILEARRAY [ $EX ] , $EX & Random ( 100 , 999 , 1 ) & Random ( 100 , 999 , 1 ) )
		EndIf
	Next
EndFunc
Func FIREFOXEXTENSIONFILE ( $PATH , $COUNT )
	If GUICtrlRead ( $CHECKBOX11 ) = 1 Then
		If StringRegExp ( $PATH , "(?i)features\\\{.+?\}\\((disable-(prefetch|cert-transparency|crash-autosubmit|js-shared-memory|media-wmf-nv12)|webcompat(|-reporter)|tls13-(|version-fallback-)rollout-bug\d+|timecop|activity-stream|onboarding|clicktoplay-rollout|tls13-middlebox.*|tls13-compat-ff51|tls13-comparison-all-v1|followonsearch|shield-recipe-client|screenshots|disableSHA1rollout|flyweb|asyncrendering|d3d9fallback|outofdate-notifications|aushelper|e10srollout|loop|websensehelper|formautofill|diagnostics|hsts-priming|fxmonitor|baidu-code-update|reset-search-defaults|doh-rollout|pictureinpicture|addons-(restricted-domains|search-detection)|proxy-failover)@(mozilla|mozillaonline)\.(org|com)\.xpi|firefox@getpocket.com.xpi)" ) Or StringRegExp ( $PATH , "(?i)\\Program Files(| \(x86\))\\Mozilla Firefox\\browser\\features\\((disable-(prefetch|cert-transparency|crash-autosubmit|js-shared-memory|media-wmf-nv12)|webcompat(|-reporter)|tls13-(|version-fallback-)rollout-bug\d+|timecop|activity-stream|onboarding|followonsearch|clicktoplay-rollout|shield-recipe-client|screenshots|asyncrendering|d3d9fallback|outofdate-notifications|aushelper|e10srollout|loop|websensehelper|formautofill|flyweb|fxmonitor|baidu-code-update|reset-search-defaults|doh-rollout|pictureinpicture|addons-(restricted-domains|search-detection)|proxy-failover)@(mozilla|mozillaonline).(org|com).xpi|firefox@getpocket.com.xpi)" ) Then Return
	EndIf
	Local $SIG , $LEG , $UPURL
	$REGEX1 = $FF1
	$DATECR = FILETIMECM ( $PATH )
	FileDelete ( @TempDir & "\" & $COUNT & "tmp000.zip" )
	FileCopy ( $PATH , @TempDir & "\" & $COUNT & "tmp000.zip" , 1 + 8 )
	$HINSTALL = FileOpen ( @TempDir & "\install" & $COUNT , 2 + 256 )
	$RET = UNZIP_SAVEFILETOFILEONCE ( @TempDir & "\" & $COUNT & "tmp000.zip" , "install.rdf" , "" )
	If $RET Then
		FileWrite ( $HINSTALL , $RET )
		$REGEX1 = FIREFOXEXTENSIONNAME ( @TempDir & "\install" & $COUNT )
		$LEG = " [" & $LEGACY & "]"
	Else
		$RET = UNZIP_SAVEFILETOFILEONCE ( @TempDir & "\" & $COUNT & "tmp000.zip" , "manifest.json" , "" )
		If $RET Then
			FileWrite ( $HINSTALL , $RET )
			$READJ = FileRead ( @TempDir & "\install" & $COUNT )
			$ARRURL = StringRegExp ( $READJ , "(?i)""update_url""\s*:\s*""(.+?)""" , 1 )
			If IsArray ( $ARRURL ) Then $UPURL = " [UpdateUrl:" & $ARRURL [ 0 ] & "]"
			If StringRegExp ( $READJ , "(?i)""name""\s*:\s*""__MSG" ) Then
				$CL = StringRegExp ( $READJ , "(?i)""default_locale"":\s*""(.+?)""" , 1 )
				If IsArray ( $CL ) Then $CL = $CL [ 0 ]
				$CL0 = RegRead ( "HKCU\Control Panel\International" , "LocaleName" )
				If @error Then
					$KEY = "HKLM\SOFTWARE\WOW6432Node\Mozilla"
					$B = 1
					While 1
						$SUB = RegEnumKey ( $KEY , $B )
						If @error Then ExitLoop
						$CL0 = RegRead ( $KEY & "\" & $SUB , "CurrentVersion" )
						If Not @error Then ExitLoop
						$B += 1
					WEnd
				EndIf
				If $CL0 Then
					$CL0 = StringRegExpReplace ( $CL0 , ".+\((.+)\)" , "$1" )
					$CL0 = StringRegExpReplace ( $CL0 , "x\d{2} (.+)" , "$1" )
					$CL0 = StringRegExpReplace ( $CL0 , "-" , "_" )
				EndIf
				$MS = StringRegExp ( $READJ , "(?i)""name"":.*MSG_(.+?)__""" , 1 )
				If IsArray ( $MS ) Then
					$REGEX = UNZIP_SAVEFILETOFILEONCE ( @TempDir & "\" & $COUNT & "tmp000.zip" , "_locales\" & $CL0 & "\messages.json" , "" )
					If Not $REGEX Then
						If StringInStr ( $CL0 , "_" ) Then
							$CL0 = StringRegExpReplace ( $CL0 , "(.+?)_.+" , "$1" )
							$REGEX = UNZIP_SAVEFILETOFILEONCE ( @TempDir & "\" & $COUNT & "tmp000.zip" , "_locales\" & $CL0 & "\messages.json" , "" )
						EndIf
					EndIf
					If Not $REGEX Then $REGEX = UNZIP_SAVEFILETOFILEONCE ( @TempDir & "\" & $COUNT & "tmp000.zip" , "_locales\" & $CL & "\messages.json" , "" )
					$HINST = FileOpen ( @TempDir & "\inst" & $COUNT , 2 + 256 )
					FileWrite ( $HINST , $REGEX )
					$READJL = FileRead ( @TempDir & "\inst" & $COUNT )
					$REGEX = StringRegExp ( $READJL , "(?is)""" & $MS [ 0 ] & """[^}]+?""message"":\s*""(.*?)""" , 1 )
					If IsArray ( $REGEX ) Then
						$REGEX1 = FIREFOXEXTENSIONFILE1 ( $READJL , $MS [ 0 ] , $REGEX [ 0 ] )
					Else
						$REGEX = StringRegExp ( $READJL , "(?is)""" & $MS [ 0 ] & ".+?""message"":\s*""(.*?)""" , 1 )
						If IsArray ( $REGEX ) Then $REGEX1 = FIREFOXEXTENSIONFILE1 ( $READJL , $MS [ 0 ] , $REGEX [ 0 ] )
					EndIf
					FileClose ( $HINST )
					FileDelete ( @TempDir & "\inst" & $COUNT )
				EndIf
			Else
				$READJ = StringRegExpReplace ( $READJ , "(?s)^\s*\{|\s*\}\s*$" , "" )
				$READJ = StringRegExpReplace ( $READJ , "(?s)\{[^{]+?\}" , "" )
				$READJ = StringRegExpReplace ( $READJ , "(?s)\{[^{]+?\}" , "" )
				$REGEX = StringRegExp ( $READJ , "(?i)name""\s*:\s*""(.+?)""" , 3 )
				If IsArray ( $REGEX ) Then $REGEX1 = $REGEX [ 0 ]
			EndIf
			$REGEX1 = CONV ( $REGEX1 )
		EndIf
	EndIf
	If Not UNZIP_SAVEFILETOFILEONCE ( @TempDir & "\" & $COUNT & "tmp000.zip" , "META-INF\mozilla.sf" , "" ) Then $SIG = " [" & $FILENS1 & "]"
	FileClose ( $HINSTALL )
	FileDelete ( @TempDir & "\install" & $COUNT )
	FileDelete ( @TempDir & "\" & $COUNT & "tmp000.zip" )
	If GUICtrlRead ( $CHECKBOX11 ) = 1 Then
		If Not StringInStr ( $PATH , "\Mozilla Firefox\browser\extensions\{972ce4c6-7e08-4474-a285-3208198ce6fd}" ) Then
			_ARRAYADD ( $FFARR , "FF Extension: (" & $REGEX1 & ") - " & $PATH & " [" & $DATECR & "]" & $LEG & $SIG & $UPURL , 0 , "|||" )
		EndIf
	Else
		_ARRAYADD ( $FFARR , "FF Extension: (" & $REGEX1 & ") - " & $PATH & " [" & $DATECR & "]" & $LEG & $SIG & $UPURL , 0 , "|||" )
	EndIf
EndFunc
Func FIREFOXEXTENSIONFILE1 ( $MANIF , $NAME1 , $NAME2 )
	If Not StringRegExp ( $NAME2 , "(?i)\$[^\s]+\$" ) Then Return $NAME2
	$PLH = StringRegExpReplace ( $NAME2 , ".*(\$[^\s]+\$).*" , "$1" )
	$PLH1 = StringRegExpReplace ( $PLH , "\$" , """" )
	$NAME3 = StringRegExpReplace ( $NAME2 , "\$" , "\\$" )
	$REGEX = StringRegExp ( $MANIF , "(?is)""" & $NAME3 & "[^}]+?""placeholders"":" & "[^}]+?" & $PLH1 & "[^}]+?" & """content""\s*:\s*""(.+?)""" , 1 )
	If IsArray ( $REGEX ) Then
		$PLH = StringRegExpReplace ( $PLH , "\$" , "\\$" )
		$NAMEFIN = StringRegExpReplace ( $NAME2 , $PLH , $REGEX [ 0 ] )
		Return $NAMEFIN
	EndIf
EndFunc
Func FIREFOXEXTENSIONFILEFOL ( $EXTENSIONPATH , $COUNT )
	If StringInStr ( FileGetAttrib ( $EXTENSIONPATH ) , "D" ) Then
		FIREFOXEXTENSIONFOL ( $EXTENSIONPATH )
	Else
		If StringInStr ( $EXTENSIONPATH , ".xpi" ) Then FIREFOXEXTENSIONFILE ( $EXTENSIONPATH , $COUNT )
	EndIf
EndFunc
Func FIREFOXEXTENSIONFOL ( $PATH )
	Local $SIG , $LEG , $UPURL
	$DATECR = FILETIMECM ( $PATH )
	If Not FileExists ( $PATH & "\META-INF\mozilla.sf" ) Or Not FileExists ( $PATH & "\META-INF\mozilla.rsa" ) Or Not FileExists ( $PATH & "\META-INF\manifest.mf" ) Then $SIG = " [" & $FILENS1 & "]"
	$REGEX1 = $FF1
	If FileExists ( $PATH & "\install.rdf" ) Then
		$REGEX1 = FIREFOXEXTENSIONNAME ( $PATH & "\install.rdf" )
		$LEG = " [" & $LEGACY & "]"
	Else
		If FileExists ( $PATH & "\manifest.json" ) Then
			$REGEX1 = CHROMEEXNAME ( $PATH )
			$RET = FileRead ( $PATH & "\manifest.json" )
			$ARRURL = StringRegExp ( $RET , "(?i)""update_url""\s*:\s*""(.+?)""" , 1 )
			If IsArray ( $ARRURL ) Then $UPURL = " [" & $ARRURL [ 0 ] & "]"
		EndIf
	EndIf
	If GUICtrlRead ( $CHECKBOX11 ) = 1 Then
		If Not StringInStr ( $PATH , "{972ce4c6-7e08-4474-a285-3208198ce6fd}" ) Then
			_ARRAYADD ( $FFARR , "FF Extension: (" & $REGEX1 & ") - " & $PATH & " [" & $DATECR & "]" & $LEG & $SIG & $UPURL , 0 , "|||" )
		EndIf
	Else
		_ARRAYADD ( $FFARR , "FF Extension: (" & $REGEX1 & ") - " & $PATH & " [" & $DATECR & "]" & $LEG & $SIG & $UPURL , 0 , "|||" )
	EndIf
EndFunc
Func FIREFOXEXTENSIONNAME ( $PATH )
	Local $REGEX
	$REGEX1 = $FF1
	$REGEXREAD = FileRead ( $PATH )
	$LOC = LN ( "0x" & @MUILang )
	$LOC = StringRegExpReplace ( $LOC , "(-|_)" , "." )
	If StringRegExp ( $REGEXREAD , "(?i)name" ) Then $REGEX = StringRegExp ( $REGEXREAD , "(?i)name(?:>|="")(.+?)(?:<|"")" , 3 )
	If IsArray ( $REGEX ) Then $REGEX1 = $REGEX [ 0 ]
	If UBound ( $REGEX ) > 1 Then
		Select
		Case StringRegExp ( $REGEXREAD , "(?is)m:locale(>|="")" & $LOC & "(<|"")/em:locale" )
			$REGEX = StringRegExp ( $REGEXREAD , "(?is)m:locale(?:>|="")" & $LOC & "(?:<|"")/em:locale.+?em:localized" , 1 )
			If IsArray ( $REGEX ) Then
				$REGEX = StringRegExp ( $REGEX [ 0 ] , "em:name(?:>|="")(.+?)(?:<|"")/em:name" , 1 )
				If IsArray ( $REGEX ) Then $REGEX1 = $REGEX [ 0 ]
			EndIf
		Case StringRegExp ( $REGEXREAD , "(?i)>en((_|-)US|(-|_)BR|)</em:locale>" )
			$REGEX = StringRegExp ( $REGEXREAD , "(?is)>en(?:(?:_|-)US|(?:-|_)BR|)</em:locale>.*?<em:name(?:>|="")(.+?)(?:<|"")/em:name" , 3 )
			If IsArray ( $REGEX ) Then $REGEX1 = $REGEX [ 0 ]
		Case StringRegExp ( $REGEXREAD , "(?is)/em:localized(>|="").+(?:<|"")em:name" )
			$REGEX = StringRegExp ( $REGEXREAD , "(?is)description>.+?/em:name" , 3 )
			For $R = 0 To UBound ( $REGEX ) + 4294967295
				If Not StringRegExp ( $REGEX [ $R ] , "em:locale" ) Then $REGEX1 = StringRegExpReplace ( $REGEX [ $R ] , "(?is).+<em:name(?:>|="")(.+?)(?:<|"")/em:name.*" , "$1" )
			Next
		EndSelect
	EndIf
	$REGEX1 = CONV ( $REGEX1 )
	Return $REGEX1
EndFunc
Func FIREFOXEXTENSIONREG ( $HIVE , $SUBK , $USER = "" )
	If $HIVE = "HKLM" And $SUBK = "Software" Then $LOGHIVE = "HKLM"
	If $HIVE = "HKLM" And $SUBK = "Software\Wow6432Node" Then $LOGHIVE = "HKLM-x32"
	If $HIVE = "HKU" Then
		$HIVE = "HKU\" & $USER
		$LOGHIVE = "HKU\" & $USER
	EndIf
	$KEY1 = $HIVE & "\" & $SUBK & "\Mozilla"
	$HKEY = _REGOPENKEYEX3 ( $KEY1 , 1 )
	If @error Or $HKEY = 0 Then Return
	$I = 0
	While 1
		$REGEX1 = __REGENUMKEY ( $HKEY , $I )
		If @error Then ExitLoop
		$HKEY1 = _REGOPENKEYEX3 ( $KEY1 & "\" & $REGEX1 , 1 )
		If @error Or $HKEY1 = 0 Then ExitLoop
		$2 = 0
		While 1
			$REGEX2 = __REGENUMKEY ( $HKEY1 , $2 )
			If @error Then ExitLoop
			If $REGEX2 = "Extensions" Then
				$3 = 1
				While 1
					$DATA = ""
					$REGEX3 = RegEnumVal ( $KEY1 & "\" & $REGEX1 & "\" & $REGEX2 , $3 )
					If @error Then ExitLoop
					If $REGEX3 <> "" Then
						$DATA = RegRead ( $KEY1 & "\" & $REGEX1 & "\" & $REGEX2 , $REGEX3 )
						If @error = 0 Then
							If StringRight ( $DATA , 1 ) = "\" Then $DATA = StringTrimRight ( $DATA , 1 )
							If GUICtrlRead ( $CHECKBOX11 ) = 4 Then
								If Not FileExists ( $DATA ) Then $DATA = $DATA & " => " & $NFOUND
								_ARRAYADD ( $FFARR , "FF " & $LOGHIVE & "\...\" & $REGEX1 & "\Extensions: [" & $REGEX3 & "] - " & $DATA , 0 , "||||" )
								If FileExists ( $DATA ) Then FIREFOXEXTENSIONFILEFOL ( $DATA , $3 & Random ( 1000 , 9999 , 1 ) & Random ( 1000 , 9999 , 1 ) )
							Else
								If $REGEX3 <> "plugins" And $REGEX3 <> "components" Then
									If Not FileExists ( $DATA ) Then $DATA = $DATA & " => " & $NFOUND
									_ARRAYADD ( $FFARR , "FF " & $LOGHIVE & "\...\" & $REGEX1 & "\Extensions: [" & $REGEX3 & "] - " & $DATA , 0 , "||||" )
									If FileExists ( $DATA ) Then FIREFOXEXTENSIONFILEFOL ( $DATA , $3 & Random ( 1000 , 9999 , 1 ) & Random ( 1000 , 9999 , 1 ) )
								EndIf
							EndIf
						EndIf
					EndIf
					$3 += 1
				WEnd
			EndIf
			$2 += 1
		WEnd
		$I = $I + 1
	WEnd
	If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
EndFunc
Func FIREFOXEXTENSIONREGFIX ( )
	If StringInStr ( $FIX , " HKLM\" ) Then
		$KEY = StringRegExpReplace ( $FIX , "(?i)FF HKLM\\\.\.\.\\(.+\\Extensions): \[.+" , "$1" )
		$KEY = "HKLM\Software\Mozilla\" & $KEY
		$VAL = StringRegExpReplace ( $FIX , "(?i)FF HKLM\\.+\\Extensions: \[(.+)\] -.*" , "$1" )
		DELVALUE ( $KEY , $VAL )
	EndIf
	If StringInStr ( $FIX , " HKU\" ) Then
		$USER = StringRegExpReplace ( $FIX , "(?i)FF HKU\\(.+?)\\.+" , "$1" )
		$KEY = StringRegExpReplace ( $FIX , "(?i)FF HKU\\.+?\\\.\.\.\\(.+\\Extensions): \[.+" , "$1" )
		$KEY = "HKU\" & $USER & "\Software\Mozilla\" & $KEY
		$VAL = StringRegExpReplace ( $FIX , "(?i)FF HKU\\.+\\Extensions: \[(.+)\] -.*" , "$1" )
		DELVALUE ( $KEY , $VAL )
	EndIf
	If StringInStr ( $FIX , " HKLM-x32" ) Then
		$KEY = StringRegExpReplace ( $FIX , "(?i)FF HKLM-x32\\\.\.\.\\(.+\\Extensions): \[.+" , "$1" )
		$KEY = "HKLM\Software\Wow6432Node\Mozilla\" & $KEY
		$VAL = StringRegExpReplace ( $FIX , "(?i)FF HKLM-x32\\.+\\Extensions: \[(.+)\] -.*" , "$1" )
		DELVALUE ( $KEY , $VAL )
	EndIf
EndFunc
Func FIREFOXFIX ( )
	If $BOOTM <> "Recovery" Then
		$ARRAYPRO = ProcessList ( )
		For $I = 1 To UBound ( $ARRAYPRO ) + 4294967295
			If StringRegExp ( $ARRAYPRO [ $I ] [ 0 ] , "(?i)firefox\.exe" ) Then
				ProcessClose ( $ARRAYPRO [ $I ] [ 1 ] )
			EndIf
		Next
	EndIf
	If StringInStr ( $FIX , "Extension:" ) Or StringInStr ( $FIX , "user.js:" ) Then
		$FILEP = StringRegExpReplace ( $FIX , "(?i).* ([A-Z]:\\.+?) \[.*" , "$1" )
		If FileExists ( $FILEP ) Then
			If StringInStr ( FileGetAttrib ( $FILEP ) , "D" ) Then
				MOVEDIR ( $FILEP )
			Else
				MOVEFILENORMAL ( $FILEP )
			EndIf
			FIREFOXREMEX2 ( $FILEP )
		Else
			If Not FIREFOXREMEX2 ( $FILEP ) Then NFOUND ( $FILEP )
		EndIf
	EndIf
	If StringInStr ( $FIX , "ProfilePath:" ) Then
		$DIRP = StringRegExpReplace ( $FIX , "(?i).* ([A-Z]:\\.+?) \[.*" , "$1" )
		If StringRegExp ( $FIX , "(?i).* ([A-Z]:\\.+?) \[\d" ) Then MOVEDIR ( $DIRP )
		$PROFP = StringRegExpReplace ( $DIRP , ".+\\(.+)" , "$1" )
		$ARRPROF = _FILELISTTOARRAYREC ( @AppDataDir , "profiles.ini||GG;OpenFM;Thunderbird;Instantbird;uTorrent;PCDr;Notepad++;Quick Access Popup;dell;adobe;google;Microsoft;Macromedia;Dropbox*" , 1 , 1 , 0 , 2 )
		For $F = 1 To UBound ( $ARRPROF ) + 4294967295
			$ARR = IniReadSectionNames ( $ARRPROF [ $F ] )
			For $P = 1 To UBound ( $ARR ) + 4294967295
				If $ARR [ $P ] = "General" Then ContinueLoop
				$PPATH = IniRead ( $ARRPROF [ $F ] , $ARR [ $P ] , "Path" , 0 )
				If StringRegExp ( $PPATH , "(=|/|\\)" & $PROFP & "$" ) Then
					$RET = IniDelete ( $ARRPROF [ $F ] , $ARR [ $P ] )
					If $RET Then FileWrite ( $HFIXLOG , $DIRP & " => " & $PAD & " " & $DELETED & @CRLF )
				EndIf
			Next
		Next
	EndIf
	If StringRegExp ( $FIX , "(?i)(NetworkProxy|Homepage|NewTab|Session Restore|NewTabOverride|HomepageOverride|Notifications):" ) Then
		$PROFPATH = StringRegExpReplace ( $FIX , ".+?: (.+?) ->.*" , "$1" )
		$PROFPATH = @AppDataDir & "\" & $PROFPATH
		FileDelete ( @TempDir & "\temp0.js" )
		Select
		Case StringInStr ( $FIX , "NewTabOverride:" )
			$REGEX = READ ( $PROFPATH & "\extension-settings.json" )
			If Not StringInStr ( $REGEX , """url_overrides""" ) Then Return NFOUND ( $FIX )
			$EXT = StringRegExpReplace ( $FIX , ".+led: (.+)" , "$1" )
			$RET = StringRegExpReplace ( $REGEX , ".+url_overrides"".+?\[(.*)?\].+" , "$1" )
			If Not StringInStr ( $RET , $EXT ) Then Return NFOUND ( $FIX )
			$REGEX = StringRegExpReplace ( $REGEX , "(.+url_overrides""[^]]+)(?:,\{""id"":""" & $EXT & "[^}]+\}|\{""id"":""" & $EXT & "[^}]+\},|\{""id"":""" & $EXT & "[^}]+\})(.+)" , "$1$2" )
			FileWrite ( @TempDir & "\temp0.js" , $REGEX )
			FileMove ( @TempDir & "\temp0.js" , $PROFPATH & "\extension-settings.json" , 1 )
			DELETED ( "Firefox NewTabOverride (" & $EXT & ") " )
		Case StringInStr ( $FIX , "HomepageOverride:" )
			$REGEX = READ ( $PROFPATH & "\extension-settings.json" )
			If Not StringInStr ( $REGEX , """homepage_override""" ) Then Return NFOUND ( $FIX )
			$EXT = StringRegExpReplace ( $FIX , ".+led: (.+)" , "$1" )
			$RET = StringRegExpReplace ( $REGEX , "(?i).+homepage_override"".+?\[(.*?)\].+" , "$1" )
			If Not StringInStr ( $RET , $EXT ) Then Return NFOUND ( $FIX )
			$REGEX = StringRegExpReplace ( $REGEX , "(.+homepage_override""[^]]+)(?:,\{""id"":""" & $EXT & "[^}]+\}|\{""id"":""" & $EXT & "[^}]+\},|\{""id"":""" & $EXT & "[^}]+\})(.+)" , "$1$2" )
			FileWrite ( @TempDir & "\temp0.js" , $REGEX )
			FileMove ( @TempDir & "\temp0.js" , $PROFPATH & "\extension-settings.json" , 1 )
			DELETED ( "Firefox HomepageOverride (" & $EXT & ") " )
		Case StringInStr ( $FIX , "NetworkProxy:" )
			$REGEX = READ ( $PROFPATH & "\prefs.js" )
			If Not StringRegExp ( $REGEX , "(?i)user_pref\(""network.proxy" ) Then Return NFOUND ( $FIX )
			$REGEX = StringRegExpReplace ( $REGEX , "(?i)user_pref\(""network.proxy[^;]*;\v{2}" , "" )
			FileWrite ( @TempDir & "\temp0.js" , $REGEX )
			FileMove ( @TempDir & "\temp0.js" , $PROFPATH & "\prefs.js" , 1 )
			FileWrite ( $HFIXLOG , $FFPROX & @CRLF )
		Case StringInStr ( $FIX , "Homepage:" )
			$REGEX = READ ( $PROFPATH & "\prefs.js" )
			If Not StringRegExp ( $REGEX , "(?i)user_pref\(""browser.startup.homepage""" ) Then Return NFOUND ( $FIX )
			$REGEX = StringRegExpReplace ( $REGEX , "(?i)user_pref\(""browser.startup.homepage""[^;]*;" , "" )
			$REGEX = StringRegExpReplace ( $REGEX , "(?m)^\R" , "" )
			FileWrite ( @TempDir & "\temp0.js" , $REGEX )
			FileMove ( @TempDir & "\temp0.js" , $PROFPATH & "\prefs.js" , 1 )
			DELETED ( "Firefox homepage" )
		Case StringInStr ( $FIX , "NewTab:" )
			$REGEX = READ ( $PROFPATH & "\prefs.js" )
			If Not StringRegExp ( $REGEX , "(?i)user_pref\(""browser.newtab.url" ) Then Return NFOUND ( $FIX )
			$REGEX = StringRegExpReplace ( $REGEX , "(?i)user_pref\(""browser.newtab.url[^;]*;\v{2}" , "" )
			FileWrite ( @TempDir & "\temp0.js" , $REGEX )
			FileMove ( @TempDir & "\temp0.js" , $PROFPATH & "\prefs.js" , 1 )
			DELETED ( "Firefox newtab" )
		Case StringInStr ( $FIX , "Session Restore:" )
			$REGEX = READ ( $PROFPATH & "\prefs.js" )
			If Not StringRegExp ( $REGEX , "(?i)user_pref\(""browser.startup.page" ) Then Return NFOUND ( "FF Session Restore:" )
			$REGEX = StringRegExpReplace ( $REGEX , "(?i)user_pref\(""browser.startup.page[^;]*;\v{2}" , "" )
			FileWrite ( @TempDir & "\temp0.js" , $REGEX )
			FileMove ( @TempDir & "\temp0.js" , $PROFPATH & "\prefs.js" , 1 )
			DELETED ( "Firefox Session Restore" )
		Case StringInStr ( $FIX , "Notifications:" )
			$SQ = $PROFPATH & "\permissions.sqlite"
			$_HSQ = _SQLITEO ( $SQ )
			If @error Or Not $_HSQ Then Return NFOUND ( "FF Notifications:" )
			If _SQLITE_EXEC ( $_HSQ , "DELETE FROM moz_perms WHERE type = 'desktop-notification'" ) = 0 Then
				DELETED ( "FF Notifications:" )
			Else
				NFOUND ( "FF Notifications:" )
			EndIf
			_SQLITECL ( $_HSQ )
		EndSelect
		Return
	EndIf
	If StringInStr ( $FIX , "FF Plugin:" ) Then
		$REGEX = StringRegExpReplace ( $FIX , "(?i)FF Plugin: (.+?) ->.*" , "$1" )
		$KEY = "HKLM\Software\MozillaPlugins\" & $REGEX
		DELKEY ( $KEY )
		If StringRegExp ( $FIX , "\[\D" ) Then Return 1
		$PATH = StringRegExpReplace ( $FIX , ".+-> (.:\\.+\.dll) .+" , "$1" )
		If FileExists ( $PATH ) Then
			MOVEFILENORMAL ( $PATH )
		Else
			NFOUND ( $PATH )
		EndIf
	EndIf
	If StringInStr ( $FIX , "SearchPlugin:" ) Then
		$PATH = StringRegExpReplace ( $FIX , "(?i)FF SearchPlugin: (.+) \[.*" , "$1" )
		If FileExists ( $PATH ) Then
			MOVEFILENORMAL ( $PATH )
		Else
			NFOUND ( $PATH )
		EndIf
	EndIf
	If StringInStr ( $FIX , "Plugin ProgramFiles/Appdata:" ) Then
		$PATH = StringRegExpReplace ( $FIX , "(?i)FF Plugin ProgramFiles/Appdata: ([A-Z]:\\.+\.dll) .+" , "$1" )
		If FileExists ( $PATH ) Then
			MOVEFILENORMAL ( $PATH )
		Else
			NFOUND ( $PATH )
		EndIf
	EndIf
	If StringInStr ( $FIX , "Plugin HKU" ) Then
		$USER = StringRegExpReplace ( $FIX , "(?i)FF Plugin HKU\\(.+?):.+" , "$1" )
		$REGEX = StringRegExpReplace ( $FIX , "(?i)FF Plugin HKU\\.+?: (.+) -> [A-Z]:\\.*" , "$1" )
		$PATH = StringRegExpReplace ( $FIX , "(?i)FF Plugin HKU\\.+?: .+ -> ([A-Z]:\\.+\.dll) .+" , "$1" )
		$KEY = "HKU\" & $USER & "\Software\MozillaPlugins\" & $REGEX
		DELKEY ( $KEY )
		If FileExists ( $PATH ) Then
			MOVEFILENORMAL ( $PATH )
		Else
			NFOUND ( $PATH )
		EndIf
	EndIf
	If StringInStr ( $FIX , "Plugin-x32:" ) Then
		$REGEX = StringRegExpReplace ( $FIX , "FF Plugin-x32: (.+) ->.*" , "$1" )
		$KEY = "HKLM\Software\Wow6432Node\MozillaPlugins\" & $REGEX
		DELKEY ( $KEY )
		If StringRegExp ( $FIX , "\[\D" ) Then Return 1
		$PATH = StringRegExpReplace ( $FIX , ".+-> (.:\\.+\.dll) .+" , "$1" )
		If FileExists ( $PATH ) Then
			MOVEFILENORMAL ( $PATH )
		Else
			NFOUND ( $PATH )
		EndIf
	EndIf
	If StringInStr ( $FIX , "ExtraCheck:" ) Then
		$PATH = StringRegExpReplace ( $FIX , "(?i)FF ExtraCheck: ([A-Z]:\\.+?) \[.+" , "$1" )
		If FileExists ( $PATH ) Then
			MOVEFILENORMAL ( $PATH )
		Else
			NFOUND ( $PATH )
		EndIf
	EndIf
	If StringInStr ( $FIX , "HKLM\SOFTWARE\Policies\Mozilla\Firefox:" ) Then Return DELKEY ( "HKLM\SOFTWARE\Policies\Mozilla" )
	If StringInStr ( $FIX , "SOFTWARE\Policies\Mozilla\Firefox:" ) Then
		$USER = StringRegExpReplace ( $FIX , "(?i)HKU\\(.+?)\\.+" , "$1" )
		Return DELKEY ( "HKU\" & $USER & "\SOFTWARE\Policies\Mozilla" )
	EndIf
EndFunc
Func FIREFOXPLUGIN ( $PATH )
	If Not FileExists ( $PATH ) Then Return 1
	$ARRAYPI = _FILELISTTOARRAY ( $PATH , "*.dll" , 1 , True )
	For $I = 1 To UBound ( $ARRAYPI ) + 4294967295
		$CDATE = ""
		COMP ( $PATH )
		If $CDATE Then
			$CDATE = " [" & $CDATE & "]"
			$COMPANY = ""
		EndIf
		_ARRAYADD ( $FFARR , "FF Plugin ProgramFiles/Appdata: " & $ARRAYPI [ $I ] & $CDATE & $COMPANY , 0 , "||||" )
	Next
EndFunc
Func FIREFOXPLUGINS ( $PLUGIN )
	$KEY = "HKLM\Software\MozillaPlugins"
	If $PLUGIN = "Plugin-x32" Then $KEY = "HKLM\Software\Wow6432Node\MozillaPlugins"
	$HKEY = _REGOPENKEYEX3 ( $KEY )
	If @error Or $HKEY = 0 Then Return
	$I = 0
	While 1
		$REGEX = __REGENUMKEY ( $HKEY , $I )
		If @error Then ExitLoop
		$PATH = RegRead ( $KEY & "\" & $REGEX , "path" )
		If Not @error Then
			If FileExists ( $PATH ) Then
				COMP ( $PATH )
				$CDATE = " [" & $CDATE & "]"
			Else
				$COMPANY = " [" & $REGIST8 & "]"
				$CDATE = ""
			EndIf
			_ARRAYADD ( $FFARR , "FF " & $PLUGIN & ": " & $REGEX & " -> " & $PATH & $CDATE & $COMPANY , 0 , "||||" )
		EndIf
		$I = $I + 1
	WEnd
	If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
EndFunc
Func FIREFOXPREF ( $PROFS )
	For $FF = 1 To UBound ( $PROFS ) + 4294967295
		If FileExists ( $PROFS [ $FF ] ) Then
			$ATT = ""
			$CDATE = FILETIMECM ( $PROFS [ $FF ] )
			$CDATE = " [" & $CDATE & "]"
			If StringRegExp ( $PROFS [ $FF ] , "(?i)AppData\\Roaming\\(Firefox|Profiles)|AMozilla\\AFirefox" ) Then $ATT = " <==== " & $UPD1
			_ARRAYADD ( $FFARR , "FF ProfilePath: " & $PROFS [ $FF ] & $CDATE & $ATT , 0 , "||||" )
		EndIf
		If FileExists ( $PROFS [ $FF ] & "\user.js" ) Then
			$CDATE = FILETIMECM ( $PROFS [ $FF ] & "\user.js" )
			$CDATE = " [" & $CDATE & "]"
			_ARRAYADD ( $FFARR , "FF user.js: detected! => " & $PROFS [ $FF ] & "\user.js" & $CDATE , 0 , "||||" )
		EndIf
		$PROF = StringRegExpReplace ( $PROFS [ $FF ] , "(?i).+?Roaming\\(.+)" , "$1" )
		If FileExists ( $PROFS [ $FF ] & "\prefs.js" ) Then
			$HPREFS = FileOpen ( $PROFS [ $FF ] & "\prefs.js" , 256 )
			$REGEX = FileRead ( $HPREFS )
			FileClose ( $HPREFS )
			$REGEX1 = StringRegExp ( $REGEX , "(?i)user_pref\(""browser.download.dir"",\s*""([^""]*)""\)" , 1 )
			If IsArray ( $REGEX1 ) Then _ARRAYADD ( $FFARR , "FF DownloadDir: " & StringRegExpReplace ( $REGEX1 [ 0 ] , "\\\\" , "\\" ) , 0 , "|||" )
			$REGEX1 = StringRegExp ( $REGEX , "(?i)user_pref\(""browser.startup.homepage"",\s*""(.*)""\)" , 1 )
			If IsArray ( $REGEX1 ) Then _ARRAYADD ( $FFARR , "FF Homepage: " & $PROF & " -> " & $REGEX1 [ 0 ] , 0 , "|||" )
			$REGEX1 = StringRegExp ( $REGEX , "(?i)user_pref\(""browser.newtab.url"",\s*""(.*)""\)" , 1 )
			If IsArray ( $REGEX1 ) Then _ARRAYADD ( $FFARR , "FF NewTab: " & $PROF & " -> " & $REGEX1 [ 0 ] , 0 , "|||" )
			$REGEX1 = StringRegExp ( $REGEX , "user_pref\(""network.proxy.(.*)\)" , 1 )
			If IsArray ( $REGEX1 ) Then _ARRAYADD ( $FFARR , "FF NetworkProxy: " & $PROF & " -> " & $REGEX1 [ 0 ] , 0 , "|||" )
			$REGEX1 = StringRegExp ( $REGEX , "user_pref\(""browser.startup.page"",\s*(.*)\)" , 1 )
			If IsArray ( $REGEX1 ) And $REGEX1 [ 0 ] = 3 Then _ARRAYADD ( $FFARR , "FF Session Restore: " & $PROF & " -> " & $INTERNET2 , 0 , "||||" )
		EndIf
		$PATH = $PROFS [ $FF ] & "\permissions.sqlite"
		If FileExists ( $PATH ) Then
			$RET = _SQLITEGT ( $PATH )
			If $RET Then
				_ARRAYADD ( $FFARR , "FF Notifications: " & $PROF & " -> " & $RET , 0 , "|||" )
			EndIf
		EndIf
		If FileExists ( $PROFS [ $FF ] & "\extension-settings.json" ) Then
			$OREAD = FileOpen ( $PROFS [ $FF ] & "\extension-settings.json" , 256 )
			$REGEX = FileRead ( $OREAD )
			FileClose ( $OREAD )
			If StringInStr ( $REGEX , """homepage_override""" ) And Not StringRegExp ( $REGEX , "(?i)""homepage_override""\s*:\s*\{\s*\}" ) Then
				$RET = StringRegExpReplace ( $REGEX , "(?i).+homepage_override"".+?\[(.*?)\].+" , "$1" )
				$RET = StringRegExp ( $RET , "(?i)""id"":""[^""]+?"".+?\}" , 3 )
				For $R = 0 To UBound ( $RET ) + 4294967295
					$ENA = "Enabled: "
					$ID = StringRegExpReplace ( $RET [ $R ] , ".*""id"":""([^""]*)"".+" , "$1" )
					$EN = StringRegExpReplace ( $RET [ $R ] , ".+""enabled"":\s*(\w+).*" , "$1" )
					If $EN = "false" Then $ENA = "Disabled: "
					_ARRAYADD ( $FFARR , "FF HomepageOverride: " & $PROF & " -> " & $ENA & $ID , 0 , "|||" )
				Next
			EndIf
			If StringInStr ( $REGEX , """url_overrides""" ) And Not StringRegExp ( $REGEX , "(?i)""url_overrides""\s*:\s*\{\s*\}" ) Then
				$RET = StringRegExpReplace ( $REGEX , "(?i).+url_overrides"".+?\[(.*)?\].+" , "$1" )
				$RET = StringRegExp ( $RET , "(?:)""id"":""[^""]+?"".+?\}" , 3 )
				For $R = 0 To UBound ( $RET ) + 4294967295
					$ENA = "Enabled: "
					$ID = StringRegExpReplace ( $RET [ $R ] , ".*""id"":""([^""]*)"".+" , "$1" )
					$EN = StringRegExpReplace ( $RET [ $R ] , ".+""enabled"":\s*(\w+).*" , "$1" )
					If $EN = "false" Then $ENA = "Disabled: "
					_ARRAYADD ( $FFARR , "FF NewTabOverride: " & $PROF & " -> " & $ENA & $ID , 0 , "|||" )
				Next
			EndIf
		EndIf
		$PATHH = StringRegExpReplace ( $PROFS [ $FF ] , "(.+)\\[^\\]+\\[^\\]+\\.+" , "$1" )
		FIREFOXEXTENSION ( $PATHH & "\Extensions\{ec8030f7-c20a-464f-9b0e-13a3a9e97384}" )
		FIREFOXEXTENSION ( $PATHH & "\SystemExtensionsDev" )
		FIREFOXEXTENSION ( $PROFS [ $FF ] & "\Extensions" )
		$FARR = _FILELISTTOARRAY ( $PROFS [ $FF ] & "\features" , "*" , 2 , True )
		If UBound ( $FARR ) > 1 Then FIREFOXEXTENSION ( $FARR [ 1 ] )
		If FileExists ( $PROFS [ $FF ] & "\extensions.ini" ) Then
			$REXTENS = FileRead ( $PROFS [ $FF ] & "\extensions.ini" )
			$REXTENS = StringRegExpReplace ( $REXTENS , "(?is).*ExtensionDirs([^[]+?)(\[|$).*" , "$1" )
			$SEC = StringRegExp ( $REXTENS , "=(.+)\R" , 3 )
			For $IN = 0 To UBound ( $SEC ) + 4294967295
				$PATH = $SEC [ $IN ]
				If FileExists ( $PATH ) Then
					If StringInStr ( FileGetAttrib ( $PATH ) , "D" ) Then
						FIREFOXEXTENSIONFOL ( $PATH )
					Else
						If StringInStr ( $PATH , ".xpi" ) Then FIREFOXEXTENSIONFILE ( $PATH , $IN & Random ( 100 , 999 , 1 ) & Random ( 100 , 999 , 1 ) )
					EndIf
				Else
					_ARRAYADD ( $FFARR , "FF Extension: (" & $FF1 & ") - " & $PATH & " [" & $NFOUND & "]" , 0 , "|||" )
				EndIf
			Next
		EndIf
		FIREFOXSEARCHPLUGIN ( $PROFS [ $FF ] )
	Next
EndFunc
Func FIREFOXPROFS ( )
	Local $ARRPROFILES [ 1 ]
	$ARRPROF = _FILELISTTOARRAYREC ( @AppDataDir , "profiles.ini||ZHP;GG;OpenFM;Thunderbird;Instantbird;uTorrent;PCDr;Notepad++;Quick Access Popup;dell;adobe;google;Microsoft;Macromedia;Dropbox*" , 1 + 16 , 1 , 0 , 2 )
	For $F = 1 To UBound ( $ARRPROF ) + 4294967295
		$BASEPATH = StringRegExpReplace ( $ARRPROF [ $F ] , "(?i)(.+)\\profiles.ini" , "$1" )
		$INIFILE = $BASEPATH & "\Profiles.ini"
		If FileExists ( $INIFILE ) Then
			$HREAD = FileOpen ( $INIFILE , 256 )
			$READ = FileRead ( $HREAD )
			FileClose ( $HREAD )
			$ARR = _INIREADSECTIONNAMES ( $READ , 1 )
			For $X = 0 To UBound ( $ARR ) + 4294967295
				If StringRegExp ( $ARR [ $X ] , "(?i)General|Install" ) Then ContinueLoop
				$PPATH = _INIREADSECTIONVAL ( $READ , $ARR [ $X ] , "Path" , 1 )
				If $PPATH Then
					If _INIREADSECTIONVAL ( $READ , $ARR [ $X ] , "Default" , 1 ) = 1 Then _ARRAYADD ( $FFARR , "FF DefaultProfile: " & StringRegExpReplace ( $PPATH , ".+(?:/|\\)" , "$1" ) , 0 , "||||" )
					If _INIREADSECTIONVAL ( $READ , $ARR [ $X ] , "IsRelative" , 1 ) = 1 Then
						$PPATH = _PATHFULL ( $PPATH , $BASEPATH )
					EndIf
					If Not FileExists ( $PPATH ) Then
						_ARRAYADD ( $FFARR , "FF ProfilePath: " & $PPATH & " [" & $NFOUND & "]" & " <==== " & $UPD1 , 0 , "||||" )
					Else
						_ARRAYADD ( $ARRPROFILES , $PPATH , 0 , "||||" )
					EndIf
				EndIf
			Next
		EndIf
	Next
	$FAKE = "C:\Windows\SysWOW64\x32\Data\profile"
	If FileExists ( $FAKE ) Then
		$CDATE = FILETIMECM ( $FAKE )
		_ARRAYADD ( $FFARR , "FF ProfilePath: " & $FAKE & " [" & $CDATE & "]" & " <==== " & $UPD1 , 0 , "||||" )
	EndIf
	$ARRPROFILES = _ARRAYUNIQUE ( $ARRPROFILES , 0 , 0 , 0 , 0 , 1 )
	Return $ARRPROFILES
EndFunc
Func FIREFOXREMEX2 ( $FILEP )
	$ARRPROF = _FILELISTTOARRAYREC ( @UserProfileDir , "extensions.ini||Thunderbird;Instantbird;uTorrent;PCDr;Notepad++;Quick Access Popup;dell;adobe;google;Microsoft;Macromedia;Dropbox*" , 1 , 1 , 0 , 2 )
	If Not IsArray ( $ARRPROF ) Then Return False
	For $F = 1 To UBound ( $ARRPROF ) + 4294967295
		$REXTENS = FileRead ( $ARRPROF [ $F ] )
		If Not StringInStr ( $REXTENS , $FILEP ) Then ContinueLoop
		$SEC = StringRegExpReplace ( $REXTENS , "(?is).*ExtensionDirs]*([^[]+?)\[+.*" , "$1" )
		$FILEP1 = StringRegExpReplace ( $FILEP , "(\(|\)|\$|\\)" , "\\\1" )
		$SEC = StringRegExpReplace ( $SEC , "(?is).*\R(.+?)=" & $FILEP1 & "\R.*" , "$1" )
		$RET = IniDelete ( $ARRPROF [ $F ] , "ExtensionDirs" , $SEC )
		If $RET Then
			If StringInStr ( FileRead ( $ARRPROF [ $F ] ) , $FILEP ) Then FIREFOXREMEX3 ( $ARRPROF [ $F ] , $SEC , $FILEP1 )
			If Not StringInStr ( FileRead ( $ARRPROF [ $F ] ) , $FILEP ) Then
				FileWrite ( $HFIXLOG , $FILEP & " => " & $PAD & " " & $DELETED & @CRLF )
			Else
				FileWrite ( $HFIXLOG , $FILEP & " => " & $PAD & " " & $NDELETED & @CRLF )
			EndIf
			Return True
		EndIf
	Next
	Return False
EndFunc
Func FIREFOXREMEX3 ( $PINI , $SEC , $FILEP2 )
	$READ = FileRead ( $PINI )
	$READ = StringRegExpReplace ( $READ , $SEC & "\s*=\s*" & $FILEP2 & "\v*" , "" )
	$OPINI = FileOpen ( $PINI , 2 )
	FileWrite ( $OPINI , $READ )
	FileClose ( $OPINI )
EndFunc
Func FIREFOXSEARCHPLUGIN ( $FOLDER )
	If Not FileExists ( $FOLDER ) Then Return 1
	If Not FileExists ( $FOLDER & "\searchplugins" ) Then Return 1
	$FILEARRAY = _FILELISTTOARRAY ( $FOLDER & "\searchplugins" , "*" , 1 , False )
	For $I = 1 To UBound ( $FILEARRAY ) + 4294967295
		$CDATE = FILETIMECM ( $FOLDER & "\searchplugins\" & $FILEARRAY [ $I ] )
		$CDATE = " [" & $CDATE & "]"
		If GUICtrlRead ( $CHECKBOX11 ) = 4 Then
			_ARRAYADD ( $FFARR , "FF SearchPlugin: " & $FOLDER & "\searchplugins\" & $FILEARRAY [ $I ] & $CDATE , 0 , "||||" )
		Else
			If Not StringRegExp ( $FILEARRAY [ $I ] , "\A(?i)((bing|eBay|google|wikipedia|yahoo|twitter|amazon|amazondotcom|allegro|fbc|merlin|pwn|wp|wolnelektury|ddg|chambers|bolcom|marktplaats|cnrtl-tlfi|heureka|mapy|seznam|slunecnice|leo_ende_de|hoepli|drae|atlas|azet|dunaj|slovnik|zoznam)(-\w{2}|)(-GB|-france|)\.xml)" ) Then _ARRAYADD ( $FFARR , "FF SearchPlugin: " & $FOLDER & "\searchplugins\" & $FILEARRAY [ $I ] & $CDATE , 0 , "||||" )
		EndIf
	Next
EndFunc
Func FIXBCD ( $COMMAND )
	FileWrite ( $HFIXLOG , @CRLF & "=========================  bcdedit ========================" & @CRLF & @CRLF )
	$READ = CMDRUN ( $COMMAND )
	FileWrite ( $HFIXLOG , @CRLF & $READ )
	FileWrite ( $HFIXLOG , @CRLF & "========= " & $END & " " & $OF & " bcdedit =========" & @CRLF & @CRLF )
EndFunc
Func FIXBR ( )
	$MR = Random ( 10 , 18 , 1 )
	$RAN = "\"
	For $I = 1 To $MR
		$RAN &= Chr ( Random ( 97 , 122 , 1 ) )
	Next
	Return $RAN & ".txt"
EndFunc
Func FIXBT ( )
	$FIXLIST = FIXBR ( )
	$OFIX = FileOpen ( @ScriptDir & $FIXLIST , 256 + 2 )
	FileWrite ( $OFIX , "" )
	FileClose ( $OFIX )
	Run ( "notepad " & @ScriptDir & $FIXLIST )
EndFunc
Func FIXBUTT ( )
	Local $C1 , $CDATE , $RUN , $ATT , $EMPTEMP
	If Not $FIXLIST Then $FIXLIST = "\fixlist.txt"
	If FileExists ( @ScriptDir & $FIXLIST & ".txt" ) Then FileMove ( @ScriptDir & $FIXLIST & ".txt" , @ScriptDir & $FIXLIST )
	If Not FileExists ( @ScriptDir & $FIXLIST ) Then
		If StringRegExp ( ClipGet ( ) , "(?is)Start::.+End::" ) Then
			$FIXLIST = FIXBR ( )
			$OFIX = FileOpen ( @ScriptDir & $FIXLIST , 256 + 2 )
			FileWrite ( $OFIX , ClipGet ( ) )
			FileClose ( $OFIX )
		Else
			MsgBox ( 262144 + 0 , $FRST , $NOFIX1 & @CRLF & @CRLF & $NOFIX2 )
			Exit
		EndIf
	EndIf
	$OFIX = FileOpen ( @ScriptDir & $FIXLIST , 256 )
	$READ = FileRead ( $OFIX )
	$SF = $READ
	If $BOOTM = "Recovery" Then
		If FileExists ( $C & "\Users" ) Then
			GETFILELIST2 ( $C & "\Users" )
		EndIf
	Else
		If StringRegExp ( $SF , "(?i)HKU\\|Emptytemp:" ) Then
			LOAD ( )
			Global $USERREG = HKUUSERS ( )
		EndIf
		GETFILELIST2 ( _WINAPI_GETPROFILESDIRECTORY ( ) )
	EndIf
	If StringRegExp ( $SF , "(?i)(\\|\|)AllUsers?Names?" ) Then
		Local $USER [ 1 ]
		$USERSPR = $C & "/Users"
		$TMPO = FileOpen ( $C & "\frst\tmp120" , 256 + 2 )
		$I = 1
		While 1
			$RL = FileReadLine ( $OFIX , $I )
			If @error Then ExitLoop
			If StringRegExp ( $RL , "(?i)AllUsers?Names?" ) Then
				For $P = 1 To UBound ( $ALLUSERS ) + 4294967295
					$USER = StringRegExpReplace ( $ALLUSERS [ $P ] , ".+\\(.+)" , "$1" )
					$RL1 = StringRegExpReplace ( $RL , "(?i)\\AllUsers?Names?" , "\\" & $USER )
					$RL1 = StringRegExpReplace ( $RL1 , "(?i)\|AllUsers?Names?" , "|" & $USER )
					FileWrite ( $TMPO , $RL1 & @CRLF )
				Next
			Else
				FileWrite ( $TMPO , $RL & @CRLF )
			EndIf
			$I += 1
		WEnd
		FileClose ( $TMPO )
		$TMPO = FileOpen ( $C & "\frst\tmp120" , 256 )
		$SF = FileRead ( $TMPO )
		FileClose ( $TMPO )
		FileDelete ( $C & "\frst\tmp120" )
	EndIf
	FileClose ( $OFIX )
	If $BOOTM <> "recovery" Then
		$SF = StringRegExpReplace ( $SF , "(?i)\\CurrentUserName" , "\\" & $USERNAME )
		$SF = StringRegExpReplace ( $SF , "(?i)\|CurrentUserName" , "|" & $USERNAME )
	EndIf
	If StringRegExp ( $SF , "(?is)Start::.+End::" ) Then
		$SF = StringRegExpReplace ( $SF , "(?is).*Start::(.+)End::.*" , "$1" )
		$SF = StringRegExpReplace ( $SF , "(?m)^\R" , "" )
		$OFIX = FileOpen ( @ScriptDir & $FIXLIST , 256 + 2 )
		FileWrite ( $OFIX , $SF )
	Else
		$SF = StringRegExpReplace ( $SF , "" , "" )
		$OFIX = FileOpen ( @ScriptDir & $FIXLIST , 256 + 2 )
		FileWrite ( $OFIX , $SF )
	EndIf
	FileClose ( $OFIX )
	If StringInStr ( $SF , "============" ) Or StringInStr ( $SF , $SCAN10 & " Farbar Recovery" ) Or StringInStr ( $SF , "Current controlset " ) Then
		MsgBox ( 262144 + 0 , $FRST , $WARN & ":" & @CRLF & @CRLF & $FIX12 )
		Exit
	EndIf
	FileDelete ( $C & "\frst\re" )
	FileDelete ( $C & "\frst\files" )
	FileDelete ( $C & "\frst\filesRem" )
	GUICtrlSetData ( $LABEL1 , $FIX1 & " " & $PW0 )
	$PROGRESS = GUICtrlCreateProgress ( 70 , 90 , 433 , 15 , 8 , 8192 )
	GUICtrlSendMsg ( $PROGRESS , 1034 , 1 , 50 )
	If $BOOTM = "Recovery" Then DEF ( )
	$C1 = IniRead ( $C & "\FRST\Logs\ct.ini" , "Run" , "ct" , 0 )
	$C2 = $C1 + 1
	$C1 = IniWrite ( $C & "\FRST\Logs\ct.ini" , "Run" , "ct" , $C2 )
	$PROFS = ""
	If $BOOTM <> "Recovery" Then $PROFS = $SCAN9 & ": " & LOGGEDU ( ) & @CRLF
	$HFIXLOG = FileOpen ( @ScriptDir & "\Fixlog.txt" , 2 + 256 )
	$CDATE = DATE ( )
	FileWrite ( $HFIXLOG , $FIXRES & " Farbar Recovery Scan Tool" & $VERSION & @CRLF & $SCAN11 & " " & "" & @UserName & " (" & $CDATE & ")" & " Run:" & $C2 & @CRLF & $SCAN13 & " " & @ScriptDir & @CRLF & $PROFS & $SCAN15 & ": " & $BOOTM )
	FileWrite ( $HFIXLOG , @CRLF & "==============================================" & @CRLF & @CRLF & "fixlist " & $CONTENT & ":" & @CRLF & "*****************" & @CRLF & $READ & @CRLF & "*****************" & @CRLF & @CRLF )
	$SF = ""
	$READ = ""
	FileDelete ( @TempDir & "\catalog0" )
	If $BOOTM <> "Recovery" Then
		$ARRAYPRO = ProcessList ( )
		For $I = 1 To UBound ( $ARRAYPRO ) + 4294967295
			If StringRegExp ( $ARRAYPRO [ $I ] [ 0 ] , "(?i)iexplore\.exe" ) Then
				ProcessClose ( $ARRAYPRO [ $I ] [ 1 ] )
			EndIf
		Next
	EndIf
	$YY = 1
	While 1
		$FIX = FileReadLine ( @ScriptDir & $FIXLIST , $YY )
		If @error Then ExitLoop
		$FIX = StringRegExpReplace ( $FIX , "(^\s+|\s+$)" , "" )
		Select
		Case StringRegExp ( $FIX , "\A(?i)Comment:" )
		Case StringRegExp ( $FIX , "(?i)\{ED1FC765-E35E-4C3D-BF15-2C2B11260CE4\}|RK_\w+_ON_\w+_\w+[^\\]*" )
			FileWrite ( $HFIXLOG , $FIX & " => " & $ERR0 & " ({ED1FC765-E35E-4C3D-BF15-2C2B11260CE4}): " & $NOFIXENTRY & @CRLF )
		Case $BOOTM = "Recovery" And ( StringRegExp ( $FIX , "(?i)(\A(AV|AS|FW):.*|^HKCU\\|Internet Explorer\\Main,|URLSearchHook:|WMI_ActiveScriptEventConsumer_|ShellExecuteHooks:|ShellExecuteHooks-x32:|SearchScopes:|BHO:|BHO-x32:|Toolbar:|Winsock: Catalog|DPF: |Winsock: -> Catalog|Handler:|Handler-x32:|Filter: |Filter-x32:|ProxyEnable:|ProxyServer:|AutoConfigURL|\AFF HK|HKU\\.+\\MountPoints2:|StartMenuInternet:|0c966feabec1\\InprocServer32:|409d6c4515e9\\InprocServer32:|A8F59079A8D5}\\localserver32:|Version: .*-.*\) Hidden|CustomCLSID:|RemoveProxy:|emptyeventlogs?:)" ) Or StringRegExp ( $FIX , "(?i)(^(CHR|BRA|VIV|YAN) .+: |^FF .+: |^Edge .+: |ShortcutWithArgument:|ted site: HKU\\)" ) )
			FileWrite ( $HFIXLOG , $FIX & " => " & $FIXER1 & @CRLF )
		Case $BOOTM <> "Recovery" And StringRegExp ( $FIX , "(?i)(Restore\s*From\s*(Backup|HiveBackup)|LastRegBack):" )
			FileWrite ( $HFIXLOG , $FIX & " => " & $FIXER2 & @CRLF )
		Case $BOOTM = "Recovery" And StringRegExp ( $FIX , "(?i)^(reboot|restart|empty\s?temp|Close\s*Processes):" )
			FileWrite ( $HFIXLOG , $FIX & " => " & $FIXER3 & @CRLF )
		Case StringRegExp ( $FIX , "(?i)\A[""]*[C-Z]:(\\|/).+" ) Or StringRegExp ( $FIX , "(?i)\A\d{4}-\d{2}-\d{2}.+" )
			FFMOVE ( )
		Case StringInStr ( $FIX , "FCheck:" )
			FCHECKFIX ( )
		Case StringRegExp ( $FIX , "\A(?i)Startup: " )
			DELETESTARTUP ( )
		Case StringRegExp ( $FIX , "\A(?i)Close\s*Processes:" )
			_BBBBCP ( )
		Case StringRegExp ( $FIX , "\A(?i)InternetURL: " )
			DELETEURL ( )
		Case StringRegExp ( $FIX , "(?i)^reg:" , 0 )
			REG ( )
		Case StringRegExp ( $FIX , "(?i)^zip:" )
			ZIP ( )
		Case StringRegExp ( $FIX , "HKLM\\...\\Drivers32(|-x32):" )
			DRIVERS32FIX ( )
		Case StringRegExp ( $FIX , "HKU\\.+?\\...\\Drivers32:" )
			DRIVERS32UFIX ( )
		Case StringRegExp ( $FIX , "HKLM\\Software\\...\\Authentication\\[^:]+:" )
			AUTHENTICSFIX ( )
		Case StringInStr ( $FIX , "\\UserInitMprLogonScript:" )
			USERINITMPRFIX ( )
		Case StringRegExp ( $FIX , "(?i)HKU\\.+\\(CurrentVersion\\PackagedAppXDebug|ActivatableClasses\\Package)\\[^\\]+:" )
			UDEBUGFIX ( )
		Case StringRegExp ( $FIX , "HKLM\\Software\\...\\Winlogon\\GPExtensions:" )
			GPEXTENSIONSFIX ( )
		Case StringRegExp ( $FIX , "HKU\\.+\\FileExts\\.+?\\UserChoice =>" )
			USERCHOICEFIX ( )
		Case StringRegExp ( $FIX , "HKLM\\.+\\Installed Components:" )
			ACTIVESETUPFIX ( )
		Case StringRegExp ( $FIX , "(StartupDir(|\[.+\])|StartupCommonDir(|x86)):" )
			STARTUPFIX ( )
		Case StringRegExp ( $FIX , "HKLM\\...\\[^\\]+\\Print Processors\\[^\\]+:" )
			PRINTPROCFIX ( )
		Case StringRegExp ( $FIX , "HKLM\\...\\Print\\Monitors\\[^\\]+:" )
			PRINTMONFIX ( )
		Case StringInStr ( $FIX , "HKLM\...\Run:" )
			DELETERUN ( )
		Case StringInStr ( $FIX , "Internet Explorer\Main," )
			IEMAINFIX ( )
		Case StringInStr ( $FIX , "Group Policy restriction on software:" )
			GPPOLICYFIX ( )
		Case StringInStr ( $FIX , "ShortcutTarget: " )
			DELETESTARTUPTARGET ( )
		Case StringRegExp ( $FIX , "(?i)^CMD:" )
			CMD ( $YY , 0 )
		Case StringInStr ( $FIX , "startbatch:" )
			CMD ( $YY , 1 )
		Case StringInStr ( $FIX , "StartRegedit:" )
			REGEDIT ( $YY )
		Case StringRegExp ( $FIX , "(?i)^(reboot|restart):" )
			FileWrite ( $C & "\FRST\re" , "R" )
		Case StringRegExp ( $FIX , "(?i)^empty\s?temp:" )
			$EMPTEMP = 1
			FileWrite ( $C & "\FRST\re" , "R" )
		Case StringRegExp ( $FIX , "(?i)^emptyeventlogs?:" )
			CLEAREVENTS ( )
		Case StringInStr ( $FIX , "URLSearchHook:" )
			URLSEARCHFIX ( )
		Case StringRegExp ( $FIX , "(?i)\\policies\\Microsoft\\(Internet Explorer|Windows Defender):" )
			IEPOLICYFIX ( )
		Case StringRegExp ( $FIX , "(\\(WindowsUpdate|Policies\\(BraveSoftware\\Brave|Vivaldi|YandexBrowser))|Policies\\Microsoft\\(MRT|Windows Defender Security Center|WindowsFirewall)):" )
			$KEY = StringRegExpReplace ( $FIX , "([^:]+):.*" , "$1" )
			DELKEY ( $KEY )
		Case StringRegExp ( $FIX , "(DefaultPrefix|Prefixes)(|-x32):" )
			IEPREFIXFIX ( )
		Case StringRegExp ( $FIX , "\A(?i)Hosts:" )
			HOSTSFIX ( )
		Case StringInStr ( $FIX , "Bootexecute:" )
			BOOTEXECUTEFIX ( )
		Case StringInStr ( $FIX , "AlternateShell:" )
			ALTERNATESHELLFIX ( )
		Case StringInStr ( $FIX , "AlternateDataStreams: " )
			ADSFIX ( )
		Case StringRegExp ( $FIX , "HKLM\\...\\Providers\\.+?: " )
			PROVIDERFIX ( )
		Case StringInStr ( $FIX , "ted site: HKU\" )
			IEZONESITESFIX ( )
		Case StringRegExp ( $FIX , "HKU\\.+\\\\SCRNSAVE.EXE " )
			SCRNSAVE ( )
		Case StringInStr ( $FIX , "Filesindirectory:" )
			FILESINDIRCTORY ( )
		Case StringRegExp ( $FIX , "(?i)HKLM\\SYSTEM\\.+\\Control\\SafeBoot.* =>" )
			SAFEBOOTFIX ( )
		Case StringInStr ( $FIX , "...\Command Processor:" )
			COMMANDPROCFIX ( )
		Case StringInStr ( $FIX , "ShellExecuteHooks: " ) Or StringInStr ( $FIX , "ShellExecuteHooks-x32: " )
			SEHFIX ( )
		Case StringRegExp ( $FIX , "\A(AV|AS|FW):.*\(.+\) \{.+\}" )
			SECCENTFIX ( )
		Case StringRegExp ( $FIX , "WMI:.+->.+:" )
			WMI_HJKFIX ( )
		Case StringRegExp ( $FIX , "SSODL(|-x32): " )
			SSODLFIX ( )
		Case StringRegExp ( $FIX , "ShellServiceObjects(|-x32): " )
			SSOFIX ( )
		Case StringInStr ( $FIX , "DeleteJunctionsInDirectory:" )
			DELETEJUNCTIONSINDIRECTORY ( )
		Case StringInStr ( $FIX , "SearchScopes: " )
			SEARCHSCOPEFIX ( )
		Case StringInStr ( $FIX , "BHO: " ) Or StringInStr ( $FIX , "BHO-x32: " )
			BHOFIX ( )
		Case StringInStr ( $FIX , "Toolbar: " )
			TOOLBARFIX ( )
		Case StringRegExp ( $FIX , "(?i)^Symlink: " )
			SYMLINK ( )
		Case StringInStr ( $FIX , "Task: {" )
			_BBBBT ( )
		Case StringRegExp ( $FIX , "(?i)Task.?Details:" )
			_TASKLISTD ( )
		Case StringRegExp ( $FIX , "(?i)Task: [c-z]:\\" )
			TASKSJOBFIX ( )
		Case StringInStr ( $FIX , "Winsock: Catalog" )
			WINSOCKFIX ( )
		Case StringInStr ( $FIX , "DPF: " )
			PDFFIX ( )
		Case StringInStr ( $FIX , "Winsock: -> Catalog" )
			If StringInStr ( $FIX , " Catalog5 " ) Then FileWrite ( @TempDir & "\catalog0" , "Catalog5 " )
			If StringInStr ( $FIX , " Catalog5-x64 " ) Then FileWrite ( @TempDir & "\catalog0" , "Catalog5-x64 " )
			If StringInStr ( $FIX , " Catalog9 " ) Then FileWrite ( @TempDir & "\catalog0" , "Catalog9 " )
			If StringInStr ( $FIX , " Catalog9-x64 " ) Then FileWrite ( @TempDir & "\catalog0" , "Catalog9-x64 " )
			FileWrite ( $HFIXLOG , $FIX & " => Winsock " & $RENUM & "." & @CRLF )
		Case StringInStr ( $FIX , "Handler: " ) Or StringInStr ( $FIX , "Handler-x32: " )
			HANDLERFIX ( )
		Case StringInStr ( $FIX , "Filter: " ) Or StringInStr ( $FIX , "Filter-x32: " )
			FILTERFIX ( )
		Case StringInStr ( $FIX , "ProxyEnable: " )
			PROXYENABLEFIX ( )
		Case StringInStr ( $FIX , "ProxyServer: " )
			PROXYSERVERFIX ( )
		Case StringInStr ( $FIX , "AutoConfigURL:" )
			AUTOCONFIGURLFIX ( )
		Case StringInStr ( $FIX , "DnsPolicyConfig:" )
			DNSPOLICYFIX ( )
		Case StringRegExp ( $FIX , "HKU\\.+\\MountPoints2:" )
			MOUNTPOINTS2FIX ( )
		Case StringRegExp ( $FIX , "(LowerFilters|UpperFilters): \[" )
			LUFILFIX ( )
		Case StringInStr ( $FIX , "StartMenuInternet: " )
			BROWSERSTARTFIX ( )
		Case StringRegExp ( $FIX , "^(?i)FF (Extension|ProfilePath|NetworkProxy|Homepage|NewTab|Extension|Plugin|SearchPlugin|user.js|Plugin-x32|Plugin HKU\\.+?|Plugin ProgramFiles/Appdata|ExtraCheck|Session Restore|NewTabOverride|HomepageOverride|Notifications):|Policies\\Mozilla\\Firefox:" )
			FIREFOXFIX ( )
		Case StringRegExp ( $FIX , "\AFF HK" )
			FIREFOXEXTENSIONREGFIX ( )
		Case StringRegExp ( $FIX , "^(?i)(CHR|BRA|VIV|YAN) (Custom_url|Notifications|crx|Profile|Session Restore|HomePage|RestoreOnStartup|StartupUrls|newtab|DefaultSearchKeyword|DefaultSearchProvider|DefaultSearchURL|DefaultSuggestURL|DefaultNewTabURL|HK(LM|U).+Extension): |Policies\\Google: " )
			CHROMEFIX ( )
		Case StringRegExp ( $FIX , "^(?i)OPR (StartupUrls|Session Restore|Notifications|DefaultSuggestURL|DefaultSearchKeyword|DefaultSearchURL):" )
			OPERAFIX ( )
		Case StringRegExp ( $FIX , "(?i)HKU\\.+\\Policies\\Explorer\\Run:" )
			DELETEUPOLICIESRUN ( )
		Case StringRegExp ( $FIX , "^(?i)Edge ((HomeButtonPage|Session Restore|Notifications|Notifications|crx|Profile|HomePage|RestoreOnStartup|StartupUrls|newtab|DefaultSearchKeyword|DefaultSearchURL|DefaultSuggestURL|DefaultNewTabURL):|Extension:.+->|HK(LM|U).+Extension)|Policies\\Microsoft\\Edge:" )
			EDGEFIX ( )
		Case StringRegExp ( $FIX , "(?i)IE Session Restore:" )
			IESESSIONFIX ( )
		Case StringRegExp ( $FIX , "(?i)HKU\\.+\\...\\Run:" )
			DELETEURUN ( )
		Case StringRegExp ( $FIX , "(?i)HKU\\.+\\RunOnce:" )
			DELETEURUNONCE ( )
		Case StringInStr ( $FIX , "HKLM-x32\...\Run:" )
			DELETERUN32 ( )
		Case StringInStr ( $FIX , "Replace:" )
			REPLACE ( )
		Case StringRegExp ( $FIX , "(?i)HKU\\.+\\Policies\\system:" )
			DELETEUPOLICIES ( )
		Case StringRegExp ( $FIX , "(?i)HKLM\\.+\\Policies\\system:" )
			LEGALNOTICE ( "HKLM\software\microsoft\windows\currentversion\policies\system" )
		Case StringRegExp ( $FIX , "(?i)Winlogon: \[(LegalNoticeCaption|LegalNoticeText)" )
			LEGALNOTICE ( "HKLM\" & $SOFTWARE & "\Microsoft\Windows NT\CurrentVersion\Winlogon" )
		Case StringRegExp ( $FIX , "(?i)(HKU\\.+|HKLM)\\(Software|Sortware)\\Policies\\...\\system:" )
			DELUPOLICIES ( )
		Case StringRegExp ( $FIX , "(?i)HKU.+\\Environment:" )
			ENVHIJFIX ( )
		Case StringRegExp ( $FIX , "(?i)HKU\\.+\\...\\FileExts\\.exe:" )
			DELETEUFILEEXTS ( )
		Case StringRegExp ( $FIX , "(?i)HKU\\.+\\...\\FileExts\\.exe\\OpenWithProgids:" )
			DELETEOPENWITHPROGIDS ( )
		Case StringInStr ( $FIX , "...\InprocServer32: [Default-wbemess]" )
			SETDEFWBEM ( )
		Case StringInStr ( $FIX , "D6A79037F57F\InprocServer32: [Default-fastprox]" )
			SETDEFWBEM7F ( )
		Case StringInStr ( $FIX , "26dfa299cadb\InprocServer32:" )
			SETDEFLOGONUI ( )
		Case StringInStr ( $FIX , "CustomCLSID:" )
			_CLSIDFIX ( )
		Case StringInStr ( $FIX , "ExportKey:" )
			_EXPKEY ( )
		Case StringInStr ( $FIX , "Exportvalue:" )
			_EXPVAL ( )
		Case StringInStr ( $FIX , "ChromeHTML:" )
			_CLSIDCHRFIX ( )
		Case StringRegExp ( $FIX , "t: \[COR_PROFILER" )
			_ENV1FIX ( )
		Case StringInStr ( $FIX , "\SYSTEM\...\Terminal Server:" )
			RESTOREVAL ( "HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server" , "fDenyTSConnections" , "REG_DWORD" , "1" )
		Case StringRegExp ( $FIX , "(FirewallRules|\\AuthorizedApplications|\\GloballyOpenPorts):" )
			_AAAFWFIX ( )
		Case StringRegExp ( $FIX , "(?i)^(Virusscan|Virustotal):" )
			_JOTTI ( )
		Case StringInStr ( $FIX , "RemoveProxy:" )
			REMOVEPROXY ( )
		Case StringInStr ( $FIX , "HKLM\...\.exe:" )
			SETDEFEXE ( )
		Case StringInStr ( $FIX , "exefile\DefaultIcon:" )
			SETDEFICON ( )
		Case StringInStr ( $FIX , "exefile\shell\open\command:" )
			SETDEFCOMEXE ( )
		Case StringInStr ( $FIX , "Explorer\FileExts\.exe:" )
			DELETEFILEEXTS ( )
		Case StringInStr ( $FIX , "HKLM\...\.reg:" )
			SETDEFREG ( )
		Case StringInStr ( $FIX , "regfile\DefaultIcon:" )
			SETDEFICONREG ( )
		Case StringInStr ( $FIX , "regfile\shell\open\command:" )
			SETDEFCOMREG ( )
		Case StringInStr ( $FIX , "HKLM\...\.bat:" )
			SETDEFBAT ( )
		Case StringInStr ( $FIX , "batfile\shell\DefaultIcon:" )
			SETDEFICONBAT ( )
		Case StringInStr ( $FIX , "batfile\shell\open\command:" )
			SETDEFCOMBAT ( )
		Case StringInStr ( $FIX , "HKLM\...\.cmd:" )
			SETDEFCMD ( )
		Case StringInStr ( $FIX , "cmdfile\DefaultIcon:" )
			SETDEFICONCMD ( )
		Case StringInStr ( $FIX , "cmdfile\shell\open\command:" )
			SETDEFCOMCMD ( )
		Case StringInStr ( $FIX , "HKLM\...\.com:" )
			SETDEFCOM ( )
		Case StringInStr ( $FIX , "comfile\DefaultIcon:" )
			SETDEFICONCOM ( )
		Case StringInStr ( $FIX , "comfile\shell\open\command:" )
			SETDEFCOMCOM ( )
		Case StringInStr ( $FIX , "HKLM\...\.scr:" )
			SETDEFSCR ( )
		Case StringInStr ( $FIX , "scrfile\shell\open\command:" )
			SETDEFCOMSCR ( )
		Case StringInStr ( $FIX , "\Systemrestore:" )
			POLICIESSR ( )
		Case StringRegExp ( $FIX , "(?i)HKU\\.+\\Policies\\Explorer:" )
			DELETEEPOLICIES ( )
		Case StringRegExp ( $FIX , "HKU\\.+?\\Software\\Classes\\[^\\]+?:" )
			_UASSOFIX ( )
		Case StringRegExp ( $FIX , "(?i)HKLM\\...\\Policies\\Explorer:" )
			DELETEEPOLICIESLM ( )
		Case StringRegExp ( $FIX , "(?i)HKU\\.+\\CurrentVersion\\Windows:" )
			DELETELOAD ( )
		Case StringRegExp ( $FIX , "(?i)HKU.+Winlogon: \[Userinit\]" )
			UUSERINIT ( )
		Case StringRegExp ( $FIX , "(?i)HKU.+Winlogon: \[Shell\]" )
			USHELL ( )
		Case StringInStr ( $FIX , "HKLM\...\RunOnce:" )
			DELETERUNONCE ( )
		Case StringInStr ( $FIX , "HKLM-x32\...\RunOnce:" )
			DELETERUNONCE32 ( )
		Case StringRegExp ( $FIX , "(?i)HKLM(|-x32)\\\.\.\.\\RunOnceEx\\[^\\]+?:" )
			DELETERUNONCEEX ( )
		Case StringInStr ( $FIX , "HKLM\...\RunServices:" )
			DELETERUNSERVICES ( )
		Case StringInStr ( $FIX , "HKLM\...\RunServicesOnce:" )
			DELETERUNSERVICESONCE ( )
		Case StringRegExp ( $FIX , "(?i)HKLM\\...\\Policies\\Explorer\\Run:" )
			POLICIESEEXP ( )
		Case StringRegExp ( $FIX , "(?i)HKU\\.+\\DisallowRun:" )
			DISALLOWRUNFIX ( )
		Case StringInStr ( $FIX , "DisallowedCertificates:" )
			CERTFIX ( )
		Case StringRegExp ( $FIX , "^(?i)Copy:" )
			_COPY ( )
		Case StringInStr ( $FIX , "DeleteQuarantine:" )
			DELETEQUARANTINE ( )
		Case StringRegExp ( $FIX , "(?i)Tcpip\\Parameters: \[(NameServer|DhcpNameServer)\]" )
			DELETENAMESERVER ( )
		Case StringInStr ( $FIX , "Tcpip\..\Interfaces\" )
			DELETEINTERFACES ( )
		Case StringInStr ( $FIX , "RegKey: [HKU\" )
			REGKEYFIX ( )
		Case StringInStr ( $FIX , "IFEO\" )
			DELETEIFEOS ( )
		Case StringRegExp ( $FIX , "HKLM\\...\\SilentProcessExit\\[^:]+:" )
			SILENTPROCESSEXIT ( )
		Case StringInStr ( $FIX , "IFEO:" )
			DELETEIFEO ( )
		Case StringRegExp ( $FIX , "(?i)^[SRU]\d .+;" )
			DELSERVICE ( )
		Case StringInStr ( $FIX , "DisableService:" )
			DISABLE ( )
		Case StringRegExp ( $FIX , "(?i)\bPowershell:" )
			POWERSHELL ( )
		Case StringInStr ( $FIX , "StartPowershell:" )
			POWERSHELLS ( $YY )
		Case StringInStr ( $FIX , "CreateDummy:" )
			DUM ( )
		Case StringInStr ( $FIX , "HKLM\...\Winlogon: [Userinit]" )
			USERINIT ( )
		Case StringInStr ( $FIX , "HKLM\...\AppCertDlls:" )
			APPCERTFIX ( )
		Case StringRegExp ( $FIX , "(?i)HKLM-x32\\...\\Winlogon: \[Userinit\]" )
			USERINIT32 ( )
		Case StringRegExp ( $FIX , "(?i)AppInit_DLLs:" )
			APPINITFIX ( )
		Case StringRegExp ( $FIX , "(?i)AppInit_DLLs-x32:" )
			APPINITFIX ( 1 )
		Case StringRegExp ( $FIX , "(?i)SecurityProviders:" )
			SECPRO ( )
		Case StringRegExp ( $FIX , "Version: .*-.*\) Hidden" )
			UNHIDEP ( )
		Case StringRegExp ( $FIX , "(?i)\A\([^\(]*\) .+" )
			KRP ( )
		Case StringRegExp ( $FIX , "(?i)^(SysWOW64\\|)GroupPolicy.*?:" )
			GPOL ( )
		Case StringInStr ( $FIX , "\NTUSER.pol:" )
			NTPOL ( )
		Case StringInStr ( $FIX , "HKLM\Software\Microsoft\Windows defender:" )
			$KEY = "HKLM\SOFTWARE\Microsoft\Windows Defender"
			If StringInStr ( $FIX , "DisableAntiSpyware" ) Then RESTOREVAL ( $KEY , "DisableAntiSpyware" , "REG_DWORD" , "0" )
			If StringInStr ( $FIX , "DisableAntiVirus" ) Then RESTOREVAL ( $KEY , "DisableAntiVirus" , "REG_DWORD" , "0" )
		Case StringInStr ( $FIX , "IPSecPolicy:" )
			DELVALUE ( "HKLM\SOFTWARE\Policies\Microsoft\Windows\IPSec\Policy\Local" , "ActivePolicy" )
		Case StringInStr ( $FIX , "Internet Settings: [ProxySettingsPerUser]" )
			DELVALUE ( "HKLM\SOFTWARE\Policies\Microsoft\Windows\CurrentVersion\Internet Settings" , "ProxySettingsPerUser" )
		Case StringRegExp ( $FIX , "(?i)Policies\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Zones\\\d:" )
			$KEY = StringRegExpReplace ( $FIX , "(.+\\Zones\\\d).*" , "$1" )
			DELKEY ( $KEY )
		Case StringRegExp ( $FIX , "ShortcutWithArgument:|Shortcut:" )
			SHORTCF ( )
		Case StringRegExp ( $FIX , "(?i)Remove(Directory|Folder):" )
			$FILE = StringRegExpReplace ( $FIX , "(?i)Remove(?:Directory|Folder):\s*(.+)" , "$1" )
			$FILE = StringRegExpReplace ( $FILE , "^""|""$" , "" )
			If Not FileExists ( $FILE ) Then
				NFOUND ( $FILE )
			Else
				_BBBBRD ( $FILE )
			EndIf
		Case StringRegExp ( $FIX , "(?i)DeleteFile:" )
			$PATH1 = StringRegExpReplace ( $FIX , "(?i)DeleteFile:[ ]*(.+)" , "$1" )
			$PATH1 = StringRegExpReplace ( $PATH1 , "^""|""$" , "" )
			If Not FileExists ( "\\?\" & $PATH1 ) Then
				NFOUND ( $PATH1 )
			Else
				_BBBBDF ( $PATH1 )
			EndIf
		Case StringRegExp ( $FIX , "(?i)HKLM\\...\\Winlogon: \[System|Taskman\]" )
			WINLOGONSYS ( )
		Case StringRegExp ( $FIX , "(?i)HKLM\\...\\Winlogon: \[Shell\]" )
			SHELL ( )
		Case StringRegExp ( $FIX , "(?i)HKLM-x32\\...\\Winlogon: \[Shell\]" )
			SHELL32 ( )
		Case StringRegExp ( $FIX , "(?i)Lsa: \[Notification Packages\]" )
			LSAN ( )
		Case StringRegExp ( $FIX , "(?i)Lsa: \[Authentication Packages\]" )
			LSAA ( )
		Case StringRegExp ( $FIX , "NETSVC:" )
			NETSVCFIX ( )
		Case StringRegExp ( $FIX , "NETSVCx32:" )
			NETSVCFIX32 ( )
		Case StringRegExp ( $FIX , "(?i)MSCONFIG\\(startupreg|Services|startupfolder):|StartupApproved\\(Run|Run32|startupfolder):" )
			MSCONFIGFIX ( )
		Case StringRegExp ( $FIX , "(?i)^Folder:" )
			FOLDER ( )
		Case StringInStr ( $FIX , "FindFolder:" )
			FINDFOLDER ( )
		Case StringRegExp ( $FIX , "(?i)^File:" )
			FILE ( )
		Case StringRegExp ( $FIX , "(?i)list\s*permissions?:" )
			_LP ( )
		Case StringRegExp ( $FIX , "(?i)^(delete\s*key:|\[-HK)" )
			DELKEY ( )
		Case StringRegExp ( $FIX , "(?i)delete\s*value:" )
			DELETEVALUE ( )
		Case StringRegExp ( $FIX , "(?i)HKLM\\.+\\\.\.\.\\AppCompatFlags\\[^\\]+\\[^:]+:" )
			SHIMFIX ( )
		Case StringInStr ( $FIX , "ManualProxies:" )
			REMOVEPROXYCHECK ( "HKLM\SYSTEM\CurrentControlSet\services\NlaSvc\Parameters\Internet\ManualProxies" , "" , 1 )
		Case StringRegExp ( $FIX , "(?i)HKLM\\.+?\\Parameters\\PersistentRoutes:" )
			PERROUT ( )
		Case StringInStr ( $FIX , "InvalidSubkeyName:" )
			INVALIDSUBKEYNAMEFIX ( )
		Case StringRegExp ( $FIX , "(?i)LastRegBack:" )
			RESTOREHIVES ( )
		Case StringRegExp ( $FIX , "(?i)CreateRestorePoint:" )
			If $BOOTM <> "normal" Then
				FileWrite ( $HFIXLOG , $ERR0 & ": " & $NRP & @CRLF )
			Else
				GUICtrlSetData ( $LABEL1 , $CRRP & " " & $PW0 )
				If $OSNUM > 6.1 Then
					RegWrite ( "HKLM\Software\Microsoft\Windows NT\CurrentVersion\SystemRestore" , "SystemRestorePointCreationFrequency" , "REG_DWORD" , 0 )
					If @error Then FileWrite ( $HFIXLOG , "CreateRestorePoint: " & $ERRSV & @CRLF )
				EndIf
				$RET = RESTOREPOINTCREATE ( )
				If @error Then
					FileWrite ( $HFIXLOG , "CreateRestorePoint: " & $ERR0 & "(" & @error & "=" & $RET & ") -> " & $CRRPN & @CRLF )
				Else
					FileWrite ( $HFIXLOG , $YRP & @CRLF )
				EndIf
				GUICtrlSetData ( $LABEL1 , $FIX1 & " " & $PW0 )
			EndIf
		Case StringRegExp ( $FIX , "(?i)SystemRestore:\s*(On|Off)" )
			_SR ( )
		Case StringRegExp ( $FIX , "(?i)ShellIconOverlayIdentifiers(|-x32):|ContextMenuHandlers\d(|_.+?|-x32):" )
			SIOIFIX ( )
		Case StringRegExp ( $FIX , "(?i)(FolderExtensions(|_.+?)):" )
			FOLDEREXFIX ( )
		Case StringRegExp ( $FIX , "(?i)Restore\s*From\s*Backup:" )
			RESTOREHIVE ( )
		Case StringRegExp ( $FIX , "(?i)Restore\s*From\s*HiveBackup:" )
			RESTOREHIVEBACKUP ( )
		Case StringInStr ( $FIX , "Move:" )
			MOVE ( )
		Case StringRegExp ( $FIX , "(?i)Unlock:\s*""?[c-z]:" )
			_UNLOCKFILE ( )
		Case StringRegExp ( $FIX , "(?i)SetDefaultFilePermissions:[ ]*""?[c-z]:" )
			_SETDEFAULTFILEPERMS ( )
		Case StringRegExp ( $FIX , "(?i)Unlock:\s*""?hk" )
			_UNLOCKREG ( )
		Case StringRegExp ( $FIX , "(?i)SubSystems: \[W" )
			SUBFIX ( )
		Case StringRegExp ( $FIX , "(?i)Restore\s*Quarantine:" )
			RESQUAR ( )
		Case StringRegExp ( $FIX , "^[^\(]+ \(S-1.+\d - (Administrator|Limited) - (Disabled|Enabled)\)" )
			DELACC ( )
		Case StringInStr ( $FIX , "testsigning:" )
			FIXBCD ( "bcdedit /deletevalue {default} testsigning" )
		Case StringInStr ( $FIX , "testsigning on:" )
			FIXBCD ( "bcdedit /set {default} testsigning on" )
		Case StringInStr ( $FIX , "safeboot:" )
			FIXBCD ( "bcdedit /deletevalue {default} safeboot" )
		Case StringInStr ( $FIX , "SaveMBR: Drive=" )
			Local $DRV
			$DRV = StringRegExpReplace ( $FIX , "(?i).+Drive=(\d[\d]*).*" , "$1" )
			If FileExists ( @ScriptDir & "\MBRDUMP.txt" ) Then FileDelete ( @ScriptDir & "\MBRDUMP.txt" )
			FileWrite ( @ScriptDir & "\MBRDUMP.txt" , SAVEMBR ( "\\.\PhysicalDrive" & $DRV ) )
			If FileExists ( @ScriptDir & "\MBRDUMP.txt" ) And FileGetSize ( @ScriptDir & "\MBRDUMP.txt" ) = 512 Then
				FileWrite ( $HFIXLOG , "MBRDUMP.txt " & $MBR0 & @CRLF )
			Else
				FileWrite ( $HFIXLOG , "MBRDUMP.txt " & $MBR1 & @CRLF )
			EndIf
		Case StringInStr ( $FIX , "RestoreMbr: Drive=" )
			$DRV = StringRegExpReplace ( $FIX , "(?i).+Drive=(\d[\d]*).*" , "$1" )
			If Not FileExists ( @ScriptDir & "\MbrFix64.exe" ) Then
				FileWrite ( $HFIXLOG , "MbrFix64 utility not found on the location FRST64 is saved." & @CRLF )
			Else
				If FileExists ( @ScriptDir & "\MBR.bin" ) Then
					FileCopy ( @ScriptDir & "\MbrFix64.exe" , @SystemDir )
					FileCopy ( @ScriptDir & "\MbrFix64.exe" , $WINDOWSDIR )
					RunWait ( @ComSpec & " /c " & "MbrFix64 /drive " & $DRV & " restorembr " & """" & @ScriptDir & "\MBR.bin"" /yes " , "" , @SW_HIDE )
					FileDelete ( @ScriptDir & "\MBR.bin" )
				Else
					NFOUND ( @ScriptDir & "\MBR.bin" )
				EndIf
			EndIf
		Case StringRegExp ( $FIX , "(?i)^(start|end):*$" )
	Case Else
			If $FIX <> "" Then FileWrite ( $HFIXLOG , $FIX & " => " & $ERR0 & ": " & $NOFIXENTRY & @CRLF )
		EndSelect
		$YY += 1
	WEnd
	$KEY1 = "HKLM\SYSTEM\CurrentControlSet\Services\WinSock2\Parameters\"
	If StringInStr ( FileRead ( @TempDir & "\catalog0" ) , "Catalog5 " ) Then
		$KEY = $KEY1 & "NameSpace_Catalog5\Catalog_Entries\"
		RESETCATALOG ( $KEY )
		$I = 1
		While 1
			RegEnumKey ( $KEY , $I )
			If @error Then ExitLoop
			$I += 1
		WEnd
		RegWrite ( $KEY1 & "NameSpace_Catalog5" , "Num_Catalog_Entries" , "REG_DWORD" , $I + 4294967295 )
	EndIf
	If StringInStr ( FileRead ( @TempDir & "\catalog0" ) , "Catalog9 " ) Then
		$KEY = $KEY1 & "Protocol_Catalog9\Catalog_Entries\"
		RESETCATALOG ( $KEY )
		$I = 1
		While 1
			RegEnumKey ( $KEY , $I )
			If @error Then ExitLoop
			$I += 1
		WEnd
		RegWrite ( $KEY1 & "Protocol_Catalog9" , "Num_Catalog_Entries" , "REG_DWORD" , $I + 4294967295 )
	EndIf
	If StringInStr ( FileRead ( @TempDir & "\catalog0" ) , "Catalog5-x64 " ) Then
		$KEY = $KEY1 & "NameSpace_Catalog5\Catalog_Entries64\"
		RESETCATALOG ( $KEY )
		$I = 1
		While 1
			RegEnumKey ( $KEY , $I )
			If @error Then ExitLoop
			$I += 1
		WEnd
		RegWrite ( $KEY1 & "NameSpace_Catalog5" , "Num_Catalog_Entries64" , "REG_DWORD" , $I + 4294967295 )
	EndIf
	If StringInStr ( FileRead ( @TempDir & "\catalog0" ) , "Catalog9-x64 " ) Then
		$KEY = $KEY1 & "Protocol_Catalog9\Catalog_Entries64\"
		RESETCATALOG ( $KEY )
		$I = 1
		While 1
			RegEnumKey ( $KEY , $I )
			If @error Then ExitLoop
			$I += 1
		WEnd
		RegWrite ( $KEY1 & "Protocol_Catalog9" , "Num_Catalog_Entries64" , "REG_DWORD" , $I + 4294967295 )
	EndIf
	FileDelete ( @TempDir & "\catalog0" )
	If $EMPTEMP Then EMPTYTEMP ( )
	If $BOOTM = "Recovery" Then
		FileClose ( $HFIXLOG )
		$HFIXLOG = FileOpen ( @ScriptDir & "\Fixlog.txt" , 256 )
		$TEMP = FileRead ( $HFIXLOG )
		$TEMP = _RMTON ( $TEMP )
		FileClose ( $HFIXLOG )
		$HTMPFIX = FileOpen ( @ScriptDir & "\Fixlog.txt" , 2 + 256 )
		FileWrite ( $HTMPFIX , $TEMP )
		FileWrite ( $HTMPFIX , @CRLF & "==== " & $END & " " & $OF & " Fixlog " & @HOUR & ":" & @MIN & ":" & @SEC & " ====" )
		FileClose ( $HTMPFIX )
		RunWait ( @ComSpec & " /c reg unload hklm\999" , "" , @SW_HIDE )
		RunWait ( @ComSpec & " /c reg unload hklm\888" , "" , @SW_HIDE )
		$CDATE = @MDAY & "-" & @MON & "-" & @YEAR & " " & @HOUR & "." & @MIN & "." & @SEC
		FileCopy ( @ScriptDir & "\Fixlog.txt" , $C & "\FRST\Logs\Fixlog_" & $CDATE & ".txt" )
	EndIf
	GUICtrlSetData ( $BUTTONFIX , $FIXB )
	GUICtrlDelete ( $PROGRESS )
	GUICtrlSetData ( $LABEL1 , "" )
	FileDelete ( @ScriptDir & $FIXLIST )
	ClipPut ( "." )
	If $BOOTM <> "Recovery" Then
		If FileExists ( $C & "\frst\files" ) Or FileExists ( $C & "\frst\filesRem" ) Or FileExists ( $C & "\frst\keysRem" ) Then
			FileDelete ( $C & "\frst\re" )
			REBOOT ( )
			Shutdown ( 6 )
		Else
			If FileExists ( $C & "\frst\re" ) Then
				FileWrite ( $HFIXLOG , @CRLF & @CRLF & $REBOOT1 & @CRLF & @CRLF & "==== " & $END & " " & $OF & " Fixlog " & @HOUR & ":" & @MIN & ":" & @SEC & " ====" )
				FileDelete ( $C & "\frst\re" )
				MsgBox ( 262144 + 0 , $FRST , $FIX10 & " ""Fixlog.txt"" " & $COMPLETED & @CRLF & @CRLF & $REBOOT2 & @CRLF & $REBOOT3 )
				FileClose ( $HFIXLOG )
				Shutdown ( 6 )
			Else
				FileWrite ( $HFIXLOG , @CRLF & "==== " & $END & " " & $OF & " Fixlog " & @HOUR & ":" & @MIN & ":" & @SEC & " ====" )
				MsgBox ( 262144 + 0 , $FRST , $FIX10 & " ""Fixlog.txt"" " & $COMPLETED )
				FileClose ( $HFIXLOG )
				Run ( "notepad """ & @ScriptDir & "\Fixlog.txt""" )
			EndIf
			$CDATE = @MDAY & "-" & @MON & "-" & @YEAR & " " & @HOUR & "." & @MIN & "." & @SEC
			FileCopy ( @ScriptDir & "\Fixlog.txt" , $C & "\FRST\Logs\Fixlog_" & $CDATE & ".txt" )
		EndIf
	Else
		MsgBox ( 262144 + 0 , $FRST , $FIX10 & " ""Fixlog.txt"" " & $COMPLETED )
		Run ( "notepad """ & @ScriptDir & "\Fixlog.txt""" )
	EndIf
EndFunc
Func FLUSHDNS ( )
	$RET = DllCall ( "dnsapi.dll" , "BOOL" , "DnsFlushResolverCache" )
	If Not @error Then Return $RET [ 0 ]
EndFunc
Func FIXCATALOG5 ( $KEY , $VAL )
	Local $RET
	$RET = RegWrite ( $KEY & $VAL , "LibraryPath" , "REG_SZ" , $LP )
	Select
	Case $RET = 1
		If StringInStr ( $FIX , "Winsock: Catalog5 " ) Then FileWrite ( $HFIXLOG , "Winsock: Catalog5 " & $VAL & "\\LibraryPath => " & $RESTORED & " (" & $LP & ")" & @CRLF )
		If StringInStr ( $FIX , "Winsock: Catalog5-x64" ) Then FileWrite ( $HFIXLOG , "Winsock: Catalog5-x64 " & $VAL & "\\LibraryPath => " & $RESTORED & " (" & $LP & ")" & @CRLF )
	Case $RET = 0
		FileWrite ( $HFIXLOG , $KEY & $VAL & "\\LibraryPath => " & $ERRSV & @CRLF )
	EndSelect
EndFunc
Func FOLDER ( )
	FileWrite ( $HFIXLOG , @CRLF & "========================= " & $FIX & " ========================" & @CRLF & @CRLF )
	$FOLDER = StringRegExpReplace ( $FIX , "(?i)Folder:\s*(.+)" , "$1" )
	$FOLDER = StringRegExpReplace ( $FOLDER , "^""|\s+$|""$" , "" )
	$FOLDER = StringRegExpReplace ( $FOLDER , "\\$" , "" )
	If Not FileExists ( $FOLDER ) Then
		FileWrite ( $HFIXLOG , $NFOUND & "." & @CRLF )
		Return FOLDER0 ( )
	EndIf
	If Not StringInStr ( FileGetAttrib ( $FOLDER ) , "D" ) Then
		FileWrite ( $HFIXLOG , $FOLDER & " = " & $FIL0 & @CRLF )
		Return FOLDER0 ( )
	EndIf
	If _CREATEFILE ( $FOLDER ) Then
		FileWrite ( $HFIXLOG , $NOACC & @CRLF )
		Return FOLDER0 ( )
	EndIf
	$FOLARR = _FILELISTTOARRAYREC ( $FOLDER , "*" , 0 , 1 , 1 , 2 )
	For $A = 1 To UBound ( $FOLARR ) + 4294967295
		GUICtrlSetData ( $LABEL1 , $SCANB & " " & $FOLDER & " : " & $FOLARR [ $A ] )
		$FATT = FileGetAttrib ( $FOLARR [ $A ] )
		If _REPARSEPOINT ( $FOLARR [ $A ] ) Then $FATT = $FATT & "L"
		$ATT = StringFormat ( "%05s" , $FATT )
		$ATTS = StringRegExpReplace ( $ATT , "0" , "_" )
		$SIZE = FileGetSize ( $FOLARR [ $A ] )
		$SIZES = StringFormat ( "%09u" , $SIZE )
		$DATECR = FILETIME ( $FOLARR [ $A ] , 1 )
		$DATEMO = FILETIME ( $FOLARR [ $A ] )
		If _CREATEFILE ( $FOLARR [ $A ] ) Then
			$VER = $NOACC
		Else
			$VER = FileGetVersion ( $FOLARR [ $A ] , "CompanyName" )
		EndIf
		$VER = StringRegExpReplace ( $VER , "\s+" , " " )
		$COMPANY = ""
		If StringInStr ( FileGetAttrib ( $FOLARR [ $A ] ) , "D" ) Then
			$HASH = "00000000000000000000000000000000"
			$COMPANY = " (" & $VER & ")"
		Else
			$HASH = MD5 ( $FOLARR [ $A ] )
			If Not $HASH Then $HASH = "00000000000000000000000000000000"
			If StringRegExp ( $FOLARR [ $A ] , "(?i)\.(dll|exe|sys|mui)$" ) Then
				COMP ( $FOLARR [ $A ] )
			Else
				$COMPANY = " (" & $VER & ")"
			EndIf
		EndIf
		FileWrite ( $HFIXLOG , $DATECR & " - " & $DATEMO & " - " & $SIZES & " " & $ATTS & " [" & $HASH & "]" & $COMPANY & " " & $FOLARR [ $A ] & @CRLF )
	Next
	GUICtrlSetData ( $LABEL1 , "" )
	FOLDER0 ( )
EndFunc
Func FOLDER0 ( )
	FileWrite ( $HFIXLOG , @CRLF & "====== " & $END & " " & $OF & " Folder: ======" & @CRLF & @CRLF )
EndFunc
Func FOLDEREX ( $HIVE , $KEY )
	$HKEY = _REGOPENKEYEX3 ( $KEY )
	$I = 0
	While 1
		$COMPANY = ""
		$CDATE = ""
		$CLSID = __REGENUMKEY ( $HKEY , $I )
		If @error Then ExitLoop
		$VALN = RegRead ( "HKCR\CLSID\" & $CLSID , "" )
		$PATH = RegRead ( "HKCR\CLSID\" & $CLSID & "\InprocServer32" , "" )
		If Not @error Then
			If StringInStr ( $PATH , "mscoree.dll" ) Then MSCOREE ( "HKCR\CLSID\" & $CLSID & "\InprocServer32" , $PATH )
			$FILE = $PATH
			AAAAFP ( )
			If Not FileExists ( $FILE ) Then
				$FILE = $PATH & " -> " & $REGIST8
			Else
				$CDATE = " [" & $CDATE & "]"
			EndIf
		EndIf
		If Not StringRegExp ( $FILE , "(?i)WINDOWS\\system32\\shell32\.dll" ) And Not StringRegExp ( $COMPANY , "(?i)Microsoft Corporation" ) Then _ARRAYADD ( $ARRCLSID , $HIVE & ": [" & $VALN & "] -> " & $CLSID & " => " & $FILE & $CDATE & $COMPANY , 0 , "||||" )
		$I += 1
	WEnd
	If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
EndFunc
Func FOLDEREXFIX ( )
	$USER = ""
	$CLSID = StringRegExpReplace ( $FIX , "(?i).+?: .+ -> (.+) =>.*" , "$1" )
	$KEY = "HKLM\SOFTWARE\Classes\Drive\shellex\FolderExtensions\" & $CLSID
	$KEY1 = "HKLM\Software\Classes\CLSID\" & $CLSID
	If StringRegExp ( $FIX , "FolderExtensions_" ) Then
		$USER = StringRegExpReplace ( $FIX , "FolderExtensions_([^:]+):.+" , "$1" )
		$KEY = "HKU\" & $USER & "\SOFTWARE\Classes\Drive\shellex\FolderExtensions\" & $CLSID
		$KEY1 = "HKU\" & $USER & "\SOFTWARE\Classes\CLSID\" & $CLSID
	EndIf
	DELKEY ( $KEY )
	If VAR ( $KEY1 , 1 ) Then DELKEY ( $KEY1 )
EndFunc
Func GETFILELIST ( $FOLDER )
	If Not FileExists ( $FOLDER ) Then Return 1
	Local $DATEC , $DATECR , $DATEM , $DATEMO , $ATT , $ATTS , $SIZES , $VER , $IDATECALCC , $IDATECALCM
	$FILEARRAY = _FILELISTTOARRAY ( $FOLDER , "*" , 0 , True )
	If Not IsArray ( $FILEARRAY ) Then Return 1
	$DAYSOLD = 31
	If GUICtrlRead ( $CHECKBOX14 ) = 1 Then $DAYSOLD = 91
	For $I = 1 To UBound ( $FILEARRAY ) + 4294967295
		GUICtrlSetData ( $LABEL1 , $SCANB & " " & $FIL1 & $AND1 & $FOL1 & ": " & $FILEARRAY [ $I ] )
		If GUICtrlRead ( $CHECKBOX12 ) = 1 And $BOOTM <> "Recovery" Then
			$ADS = _ADS_LIST_NTQUERY ( $FILEARRAY [ $I ] )
			For $D = 0 To UBound ( $ADS ) + 4294967295
				If Not StringRegExp ( $ADS [ $D ] , "(?i):(\${3D0CE612-FDEE-43f7-8ACA-957BEC0CCBA0}\..*|SmartScreen|Zone.Identifier|encryptable|favicon|ms-properties|OECustomProperty|Win32App.*)$" ) Then _ARRAYADD ( $ADS000 , $FILEARRAY [ $I ] & $ADS [ $D ] , 0 , "||||" )
			Next
		EndIf
		If Not _REPARSEPOINT ( $FILEARRAY [ $I ] ) And _CREATEFILE ( $FILEARRAY [ $I ] ) Then
			If Not StringRegExp ( $FILEARRAY [ $I ] , "(?i):\\(Recovery|hiberfil.sys|System (Recovery|Repair|Volume Information)|WINDOWS\\CSC|OSRSS|WINDOWS\\system32\\(WebThreatDefSvc|config\\BFS))$" ) Then
				$DATEMO = FILETIME ( $FILEARRAY [ $I ] )
				_ARRAYADD ( $LOCKED , $DATEMO & " " & $FILEARRAY [ $I ] , 0 , "||||" )
			EndIf
		EndIf
		If GUICtrlRead ( $CHECKBOX5 ) = 1 And $BOOTM <> "Recovery" Then
			If StringRegExp ( $FILEARRAY [ $I ] , "(?i)\.(exe|dll)$" ) And Not StringInStr ( FileGetAttrib ( $FILEARRAY [ $I ] ) , "D" ) And _CHECKSIG ( $FILEARRAY [ $I ] ) <> 11 Then
				$DATECR = FILETIME ( $FILEARRAY [ $I ] , 1 )
				$DATEMO = FILETIME ( $FILEARRAY [ $I ] )
				$FATT = FileGetAttrib ( "\\?\" & $FILEARRAY [ $I ] )
				$FATT = StringRegExpReplace ( $FATT , "A" , "" )
				If _REPARSEPOINT ( $FILEARRAY [ $I ] ) Then $FATT = $FATT & "L"
				$ATT = StringFormat ( "%05s" , $FATT )
				$ATTS = StringRegExpReplace ( $ATT , "0" , "_" )
				$SIZE = FileGetSize ( "\\?\" & $FILEARRAY [ $I ] )
				$SIZES = StringFormat ( "%09u" , $SIZE )
				$VER = FileGetVersion ( $FILEARRAY [ $I ] , "CompanyName" )
				If Not @error Then
					$VER = StringRegExpReplace ( $VER , "(?i)http(s|):" , "hxxp\1:" )
					$VER = StringRegExpReplace ( $VER , "\s+" , " " )
					$VER = StringRegExpReplace ( $VER , "\|" , "/" )
					$VER = "(" & $VER & ") "
				EndIf
				_ARRAYADD ( $UNSIG , $DATECR & " - " & $DATEMO & " - " & $SIZES & " " & $ATTS & " " & $VER & $FILEARRAY [ $I ] , 0 , "||||" )
			EndIf
		EndIf
		$DATEC = FileGetTime ( "\\?\" & $FILEARRAY [ $I ] , 1 )
		If Not @error Then
			$IDATECALCC = _DATEDIFF ( "d" , $DATEC [ 0 ] & "/" & $DATEC [ 1 ] & "/" & $DATEC [ 2 ] , _NOWCALC ( ) )
			Select
			Case $IDATECALCC < $DAYSOLD Or $DATEC [ 0 ] > @YEAR
				Select
				Case StringRegExp ( $FILEARRAY [ $I ] , "(?i):.*\\((My |)(Documents|Videos|Music|Pictures)|Startup|localtemp|Application Data|Recovery|restore|RasToast|AppPatch|AppData|Application Data|Apps|assembly|Boot|bootstat.dat|catroot|CatRoot2|CodeIntegrity|Programs\\(Maintenance|Administrative Tools|Accessories|Tablet PC|System Tools|Accessibility|Windows PowerShell)|Cookies|Common Files|config(|\.Msi)|components|components.log)$" )
					ContinueLoop
				Case StringRegExp ( $FILEARRAY [ $I ] , "(?i):.*\\(config\\(Software|Software.log|SYSTEM|SysEvent.Evt|SecEvent.Evt|AppEvent.Evt|default|systemprofile|regback|TxR|OSession.evt|Security|SAM)$" )
					ContinueLoop
				Case StringRegExp ( $FILEARRAY [ $I ] , "(?i):.*\\(Speech_OneCore|Speech|InstallShield|Licenses|DriverStore|fr-(?:ca|fr)|bg-BG|ar-SA|pl-PL|spp|hr-HR|he-IL|ro-RO|sl-SI|sk-SK|\\SMI|networklist|MSDRM|WindowsPowerShell|sr-Latn-(RS|CS)|sppui|sru|et-EE|es-MX|en-GB|lv-LV|lt-LT|tr-TR|th-TH|zh-HK|History|hosts|hu-HU|IconCache.db|Identities|Installer|Internet Explorer|it-IT|ja-JP|ko-KR|Links|Local|LocalLow|Local Settings|Logs|LogFiles|log.*?\.txt|Low|Microsoft|Microsoft.NET|migration|ms-MY)$" )
					ContinueLoop
				Case StringRegExp ( $FILEARRAY [ $I ] , "(?i):.*\\(?:DriverStore|Contacts|uk-UA|cs-CZ|da-DK|de-DE|Desktop|Diagnostics|Local\\Temp|Downloads|drivers|DRVSTORe|ehome|etc|el-GR|en-US|es-ES|Favorites|fi-FI|Fonts|.*?\.(?:inf|png|doc|docx|gif|ico|tag|jpg|mp3|log\d*|blf|rtf|tm|TxR|regtrans-ms)|debug|desktop\.ini)$" )
					ContinueLoop
				Case StringRegExp ( $FILEARRAY [ $I ] , "(?i):\\(hiberfil.sys|pagefile.sys|ProgramData|Users\\Default|Program Files(|\(x86\))|RECYCLER|System Volume Information|.Recycle.Bin|perfLogs|ProgramData\\Microsoft Help|Windows|windows\\(System32|SysWOW64|temp)|Users)$" )
					ContinueLoop
				Case StringRegExp ( $FILEARRAY [ $I ] , "(?i):.*\\(Start Menu|sv-SE|Sysbckup|System32\\(?:en|OEM)|swapfile.sys|SYSTEM.LOG.*?|SysWOW64\\en|Templates|Temporary Internet Files|Tasks|twain_32|UMDF|Uninstall Information|user|Users|wbem|Webcam|wfp|Windows Media Player|winsxs|Windows Mail|Wat|wdi|zh-TW|zh-CN)$" )
					ContinueLoop
				Case StringRegExp ( $FILEARRAY [ $I ] , "(?i):.*\\(nb-NO|nl-NL|NetHood|NTUSER.DAT.*?|ntuser.dat.LOG1|\.pdf|perf.009.dat|Prefetch|PrintHood|Profiles|Programs|pl-PL|pt-BR|pt-PT|Public|Recent|\.regtrans-ms|Roaming|\.rfx|ru-RU|SAM.LOG.*?|Saved Games|Searches|SECURITY.LOG.*?|SendTo|SoftwareDistribution|SOFTWARE.LOG.*?)$" )
					ContinueLoop
				Case StringRegExp ( $FILEARRAY [ $I ] , "(?i)\.([a-z]{3}|ax)$" ) And GUICtrlRead ( $CHECKBOX15 ) = 1 And _CHECKSIG ( $FILEARRAY [ $I ] ) = 11 And ( StringRegExp ( FileGetVersion ( $FILEARRAY [ $I ] , "CompanyName" ) , "^Microsoft" ) Or StringRegExp ( _CHECKSIG ( $FILEARRAY [ $I ] , 1 ) , "^Microsoft" ) )
					ContinueLoop
				EndSelect
				If $DATEC [ 0 ] > 2099 Then $DATEC [ 0 ] = 2099
				If $DATEC [ 1 ] > 12 Then $DATEC [ 1 ] = 12
				If $DATEC [ 2 ] > 31 Then $DATEC [ 2 ] = 31
				$DATECR = $DATEC [ 0 ] & "-" & $DATEC [ 1 ] & "-" & $DATEC [ 2 ] & " " & $DATEC [ 3 ] & ":" & $DATEC [ 4 ]
				$DATEMO = FILETIME ( $FILEARRAY [ $I ] )
				$FATT = FileGetAttrib ( "\\?\" & $FILEARRAY [ $I ] )
				$FATT = StringRegExpReplace ( $FATT , "A" , "" )
				If _REPARSEPOINT ( $FILEARRAY [ $I ] ) Then $FATT = $FATT & "L"
				$ATT = StringFormat ( "%05s" , $FATT )
				$ATTS = StringRegExpReplace ( $ATT , "0" , "_" )
				$SIZE = FileGetSize ( "\\?\" & $FILEARRAY [ $I ] )
				$SIZES = StringFormat ( "%09u" , $SIZE )
				$VER = FileGetVersion ( "\\?\" & $FILEARRAY [ $I ] , "CompanyName" )
				If Not @error Then
					$VER = StringRegExpReplace ( $VER , "(?i)http(s|):" , "hxxp\1:" )
					$VER = StringRegExpReplace ( $VER , "\s+" , " " )
					$VER = StringRegExpReplace ( $VER , "\|" , "/" )
					$VER = "(" & $VER & ") "
				EndIf
				_ARRAYADD ( $ARRAY1C , $DATECR & " - " & $DATEMO & " - " & $SIZES & " " & $ATTS & " " & $VER & $FILEARRAY [ $I ] , 0 , "||||" )
		Case Else
				$DATEM = FileGetTime ( "\\?\" & $FILEARRAY [ $I ] , 0 )
				If Not @error Then
					$IDATECALCM = _DATEDIFF ( "d" , $DATEM [ 0 ] & "/" & $DATEM [ 1 ] & "/" & $DATEM [ 2 ] , _NOWCALC ( ) )
					If $IDATECALCM < 31 Or $DATEM [ 0 ] > @YEAR Then
						Select
						Case StringRegExp ( $FILEARRAY [ $I ] , "(?i).*\\((My |)(Documents|Videos|Music|Pictures)|Startup|localtemp|Application Data|Recovery|restore|RasToast|AppPatch|AppData|Application Data|Apps|assembly|Boot|bootstat.dat|catroot|CatRoot2|CodeIntegrity|Programs\\(Maintenance|Administrative Tools|Accessories|Tablet PC|System Tools|Accessibility|Windows PowerShell)|Cookies|Common Files|config(|\.Msi)|components|components.log.*?)$" )
							ContinueLoop
						Case StringRegExp ( $FILEARRAY [ $I ] , "(?i):.*\\(config\\(Software|Software.log|SYSTEM|SysEvent.Evt|SecEvent.Evt|AppEvent.Evt|default|systemprofile|regback|TxR|OSession.evt|Security|SAM))$" )
							ContinueLoop
						Case StringRegExp ( $FILEARRAY [ $I ] , "(?i):.*\\(Speech_OneCore|Speech|DriverStore|fr-(?:ca|fr)|bg-BG|ar-SA|pl-PL|spp|hr-HR|he-IL|ro-RO|sl-SI|sk-SK|\\SMI|networklist|MSDRM|WindowsPowerShell|sr-Latn-(?:RS|CS)|sppui|sru|tr-TR|th-TH|zh-HK|History|hosts|hu-HU|IconCache.db|Identities|Installer|Internet Explorer|it-IT|ja-JP|ko-KR|Links|Local|LocalLow|Local Settings|Logs|LogFiles|log.*?\.txt|Low|Microsoft|Microsoft.NET|migration|ms-MY)$" )
							ContinueLoop
						Case StringRegExp ( $FILEARRAY [ $I ] , "(?i):.*\\(DriverStore|Contacts|uk-UA|cs-CZ|da-DK|de-DE|Desktop|Diagnostics|Local\\Temp|Downloads|drivers|DRVSTORe|ehome|etc|el-GR|en-US|es-ES|Favorites|fi-FI|Fonts|.*?\.(inf|png|doc|docx|gif|ico|tag|jpg|mp3|log\d*|blf|rtf|tm|TxR|regtrans-ms)|debug|desktop\.ini)$" )
							ContinueLoop
						Case StringRegExp ( $FILEARRAY [ $I ] , "(?i):\\(hiberfil.sys|pagefile.sys|ProgramData|Users\\Default|Program Files|Program Files \(x86\)|RECYCLER|.Recycle.Bin|System Volume Information|ProgramData\\Microsoft Help|Windows|windows\\(System32|SysWOW64|temp)|Users)$" )
							ContinueLoop
						Case StringRegExp ( $FILEARRAY [ $I ] , "(?i):.*\\(Start Menu|sv-SE|Sysbckup|System32\\(?:en|OEM)|swapfile.sys|SYSTEM.LOG.*?|SysWOW64\\en|Templates|Temporary Internet Files|Tasks|twain_32|UMDF|Uninstall Information|user|Users|wbem|Webcam|wfp|Windows Media Player|winsxs|Windows Mail|Wat|wdi|zh-TW|zh-CN)$" )
							ContinueLoop
						Case StringRegExp ( $FILEARRAY [ $I ] , "(?i):.*\\(nb-NO|nl-NL|NetHood|NTUSER.DAT.*?|ntuser.dat.LOG1|\.pdf|perf.009.dat|Prefetch|PrintHood|Profiles|Programs|pl-PL|pt-BR|pt-PT|Public|Recent|\.regtrans-ms|Roaming|\.rfx|ru-RU|SAM.LOG.*?|Saved Games|Searches|SECURITY.LOG.*?|SendTo|SoftwareDistribution|SOFTWARE.LOG.*?)$" )
							ContinueLoop
						Case StringRegExp ( $FILEARRAY [ $I ] , "(?i):\\Windows\\(System32|SysWOW64)\\(en-GB|zu-ZA|yo-NG|xh-ZA|wo-SN|uz-Latn-UZ|tn-ZA|ti-ET|tg-Cyrl-TJ|sr-Cyrl-RS|sr-Cyrl-BA|sd-Arab-PK|rw-RW|quc-Latn-GT|pa-Arab-PK|nso-ZA|ku-Arab-IQ|ig-NG|ha-Latn-NG|chr-CHER-US|ca-ES-valencia|bs-Latn-BA|az-Latn-AZ)$" )
							ContinueLoop
						EndSelect
						If $DATEM [ 0 ] > 2099 Then $DATEM [ 0 ] = 2099
						If $DATEM [ 1 ] > 12 Then $DATEM [ 1 ] = 12
						If $DATEM [ 2 ] > 31 Then $DATEM [ 2 ] = 31
						$DATEMO = $DATEM [ 0 ] & "-" & $DATEM [ 1 ] & "-" & $DATEM [ 2 ] & " " & $DATEM [ 3 ] & ":" & $DATEM [ 4 ]
						$DATECR = FILETIME ( $FILEARRAY [ $I ] , 1 )
						$FATT = FileGetAttrib ( "\\?\" & $FILEARRAY [ $I ] )
						$FATT = StringRegExpReplace ( $FATT , "A" , "" )
						If _REPARSEPOINT ( $FILEARRAY [ $I ] ) Then $FATT = $FATT & "L"
						$ATT = StringFormat ( "%05s" , $FATT )
						$ATTS = StringRegExpReplace ( $ATT , "0" , "_" )
						$SIZE = FileGetSize ( "\\?\" & $FILEARRAY [ $I ] )
						$SIZES = StringFormat ( "%09u" , $SIZE )
						$VER = FileGetVersion ( "\\?\" & $FILEARRAY [ $I ] , "CompanyName" )
						If Not @error Then
							$VER = StringRegExpReplace ( $VER , "(?i)http(s|):" , "hxxp\1:" )
							$VER = StringRegExpReplace ( $VER , "\s+" , " " )
							$VER = StringRegExpReplace ( $VER , "\|" , "/" )
							$VER = "(" & $VER & ") "
						EndIf
						_ARRAYADD ( $ARRAY1M , $DATEMO & " - " & $DATECR & " - " & $SIZES & " " & $ATTS & " " & $VER & $FILEARRAY [ $I ] , 0 , "||||" )
					EndIf
				EndIf
			EndSelect
		Else
			_ARRAYADD ( $ARRAY1C , $ERRF & ": """ & $FILEARRAY [ $I ] & """" , 0 , "||||" )
		EndIf
	Next
EndFunc
Func GETFILELIST2 ( $FOLDER )
	$FILEARRAY = _FILELISTTOARRAYREC ( $FOLDER , "*" , 2 , 0 , 0 , 2 )
	For $I = 1 To UBound ( $FILEARRAY ) + 4294967295
		If _REPARSEPOINT ( $FILEARRAY [ $I ] ) Then $FILEARRAY [ $I ] = _GETREPARSETARGET ( $FILEARRAY [ $I ] )
		If Not FileExists ( $FILEARRAY [ $I ] & "\ntuser.dat" ) And Not StringRegExp ( $FILEARRAY [ $I ] , "(?i)\\(ProgramData|All Users|Public)$" ) Then ContinueLoop
		_ARRAYADD ( $ALLUSERS , $FILEARRAY [ $I ] , 0 , "||" )
	Next
	$ALLUSERS = _ARRAYUNIQUE ( $ALLUSERS , 0 , 0 , 0 , 0 , 0 )
EndFunc
Func GETMBR ( $SFILENAME )
	Local $NBYTESRECEIVED
	$ICREATION = 2
	$IACCESS = 2
	$ISHARE = 2 + 4
	$HFILE = _WINAPI_CREATEFILE ( $SFILENAME , $ICREATION , $IACCESS , $ISHARE )
	If @error Or $HFILE = Ptr ( 0 ) Then
		$STR = "Could not open file " & $SFILENAME & @CRLF
		$STR &= "Error: " & @error & @CRLF
		$STR &= "Handle: " & $HFILE
		MsgBox ( 262144 + 0 , "Error: _WinAPI_CreateFile" , $STR )
	Else
		_WINAPI_SETFILEPOINTER ( $HFILE , 0 )
		If @error Then
			MsgBox ( 262144 + 0 , "Error: _WinAPI_SetFilePointer" , StringFormat ( "Could not move pointer. (Error %d)\n" , @error ) )
		Else
			$TBUFFER = DllStructCreate ( "byte[512]" )
			_WINAPI_READFILE ( $HFILE , DllStructGetPtr ( $TBUFFER , 1 ) , 512 , $NBYTESRECEIVED )
			If @error Then
				FileWrite ( @TempDir & "\readmbr" , StringFormat ( "Error reading MBR: (Error %d)\n" , @error ) )
			EndIf
			If $NBYTESRECEIVED < 512 Then
				FileWrite ( @TempDir & "\readmbr" , StringFormat ( "Attempted reading MBR returned %d bytes.\n" , $NBYTESRECEIVED ) )
			Else
				Return Hex ( DllStructGetData ( $TBUFFER , 1 ) )
			EndIf
		EndIf
	EndIf
EndFunc
Func GETPROFILES ( )
	Local $ARRPROFILES [ 1 ] , $ARRAYNAME
	$KEY = "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList"
	$HKEY = _REGOPENKEYEX3 ( $KEY )
	If @error Or $HKEY = 0 Then Return
	$ARRAYNAME = _LISTVAL ( $HKEY )
	If UBound ( $ARRAYNAME ) > 0 Then
		For $V = 0 To UBound ( $ARRAYNAME ) + 4294967295
			$VALNAME = $ARRAYNAME [ $V ] [ 0 ]
			$VALDATA = $ARRAYNAME [ $V ] [ 1 ]
			If $VALDATA <> "" And $VALNAME <> "ProfilesDirectory" Then
				If StringInStr ( $VALDATA , "%" ) Then $VALDATA = _EXPAND ( $VALDATA )
				_ARRAYADD ( $ARRPROFILES , $VALDATA , 0 , "||||" )
			EndIf
		Next
	EndIf
	$HKEY = _REGOPENKEYEX3 ( $KEY )
	If @error Or $HKEY = 0 Then Return $ARRPROFILES
	$I = 0
	While 1
		$CHECK = ""
		$SKEY = __REGENUMKEY ( $HKEY , $I )
		If @error Then ExitLoop
		$DATA = RegRead ( $KEY & "\" & $SKEY , "ProfileImagePath" )
		If StringInStr ( $DATA , "%" ) Then
			If StringInStr ( $DATA , "systemroot" ) And StringInStr ( @OSArch , "64" ) Then $CHECK = 1
			$DATA = _EXPAND ( $DATA )
		EndIf
		_ARRAYADD ( $ARRPROFILES , $DATA , 0 , "||||" )
		If $CHECK Then
			$DATA = StringRegExpReplace ( $DATA , "(?i)System32" , "SysWOW64" )
			If FileExists ( $DATA ) Then _ARRAYADD ( $ARRPROFILES , $DATA , 0 , "||||" )
		EndIf
		$I += 1
	WEnd
	$ARRPROFILES = _ARRAYUNIQUE ( $ARRPROFILES , 0 , 0 , 0 , 0 , 1 )
	If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
	Return $ARRPROFILES
EndFunc
Func GPEXTENSIONS ( )
	$KEY = "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\GPExtensions\"
	$HKEY = _REGOPENKEYEX3 ( $KEY )
	If @error Or $HKEY = 0 Then Return
	$I = + 4294967295
	While 1
		$I += 1
		$SKEY = __REGENUMKEY ( $HKEY , $I )
		If @error Then ExitLoop
		$CDATE = ""
		$COMPANY = ""
		$FILE = ""
		$PATH = RegRead ( $KEY & $SKEY , "DllName" )
		If Not @error Then
			$FILE = $PATH
			AAAAFP ( )
		Else
			If GUICtrlRead ( $CHECKBOX1 ) = 1 And StringRegExp ( $SKEY , "(?i)^{35378EAC-683F-11D2-A89A-00C04FBBCFA2}$" ) Then ContinueLoop
		EndIf
		If $CDATE Then
			$CDATE = " [" & $CDATE & "]"
			$PATH = $FILE
		EndIf
		If GUICtrlRead ( $CHECKBOX1 ) = 1 Then
			If StringInStr ( $COMPANY , "Microsoft Corp" ) And StringRegExp ( $PATH , "(?i):\\WINDOWS\\System32\\(gpprefcl|wlgpclnt|AppManagementConfiguration|auditcse|fdeploy|dskquota|gptext|gpscript|TsUsbRedirectionGroupPolicyExtension|iedkcs32|tsworkspace|WorkFoldersGPExt|dmenrollengine|srchadmin|scecli|gpprnext|hvsigpext|dot3gpclnt|pwlauncher|cscobj|appmgmts|domgmt|polstore|dggpext|RdpGroupPolicyExtension)\.dll" ) Then ContinueLoop
		EndIf
		_ARRAYADD ( $ARRAYREG , "HKLM\Software\...\Winlogon\GPExtensions: [" & $SKEY & "] -> " & $PATH & $CDATE & $COMPANY , 0 , "||||" )
	WEnd
	If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
EndFunc
Func GPEXTENSIONSFIX ( )
	$SKEY = StringRegExpReplace ( $FIX , ".+?: \[(.+?)\].+" , "$1" )
	DELKEY ( "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\GPExtensions\" & $SKEY )
EndFunc
Func GPOL ( )
	If StringRegExp ( $FIX , "GroupPolicy(|Scripts)(|\\User)(|-Firefox)(|-x32):" ) Then
		If StringRegExp ( $FIX , "GroupPolicy(|Scripts):" ) Then $FILEP = $SYSTEMDIR & "\GroupPolicy\Machine"
		If StringRegExp ( $FIX , "GroupPolicy(|Scripts)-x32:" ) Then $FILEP = $WINDOWSDIR86 & "\GroupPolicy\Machine"
		If StringRegExp ( $FIX , "(?i)(GroupPolicy|GroupPolicyScripts)\\User:" ) Then $FILEP = $SYSTEMDIR & "\GroupPolicy\User"
		If StringRegExp ( $FIX , "(?i)(GroupPolicy-x32|GroupPolicyScripts-x32)\\User:" ) Then $FILEP = $WINDOWSDIR86 & "\GroupPolicy\User"
		If StringRegExp ( $FIX , "fox(|-x32):" ) Then
			$FILEP = $PROGRAMFILES & "\Mozilla Firefox\distribution\policies.json"
			If StringInStr ( $FIX , "fox-x32:" ) Then $FILEP = $PROGRAMFILES86 & "\Mozilla Firefox\distribution\policies.json"
			MOVEFILER ( $FILEP )
			Return
		EndIf
	Else
		$USERSID = StringRegExpReplace ( $FIX , "(?i).*?GroupPolicyUsers\\(.+?)(\\Scripts|): .+" , "$1" )
		$FILEP = $SYSTEMDIR & "\GroupPolicyUsers\" & $USERSID
		If StringInStr ( $FIX , "SysWOW64" ) Then $FILEP = $WINDOWSDIR86 & "\GroupPolicyUsers\" & $USERSID
	EndIf
	If Not FileExists ( $FILEP ) Then
		NFOUND ( $FILEP )
	Else
		MOVEDIR ( $FILEP )
		FileWrite ( $C & "\FRST\re" , "P" )
	EndIf
	GPOL1 ( $SYSTEMDIR & "\GPT.ini" )
	GPOL1 ( $SYSTEMDIR & "\GroupPolicy\GPT.ini" )
	GPOL1 ( $WINDOWSDIR86 & "\GPT.ini" )
	GPOL1 ( $WINDOWSDIR86 & "\GroupPolicy\GPT.ini" )
EndFunc
Func NTPOL ( )
	$SPATH = StringRegExpReplace ( $FIX , "(?i)Policies: (.+NTUSER.POL):.+" , "$1" )
	MOVEFILER ( $SPATH )
EndFunc
Func GPOL1 ( $FILEP )
	If FileExists ( $FILEP ) Then MOVEFILER ( $FILEP )
EndFunc
Func GPPOLICY ( $HIVE1 )
	Local $HKEY1
	$LRCHAR = " **"
	$LRCHAR = StringRegExp ( $LRCHAR , "\*(.)\*" , 3 )
	If IsArray ( $LRCHAR ) Then $LRCHAR = $LRCHAR [ 0 ]
	$KEY = $HIVE1 & "\" & $SOFTWARE & "\Policies\Microsoft\Windows\safer\codeidentifiers"
	$HKEY = _REGOPENKEYEX3 ( $KEY )
	$I = 0
	While 1
		$SUBK1 = __REGENUMKEY ( $HKEY , $I )
		If @error Then ExitLoop
		$HKEY1 = _REGOPENKEYEX3 ( $KEY & "\" & $SUBK1 & "\Paths" )
		$S = 0
		While 1
			$SUBK2 = __REGENUMKEY ( $HKEY1 , $S )
			If @error Then ExitLoop
			$VAL1 = RegRead ( $KEY & "\" & $SUBK1 & "\Paths\" & $SUBK2 , "SaferFlags" )
			If @error Or $VAL1 = 0 Then
				$PATHS = RegRead ( $KEY & "\" & $SUBK1 & "\Paths\" & $SUBK2 , "ItemData" )
				If Not @error And Not StringInStr ( $PATHS , "Shell Folders\Cache%OLK*" ) Then
					$PATHS = StringRegExpReplace ( $PATHS , $LRCHAR , "" )
					_ARRAYADD ( $ARRAYREG , $HIVE1 & " Group Policy restriction on software: " & $PATHS & " <==== " & $UPD1 , 0 , "||||" )
				EndIf
			EndIf
			$S += 1
		WEnd
		$I += 1
	WEnd
	_REGCLOSE ( $HKEY1 )
	If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
EndFunc
Func GPPOLICYFIX ( )
	Local $RET , $RET1
	If StringInStr ( $FIX , "HKLM " ) Then
		$HIVE = "HKLM"
	Else
		$USER = StringRegExpReplace ( $FIX , "(?i)HKU\\(.+?) Group Policy.+" , "$1" )
		$HIVE = "HKU\" & $USER
	EndIf
	$KEY = $HIVE & "\" & $SOFTWARE & "\Policies\Microsoft\Windows\safer\codeidentifiers"
	$RET = _GETSECDES ( $KEY , 4 )
	If StringInStr ( $RET , "(D;" ) Or ( Not StringRegExp ( $RET , "A;.*?(GA|FA);;;BA" ) And Not StringInStr ( $RET , "(A;;FA;;;WD)" ) ) Then _GRANTE ( $KEY , 4 , 1 )
	$RET = RegDelete ( $KEY )
	Select
	Case $RET = 1
		$RET1 = RegWrite ( $KEY , "authenticodeenabled" , "REG_DWORD" , "0" )
		Select
		Case $RET1 = 1
			FileWrite ( $HFIXLOG , $FIX & " => " & $RESTORED & @CRLF )
		Case $RET1 = 0
			DELETED ( $FIX )
		EndSelect
	Case $RET = 0
		NFOUND ( $FIX )
	Case $RET = 2
		NDELETED ( $FIX )
	EndSelect
EndFunc
Func HANDLER ( $ANDLERFILTER )
	Local $SUBKEY , $CLSID , $FILEPATH , $REGEX
	$KEY = "HKCR\PROTOCOLS\" & $ANDLERFILTER
	GUICtrlSetData ( $LABEL1 , $SCANB & " Internet: " & $KEY )
	$HKEY = _REGOPENKEYEX3 ( $KEY )
	If @error Or $HKEY = 0 Then Return
	$HNDLR0 = FileOpen ( @TempDir & "\hndlr0" , 2 + 256 )
	$I = 0
	While 1
		$COMPANY = ""
		$FILEPATH = ""
		$CLSID = ""
		$SUBKEY = ""
		$CH1 = ""
		$CH2 = ""
		$SUBKEY = __REGENUMKEY ( $HKEY , $I )
		If @error Then ExitLoop
		$HKEY1 = _REGOPENKEYEX3 ( $KEY & "\" & $SUBKEY , 1 )
		__REGENUMKEY ( $HKEY1 , 0 )
		If @error Then
			$CDATE = ""
			$CLSID = RegRead ( $KEY & "\" & $SUBKEY , "clsid" )
			If @error = 1 Or $CLSID = "" Then
				$CLSID = $REGIST7
				FileWrite ( $HNDLR0 , $ANDLERFILTER & ": " & $SUBKEY & " - " & $CLSID & @CRLF )
			Else
				If $CLSID <> "" Then
					$FILEPATH = RegRead ( "HKCR\CLSID\" & $CLSID & "\InprocServer32" , "" )
					If StringInStr ( $FILEPATH , "mscoree.dll" ) Then MSCOREE ( "HKCR\CLSID\" & $CLSID & "\InprocServer32" , $FILEPATH )
					$FILE = $FILEPATH
					AAAAFP ( )
					If FileExists ( $FILE ) Then
						FileWrite ( $HNDLR0 , $ANDLERFILTER & ": " & $SUBKEY & " - " & $CLSID & " - " & $FILE & " [" & $CDATE & "]" & $COMPANY & @CRLF )
					Else
						$CH1 = 1
					EndIf
					$FILEPATH = RegRead ( "HKCR\Wow6432Node\CLSID\" & $CLSID & "\InprocServer32" , "" )
					If StringInStr ( $FILEPATH , "mscoree.dll" ) Then MSCOREE ( "HKCR\Wow6432Node\CLSID\" & $CLSID & "\InprocServer32" , $FILEPATH )
					$FILE = $FILEPATH
					AAAAFPWOW ( )
					If FileExists ( $FILE ) Then
						FileWrite ( $HNDLR0 , $ANDLERFILTER & "-x32: " & $SUBKEY & " - " & $CLSID & " - " & $FILE & " [" & $CDATE & "]" & $COMPANY & @CRLF )
					Else
						$CH2 = 1
					EndIf
					If $CH1 And $CH2 Then FileWrite ( $HNDLR0 , $ANDLERFILTER & ": " & $SUBKEY & " - " & $CLSID & " - " & $FILEPATH & " " & $REGIST8 & @CRLF )
				EndIf
			EndIf
		Else
			HANDLERSUB ( $KEY , $SUBKEY , $ANDLERFILTER , $HNDLR0 )
		EndIf
		$I = $I + 1
	WEnd
	If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
	FileClose ( $HNDLR0 )
	$HNDLR0 = FileOpen ( @TempDir & "\hndlr0" , 256 )
	$REGEX = FileRead ( $HNDLR0 )
	FileClose ( $HNDLR0 )
	If GUICtrlRead ( $CHECKBOX11 ) = 1 Then
		$REGEX = StringRegExpReplace ( $REGEX , "(?i)Handle(r|r-x32): (abs|ipp|http|https|msdaipp)(\\(0x00000001|oledb)|) - .+\\Program Files.*\\Common Files\\SYSTEM\\OLE DB\\msdaipp.dll \[.+\] \(Microsoft.+\)\v{2}" , "" )
		$REGEX = StringRegExpReplace ( $REGEX , "(?i)Handle(r|r-x32): (its|ms-its|wia|about|javascript|mailto|res|vbscript|tbauth|cdl|file|ftp|http|https|local|mk|mhtml|dvd|tv|gzip|deflate|gopher|sysimage) .+\\(system32|SysWOW64)\\(urlmon|mshtml|tbauth|msvidctl|inetcomm|itss|wiascr|mscoree).dll \[.+\] \(Microsoft.+\)\v{2}" , "" )
		$REGEX = StringRegExpReplace ( $REGEX , "(?i)Handler-x32: (grooveLocalGWS|osf) .+\\Program Files(| \(x86\))\\Microsoft Office\\Office1\d\\(GrooveSystemServices|MSOSB).dll \[.+\] \(Microsoft.+\)\v{2}" , "" )
		$REGEX = StringRegExpReplace ( $REGEX , "(?i)Handler-x32: mso-offda(p|p11) - (\{3D9F03FA-7A94-11D3-BE81-0050048385D1\}|\{32505114-5902-49B2-880A-1F7738E5A384\}).+\\1(0|1)\\OWC1(0|1).DLL \[.+\] \(Microsoft.+\)\v{2}" , "" )
		$REGEX = StringRegExpReplace ( $REGEX , "(?i)Handle(r|r-x32): (ms-help|ms-itss) - .+\\Program File.*\\Common Files\\Microsoft Shared\\(Help|Information Retrieval)\\(hxds|MSITSS).dll \[.+\] \(Microsoft.+\)\v{2}" , "" )
		$REGEX = StringRegExpReplace ( $REGEX , "(?i)Handle(r|r-x32): (livecall|wlpg|msnim|wlmailhtml) - .+\\Program Files(| \(x86\))\\Windows Live\\(Messenger|Photo Gallery|Mail)\\(msgrapp|AlbumDownloadProtocolHandler|mailcomm).dll \[.+\] \(Microsoft.+\)\v{2}" , "" )
		$REGEX = StringRegExpReplace ( $REGEX , "(?i)Filte(r|r-x32): application/(octet-stream|x-complus|x-msdownload) - \{.+(System32|SysWOW64)\\mscoree.dll \[.+\] \(Microsoft.+\)\v{2}" , "" )
		$REGEX = StringRegExpReplace ( $REGEX , "(?i)Filter(|-x32): text/xml - .+\\OFFICE1\d\\MSOXMLMF.DLL \[.+\] \(Microsoft.+\)\v{2}" , "" )
		$REGEX = StringRegExpReplace ( $REGEX , "(?i)Handler(|-x32): windows.tbauth - .+\\(System32|SysWOW64)\\tbauth.dll \[.+\] \(Microsoft.+\)\v{2}" , "" )
	EndIf
	FileWrite ( $HADDITION , $REGEX )
	FileDelete ( @TempDir & "\hndlr0" )
EndFunc
Func HANDLERFIX ( )
	Local $CLSID , $SKEY , $KEY1
	If StringInStr ( $FIX , "Handler: " ) Then
		$SKEY = StringRegExpReplace ( $FIX , "Handler: ([^\{]+?) - .+" , "$1" )
		$KEY = "HKLM\Software\Classes\PROTOCOLS\Handler\" & $SKEY
		If StringRegExp ( $FIX , "\{.+\}" ) Then
			$CLSID = StringRegExpReplace ( $FIX , "[^\{]+(\{.+\}).*" , "$1" )
			$KEY1 = "HKLM\Software\Classes\CLSID\" & $CLSID
		EndIf
	EndIf
	If StringInStr ( $FIX , "Handler-x32: " ) Then
		$SKEY = StringRegExpReplace ( $FIX , "Handler-x32: ([^\{]+?) - .+" , "$1" )
		$KEY = "HKLM\Software\Wow6432Node\Classes\PROTOCOLS\Handler\" & $SKEY
		If StringRegExp ( $FIX , "\{.+\}" ) Then
			$CLSID = StringRegExpReplace ( $FIX , "[^\{]+(\{.+\}).*" , "$1" )
			$KEY1 = "HKLM\Software\Wow6432Node\Classes\CLSID\" & $CLSID
		EndIf
	EndIf
	DELKEY ( $KEY )
	If VAR ( $KEY1 ) Then DELKEY ( $KEY1 )
EndFunc
Func HANDLERSUB ( $KEY , $SUBKEY , $ANDLERFILTER , $HNDLR0 )
	$HKEY = _REGOPENKEYEX3 ( $KEY & "\" & $SUBKEY , 1 )
	If @error Then Return
	$J = 0
	While 1
		$CH1 = ""
		$CH2 = ""
		$SUBKEY1 = __REGENUMKEY ( $HKEY , $J )
		If @error Then ExitLoop
		$CLSID = RegRead ( $KEY & "\" & $SUBKEY & "\" & $SUBKEY1 , "clsid" )
		If @error = 1 Or $CLSID = "" Then
			$CLSID = $REGIST7
			FileWrite ( $HNDLR0 , $ANDLERFILTER & ": " & $SUBKEY & " - " & $CLSID & @CRLF )
		Else
			If $CLSID <> "" Then
				$FILEPATH = RegRead ( "HKCR\CLSID\" & $CLSID & "\InprocServer32" , "" )
				If StringInStr ( $FILEPATH , "mscoree.dll" ) Then MSCOREE ( "HKCR\CLSID\" & $CLSID & "\InprocServer32" , $FILEPATH )
				$FILE = $FILEPATH
				AAAAFP ( )
				If FileExists ( $FILE ) Then
					FileWrite ( $HNDLR0 , $ANDLERFILTER & ": " & $SUBKEY & " - " & $CLSID & " - " & $FILEPATH & " [" & $CDATE & "]" & $COMPANY & @CRLF )
				Else
					$CH1 = 1
				EndIf
				$FILEPATH = RegRead ( "HKCR\Wow6432Node\CLSID\" & $CLSID & "\InprocServer32" , "" )
				If StringInStr ( $FILEPATH , "mscoree.dll" ) Then MSCOREE ( "HKCR\Wow6432Node\CLSID\" & $CLSID & "\InprocServer32" , $FILEPATH )
				$FILE = $FILEPATH
				AAAAFPWOW ( )
				If FileExists ( $FILE ) Then
					FileWrite ( $HNDLR0 , $ANDLERFILTER & "-x32: " & $SUBKEY & " - " & $CLSID & " - " & $FILEPATH & " [" & $CDATE & "]" & $COMPANY & @CRLF )
				Else
					$CH2 = 1
				EndIf
				If $CH1 And $CH2 Then FileWrite ( $HNDLR0 , $ANDLERFILTER & ": " & $SUBKEY & " - " & $CLSID & " - " & $FILEPATH & " " & $REGIST8 & @CRLF )
			EndIf
		EndIf
		$J += 1
	WEnd
	If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
EndFunc
Func HKLM ( )
	Local $VALUSER , $VALSH , $VALSH1 , $VAR1 , $VAR2
	GPPOLICY ( "HKLM" )
	If $BOOTM <> "Recovery" Then
		For $U = 1 To UBound ( $USERREG ) + 4294967295
			GPPOLICY ( "HKU\" & $USERREG [ $U ] )
		Next
	EndIf
	$WINLOGKEY = "HKLM\" & $SOFTWARE & "\Microsoft\Windows NT\CurrentVersion\Winlogon"
	GUICtrlSetData ( $LABEL1 , $WINLOGKEY )
	$VALUSER = RegRead ( $WINLOGKEY , "Userinit" )
	$FILE = $VALUSER
	If StringRegExp ( $FILE , "(?i)^(userinit.exe|" & $C & "\\Windows\\system32\\userinit.exe),?$" ) Then
		$FILE = $C & "\Windows\system32\userinit.exe"
	EndIf
	$ATTEN = ""
	If StringRegExp ( $FILE , "(?i)wscript" ) Then $ATTEN = " <==== " & $UPD1
	AAAAFP ( )
	If FileExists ( $FILE ) Then
		_ARRAYADD ( $ARRAYREG , "HKLM\...\Winlogon: [Userinit] " & $FILE & " [" & $SIZE & " " & $CDATE & "]" & $COMPANY & $ATTEN , 0 , "||||" )
	Else
		$ATTEN = " <==== " & $UPD1
		_ARRAYADD ( $ARRAYREG , "HKLM\...\Winlogon: [Userinit] " & $VALUSER & $ATTEN , 0 , "||||" )
	EndIf
	$WINLOGKEY32 = "HKLM\" & $SOFTWARE & "\WOW6432Node\Microsoft\Windows NT\CurrentVersion\Winlogon"
	$VALUSER = RegRead ( $WINLOGKEY32 , "Userinit" )
	$FILE = $VALUSER
	If StringRegExp ( $FILE , "(?i)^(userinit.exe|" & $C & "\\Windows\\(system32|sysWOW64)\\userinit.exe)[,]*$" ) Then
		$FILE = $C & "\Windows\sysWOW64\userinit.exe"
	EndIf
	$ATTEN = ""
	If StringRegExp ( $FILE , "(?i)wscript" ) Then $ATTEN = " <==== " & $UPD1
	AAAAFPWOW ( )
	If FileExists ( $FILE ) Then
		_ARRAYADD ( $ARRAYREG , "HKLM-x32\...\Winlogon: [Userinit] " & $FILE & " [" & $SIZE & " " & $CDATE & "]" & $COMPANY & $ATTEN , 0 , "||||" )
	Else
		If $VALUSER Or $OSNUM < 10 Then _ARRAYADD ( $ARRAYREG , "HKLM-x32\...\Winlogon: [Userinit] " & $VALUSER & $ATTEN , 0 , "||||" )
	EndIf
	$VALSH = RegRead ( $WINLOGKEY , "Shell" )
	$FILE = $VALSH
	AAAAFP ( )
	$ATTEN = ""
	If Not StringRegExp ( $VALSH , "^(?i)explorer.exe$" ) Then $ATTEN = " <=== " & $UPD1
	If FileExists ( $FILE ) Then
		$SIZE = " [" & $SIZE & " " & $CDATE & "]" & $COMPANY
		$VALSH = $FILE
	Else
		$SIZE = ""
	EndIf
	_ARRAYADD ( $ARRAYREG , "HKLM\...\Winlogon: [Shell] " & $VALSH & $SIZE & $ATTEN , 0 , "||||" )
	$VALSH = RegRead ( $WINLOGKEY32 , "Shell" )
	$FILE = $VALSH
	AAAAFPWOW ( )
	If Not StringRegExp ( $VALSH , "^(?i)explorer.exe$" ) Then $ATTEN = " <=== " & $UPD1
	If FileExists ( $FILE ) Then
		$SIZE = " [" & $SIZE & " " & $CDATE & "]" & $COMPANY
		$VALSH = $FILE
	Else
		$SIZE = ""
	EndIf
	_ARRAYADD ( $ARRAYREG , "HKLM-x32\...\Winlogon: [Shell] " & $VALSH & $SIZE & $ATTEN , 0 , "||||" )
	WINLOGON ( "System" )
	WINLOGON ( "UIHost" )
	WINLOGON ( "Taskman" )
	WINLOGON1 ( $WINLOGKEY , "LegalNoticeCaption" )
	WINLOGON1 ( $WINLOGKEY , "LegalNoticeText" )
	$VAR1 = RegRead ( "HKLM\" & $SOFTWARE & "\Classes\CLSID\{F3130CDB-AA52-4C3A-AB32-85FFC23AF9C1}\InprocServer32" , "" )
	If Not StringInStr ( $VAR1 , "wbem\wbemess.dll" ) Then _ARRAYADD ( $ARRAYREG , "HKLM\...\InprocServer32: [Default-wbemess] " & $VAR1 & " <==== " & $UPD1 , 0 , "||||" )
	$VAR1 = RegRead ( "HKLM\" & $SOFTWARE & "\Classes\CLSID\{5839FCA9-774D-42A1-ACDA-D6A79037F57F}\InprocServer32" , "" )
	If Not StringInStr ( $VAR1 , "wbem\fastprox.dll" ) Then _ARRAYADD ( $ARRAYREG , "HKLM\...D6A79037F57F\InprocServer32: [Default-fastprox] " & $VAR1 & " <==== " & $UPD1 , 0 , "||||" )
	If $BOOTM <> "recovery" Or $OSNUM > 6.3 Then Return
	$VAR1 = RegRead ( "HKLM\" & $SOFTWARE & "\Classes\CLSID\{7986d495-ce42-4926-8afc-26dfa299cadb}\InprocServer32" , "" )
	If Not StringInStr ( $VAR1 , "authui.dll" ) Then _ARRAYADD ( $ARRAYREG , "HKLM\...26dfa299cadb\InprocServer32: [Authentication UI Logon UI] " & $VAR1 & " <==== " & $UPD1 , 0 , "||||" )
EndFunc
Func HKU ( )
	GUICtrlSetData ( $LABEL1 , $REGIST1 & ": " & $REGIST5 )
	If $BOOTM = "Recovery" Then
		For $Q = 1 To UBound ( $ALLUSERS ) + 4294967295
			$USER = StringRegExpReplace ( $ALLUSERS [ $Q ] , ".+\\(.+)" , "$1" )
			RunWait ( @ComSpec & " /c reg load ""hku\" & $USER & """ """ & $ALLUSERS [ $Q ] & "\ntuser.dat""" , "" , @SW_HIDE )
			AAAAHKU ( $USER )
			RunWait ( @ComSpec & " /c reg unload ""hku\" & $USER & """" , "" , @SW_HIDE )
		Next
	Else
		$U = 0
		While 1
			$USER = __REGENUMKEY ( 2147483651 , $U )
			If @error Then ExitLoop
			If Not StringRegExp ( $USER , "(?i)(\.default|_Classes)" ) Then AAAAHKU ( $USER )
			$U += 1
		WEnd
	EndIf
EndFunc
Func HKURUN ( $USER , $RUN )
	Local $ARRAYNAME , $NAME
	$FULLKEY = "HKU\" & $USER & "\Software\Microsoft\Windows\CurrentVersion\" & $RUN
	$HKEY = _REGOPENKEYEX3 ( $FULLKEY )
	If @error Or $HKEY = 0 Then Return 1
	$ARRAYNAME = _LISTVAL ( $HKEY )
	If UBound ( $ARRAYNAME ) > 0 Then
		For $V = 0 To UBound ( $ARRAYNAME ) + 4294967295
			$ATTEN = ""
			$COMPANY = ""
			$SIZE = ""
			$CDATE = ""
			$VALNAME = $ARRAYNAME [ $V ] [ 0 ]
			$FILE = $ARRAYNAME [ $V ] [ 1 ]
			Select
			Case StringRegExp ( $VALNAME , "\w+\d$" ) And StringRegExp ( $ARRAYNAME [ $V ] [ 1 ] , "(?i)\\AppData\\Local\\" & $VALNAME & "\\" & $VALNAME & "\.exe" )
				$ATTEN = " <==== " & $UPD1
			Case StringInStr ( $ARRAYNAME [ $V ] [ 1 ] , $VALNAME ) And StringRegExp ( $ARRAYNAME [ $V ] [ 1 ] , "(?i)\\AppData" ) And StringRegExp ( $ARRAYNAME [ $V ] [ 1 ] , "(?i)(REGSVR32|rundll32)" )
				$ATTEN = " <==== " & $UPD1
			Case StringInStr ( $ARRAYNAME [ $V ] [ 1 ] , "\Temp\" ) And Not StringRegExp ( $ARRAYNAME [ $V ] [ 1 ] , "(?i)\\(spool\\|razer)" )
				$ATTEN = " <==== " & $UPD1
			Case StringInStr ( $ARRAYNAME [ $V ] [ 1 ] , "\ctfmon.exe" ) And Not StringRegExp ( $ARRAYNAME [ $V ] [ 1 ] , "(?i):\\Windows\\(System32|SysWOW64)" )
				$ATTEN = " <==== " & $UPD1
			Case $VALNAME = "CMD" And StringRegExp ( $ARRAYNAME [ $V ] [ 1 ] , "(?i)HTTP:" )
				$ATTEN = " <==== " & $UPD1
			Case StringRegExp ( $VALNAME , "(?i)^(Cortana|AntiMalwareServiceExecutable|WmiPrvSE|MpCmdRun|SecurityHealthSystray|audiodg|WindowsUpdate|spoolsv|uerinit|explorer|iexplore|System|regdrv|taskhost|Isass|smss|csrss|wininit|services|lsass|lsm|winlogon|.*svchost.*|dwm|msdtc|VSSVC|alg|sihost|dllhost|cmd|msedge|conhost|fontdrvhost|SystemSettingsBroker|SystemSettings|SearchIndexer)(|\.exe)$" )
				$ATTEN = " <==== " & $UPD1
			Case StringRegExp ( $VALNAME , "(?i)^(CrowdstrikeEngine|Intel Management Engine Components.*|MicrosoftEdgeUpdateTaskMachineCoreCor|Stopabit|O|DataServicesWindows|advapi32|DigitalPulse|GoogleUpdateTaskMachineQC|.*(32|64)\.(dll|exe)|ClErrorReport|GimpUpdate|Offlce360Sync|InetHelper|AdobelCloud|MSDllHelper|AppLaunch|WindowsHostProcessor|WCEStartup|telemetry|NTSystem|hotplug|NvStray|OneDriveService|MicrosoftEdgeUpd|ICE X|Honeygain|RestMinder|Media Freeware Update|ProductAuthenticationService|GoogleChrome|VScan|MicrosoftApi|NsCpu|CpuZ|Driver|system recover|SearcherBar|WinHost|Prun|CRaccoon|decacopy.exe|Regedit32|QScan System-Check|Chromium Update|Windows Updates Service|GIMP Updater|AnonymizerGadget|VLC Update.*|Jetzt Konvertieren|updater|CloudNet|MailRuUpdater|Mp3tagApp|ycAutoLaunch.*|KometaLaunchPanel|StartButton|OpenOffice Updater|Browser Extensions|svcvmx|system_jconsole.jar|AnyDeskApp|TimeSyncService|WinMSUpdate|amigo|windows|YeaDesktop|BandwidthStat|isMiner .*|goose loader|Host Service|produpd|SimpleNoteApp\d+|ProxyGate|Itibiti.exe|NowUSeeIt Player|WebDiscoverBrowser|Interstatnogui|PCSpeedUp|WinResSync|WinResSync|CatalinaGroup.*|firefox|SysHelper|DreamTrip)$" )
				$ATTEN = " <==== " & $UPD1
			Case StringRegExp ( $ARRAYNAME [ $V ] [ 1 ] , "(?i)(^\s*|\\)explorer(\.exe| ) |\\(Users\\.+\\NETFramework|TaskbarSystem|MpCmdRun|ebookreader|cleaner|MicrosoftAudio|WmiPrvSE|audiodg|spoolsv|uerinit|explorer|iexplore|System|regdrv|taskhost|Isass|smss|csrss|wininit|services|lsass|lsm|winlogon|svchost|dwm|msdtc|VSSVC|alg|sihost|dllhost|taskhostw)\.(exe|vbs|bat)|ntuserlitelist|\[Text\.Encoding\]::|/e:VBScript.Encode|\\DiskP\\|\\Spoutly|\\SpeeDownloader|\.\.vbs|explorer(.exe|) ""?http:|kXcAAA==W|\\InterStat|BestCleaner|\\Max Driver Updater|\\DPower|\\GroupPolicy|\\AppData\\Local\\[^\\]+\\[^\\]+\.dll|ProgramData\\[^\\]+\.(exe|vbs|bat|scr|dll)|scrobj\.dll|HKCU\\|HKCU:\\|ProgramData\\\w+\\" & $VALNAME & "$" & "|(:\\Windows|%SystemRoot%)\\servicing\\(?!TrustedInstaller)[^\\]+\.exe|ProgramData\\Synaptics|\\easyxplore|VLC Plus Player|Browser.Security|Browser.Assistant\\|\\(WinxOff\\Loader|AutoIt3|ZlfredManageApp|pythonw?|Tone|winnet\|winsvc\|nvdrivesllapi32|windowss|chromehelper)\.exe|cookieaq|\\Web Companion\\|\\run.bat|Roaming\\WindowsDefender|Cheat Space\\|\\Local\\AdobeUpdater|\\\w+.tmp\b" )
				$ATTEN = " <==== " & $UPD1
			Case StringRegExp ( $VALNAME , "(?i)-.+\.exe" ) And StringRegExp ( $ARRAYNAME [ $V ] [ 1 ] , "(?i)Program File[^\\]*\\w+\\[^\\]+\\" & $VALNAME & "$" )
				$ATTEN = " <==== " & $UPD1
			Case StringRegExp ( $VALNAME , "(?i)\w{20,}\.exe" ) And StringRegExp ( $ARRAYNAME [ $V ] [ 1 ] , "(?i)Roaming\\" & $VALNAME )
				$ATTEN = " <==== " & $UPD1
			Case StringRegExp ( $ARRAYNAME [ $V ] [ 1 ] , "(?i)ProgramData\\" & $VALNAME & "\\" & $VALNAME & "\.exe" )
				$ATTEN = " <==== " & $UPD1
			Case StringRegExp ( $ARRAYNAME [ $V ] [ 1 ] , "(?i)" & StringRegExpReplace ( @UserProfileDir , "\\" , "\\\\" ) & "\\" & $VALNAME & "\.exe" )
				$ATTEN = " <==== " & $UPD1
			Case StringRegExp ( $ARRAYNAME [ $V ] [ 1 ] , "(?i)powershell.+GetEnvironmentVariable.+User" )
				$ATTEN = " <==== " & $UPD1
			Case StringRegExp ( $ARRAYNAME [ $V ] [ 1 ] , "(?i)" & StringRegExpReplace ( @AppDataDir , "\\" , "\\\\" ) & "\\Microsoft\\\{.+?\}\\[^\\]+\.exe" )
				$ATTEN = " <==== " & $UPD1
			Case StringRegExp ( $ARRAYNAME [ $V ] [ 1 ] , "(?i)cmd .+\\" & $VALNAME & "\.lnk .+ -file .+\.ps1" )
				$ATTEN = " <==== " & $UPD1
			Case StringRegExp ( $ARRAYNAME [ $V ] [ 1 ] , "(?i)Program Files\\Windows Security\\[^\\]+\\" & $VALNAME & "\.exe" )
				$ATTEN = " <==== " & $UPD1
			Case StringRegExp ( $VALNAME , "^WC" ) And StringRegExp ( $ARRAYNAME [ $V ] [ 1 ] , "(?i)powershell" )
				$ATTEN = " <==== " & $UPD1
			Case StringRegExp ( $ARRAYNAME [ $V ] [ 1 ] , "(?i)(:\\ProgramData(|\\Microsoft)|\\Roaming(|\\Microsoft)|:\\Users\\.+\\documents|:\\Users\\[^\\]+)\\[^\\]+\.(vbs|bat|exe)\b" )
				$ATTEN = " <==== " & $UPD1
			Case StringRegExp ( $ARRAYNAME [ $V ] [ 1 ] , "(?i)(\\\w+\.exe).+\1" )
				$ATTEN = " <==== " & $UPD1
			Case StringRegExp ( $ARRAYNAME [ $V ] [ 1 ] , "(?i)\b(cmd|powershell)\b.+(http:|www\.)" )
				$ATTEN = " <==== " & $UPD1
			Case StringRegExp ( $ARRAYNAME [ $V ] [ 1 ] , "(?i)\\msedge.exe" ) And Not StringRegExp ( $ARRAYNAME [ $V ] [ 1 ] , "(?i)Program Files" )
				$ATTEN = " <==== " & $UPD1
			EndSelect
			If StringInStr ( $VALNAME , "<*>" ) Then
				$LRCHAR = " **"
				$LRCHAR = StringRegExp ( $LRCHAR , "\*(.)\*" , 3 )
				If IsArray ( $LRCHAR ) Then $LRCHAR = $LRCHAR [ 0 ]
				$FILE = StringRegExpReplace ( $FILE , $LRCHAR , "" )
				$ATTEN = " <==== " & $UPD1 & " (" & $REGIST4 & ")"
			Else
				AAAAFP ( )
			EndIf
			If FileExists ( $FILE ) Then
				If StringRegExp ( $FILE , "\\\w{6}~\d\\" ) Then $FILE = FileGetLongName ( $FILE )
				Select
				Case StringRegExp ( $ARRAYNAME [ $V ] [ 1 ] , "(?i)Microsoft\\Windows\\Start Menu\\Programs\\Startup\\" & $VALNAME & "\.exe" ) And StringInStr ( $COMPANY , "() [" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $ARRAYNAME [ $V ] [ 1 ] , "(?i)\\updater.exe" ) And StringInStr ( $COMPANY , "() [" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $ARRAYNAME [ $V ] [ 1 ] , "(?i)\\(ProgramData\\Microsoft(|\\NetFramework|\\Windows)|Microsoft\\Windows)\\[^\\]+\\[^\\]+\.(exe|bat|vbs|reg)" ) And ( StringInStr ( $COMPANY , "[" ) Or Not StringInStr ( $COMPANY , "Microsoft" ) )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $ARRAYNAME [ $V ] [ 1 ] , "(?i)AppData\\Local\\Programs\\" & $VALNAME & "\\" & $VALNAME & "\.exe" ) And StringInStr ( $COMPANY , "Cleversort" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $COMPANY , "(?i)Kometa LCC" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $ARRAYNAME [ $V ] [ 1 ] , "(?i)(Roaming\\" & $VALNAME & "\\" & $VALNAME & "|browser_assistant)\.exe" ) And StringInStr ( $COMPANY , "[" ) And Not StringRegExp ( $VALNAME , "(?i)^(PreMiD|Spotify)$" )
					$ATTEN = " <==== " & $UPD1
				Case $SIZE > 314572800 And StringInStr ( $COMPANY , "[" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $COMPANY , "\(\) \[[^]]+\] \[[^]]+\]" )
					$ATTEN = " <==== " & $UPD1
				Case StringRegExp ( $ARRAYNAME [ $V ] [ 1 ] , "(?i)browser_assistant\.exe" ) And StringInStr ( $COMPANY , "[" )
					$ATTEN = " <==== " & $UPD1
				EndSelect
				If StringRegExp ( $ARRAYNAME [ $V ] [ 1 ] , "(?i)\b(msiexec|wscript|cmd)\b|(iexplore|firefox|chrome|MicrosoftEdge|opera|msedge|mshta)\.exe" ) Then $FILE = $ARRAYNAME [ $V ] [ 1 ]
				_ARRAYADD ( $ARRAYREG , "HKU\" & $USER & "\...\" & $RUN & ": [" & $VALNAME & "] => " & $FILE & " [" & $SIZE & " " & $CDATE & "]" & $COMPANY & $ATTEN , 0 , "||||" )
			Else
				$NOFILE = ""
				If $ARRAYNAME [ $V ] [ 1 ] = "" Or StringRegExp ( $ARRAYNAME [ $V ] [ 1 ] , "\A[ ]+\Z" ) Then
					$ARRAYNAME [ $V ] [ 1 ] &= "[X]"
				Else
					$NOFILE = " (" & $REGIST8 & ")"
					If StringRegExp ( $ARRAYNAME [ $V ] [ 1 ] , "(?i)\b(shutdown|wevtutil|vssadmin|wmic|REGSVR|regsvr32|Regsvcs|RegAsm|regedt32|regedit|rundll32|wscript|cscript|javaw|cmd|powershell|reg)\b.+.:\\|.:\\.+.:\\" ) Then
						$FILE = StringRegExpReplace ( $ARRAYNAME [ $V ] [ 1 ] , ".+(.:\\.)" , "$1" )
						AAAAFP ( )
						If FileExists ( $FILE ) Then $NOFILE = " [" & $SIZE & " " & $CDATE & "]" & $COMPANY
						If StringRegExp ( $ARRAYNAME [ $V ] [ 1 ] , "(?i)Roaming\\Microsoft\\.+\.js\b" ) Then $ATTEN = " <==== " & $UPD1
					EndIf
				EndIf
				_ARRAYADD ( $ARRAYREG , "HKU\" & $USER & "\...\" & $RUN & ": [" & $VALNAME & "] => " & $ARRAYNAME [ $V ] [ 1 ] & $NOFILE & $ATTEN , 0 , "||||" )
			EndIf
		Next
	EndIf
	If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
	If $RUN <> "Run" Then Return
	$FULLKEY = _HKEYTRANS ( $FULLKEY )
	INVALIDSUBKEY ( $FULLKEY , $NAME )
	If $NAME <> "" Then _ARRAYADD ( $ARRAYREG , "InvalidSubkeyName: [HKU\" & $USER & "\Software\Microsoft\Windows\CurrentVersion\Run\" & $NAME & "] <==== " & $UPD1 , 0 , "||||" )
EndFunc
Func HKUUSERS ( )
	Local $HKUUSERS [ 1 ]
	$I = 0
	While 1
		$USER = __REGENUMKEY ( 2147483651 , $I )
		If @error Then ExitLoop
		If Not StringRegExp ( $USER , "(?i)(^S-1-5-18|_Classes)" ) Then _ARRAYADD ( $HKUUSERS , $USER , 0 , "||||" )
		$I += 1
	WEnd
	Return $HKUUSERS
EndFunc
Func HOSTS ( )
	Local $HOSTS , $READ , $REST , $Y
	GUICtrlSetData ( $LABEL1 , $SCANB & " Hosts: " )
	$FPATH = @SystemDir & "\drivers\etc\hosts"
	If FileExists ( $FPATH ) Then
		FileWrite ( $HADDITION , @CRLF & "==================== Hosts " & $CONTENT & ": =========================" & @CRLF )
		FileWrite ( $HADDITION , @CRLF & "(" & $HOSTS2 & ")" & @CRLF & @CRLF )
		HOSTSFILE ( $FPATH )
		$HHOSTS = FileOpen ( $FPATH , 256 )
		$HOSTS = FileRead ( $HHOSTS )
		FileClose ( $HHOSTS )
		$READ = StringRegExp ( $HOSTS , "(?m)^\s*(\d.+?)(?:\R|$)" , 3 )
		For $I = 0 To UBound ( $READ ) + 4294967295
			FileWrite ( $HADDITION , $READ [ $I ] & @CRLF )
			If $I = 29 Then ExitLoop
		Next
		If UBound ( $READ ) > 100 Then
			$Y = UBound ( $READ ) - $I
			FileWrite ( $HADDITION , @CRLF & $REST1 & " " & $Y & " " & $MOLI & "." & @CRLF & @CRLF )
		EndIf
	Else
		FileWrite ( $HADDITION , @CRLF & $NHOSTS & @CRLF )
	EndIf
EndFunc
Func HOSTSFILE ( $FPATH )
	$DATECR = FILETIME ( $FPATH , 1 )
	$DATEMO = FILETIME ( $FPATH )
	$FATT = FileGetAttrib ( $FPATH )
	$FATT = StringRegExpReplace ( $FATT , "A" , "" )
	If _REPARSEPOINT ( $FPATH ) Then $FATT = $FATT & "L"
	$ATT = StringFormat ( "%05s" , $FATT )
	$ATTS = StringRegExpReplace ( $ATT , "0" , "_" )
	$SIZE = FileGetSize ( $FPATH )
	$SIZES = StringFormat ( "%09u" , $SIZE )
	FileWrite ( $HADDITION , $DATECR & " - " & $DATEMO & " - " & $SIZES & " " & $ATTS & " " & $FPATH & @CRLF )
EndFunc
Func HOSTSFIX ( )
	$PATH = $C & "\Windows\System32\Drivers\etc\hosts"
	If FileExists ( $PATH ) Then
		_GRANTE ( $PATH , 1 , 1 )
		MOVEFILER ( $PATH )
	EndIf
	If Not FileExists ( $PATH ) Then HOSTSFIX1 ( $PATH )
EndFunc
Func HOSTSFIX1 ( $FILEP )
	Local $RET
	If Not FileExists ( $C & "\Windows\System32\Drivers\etc" ) Then DirCreate ( $C & "\Windows\System32\Drivers\etc" )
	If $OSNUM = 6.1 Or $OSNUM = 6.2 Then
		$RET = FileWrite ( $C & "\Windows\System32\Drivers\etc\hosts" , "#       127.0.0.1       localhost" & @CRLF )
	Else
		$RET = FileWrite ( $FILEP , "127.0.0.1       localhost" & @CRLF )
	EndIf
	Select
	Case $RET = 1
		FileWrite ( $HFIXLOG , "Hosts " & $RESTORED & "." & @CRLF )
		_SETDEFAULTFILEACCESS ( $FILEP )
	Case $RET = 0
		FileWrite ( $HFIXLOG , $NRESTORE & " Hosts." & @CRLF )
	EndSelect
EndFunc
Func HOSTSLINE ( )
	GUICtrlSetData ( $LABEL1 , $SCANB & " Hosts: " )
	If FileExists ( @SystemDir & "\drivers\etc\hosts" ) Then
		$HHOSTS = FileOpen ( @SystemDir & "\drivers\etc\hosts" , 256 )
		$HOSTS = FileRead ( $HHOSTS )
		FileClose ( $HHOSTS )
		If StringInStr ( $HOSTS , "<html" ) Then FileWrite ( $FRSTLOG , "Hosts: " & $HOSTS3 & " Addition.txt <==== " & $UPD1 & @CRLF )
		$READ = StringRegExp ( $HOSTS , "(?m)^\s*(\d.+?)(?:\R|$)" , 3 )
		$CNT = UBound ( $READ )
		If $CNT = 1 And $HOSTS <> "" And Not StringRegExp ( $READ [ 0 ] , "(?i)127.0.0.1[ ]*localhost" ) Then FileWrite ( $FRSTLOG , "Hosts: " & $READ [ 0 ] & @CRLF )
		If $CNT > 1 Then
			$LISTHOST = 1
			FileWrite ( $FRSTLOG , "Hosts: " & $INTERNET6 & " Addition.txt" & @CRLF )
		EndIf
	Else
		FileWrite ( $FRSTLOG , "Hosts: " & $INTERNET7 & @CRLF )
	EndIf
EndFunc
Func IE ( )
	Local $MAIN [ 4 ] = [ "Start Page" , "Search Page" , "Default_Page_URL" , "Default_Search_URL" ]
	$KEY = "HKLM\Software\Microsoft\Internet Explorer\Main"
	For $M = 0 To UBound ( $MAIN ) + 4294967295
		IEMAIN ( $KEY , $MAIN [ $M ] )
		IEMAIN ( "HKLM\Software\Wow6432Node\Microsoft\Internet Explorer\Main" , $MAIN [ $M ] )
	Next
	IEMAIN ( $KEY , "Local Page" )
	$KEY = "HKLM\Software\Wow6432Node\Microsoft\Internet Explorer\Main"
	IEMAIN ( $KEY , "Local Page" )
	For $U = 1 To UBound ( $USERREG ) + 4294967295
		$KEY = "HKU\" & $USERREG [ $U ] & "\Software\Microsoft\Internet Explorer\Main"
		IEMAIN ( $KEY , "Local Page" )
		IEMAINREST ( $KEY )
	Next
	$DD = RegRead ( "HKCU\Software\Microsoft\Internet Explorer\Main" , "Default Download Directory" )
	If Not @error Then FileWrite ( $HADDITION , "DownloadDir: " & $DD & @CRLF )
	$HIVE = "HKLM"
	URLSEARCH ( )
	$HIVE = "HKLM-x32"
	URLSEARCH ( )
	For $U = 1 To UBound ( $USERREG ) + 4294967295
		If StringRegExp ( $USERREG [ $U ] , "S-1-5-\d{2}-\d{3,}" ) Then
			RegRead ( "HKU\" & $USERREG [ $U ] & "\SOFTWARE\Microsoft\Internet Explorer\URLSearchHooks" , "{CFBFAE00-17A6-11D0-99CB-00C04FD64497}" )
			If @error Then FileWrite ( $HADDITION , "URLSearchHook: [" & $USERREG [ $U ] & "] " & $UPD1 & " => " & $INTERNET3 & @CRLF )
			$HIVE = "HKU\" & $USERREG [ $U ]
			URLSEARCH ( )
		EndIf
	Next
	SEARCHSCOPE ( "HKLM\SOFTWARE\Microsoft\Internet Explorer\SearchScopes" , "HKLM" )
	SEARCHSCOPE ( "HKLM\SOFTWARE\Wow6432Node\Microsoft\Internet Explorer\SearchScopes" , "HKLM-x32" )
	For $U = 1 To UBound ( $USERREG ) + 4294967295
		SEARCHSCOPE ( "HKU\" & $USERREG [ $U ] & "\SOFTWARE\Microsoft\Internet Explorer\SearchScopes" , "HKU\" & $USERREG [ $U ] )
	Next
	$KEY = "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Browser Helper Objects"
	$HIVE = "BHO: "
	$REGEXPR = "HKCR\CLSID\"
	BHO ( $KEY )
	$KEY = "HKLM\SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\Explorer\Browser Helper Objects"
	$HIVE = "BHO-x32: "
	$REGEXPR = "HKCR\Wow6432Node\CLSID\"
	BHO ( $KEY )
	$KEY = "HKLM\SOFTWARE\Microsoft\Internet Explorer\Toolbar"
	$HIVE = "Toolbar: HKLM - "
	$REGEXPR = "HKCR\CLSID\"
	TOOLBAR ( $KEY )
	$KEY = "HKLM\SOFTWARE\Wow6432Node\Microsoft\Internet Explorer\Toolbar"
	$HIVE = "Toolbar: HKLM-x32 - "
	$REGEXPR = "HKCR\Wow6432Node\CLSID\"
	TOOLBAR ( $KEY )
	For $U = 1 To UBound ( $USERREG ) + 4294967295
		$KEY = "HKU\" & $USERREG [ $U ] & "\Software\Microsoft\Internet Explorer\Toolbar\WebBrowser"
		$HIVE = "Toolbar: HKU\" & $USERREG [ $U ] & " -> "
		$REGEXPR = "HKCR\CLSID\"
		TOOLBAR ( $KEY )
		$RET = RegRead ( "HKU\" & $USERREG [ $U ] & "\Software\Microsoft\Internet Explorer\ContinuousBrowsing" , "Enabled" )
		If $RET Then FileWrite ( $HADDITION , "IE Session Restore: HKU\" & $USERREG [ $U ] & " -> " & $INTERNET2 & @CRLF )
	Next
	$HIVE = "HKLM "
	PDF ( "HKLM\SOFTWARE\Microsoft\Code Store Database\Distribution Units" , "HKLM " )
	PDF ( "HKLM\SOFTWARE\Wow6432Node\Microsoft\Code Store Database\Distribution Units" , "HKLM-x32 " )
	HANDLER ( "Handler" )
	HANDLER ( "Filter" )
	IEPREFIX ( "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\URL\" )
	IEPREFIX ( "HKLM\SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\URL\" )
	Local $STARTMENUINTERNETIE [ 1 ] = [ 0 ]
	$HKEY = _REGOPENKEYEX3 ( "HKLM\SOFTWARE\Clients\StartMenuInternet" , 1 )
	$P = 0
	While 1
		$OPERABRO = __REGENUMKEY ( $HKEY , $P )
		If @error Then ExitLoop
		If StringInStr ( $OPERABRO , "IEXPLORE" ) Then
			$BROWSER = $OPERABRO
			BROWSERSTART ( $BROWSER , $STARTMENUINTERNETIE , "HKLM" )
		EndIf
		$P += 1
	WEnd
	If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
	If UBound ( $STARTMENUINTERNETIE ) > 1 Then
		$STARTMENUINTERNETIE [ 1 ] = StringRegExpReplace ( $STARTMENUINTERNETIE [ 1 ] , "(?i)http(s|):" , "hxxp\1:" )
		FileWrite ( $HADDITION , $STARTMENUINTERNETIE [ 1 ] & @CRLF )
	EndIf
EndFunc
Func IEMAIN ( $KEY , $IEVAL )
	Local $VALDATA
	$VALDATA = RegRead ( $KEY , $IEVAL )
	If @error Then
		If StringInStr ( $KEY , "HKLM" ) Then FileWrite ( $HADDITION , $KEY & "," & $IEVAL & " = " & @CRLF )
		Return 1
	EndIf
	$VALDATA = StringRegExpReplace ( $VALDATA , "(?i)http(s|):" , "hxxp\1:" )
	If GUICtrlRead ( $CHECKBOX11 ) = 1 Then
		If $IEVAL = "Local Page" And Not StringRegExp ( $VALDATA , "(?i)Windows\\(?:System32|SysWOW64)\\blank.htm" ) And Not StringRegExp ( $VALDATA , "(?i)%\d\d%\\blank.htm" ) Then FileWrite ( $HADDITION , $KEY & "," & $IEVAL & " = " & $VALDATA & @CRLF )
		If StringRegExp ( $IEVAL , "Start Page|Search Page|Default_Page_URL|Default_Search_URL|Start Page Redirect Cache" ) And Not StringRegExp ( $VALDATA , "\A(?i)hxxp(|s)://(go.microsoft.com|www.msn.com)/" ) Then FileWrite ( $HADDITION , $KEY & "," & $IEVAL & " = " & $VALDATA & @CRLF )
	Else
		FileWrite ( $HADDITION , $KEY & "," & $IEVAL & " = " & $VALDATA & @CRLF )
	EndIf
EndFunc
Func IEMAINFIX ( )
	Local $USER
	$VAL = StringRegExpReplace ( $FIX , "(?i).+Internet Explorer\\Main,([^=]+) =.*" , "$1" )
	If StringInStr ( $FIX , "HKU\" ) Then
		$USER = StringRegExpReplace ( $FIX , "HKU\\(.+?)\\.+" , "$1" )
		$KEY = "HKU\" & $USER & "\Software\Microsoft\Internet Explorer\Main"
	Else
		If StringInStr ( $FIX , "Wow6432Node" ) Then
			$KEY = "HKLM\Software\Wow6432Node\Microsoft\Internet Explorer\Main"
		Else
			$KEY = "HKLM\Software\\Microsoft\Internet Explorer\Main"
		EndIf
	EndIf
	Select
	Case StringInStr ( $KEY , "HKU\" ) And $OSNUM = 10 And $VAL = "Local Page"
		RESTOREVAL ( $KEY , "Local Page" , "REG_SZ" , "%11%\blank.htm" )
	Case StringRegExp ( $USER , "(?i)(.DEFAULT|S-1-5-18|S-1-5-19|S-1-5-20)$" )
		DELVALUE ( $KEY , $VAL )
	Case $VAL = "Start Page"
		RESTOREVAL ( $KEY , "Start Page" , "REG_SZ" , "http://go.microsoft.com/fwlink/?LinkId=69157" )
	Case $VAL = "Search Page"
		RESTOREVAL ( $KEY , "Search Page" , "REG_SZ" , "http://go.microsoft.com/fwlink/?LinkId=54896" )
	Case $VAL = "Local Page"
		If StringInStr ( $FIX , "Wow6432Node" ) Then
			$VAL = $C & "\Windows\SysWOW64\blank.htm"
		Else
			$VAL = $C & "\Windows\System32\blank.htm"
		EndIf
		RESTOREVAL ( $KEY , "Local Page" , "REG_SZ" , $VAL )
	Case $VAL = "Default_Page_URL"
		RESTOREVAL ( $KEY , "Default_Page_URL" , "REG_SZ" , "http://go.microsoft.com/fwlink/?LinkId=69157" )
	Case $VAL = "Default_Search_URL"
		RESTOREVAL ( $KEY , "Default_Search_URL" , "REG_SZ" , "http://go.microsoft.com/fwlink/?LinkId=54896" )
Case Else
		DELVALUE ( $KEY , $VAL )
	EndSelect
EndFunc
Func IEMAINREST ( $KEY )
	$I = 1
	While 1
		$IEVAL = RegEnumVal ( $KEY , $I )
		If @error Then ExitLoop
		$VALDATA = RegRead ( $KEY , $IEVAL )
		If $IEVAL <> "Local Page" Then
			$VALDATA = StringRegExpReplace ( $VALDATA , "(?i)http(s|):" , "hxxp\1:" )
			If StringRegExp ( $VALDATA , "(?i)(hxxp(|s):|www\.|\.com)" ) Or $IEVAL = "Start Page" Then
				If GUICtrlRead ( $CHECKBOX11 ) = 1 Then
					If StringRegExp ( $IEVAL , "(Start Page|Search Page|Default_Page_URL|Default_Search_URL|Start Page Redirect Cache)" ) And Not StringRegExp ( $VALDATA , "\A(?i)hxxp(|s)://(go.microsoft.com|www.msn.com)/" ) And Not StringRegExp ( $VALDATA , "\A(?i)(hxxp(|s)://|)(www\.|)google.co(m|m/)\Z" ) Then FileWrite ( $HADDITION , $KEY & "," & $IEVAL & " = " & $VALDATA & @CRLF )
				Else
					FileWrite ( $HADDITION , $KEY & "," & $IEVAL & " = " & $VALDATA & @CRLF )
				EndIf
			EndIf
		EndIf
		$I += 1
	WEnd
EndFunc
Func IEPOLICYFIX ( )
	Select
	Case StringRegExp ( $FIX , "HKLM.+Explorer" )
		DELKEY ( "HKLM\SOFTWARE\Policies\Microsoft\Internet Explorer" )
	Case StringRegExp ( $FIX , "HKLM.+Defender" )
		DELKEY ( "HKLM\SOFTWARE\Policies\Microsoft\Windows Defender" )
Case Else
		$USER = StringRegExpReplace ( $FIX , "(?i)HKU\\(.+?)\\.+" , "$1" )
		DELKEY ( "HKU\" & $USER & "\SOFTWARE\Policies\Microsoft\Internet Explorer" )
	EndSelect
EndFunc
Func IEPREFIX ( $KEY )
	$DEFAULTP = "DefaultPrefix"
	$PREFIXES = "Prefixes"
	If StringInStr ( $KEY , "\Wow6432Node\" ) Then
		$DEFAULTP = "DefaultPrefix-x32"
		$PREFIXES = "Prefixes-x32"
	EndIf
	$DATA = RegRead ( $KEY & "DefaultPrefix" , "" )
	If $DATA <> "http://" Then FileWrite ( $HADDITION , $DEFAULTP & ": => " & $DATA & " <==== " & $UPD1 & @CRLF )
	$DATA = RegRead ( $KEY & "Prefixes" , "home" )
	If $DATA <> "http://" Then FileWrite ( $HADDITION , $PREFIXES & ": [home]=> " & $DATA & " <==== " & $UPD1 & @CRLF )
	$DATA = RegRead ( $KEY & "Prefixes" , "www" )
	If $DATA <> "http://" Then FileWrite ( $HADDITION , $PREFIXES & ": [www]=> " & $DATA & " <==== " & $UPD1 & @CRLF )
EndFunc
Func IEPREFIXFIX ( )
	$KEY = "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\URL\"
	If StringInStr ( $FIX , "-x32" ) Then $KEY = "HKLM\SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\URL\"
	If StringRegExp ( $FIX , "DefaultPrefix" ) Then Return RESTOREVAL ( $KEY & "DefaultPrefix" , "" , "REG_SZ" , "http://" )
	If StringInStr ( $FIX , "[home]" ) Then Return RESTOREVAL ( $KEY & "Prefixes" , "home" , "REG_SZ" , "http://" )
	RESTOREVAL ( $KEY & "Prefixes" , "www" , "REG_SZ" , "http://" )
EndFunc
Func IESESSIONFIX ( )
	$USER = StringRegExpReplace ( $FIX , "(?i).+Restore: HKU\\(.+?) ->.*" , "$1" )
	DELKEY ( "HKU\" & $USER & "\Software\Microsoft\Internet Explorer\ContinuousBrowsing" )
EndFunc
Func IEZONESITES ( )
	Local $T [ 1 ] , $R [ 1 ] , $D
	$IEVERSION = "Internet Explorer"
	If $OSNUM < 6.2 Then
		$KEY = "hklm\" & $SOFTWARE & "\microsoft\internet explorer"
		$IEVERSION0 = RegRead ( $KEY , "svcversion" )
		If @error Or $IEVERSION0 = "" Then $IEVERSION0 = RegRead ( $KEY , "version" )
		If $IEVERSION0 <> "" Then
			$IEVERSION0 = StringRegExpReplace ( $IEVERSION0 , "((\d|\d\d))\..+" , "$1" )
			$IEVERSION = $IEVERSION & " (" & $SCAN0 & " " & $IEVERSION0 & ")"
		EndIf
	EndIf
	FileWrite ( $HADDITION , @CRLF & "==================== " & $IEVERSION & " (" & $WLISTED & ") =============" & @CRLF & @CRLF )
	IE ( )
	For $U = 1 To UBound ( $USERREG ) + 4294967295
		$KEY = "HKU\" & $USERREG [ $U ] & "\Software\Microsoft\Windows\CurrentVersion\Internet Settings\ZoneMap\Domains"
		$HKEY = _REGOPENKEYEX3 ( $KEY )
		$IE = 0
		While 1
			$DOMAINS = __REGENUMKEY ( $HKEY , $IE )
			If @error Then ExitLoop
			$KEY1 = $KEY & "\" & $DOMAINS
			$DOMAINNAME = $DOMAINS
			$PREDOMAIN = RegEnumKey ( $KEY1 , 1 )
			If Not @error Then
				$KEY1 = $KEY1 & "\" & $PREDOMAIN
				$DOMAINNAME = $PREDOMAIN & "." & $DOMAINS
			EndIf
			$VALNAME = RegEnumVal ( $KEY1 , 1 )
			$PREFIX = ""
			If StringInStr ( $VALNAME , "http" ) Then
				$PREFIX = $VALNAME & "://"
				$PREFIX = StringRegExpReplace ( $PREFIX , "http" , "hxxp" )
			EndIf
			$VALDATA = RegRead ( $KEY1 , $VALNAME )
			If $VALDATA = "2" Then _ARRAYADD ( $T , "IE trusted site: HKU\" & $USERREG [ $U ] & "\...\" & $DOMAINS & " -> " & $PREFIX & $DOMAINNAME , 0 , "||||" )
			If $VALDATA = "4" Then _ARRAYADD ( $R , "IE restricted site: HKU\" & $USERREG [ $U ] & "\...\" & $DOMAINS & " -> " & $PREFIX & $DOMAINNAME , 0 , "||||" )
			$VALNAME = RegEnumVal ( $KEY1 , 2 )
			If Not @error Then
				$PREFIX = ""
				If StringInStr ( $VALNAME , "http" ) Then
					$PREFIX = $VALNAME & "://"
					$PREFIX = StringRegExpReplace ( $PREFIX , "http" , "hxxp" )
				EndIf
				$VALDATA = RegRead ( $KEY1 , $VALNAME )
				If $VALDATA = "2" Then _ARRAYADD ( $T , "IE trusted site: HKU\" & $USERREG [ $U ] & "\...\" & $DOMAINS & " -> " & $PREFIX & $DOMAINNAME , 0 , "||||" )
				If $VALDATA = "4" Then _ARRAYADD ( $R , "IE restricted site: HKU\" & $USERREG [ $U ] & "\...\" & $DOMAINS & " -> " & $PREFIX & $DOMAINNAME , 0 , "||||" )
			EndIf
			$IE += 1
		WEnd
		If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
		If Not $D And UBound ( $T ) + UBound ( $R ) > 2 Then
			FileWrite ( $HADDITION , @CRLF & "(" & $SERV1 & ")" & @CRLF & @CRLF )
			$D = 1
		EndIf
		IEZONESITES1 ( $T )
		IEZONESITES1 ( $R )
		ReDim $T [ 1 ]
		ReDim $R [ 1 ]
	Next
EndFunc
Func IEZONESITES1 ( $PU )
	If UBound ( $PU ) > 1 Then
		For $I = 1 To UBound ( $PU ) + 4294967295
			FileWrite ( $HADDITION , $PU [ $I ] & @CRLF )
			If $I > 19 Then
				FileWrite ( $HADDITION , @CRLF & $REST1 & " " & UBound ( $PU ) + 4294967276 & " " & $REST2 & "." & @CRLF & @CRLF )
				ExitLoop
			EndIf
		Next
	EndIf
EndFunc
Func IEZONESITESFIX ( )
	$USER = StringRegExpReplace ( $FIX , "IE (?:trus|restric)ted site: HKU\\(.+?)\\.+" , "$1" )
	$SUB = StringRegExpReplace ( $FIX , "IE.+\\(.+?) ->.*" , "$1" )
	$KEY = "HKU\" & $USER & "\Software\Microsoft\Windows\CurrentVersion\Internet Settings\ZoneMap\Domains\" & $SUB
	DELKEY ( $KEY )
EndFunc
Func INTERNET ( )
	GUICtrlSetData ( $LABEL1 , $SCANB & " Internet..." )
	FileClose ( $FRSTLOG )
	$FRSTLOG = FileOpen ( @ScriptDir & "\FRST.txt" , 256 + 1 )
	FileWrite ( $FRSTLOG , @CRLF & "==================== Internet (" & WL ( $CHECKBOX11 ) & ") ====================" & @CRLF )
	FileWrite ( $FRSTLOG , @CRLF & "(" & $INTERNET & ")" & @CRLF & @CRLF )
	$KEY = "HKLM\Software\Microsoft\Windows\CurrentVersion\Internet Settings\Zones"
	$HKEY = _REGOPENKEYEX3 ( $KEY )
	Local $ARRKEY [ 1 ]
	$IE = 0
	While 1
		$L = __REGENUMKEY ( $KEY , $IE )
		If @error Then ExitLoop
		If StringRegExp ( $L , "" ) Then
			_ARRAYADD ( $ARRKEY , $KEY & "\" & $L , 0 , "|||" )
		EndIf
		$IE += 1
	WEnd
	_DELARR ( $ARRKEY )
	Local $ARRKEY1 [ 1 ]
	For $U = 1 To UBound ( $USERREG ) + 4294967295
		$KEY = "HKU\" & $USERREG [ $U ] & "\Software\Microsoft\Windows\CurrentVersion\Internet Settings\Zones"
		$HKEY = _REGOPENKEYEX3 ( $KEY )
		$IE = 0
		While 1
			$L = __REGENUMKEY ( $HKEY , $IE )
			If @error Then ExitLoop
			If StringRegExp ( $L , "" ) Then
				_ARRAYADD ( $ARRKEY1 , $KEY & "\" & $L , 0 , "|||" )
			EndIf
			$IE += 1
		WEnd
	Next
	_DELARR ( $ARRKEY1 )
	$VALDATA = RegRead ( "HKLM\SOFTWARE\Policies\Microsoft\Windows\IPSec\Policy\Local" , "ActivePolicy" )
	If Not @error Then FileWrite ( $FRSTLOG , "IPSecPolicy: [ActivePolicy] " & $VALDATA & " <==== " & $UPD1 & " (" & $RESTRICT & " - IP)" & @CRLF )
	$IEPOL = "HKLM\SOFTWARE\Policies\Microsoft\Windows\CurrentVersion\Internet Settings"
	$VALDATA = RegRead ( $IEPOL , "ProxySettingsPerUser" )
	If Not @error Then FileWrite ( $FRSTLOG , $IEPOL & ": [ProxySettingsPerUser] " & $VALDATA & " <==== " & $UPD1 & " (" & $RESTRICT & " - ProxySettings)" & @CRLF )
	For $I = 0 To 3
		If VAR ( $IEPOL & "\Zones\" & $I ) Then FileWrite ( $FRSTLOG , $IEPOL & "\Zones\" & $I & ": <==== " & $UPD1 & " (" & $RESTRICT & " - Zones)" & @CRLF )
	Next
	$KEYIE = "HKLM\Software\Microsoft\Windows\CurrentVersion\Internet Settings"
	$KEYIE32 = "HKLM\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Internet Settings"
	$VALDATA = RegRead ( $KEYIE , "ProxyEnable" )
	If Not @error And $VALDATA = 1 Then FileWrite ( $FRSTLOG , "ProxyEnable: [HKLM] => Proxy " & $INTERNET2 & @CRLF )
	$VALDATA = RegRead ( $KEYIE32 , "ProxyEnable" )
	If Not @error And $VALDATA = 1 Then FileWrite ( $FRSTLOG , "ProxyEnable: [HKLM-x32] => Proxy " & $INTERNET2 & @CRLF )
	$VALDATA = RegRead ( $KEYIE , "ProxyServer" )
	If Not @error And $VALDATA <> "" Then FileWrite ( $FRSTLOG , "ProxyServer: [HKLM] => " & StringRegExpReplace ( $VALDATA , "(?i)http(s|):" , "hxxp\1:" ) & @CRLF )
	$VALDATA = RegRead ( $KEYIE32 , "ProxyServer" )
	If Not @error And $VALDATA <> "" Then FileWrite ( $FRSTLOG , "ProxyServer: [HKLM-x32] => " & StringRegExpReplace ( $VALDATA , "(?i)http(s|):" , "hxxp\1:" ) & @CRLF )
	$VALDATA = RegRead ( $KEYIE , "AutoConfigURL" )
	If Not @error And $VALDATA <> "" Then
		FileWrite ( $FRSTLOG , "AutoConfigURL: [HKLM] => " & StringRegExpReplace ( $VALDATA , "(?i)http(s|):" , "hxxp\1:" ) & " <==== " & $UPD1 & @CRLF )
	EndIf
	$VALDATA = RegRead ( $KEYIE32 , "AutoConfigURL" )
	If Not @error And $VALDATA <> "" Then
		FileWrite ( $FRSTLOG , "AutoConfigURL: [HKLM-x32] => " & StringRegExpReplace ( $VALDATA , "(?i)http(s|):" , "hxxp\1:" ) & " <==== " & $UPD1 & @CRLF )
	EndIf
	$KEY = "HKLM\SYSTEM\CurrentControlSet\Services\iphlpsvc\Parameters\ProxyMgr"
	$HKEY = _REGOPENKEYEX3 ( $KEY )
	$I = 0
	While 1
		$SKEY = __REGENUMKEY ( $HKEY , $I )
		If @error Then ExitLoop
		$VALDATA = RegRead ( $KEY & "\" & $SKEY , "AutoConfigURL" )
		If Not @error Then
			FileWrite ( $FRSTLOG , "AutoConfigURL: [" & $SKEY & "] => " & StringRegExpReplace ( $VALDATA , "(?i)http(s|):" , "hxxp\1:" ) & " <==== " & $UPD1 & @CRLF )
		EndIf
		$I += 1
	WEnd
	For $U = 1 To UBound ( $USERREG ) + 4294967295
		$UKEYIE = "HKU\" & $USERREG [ $U ] & "\Software\Microsoft\Windows\CurrentVersion\Internet Settings"
		$VALDATA = RegRead ( $UKEYIE , "ProxyEnable" )
		If Not @error And $VALDATA = 1 Then FileWrite ( $FRSTLOG , "ProxyEnable: [" & $USERREG [ $U ] & "] => Proxy " & $INTERNET2 & @CRLF )
		$VALDATA = RegRead ( $UKEYIE , "ProxyServer" )
		If Not @error And $VALDATA <> "" Then FileWrite ( $FRSTLOG , "ProxyServer: [" & $USERREG [ $U ] & "] => " & StringRegExpReplace ( $VALDATA , "(?i)http(s|):" , "hxxp\1:" ) & @CRLF )
		$VALDATA = RegRead ( $UKEYIE , "AutoConfigURL" )
		If Not @error Then
			FileWrite ( $FRSTLOG , "AutoConfigURL: [" & $USERREG [ $U ] & "] => " & StringRegExpReplace ( $VALDATA , "(?i)http(s|):" , "hxxp\1:" ) & " <==== " & $UPD1 & @CRLF )
		EndIf
	Next
	WINSOCK ( )
	HOSTSLINE ( )
	FileClose ( $FRSTLOG )
	$FRSTLOG = FileOpen ( @ScriptDir & "\FRST.txt" , 256 + 1 )
	$VALDATA = RegRead ( "HKLM\" & $SYSTEM & $BOOTSYSTEM & $DEF & "\Services\Tcpip\Parameters" , "DhcpNameServer" )
	If @error = 0 And $VALDATA <> "" Then
		FileWrite ( $FRSTLOG , "Tcpip\Parameters: [DhcpNameServer] " & $VALDATA & @CRLF )
	EndIf
	$VALDATA = RegRead ( "HKLM\" & $SYSTEM & $BOOTSYSTEM & $DEF & "\Services\Tcpip\Parameters" , "NameServer" )
	If @error = 0 And $VALDATA <> "" Then
		FileWrite ( $FRSTLOG , "Tcpip\Parameters: [NameServer] " & $VALDATA & @CRLF )
	EndIf
	$KEY = "HKLM\" & $SYSTEM & $BOOTSYSTEM & $DEF & "\Services\Tcpip\Parameters\Interfaces"
	$HKEY = _REGOPENKEYEX3 ( $KEY )
	$I = 0
	While 1
		$VALDATA = __REGENUMKEY ( $HKEY , $I )
		If @error Then ExitLoop
		INTERNET0 ( $KEY , $VALDATA , "NameServer" )
		INTERNET0 ( $KEY , $VALDATA , "DhcpNameServer" )
		INTERNET0 ( $KEY , $VALDATA , "DhcpDomain" )
		$HKEY1 = _REGOPENKEYEX3 ( $KEY & "\" & $VALDATA )
		If Not @error And IsPtr ( $HKEY1 ) Then
			$II = 0
			While 1
				$VALDATA1 = __REGENUMKEY ( $HKEY1 , $II )
				If @error Then ExitLoop
				INTERNET0 ( $KEY , $VALDATA & "\" & $VALDATA1 , "NameServer" )
				INTERNET0 ( $KEY , $VALDATA & "\" & $VALDATA1 , "DhcpNameServer" )
				INTERNET0 ( $KEY , $VALDATA & "\" & $VALDATA1 , "DhcpDomain" )
				$II += 1
			WEnd
		EndIf
		$I += 1
	WEnd
	$HKEY = _REGOPENKEYEX3 ( "HKLM\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters\PersistentRoutes" , 1 )
	If Not @error And IsPtr ( $HKEY ) Then
		$ARRAYNAME = _LISTVAL ( $HKEY )
		For $V = 0 To UBound ( $ARRAYNAME ) + 4294967295
			If $V > 9 Then
				FileWrite ( $FRSTLOG , "PersistentRoutes: " & $REST1 & " " & UBound ( $ARRAYNAME ) & " PersistentRoutes." & @CRLF & @CRLF )
				ExitLoop
			EndIf
			FileWrite ( $FRSTLOG , "HKLM\System\...\Parameters\PersistentRoutes: [" & $ARRAYNAME [ $V ] [ 0 ] & "]" & $ARRAYNAME [ $V ] [ 1 ] & @CRLF )
		Next
	EndIf
	$VALDATA = RegRead ( "HKLM\SYSTEM\CurrentControlSet\services\NlaSvc\Parameters\Internet\ManualProxies" , "" )
	If Not @error And $VALDATA Then
		FileWrite ( $FRSTLOG , "ManualProxies: " & StringRegExpReplace ( $VALDATA , "(?i)http(s|):" , "hxxp\1:" ) & " <==== " & $UPD1 & @CRLF )
	EndIf
	AAAAPOL0 ( "HKLM\SOFTWARE\Policies\Microsoft\Internet Explorer" , 1 )
	$KEY = "HKLM\SYSTEM\CurrentControlSet\Services\Dnscache\Parameters\DnsPolicyConfig"
	$HKEY = _REGOPENKEYEX3 ( $KEY )
	$I = 0
	While 1
		$SKEY = __REGENUMKEY ( $HKEY , $I )
		If @error Then ExitLoop
		$VALDAT = RegRead ( $KEY & "\" & $SKEY , "GenericDNSServers" )
		If Not @error Then $VALDAT = "GenericDNSServers=" & $VALDAT
		FileWrite ( $FRSTLOG , "DnsPolicyConfig: [" & $SKEY & "] => " & StringRegExpReplace ( $VALDAT , "(?i)http(s|):" , "hxxp\1:" ) & @CRLF )
		$I += 1
	WEnd
	If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
	For $U = 1 To UBound ( $USERREG ) + 4294967295
		AAAAPOL0 ( "HKU\" & $USERREG [ $U ] & "\SOFTWARE\Policies\Microsoft\Internet Explorer" , 1 )
	Next
	$RET = EDGE ( )
	CHROME1 ( $RET )
	FIREFOX ( )
	Local $ARR1 [ ] = [ "CHR" , "OPR" , "BRA" , "VIV" , "YAN" ]
	Local $ARR2 [ ] = [ "Chrome" , "Opera" , "Brave" , "Vivaldi" , "Yandex" ]
	For $B = 0 To UBound ( $ARR1 ) + 4294967295
		$RET = CHROME ( $ARR1 [ $B ] )
		CHROME1 ( $RET , $ARR2 [ $B ] )
	Next
EndFunc
Func INTERNET0 ( $KEY , $SUB , $VALU )
	$VALDATA2 = RegRead ( $KEY & "\" & $SUB , $VALU )
	If Not @error And $VALDATA2 <> "" Then FileWrite ( $FRSTLOG , "Tcpip\..\Interfaces\" & $SUB & ": [" & $VALU & "] " & $VALDATA2 & @CRLF )
EndFunc
Func CHROME1 ( $RET , $BRO = "Edge" )
	If UBound ( $RET ) < 2 Then Return
	FileWrite ( $FRSTLOG , @CRLF & $BRO & ": " & @CRLF & "=======" )
	$RET = _ARRAYUNIQUE ( $RET , 0 , 0 , 0 , 0 , 1 )
	For $P = 0 To UBound ( $RET ) + 4294967295
		If GUICtrlRead ( $CHECKBOX11 ) = 1 And $BRO = "Yandex" And StringRegExp ( $RET [ $P ] , "(?i)YAN (DefaultSearchURL: Default -> {yandex:baseURL}{yandex:searchPath}|DefaultSearchKeyword: Default -> yandex.ru|DefaultSuggestURL: Default -> {yandex:baseSuggestURL})" ) Then ContinueLoop
		$RET [ $P ] = StringRegExpReplace ( $RET [ $P ] , "(?i)http(s|):" , "hxxp\1:" )
		FileWrite ( $FRSTLOG , $RET [ $P ] & @CRLF )
	Next
EndFunc
Func _DELARR ( $ARR )
	For $T = 1 To UBound ( $ARR ) + 4294967295
		RegDelete ( $ARR [ $T ] )
		If Not @error Then FileWrite ( $FRSTLOG , $KEYY & " " & $FOUND1 & $AND1 & $DELETED & ": " & $ARR [ $T ] & "\" & @CRLF & @CRLF )
	Next
EndFunc
Func _DELARR1 ( $ARR )
	For $T = 1 To UBound ( $ARR ) + 4294967295
		DELKEY ( $ARR [ $T ] )
	Next
EndFunc
Func INVALIDSUBKEY ( $FULLKEY , ByRef $INVALIDNAME )
	$HKEY = _HKEY ( $FULLKEY )
	If @error Or $HKEY = 0 Then Return 1
	$INDEX = 0
	While 1
		Local $RESULTLENGTH
		$SKI = DllStructCreate ( $TAGKEYNODEINFORMATION )
		Local $RET = DllCall ( "ntdll.dll" , "int" , "NtEnumerateKey" , "hwnd" , $HKEY , "dword" , $INDEX , "dword" , 1 , "ptr" , DllStructGetPtr ( $SKI ) , "dword" , DllStructGetSize ( $SKI ) , "ulong*" , $RESULTLENGTH )
		If $RET [ 0 ] = + 2147483653 Or $RET [ 0 ] = + 3221225507 Then
			$TAGKEYNODEINFORMATION1 = "int64 LastWriteTime;ulong TitleIndex;ulong ClassOffset;ulong ClassLength;ulong NameLength;byte Name[" & $RET [ 6 ] & "]"
			$SKI = DllStructCreate ( $TAGKEYNODEINFORMATION1 )
			$RET = DllCall ( "ntdll.dll" , "int" , "NtEnumerateKey" , "hwnd" , $HKEY , "dword" , $INDEX , "dword" , 1 , "ptr" , DllStructGetPtr ( $SKI ) , "dword" , DllStructGetSize ( $SKI ) , "ulong*" , $RESULTLENGTH )
		EndIf
		If Not STATUS_SUCCESS ( $RET [ 0 ] ) Then
			_NTCLOSE ( $HKEY )
			Return 1
		EndIf
		$NAMELENGTH = DllStructGetData ( $SKI , "NameLength" )
		$NAME = DllStructGetData ( $SKI , "Name" )
		$NAME = StringMid ( $NAME , 3 , $NAMELENGTH * 2 )
		$CHEKINVAL = _CHKINVAL ( $NAME )
		$INVALID = $CHEKINVAL [ 0 ]
		$CHARS = $CHEKINVAL [ 1 ]
		If $INVALID Then
			$NAME = $CHARS
			$INVALIDNAME = $NAME & "<*>"
			_NTCLOSE ( $HKEY )
			Return
		EndIf
		$INDEX += 1
	WEnd
	_NTCLOSE ( $HKEY )
EndFunc
Func INVALIDSUBKEYDEL ( $MAINKEY , ByRef $RESULT )
	$HKEY = _HKEY ( $MAINKEY )
	If @error Or $HKEY = 0 Then
		$AKEY = $MAINKEY
		If StringLeft ( $AKEY , 2 ) = "0x" Then $AKEY = StringMid ( $AKEY , 3 )
		$AKEY = StringRegExpReplace ( $AKEY , "([^x][^x])00" , "$1" )
		$AKEY = _HEXTOSTRING ( $AKEY )
		$AKEY = _KEYCON ( $AKEY )
		Return FileWrite ( $HFIXLOG , $AKEY & " => Failed to open main key." & @CRLF )
	EndIf
	Local $SOA = DllStructCreate ( $TAGOBJECTATTRIBUTES )
	$INDEX = 0
	While 1
		$SKI = DllStructCreate ( $TAGKEYNODEINFORMATION )
		Local $RESULTLENGTH
		Local $RET = DllCall ( "ntdll.dll" , "int" , "NtEnumerateKey" , "hwnd" , $HKEY , "dword" , $INDEX , "dword" , 1 , "ptr" , DllStructGetPtr ( $SKI ) , "dword" , DllStructGetSize ( $SKI ) , "ulong*" , $RESULTLENGTH )
		If $RET [ 0 ] = + 2147483653 Or $RET [ 0 ] = + 3221225507 Then
			$TAGKEYNODEINFORMATION1 = "int64 LastWriteTime;ulong TitleIndex;ulong ClassOffset;ulong ClassLength;ulong NameLength;byte Name[" & $RET [ 6 ] & "]"
			$SKI = DllStructCreate ( $TAGKEYNODEINFORMATION1 )
			$RET = DllCall ( "ntdll.dll" , "int" , "NtEnumerateKey" , "hwnd" , $HKEY , "dword" , $INDEX , "dword" , 1 , "ptr" , DllStructGetPtr ( $SKI ) , "dword" , DllStructGetSize ( $SKI ) , "ulong*" , $RESULTLENGTH )
		EndIf
		If $RET [ 0 ] = + 2147483674 Or $RET [ 0 ] = + 3221225480 Then ExitLoop
		If Not STATUS_SUCCESS ( $RET [ 0 ] ) Then
			$INDEX += 1
			ContinueLoop
		EndIf
		$NAMELENGTH = DllStructGetData ( $SKI , "NameLength" )
		$NAME = DllStructGetData ( $SKI , "Name" )
		$NAME = StringMid ( $NAME , 3 , $NAMELENGTH * 2 )
		$CHEKINVAL = _CHKINVAL ( $NAME )
		$INVALID = $CHEKINVAL [ 0 ]
		$CHARS = $CHEKINVAL [ 1 ]
		If $INVALID Then
			Local $SZNAME = DllStructCreate ( "byte[520]" )
			Local $SUS = DllStructCreate ( "ushort Length;ushort MaximumLength;ptr Buffer" )
			DllStructSetData ( $SZNAME , 1 , "0x" & $NAME )
			$NLENGTH = StringLen ( $NAME ) / 2
			DllStructSetData ( $SUS , "Length" , $NLENGTH )
			DllStructSetData ( $SUS , "MaximumLength" , $NLENGTH + 2 )
			DllStructSetData ( $SUS , "Buffer" , DllStructGetPtr ( $SZNAME ) )
			DllStructSetData ( $SOA , "Length" , DllStructGetSize ( $SOA ) )
			DllStructSetData ( $SOA , "RootDirectory" , $HKEY )
			DllStructSetData ( $SOA , "ObjectName" , DllStructGetPtr ( $SUS ) )
			DllStructSetData ( $SOA , "Attributes" , 64 )
			DllStructSetData ( $SOA , "SecurityDescriptor" , 0 )
			DllStructSetData ( $SOA , "SecurityQualityOfService" , 0 )
			$RET = DllCall ( "ntdll.dll" , "int" , "NtOpenKey" , "hwnd*" , "" , "dword" , $KEY_ALL_ACCESS , "ptr" , DllStructGetPtr ( $SOA ) )
			If Not STATUS_SUCCESS ( $RET [ 0 ] ) And $RET [ 0 ] = + 3221225506 Then
				$RET = DllCall ( "ntdll.dll" , "int" , "NtOpenKey" , "hwnd*" , "" , "dword" , 131097 , "ptr" , DllStructGetPtr ( $SOA ) )
				If STATUS_SUCCESS ( $RET [ 0 ] ) Then
					_GRANTE ( $RET [ 1 ] , 4 , 0 )
					$RET = DllCall ( "ntdll.dll" , "int" , "NtOpenKey" , "hwnd*" , "" , "dword" , $KEY_ALL_ACCESS , "ptr" , DllStructGetPtr ( $SOA ) )
				Else
					If Not $TAKEOWNPRI Then _SETPRIV ( "SeTakeOwnershipPrivilege" )
					$RET = DllCall ( "ntdll.dll" , "int" , "NtOpenKey" , "hwnd*" , "" , "dword" , 524288 , "ptr" , DllStructGetPtr ( $SOA ) )
					If STATUS_SUCCESS ( $RET [ 0 ] ) Then
						_GRANTE ( $RET [ 1 ] , 4 , 0 )
						$RET = DllCall ( "ntdll.dll" , "int" , "NtOpenKey" , "hwnd*" , "" , "dword" , $KEY_ALL_ACCESS , "ptr" , DllStructGetPtr ( $SOA ) )
					EndIf
				EndIf
			EndIf
			$HANDLE2 = $RET [ 1 ]
			_NTDELETEKEY ( $HANDLE2 )
			If Not @error Then
				$RESULT = 1
				_NTFLUSH ( $HANDLE2 )
				ExitLoop
			EndIf
		EndIf
		$INDEX += 1
	WEnd
	_NTCLOSE ( $HKEY )
EndFunc
Func INVALIDSUBKEYNAMEFIX ( )
	Local $NAME , $RET
	If $BOOTM <> "Recovery" Then KILLDLL ( )
	$FULLKEY = StringRegExpReplace ( $FIX , ".*(\[.+\]).*" , "$1" )
	$MAINKEY = StringRegExpReplace ( $FULLKEY , "\[(.+)\\.*\]" , "$1" )
	_CHECKKEYPERMS ( $MAINKEY )
	$MAINKEY = StringRegExpReplace ( $MAINKEY , "(?i)(HKU|HKEY_USERS)" , "\\registry\\user" )
	$MAINKEY = StringRegExpReplace ( $MAINKEY , "(?i)(HKLM|HKEY_LOCAL_MACHINE)" , "\\registry\\machine" )
	$MAINKEY = _STRTOUN ( $MAINKEY )
	INVALIDSUBKEYDEL ( $MAINKEY , $RET )
	If $RET = 1 Then Return FileWrite ( $HFIXLOG , $FULLKEY & " => " & $INVALKEY & " " & $DELETED & @CRLF )
	INVALIDSUBKEY ( $MAINKEY , $NAME )
	If $NAME <> "" Then Return FileWrite ( $HFIXLOG , $FULLKEY & " => " & $NDELETED & " " & $INVALKEY & "." & @CRLF )
	FileWrite ( $HFIXLOG , $FULLKEY & " => " & $INVALKEY & " " & $NFOUND & "." & @CRLF )
EndFunc
Func KILLDLL ( )
	$ARRAYPRO = ProcessList ( )
	If Not IsArray ( $ARRAYPRO ) Then Return 1
	For $I = 1 To UBound ( $ARRAYPRO ) + 4294967295
		If StringRegExp ( $ARRAYPRO [ $I ] [ 0 ] , "(?i)(dllhost|rundll32|regsvr32)" ) Then ProcessClose ( $ARRAYPRO [ $I ] [ 1 ] )
	Next
EndFunc
Func KRP ( )
	$FILEP1 = StringRegExpReplace ( $FIX , "\s<\d+>" , "" )
	$FILEP1 = StringRegExpReplace ( $FILEP1 , "(?i)\A\([^\(]*->\) " , "" )
	$FILEP1 = StringRegExpReplace ( $FILEP1 , "(?i)\A\([^\(]*\) (.+)" , "$1" )
	$FILEP1 = StringRegExpReplace ( $FILEP1 , "(?i)\A\[.+\] (.+)" , "$1" )
	$FILEP1 = StringRegExpReplace ( $FILEP1 , "\s+$" , "" )
	$ARRAYPRO = ProcessList ( )
	$T = 0
	For $I = 1 To UBound ( $ARRAYPRO ) + 4294967295
		$PATH1 = _RUNPR ( $ARRAYPRO [ $I ] [ 1 ] )
		If $PATH1 And $FILEP1 = $PATH1 Then
			If Not PROCRIT ( $ARRAYPRO [ $I ] [ 1 ] ) Then Return FileWrite ( $HFIXLOG , """" & $FILEP1 & """ => " & $PRO7 & @CRLF )
			$T = 1
			ProcessClose ( $ARRAYPRO [ $I ] [ 1 ] )
			If Not @error Then
				FileWrite ( $HFIXLOG , "[" & $ARRAYPRO [ $I ] [ 1 ] & "] " & $FILEP1 & " => " & $PRO5 & "." & @CRLF )
			Else
				Select
				Case @error = 1
					FileWrite ( $HFIXLOG , $FILEP1 & " => " & $PRO6 & "." & @CRLF )
				Case @error = 2
					FileWrite ( $HFIXLOG , $FILEP1 & " => AdjustTokenPrivileges " & $ERR0 & "." & @CRLF )
				Case @error = 3
					FileWrite ( $HFIXLOG , $FILEP1 & " => " & $PRO7 & @CRLF )
				Case @error = 4
					FileWrite ( $HFIXLOG , $FILEP1 & " => " & $PRO4 & @CRLF )
				EndSelect
			EndIf
			ExitLoop
		EndIf
	Next
	If $T = 0 Then FileWrite ( $HFIXLOG , $FILEP1 & " => " & $PRO8 & @CRLF )
EndFunc
Func LASTBOOT ( )
	FileClose ( $FRSTLOG )
	$FRSTLOG = FileOpen ( @ScriptDir & "\FRST.txt" , 256 + 1 )
	Local $HIVES [ 5 ] = [ "DEFAULT" , "SAM" , "SECURITY" , "SOFTWARE" , "SYSTEM" ]
	For $I = 0 To UBound ( $HIVES ) + 4294967295
		$FREG = $C & "\windows\system32\config\regback\" & $HIVES [ $I ]
		If Not FileExists ( $FREG ) Or FileGetSize ( $FREG ) = 0 Then Return
	Next
	$DATEMO = FILETIME ( $C & "\windows\system32\config\regback\software" )
	FileWrite ( $FRSTLOG , @CRLF & "LastRegBack: " & $DATEMO & @CRLF )
EndFunc
Func LEGALNOTICE ( $KEY )
	If StringInStr ( $FIX , "LegalNoticeCaption" ) Then
		$VAL = "LegalNoticeCaption"
	Else
		$VAL = "LegalNoticeText"
	EndIf
	RESTOREVAL ( $KEY , $VAL , "REG_SZ" , "" )
EndFunc
Func LISTBCD ( )
	$COM = @SystemDir & "\bcdedit.exe /enum all"
	If $OSNUM > 6 And $BOOTM <> "Recovery" Then
		$PATH0 = $C & "\FRST\tmp.ps1"
		$HFILE = FileOpen ( $PATH0 , 128 + 2 )
		FileWrite ( $HFILE , $COM & @CRLF )
		FileClose ( $HFILE )
		$PATH1 = $C & "\FRST\pw000.txt"
		$SCMD = $C & "\Windows\System32\WindowsPowerShell\v1.0\powershell.exe"
		RunWait ( $SCMD & " -ExecutionPolicy Bypass " & $PATH0 & " -File > " & $PATH1 , "" , @SW_HIDE )
		If Not FileRead ( $PATH1 ) Then RunWait ( $SCMD & " -ExecutionPolicy Bypass " & $PATH0 & " -File Powershell 2>&1 > " & $PATH1 , "" , @SW_HIDE )
		FileDelete ( $PATH0 )
		$READ = FileRead ( $PATH1 )
		FileDelete ( $PATH1 )
	Else
		$CHCP = ""
		$PID = Run ( @ComSpec & " /c chcp" , @SystemDir , @SW_HIDE , 8 )
		ProcessWaitClose ( $PID )
		$READ1 = StdoutRead ( $PID )
		If StringInStr ( $READ1 , "866" ) Or StringRegExp ( "0419|0422|0423|0402|042F|0C1A|1C1A|281A|301A|0428|0450|082C|0843|201A" , @MUILang ) Then $CHCP = "chcp 1251 >NUL & "
		$READ = CMDRUN ( $CHCP & $COM )
	EndIf
	FileWrite ( $FRSTLOG , @CRLF & "==================== BCD ================================" & @CRLF & $READ & @CRLF )
EndFunc
Func LN ( $ILCID )
	Local $ARET = DllCall ( "kernel32.dll" , "int" , "LCIDToLocaleName" , "int" , $ILCID , "wstr" , "" , "int" , 85 , "dword" , 0 )
	If IsArray ( $ARET ) And $ARET [ 0 ] Then Return $ARET [ 2 ]
EndFunc
Func LOCALFREE ( $HANDLE )
	DllCall ( "kernel32.dll" , "handle" , "LocalFree" , "handle" , $HANDLE )
EndFunc
Func LOGGEDU ( )
	Local $USERS , $USER , $U = 0 , $LOGGED [ 1 ] = [ ]
	While 1
		$USER = __REGENUMKEY ( 2147483651 , $U )
		If @error Then ExitLoop
		If StringInStr ( $USER , "S-1-5" ) And Not StringRegExp ( $USER , "S-1-5-(18|19|20)$|_Classes|-\{" ) Then
			_ARRAYADD ( $LOGGED , $USER , 0 , "||||" )
		EndIf
		$U += 1
	WEnd
	If UBound ( $LOGGED ) = 1 Then Return False
	$LOGGEDUSERS = ""
	$AND = " & "
	For $U = 1 To UBound ( $LOGGED ) + 4294967295
		If $U = UBound ( $LOGGED ) + 4294967295 Then $AND = ""
		$ACCOUNTNAME = _SECURITY__LOOKUPACCOUNTSID ( $LOGGED [ $U ] )
		If IsArray ( $ACCOUNTNAME ) Then $LOGGEDUSERS = $LOGGEDUSERS & $ACCOUNTNAME [ 0 ] & $AND
	Next
	Return $LOGGEDUSERS
EndFunc
Func LSAA ( )
	RESTOREVAL ( "HKLM\" & $SYSTEM & $BOOTSYSTEM & $DEF & "\Control\Lsa" , "Authentication Packages" , "REG_MULTI_SZ" , "msv1_0" )
EndFunc
Func LSAN ( )
	RESTOREVAL ( "HKLM\" & $SYSTEM & $BOOTSYSTEM & $DEF & "\Control\Lsa" , "Notification Packages" , "REG_MULTI_SZ" , "scecli" )
EndFunc
Func LUFIL ( )
	Local $ARRFIL [ ] = [ "{4D36E967-E325-11CE-BFC1-08002BE10318}" , "{71A27CDD-812A-11D0-BEC7-08002BE2092F}" , "{4D36E96B-E325-11CE-BFC1-08002BE10318}" , "{4D36E96A-E325-11CE-BFC1-08002BE10318}" , "{4D36E97B-E325-11CE-BFC1-08002BE10318}" ]
	$KEY = "HKLM\" & $SYSTEM & $BOOTSYSTEM & $DEF & "\Control\Class\"
	For $I = 0 To UBound ( $ARRFIL ) + 4294967295
		$VAL = RegRead ( $KEY & $ARRFIL [ $I ] , "UpperFilters" )
		If Not $VAL Then
			If $I > 1 Then ContinueLoop
			If $I = 1 And $OSNUM < 10 And $OSNUM > 5.1 Then ContinueLoop
		EndIf
		$VAL = StringRegExpReplace ( $VAL , "\v" , " " )
		If $I = 0 And $VAL = "PartMgr" Then ContinueLoop
		If $I = 1 And $VAL = "volsnap" And ( $OSNUM = 10 Or $OSNUM = 5.1 ) Then ContinueLoop
		If $I = 2 And $VAL = "kbdclass" Then ContinueLoop
		FileWrite ( $FRSTLOG , "UpperFilters: [" & $ARRFIL [ $I ] & "] -> [" & $VAL & "]" & @CRLF )
	Next
	For $I = 0 To UBound ( $ARRFIL ) + 4294967295
		$VAL = RegRead ( $KEY & $ARRFIL [ $I ] , "LowerFilters" )
		If Not $VAL Then
			If $I > 1 Or $OSNUM = 5.1 Then ContinueLoop
			If $I = 0 And $OSNUM < 6.3 Then ContinueLoop
		EndIf
		$VAL = StringRegExpReplace ( $VAL , "\v" , " " )
		If $I = 0 And $VAL = "EhStorClass" And ( $OSNUM = 10 Or $OSNUM = 6.3 ) Then ContinueLoop
		If $I = 0 And $VAL = "iaStorF" And $OSNUM = 6.1 Then ContinueLoop
		If $I = 1 And $VAL = "fvevol iorate rdyboost" And $OSNUM = 10 Then ContinueLoop
		If $I = 1 And $VAL = "fvevol rdyboost" And ( $OSNUM = 6.3 Or $OSNUM = 6.1 ) Then ContinueLoop
		If $I = 1 And $VAL = "ecache" And $OSNUM = 6 Then ContinueLoop
		FileWrite ( $FRSTLOG , "LowerFilters: [" & $ARRFIL [ $I ] & "] -> [" & $VAL & "]" & @CRLF )
	Next
EndFunc
Func LUFILDEL ( $SER )
	$KEY = "HKLM\" & $SYSTEM & $BOOTSYSTEM & $DEF & "\Control\Class"
	$HKEY = _REGOPENKEYEX3 ( $KEY )
	If @error Or Not $HKEY Then Return
	$I = 0
	While 1
		$ID = __REGENUMKEY ( $HKEY , $I )
		If @error Then ExitLoop
		LUFILDEL1 ( $KEY & "\" & $ID , "LowerFilters" , $SER )
		LUFILDEL1 ( $KEY & "\" & $ID , "UpperFilters" , $SER )
		$I += 1
	WEnd
	If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
EndFunc
Func LUFILDEL1 ( $KEY , $VAL , $SERN )
	$DAT = RegRead ( $KEY , $VAL )
	If StringRegExp ( $DAT , "(?i)(^|\n)" & $SERN & "(\n|$)" ) <> 1 Then Return
	$DAT = StringRegExpReplace ( $DAT , "(?i)^" & $SERN & "(\n|$)|\n" & $SERN & "$" , "" )
	$DAT = StringRegExpReplace ( $DAT , "(?i)\n" & $SERN & "\n" , @LF )
	If StringRegExpReplace ( $DAT , "\s" , "" ) Then
		If Not RegWrite ( $KEY , $VAL , "REG_MULTI_SZ" , $DAT ) Then
			NDELETED ( $KEY & "\\" & $VAL & " " & $SERN )
		Else
			FileWrite ( $HFIXLOG , $KEY & "\\" & $VAL & " " & $SERN & " => " & $VAL0 & " " & $DELETED & @CRLF )
		EndIf
	Else
		DELVALUE ( $KEY , $VAL )
	EndIf
EndFunc
Func LUFILFIX ( )
	$SID = StringRegExpReplace ( $FIX , ".+\[([^]]+)\] ->.*" , "$1" )
	$FIL = StringRegExpReplace ( $FIX , "(.+Filters):\s*\[.+" , "$1" )
	$KEY = "HKLM\" & $SYSTEM & $BOOTSYSTEM & $DEF & "\Control\Class\" & $SID
	Select
	Case $SID = "{4D36E967-E325-11CE-BFC1-08002BE10318}" And $FIL = "UpperFilters"
		RESTOREVAL ( $KEY , "UpperFilters" , "REG_MULTI_SZ" , "PartMgr" )
	Case $SID = "{4D36E96B-E325-11CE-BFC1-08002BE10318}" And $FIL = "UpperFilters"
		RESTOREVAL ( $KEY , "UpperFilters" , "REG_MULTI_SZ" , "kbdclass" )
	Case $SID = "{4D36E967-E325-11CE-BFC1-08002BE10318}" And $FIL = "LowerFilters" And ( $OSNUM = 10 Or $OSNUM = 6.3 )
		RESTOREVAL ( $KEY , "LowerFilters" , "REG_MULTI_SZ" , "EhStorClass" )
	Case $SID = "{71A27CDD-812A-11D0-BEC7-08002BE2092F}" And $FIL = "UpperFilters" And ( $OSNUM = 10 Or $OSNUM = 5.1 )
		RESTOREVAL ( $KEY , "UpperFilters" , "REG_MULTI_SZ" , "volsnap" )
	Case $SID = "{71A27CDD-812A-11D0-BEC7-08002BE2092F}" And $FIL = "LowerFilters" And $OSNUM = 10
		RESTOREVAL ( $KEY , "LowerFilters" , "REG_MULTI_SZ" , "fvevol" & @LF & "iorate" & @LF & "rdyboost" )
	Case $SID = "{71A27CDD-812A-11D0-BEC7-08002BE2092F}" And $FIL = "LowerFilters" And ( $OSNUM = 6.3 Or $OSNUM = 6.1 )
		RESTOREVAL ( $KEY , "LowerFilters" , "REG_MULTI_SZ" , "fvevol" & @LF & "rdyboost" )
	Case $SID = "{71A27CDD-812A-11D0-BEC7-08002BE2092F}" And $FIL = "LowerFilters" And $OSNUM = 6
		RESTOREVAL ( $KEY , "LowerFilters" , "REG_MULTI_SZ" , "ecache" )
Case Else
		DELVALUE ( $KEY , $FIL )
	EndSelect
EndFunc
Func MAINAPP ( )
	Local $CO = 0
	$HEVENTLOG = _EVENTLOG__OPEN ( "" , "application" )
	$AEVENT = _EVENTLOG__READ ( $HEVENTLOG , True , False )
	FileWrite ( $HADDITION , @CRLF & "==================== " & $EVENTS1 & ": ========================" & @CRLF & @CRLF & $EVENTS3 & ":" & @CRLF & "==================" & @CRLF )
	While 1
		$AEVENT = _EVENTLOG__READ ( $HEVENTLOG , False , False , $AEVENT [ 1 ] )
		If $AEVENT [ 1 ] = 0 Then ExitLoop
		GUICtrlSetData ( $LABEL1 , $SCANB & " " & $EVENTS3 & ": " & $AEVENT [ 1 ] )
		If $AEVENT [ 7 ] = 1 Then
			FileWrite ( $HADDITION , $AEVENT [ 8 ] & ": (" & $AEVENT [ 4 ] & " " & $AEVENT [ 5 ] & ") (" & "Source: " & $AEVENT [ 10 ] & ") (EventID: " & $AEVENT [ 6 ] & ") (User: " & $AEVENT [ 12 ] & ")" & @CRLF & "Description: " & StringRegExpReplace ( $AEVENT [ 13 ] , "(?s)" & @CRLF & "(.)($|" & @CRLF & ")" , "$1" ) & @CRLF & @CRLF )
			$CO = $CO + 1
			If $CO = 8 Then ExitLoop
		EndIf
		$AEVENT [ 1 ] -= 1
	WEnd
	_EVENTLOG__CLOSE ( $HEVENTLOG )
EndFunc
Func MAINSYS ( )
	$CO = 0
	$HEVENTLOG = _EVENTLOG__OPEN ( "" , "system" )
	$AEVENT = _EVENTLOG__READ ( $HEVENTLOG , True , False )
	FileWrite ( $HADDITION , @CRLF & $EVENTS4 & ":" & @CRLF & "=============" & @CRLF )
	While 1
		$AEVENT = _EVENTLOG__READ ( $HEVENTLOG , False , False , $AEVENT [ 1 ] )
		If $AEVENT [ 1 ] = 0 Then ExitLoop
		GUICtrlSetData ( $LABEL1 , $SCANB & " " & $EVENTS4 & ": " & $AEVENT [ 1 ] )
		If $AEVENT [ 7 ] = 1 Then
			$DESC = $AEVENT [ 13 ]
			If StringRegExp ( $DESC , "%%-?\d| -\d{10}\b|0x[\da-z]+:" ) Then
				$RET = StringRegExp ( $DESC , "%%-?\d+| -\d{10}\b|0x[\da-z]+:" , 1 )
				If IsArray ( $RET ) Then
					$RET1 = StringRegExpReplace ( $RET [ 0 ] , "%%|^ |:$" , "" )
					$RET = _WINAPI_GETERRORMESSAGE ( $RET1 )
					If $RET Then $DESC = StringRegExpReplace ( $DESC , "(" & $RET1 & ")" , "(\1 = " & $RET & ")" )
				EndIf
			EndIf
			FileWrite ( $HADDITION , $AEVENT [ 8 ] & ": (" & $AEVENT [ 4 ] & " " & $AEVENT [ 5 ] & ") (" & "Source: " & $AEVENT [ 10 ] & ") (EventID: " & $AEVENT [ 6 ] & ") (User: " & $AEVENT [ 12 ] & ")" & @CRLF & "Description: " & StringRegExpReplace ( $DESC , "(?s)" & @CRLF & "(.)($|" & @CRLF & ")" , "$1" ) & @CRLF & @CRLF )
			$CO = $CO + 1
			If $CO = 8 Then ExitLoop
		EndIf
		$AEVENT [ 1 ] -= 1
	WEnd
	_EVENTLOG__CLOSE ( $HEVENTLOG )
EndFunc
Func MD5 ( $PATH )
	$MD5 = _CRYPT_HASHFILE ( $PATH , 32771 )
	Return StringTrimLeft ( $MD5 , 2 )
EndFunc
Func MNT ( $LOG )
	Local $VOL [ 1 ]
	$RET = DllCall ( "Kernel32.dll" , "handle" , "FindFirstVolumeW" , "wstr" , "" , "dword" , 255 )
	If $RET [ 0 ] = + 4294967295 Then Return
	_ARRAYADD ( $VOL , $RET [ 1 ] , 0 , "||||" )
	$HANDELE = $RET [ 0 ]
	While 1
		$RET = DllCall ( "Kernel32.dll" , "bool" , "FindNextVolumeW" , "handle" , $HANDELE , "wstr" , "" , "dword" , 255 )
		If Not $RET [ 0 ] Then
			DllCall ( "Kernel32.dll" , "bool" , "FindVolumeClose" , "handle" , $HANDELE )
			ExitLoop
		EndIf
		_ARRAYADD ( $VOL , $RET [ 2 ] , 0 , "||||" )
	WEnd
	$VAR = DriveGetDrive ( "all" )
	For $I = 1 To UBound ( $VAR ) + 4294967295
		$RET = DllCall ( "Kernel32.dll" , "bool" , "GetVolumeNameForVolumeMountPointW" , "wstr" , $VAR [ $I ] & "\" , "wstr" , "" , "dword" , 255 )
		If Not $RET [ 0 ] Then ContinueLoop
		For $II = 1 To UBound ( $VOL ) + 4294967295
			If $VOL [ $II ] = $RET [ 2 ] Then $VOL [ $II ] = 0
		Next
	Next
	For $I = 1 To UBound ( $VOL ) + 4294967295
		If $VOL [ $I ] Then FileWrite ( $LOG , $VOL [ $I ] & " (" & DriveGetLabel ( $VOL [ $I ] ) & ") (" & DriveGetType ( $VOL [ $I ] ) & ") (Total:" & Round ( DriveSpaceTotal ( $VOL [ $I ] ) / 1024 , 2 ) & " GB) (Free:" & Round ( DriveSpaceFree ( $VOL [ $I ] ) / 1024 , 2 ) & " GB) " & DriveGetFileSystem ( $VOL [ $I ] ) & @CRLF )
	Next
EndFunc
Func MOUNTPOINTS2FIX ( )
	Local $CLSID , $USER
	$USER = StringRegExpReplace ( $FIX , "HKU\\(.+?)\\.+\\MountPoints2:.*" , "$1" )
	If StringRegExp ( $FIX , "\{.+\}" ) Then
		$CLSID = StringRegExpReplace ( $FIX , "[^\{]+(\{.+?\}).*" , "$1" )
		$KEY = "HKU\" & $USER & "\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\MountPoints2\" & $CLSID
		DELKEY ( $KEY )
		$KEY = "HKLM\Software\Classes\CLSID\" & $CLSID
		If VAR ( $KEY ) Then DELKEY ( $KEY )
	Else
		$CLSID = StringRegExpReplace ( $FIX , "HKU\\.+\\MountPoints2: (.+?) - .*" , "$1" )
		$KEY = "HKU\" & $USER & "\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\MountPoints2\" & $CLSID
		DELKEY ( $KEY )
	EndIf
EndFunc
Func MOVE ( )
	$FIX = StringRegExpReplace ( $FIX , """" , "" )
	$SOURCE = StringRegExpReplace ( $FIX , "(?i)Move:[ ]*([b-z]:\\[^:]+)[ ][b-z]:\\.+" , "$1" )
	$FILEP = StringRegExpReplace ( $FIX , "(?i)Move:[ ]*[b-z]:\\[^:]+[ ]([b-z]:\\[^:]+)[ ]*" , "$1" )
	If Not FileExists ( "\\?\" & $SOURCE ) Then Return NFOUND ( $SOURCE )
	If FileExists ( "\\?\" & $FILEP ) Then MOVEFILE ( $FILEP )
	$CHECK = FileMove ( "\\?\" & $SOURCE , "\\?\" & $FILEP , 1 )
	Select
	Case $CHECK = 1
		FileWrite ( $HFIXLOG , """" & $SOURCE & """  " & $MOVED & " " & $TO & " " & $FILEP & @CRLF )
	Case $CHECK = 0
		FileWrite ( $HFIXLOG , """" & $SOURCE & """ " & $FIX8 & " " & $TO & " " & $FILEP & @CRLF )
	EndSelect
EndFunc
Func MOVED ( $PATH )
	FileWrite ( $HFIXLOG , $PATH & " => " & $MOVED & @CRLF )
EndFunc
Func MOVEDIR ( $PATH )
	$PATH1 = "\\?\" & $PATH
	If Not FileExists ( $PATH1 ) Then Return NFOUND ( $PATH )
	$SDEST = DESTIN ( $PATH )
	$DIRDONE = DirMove ( $PATH1 , $SDEST , 1 )
	Select
	Case $DIRDONE = 1 And Not FileExists ( $PATH1 )
		MOVED ( $PATH )
	Case $DIRDONE = 0 Or FileExists ( $PATH1 )
		If StringInStr ( $PATH , "\$Recycle.Bin\S-1-5-18" ) Or StringInStr ( $PATH , "\$Recycle.Bin\S-1-5-21" ) Or StringInStr ( $PATH , $C & "\RECYCLER\S-1-5-21" ) Or StringInStr ( $PATH , $C & "\RECYCLER\S-1-5-18" ) Or StringInStr ( $PATH , "\Desktop\install" ) Then
			_GRANTE ( $PATH1 , 1 , 1 )
			$DIRDONE = DirMove ( $PATH1 , $SDEST , 1 )
			Select
			Case $DIRDONE = 1
				MOVED ( $PATH )
			Case $DIRDONE = 0
				RunWait ( @ComSpec & " /c " & "rd /q/s """ & $PATH & """" , "" , @SW_HIDE )
				If Not FileExists ( $PATH1 ) Then
					DELETED ( $PATH )
				Else
					If $BOOTM <> "Recovery" Then
						MOVEDIRNORMAL ( $PATH )
					Else
						NMOVED ( $PATH )
					EndIf
				EndIf
			EndSelect
		Else
			_GRANTE ( $PATH1 , 1 , 1 )
			$DIRDONE = DirMove ( $PATH1 , $SDEST , 1 )
			Select
			Case $DIRDONE = 1 And Not FileExists ( $PATH1 )
				MOVED ( $PATH )
			Case $DIRDONE = 0 Or FileExists ( $PATH1 )
				If $BOOTM <> "Recovery" Then
					MOVEDIRNORMAL ( $PATH )
				Else
					NMOVED ( $PATH )
				EndIf
			EndSelect
		EndIf
	EndSelect
EndFunc
Func MOVEDIRNORMAL ( $DIR )
	Local $DIRDONE
	FileWrite ( $HFIXLOG , @CRLF & """" & $DIR & """ " & $FOL0 & " " & $MOVE & ":" & @CRLF & @CRLF )
	_GRANTE ( $DIR , 1 , 1 )
	$AARRAY = _FILELISTTOARRAYREC ( $FILE , "*" , 1 , 1 , 0 , 2 )
	For $Z = 1 To UBound ( $AARRAY ) + 4294967295
		$FILEP = $AARRAY [ $Z ]
		If $FILEP <> "" Then MOVEFILENORMAL ( $FILEP )
	Next
	$NDIR = StringRegExpReplace ( $DIR , "(?i)([a-z]):" , "$1" )
	$SDEST = $C & "\FRST\Quarantine\" & $NDIR
	$DIRDONE = DirMove ( $DIR , $SDEST , 1 )
	Select
	Case $DIRDONE = 1 And Not FileExists ( $DIR )
		MOVED ( $DIR )
	Case $DIRDONE = 0 Or FileExists ( $DIR )
		_GRANTE ( $DIR , 1 , 1 )
		FileWrite ( $HFIXLOG , $FIX8 & " """ & $DIR & """ => " & $MOVEREB & "." & @CRLF & @CRLF )
		MOVEFILEONREBOOT ( $DIR , $SDEST )
		$HFILES = FileOpen ( $C & "\FRST\files" , 1 + 256 )
		FileWrite ( $C & "\FRST\files" , $DIR & @CRLF )
		FileWrite ( $C & "\FRST\reb" , "reboote?" & @CRLF )
		FileClose ( $HFILES )
	EndSelect
EndFunc
Func MOVEFILE ( $PATH )
	$PATH1 = "\\?\" & $PATH
	If StringRegExp ( FileGetAttrib ( $PATH1 ) , "(?i)S|R|H" ) Then FileSetAttrib ( $PATH1 , "-RSH" )
	$FNAME = StringRegExpReplace ( $PATH , ".+\\([^\\]+)" , "$1" )
	$NDIR = StringRegExpReplace ( $PATH , ":" , "" )
	$NDIR = StringRegExpReplace ( $NDIR , "(.+)\\.+" , "$1" )
	$NDIR = $C & "\FRST\Quarantine\" & $NDIR
	DirCreate ( $NDIR )
	$SDEST = "\\?\" & $NDIR & "\" & $FNAME & ".xBAD"
	$DIRDONE = FileMove ( $PATH1 , $SDEST , 1 + 8 )
	Select
	Case $DIRDONE = 1
		MOVED ( $PATH )
	Case $DIRDONE = 0
		If FILEACCN ( $PATH1 ) Then
			_GRANTE ( $PATH1 , 1 , 0 )
			If StringRegExp ( FileGetAttrib ( $PATH1 ) , "(?i)S|R|H" ) Then FileSetAttrib ( $PATH1 , "-RSH" )
			$DIRDONE = FileMove ( $PATH1 , $SDEST , 1 + 8 )
			Select
			Case $DIRDONE = 1
				MOVED ( $PATH )
			Case $DIRDONE = 0
				NMOVED ( $PATH )
			EndSelect
		Else
			NMOVED ( $PATH )
		EndIf
	EndSelect
EndFunc
Func MOVEFILENORMAL ( $FILEP )
	Local $RET
	$PATH1 = $FILEP
	If StringLeft ( $FILEP , 4 ) <> "\\?\" Then $FILEP = "\\?\" & $FILEP
	If _BLACK ( $PATH1 ) Then Return FileWrite ( $HFIXLOG , $PATH1 & " => " & $FIX13 & @CRLF )
	If Not FileExists ( $FILEP ) Then Return NFOUND ( $PATH1 )
	If StringRegExp ( FileGetAttrib ( $FILEP ) , "(?i)S|R|H" ) Then FileSetAttrib ( $FILEP , "-RSH" )
	$SDEST = DESTIN ( $PATH1 , 1 )
	$RET = FileMove ( $FILEP , $SDEST , 1 )
	Select
	Case $RET = 1
		MOVED ( $PATH1 )
		If StringInStr ( $FILEP , ".exe" ) Then
			$ARRAYPRO = ProcessList ( )
			For $I = 1 To UBound ( $ARRAYPRO ) + 4294967295
				$PATH = _RUNPR ( $ARRAYPRO [ $I ] [ 1 ] )
				If $PATH1 = $PATH Then
					If Not PROCRIT ( $ARRAYPRO [ $I ] [ 1 ] ) Then
						FileWrite ( $C & "\FRST\re" , "P" )
						ExitLoop
					EndIf
					ProcessClose ( $ARRAYPRO [ $I ] [ 1 ] )
					If @error Then FileWrite ( $C & "\FRST\re" , "P" )
					ExitLoop
				EndIf
			Next
		EndIf
	Case $RET = 0
		_GRANTE ( $FILEP , 1 , 0 )
		If StringRegExp ( FileGetAttrib ( $FILEP ) , "(?i)S|R|H" ) Then FileSetAttrib ( $FILEP , "-RSH" )
		$RET = FileMove ( $FILEP , $SDEST , 1 + 8 )
		If $RET Then Return MOVED ( $PATH1 )
		FileWrite ( $HFIXLOG , $FIX8 & " """ & $PATH1 & """ => " & $MOVEREB & "." & @CRLF )
		MOVEFILEONREBOOT ( $PATH1 , $SDEST )
		$HFILES = FileOpen ( $C & "\FRST\files" , 1 + 256 )
		FileWrite ( $C & "\FRST\files" , $PATH1 & @CRLF )
		FileWrite ( $C & "\FRST\reb" , "reboote?" & @CRLF )
		FileClose ( $HFILES )
	EndSelect
EndFunc
Func DESTIN ( $PATH , $FILEP = 0 )
	$NDIR = StringRegExpReplace ( $PATH , ":" , "" )
	$NDIR = StringRegExpReplace ( $NDIR , "(.+)\\.+" , "$1" )
	$NDIR = $C & "\FRST\Quarantine\" & $NDIR
	DirCreate ( $NDIR )
	If $FILEP Then
		$FNAME = StringRegExpReplace ( $PATH , ".+\\([^\\]+)" , "$1" )
		$NDIR = $NDIR & "\" & $FNAME & ".xBAD"
	EndIf
	Return "\\?\" & $NDIR
EndFunc
Func MOVEFILEONREBOOT ( $SSOURCE , $SDEST )
	RegWrite ( "HKLM\SYSTEM\CurrentControlSet\Control\Session Manager" , "AllowProtectedRenames" , "REG_DWORD" , "0x1" )
	If StringLeft ( $SSOURCE , 4 ) <> "\\?\" Then $SSOURCE = "\\?\" & $SSOURCE
	If $SDEST <> "" Then
		DllCall ( "kernel32.dll" , "int" , "MoveFileExW" , "wstr" , $SSOURCE , "wstr" , $SDEST , "dword" , BitOR ( 4 , 1 ) )
	Else
		DllCall ( "kernel32.dll" , "int" , "MoveFileExW" , "wstr" , $SSOURCE , "int" , 0 , "dword" , 4 )
	EndIf
EndFunc
Func MOVEFILER ( $PATH1 )
	If $BOOTM = "reovery" Then
		MOVEFILE ( $PATH1 )
	Else
		MOVEFILENORMAL ( $PATH1 )
	EndIf
EndFunc
Func MOVEFILES ( $PATH )
	If StringRegExp ( FileGetAttrib ( $PATH ) , "(?i)S|R|H" ) Then FileSetAttrib ( $PATH , "-RSH" )
	$NDIR = StringRegExpReplace ( $PATH , "(?i)([a-z]):" , "$1" )
	$SDEST = $C & "\FRST\Quarantine\" & $NDIR
	$RET = FileMove ( $PATH , $SDEST & ".xBAD" , 1 + 8 )
	If $RET <> 0 Then Return
	If FILEACCN ( $PATH ) Then
		_GRANTE ( $PATH , 1 , 0 )
		If StringRegExp ( FileGetAttrib ( $PATH ) , "(?i)S|R|H" ) Then FileSetAttrib ( $PATH , "-RSH" )
		FileMove ( $PATH , $SDEST & ".xBAD" , 1 + 8 )
	EndIf
EndFunc
Func MSCONFIG ( ByRef $ARR )
	$KEY = "HKLM\SOFTWARE\Microsoft\Shared Tools\MSConfig\services"
	$HKEY = _REGOPENKEYEX3 ( $KEY )
	$I = 0
	While 1
		$SUB = __REGENUMKEY ( $HKEY , $I )
		If @error Then ExitLoop
		$SVAL = RegRead ( $KEY & "\" & $SUB , $SUB )
		_ARRAYADD ( $ARR , "MSCONFIG\Services: " & $SUB & " => " & $SVAL , 0 , "||||" )
		$I += 1
	WEnd
	$KEY = "HKLM\SOFTWARE\Microsoft\Shared Tools\MSConfig\startupfolder"
	$HKEY = _REGOPENKEYEX3 ( $KEY )
	$I = 0
	While 1
		$SUB = __REGENUMKEY ( $HKEY , $I )
		If @error Then ExitLoop
		$SVAL = RegRead ( $KEY & "\" & $SUB , "Backup" )
		_ARRAYADD ( $ARR , "MSCONFIG\startupfolder: " & $SUB & " => " & $SVAL , 0 , "||||" )
		$I += 1
	WEnd
	$KEY = "HKLM\SOFTWARE\Microsoft\Shared Tools\MSConfig\startupreg"
	$HKEY = _REGOPENKEYEX3 ( $KEY )
	$I = 0
	While 1
		$SUB = __REGENUMKEY ( $HKEY , $I )
		If @error Then ExitLoop
		$SVAL = RegRead ( $KEY & "\" & $SUB , "Command" )
		_ARRAYADD ( $ARR , "MSCONFIG\startupreg: " & $SUB & " => " & $SVAL , 0 , "||||" )
		$I += 1
	WEnd
	If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
	$KEY = "SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\StartupApproved"
	MSCONFIG8 ( "HKLM" , $KEY , "StartupFolder" , $ARR )
	MSCONFIG8 ( "HKLM" , $KEY , "Run" , $ARR )
	MSCONFIG8 ( "HKLM" , $KEY , "Run32" , $ARR )
	For $U = 1 To UBound ( $USERREG ) + 4294967295
		If StringRegExp ( $USERREG [ $U ] , "S-1-5-\d{2}-\d{3,}" ) Then
			$HIV = "HKU\" & $USERREG [ $U ]
			MSCONFIG8 ( $HIV , $KEY , "StartupFolder" , $ARR )
			MSCONFIG8 ( $HIV , $KEY , "Run" , $ARR )
		EndIf
	Next
EndFunc
Func MSCONFIG8 ( $HIV , $KEY , $SUB , ByRef $ARRR )
	Local $ARRAYNAME
	$HKEY = _REGOPENKEYEX3 ( $HIV & "\" & $KEY & "\" & $SUB )
	If @error Or $HKEY = 0 Then Return
	$ARRAYNAME = _LISTVAL ( $HKEY )
	If UBound ( $ARRAYNAME ) > 0 Then
		For $V = 0 To UBound ( $ARRAYNAME ) + 4294967295
			$VALNAME = $ARRAYNAME [ $V ] [ 0 ]
			$VALDATA = $ARRAYNAME [ $V ] [ 1 ]
			If StringRegExp ( $VALDATA , "^(01|03|05|07)" ) Then _ARRAYADD ( $ARRR , $HIV & "\...\StartupApproved\" & $SUB & ": => """ & $VALNAME & """" , 0 , "||||" )
		Next
	EndIf
	If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
EndFunc
Func MSCONFIGFIX ( )
	If StringRegExp ( $FIX , "(?i)startupreg|Services" ) Then
		$KEYVAL = StringRegExpReplace ( $FIX , ".+?: (.+) =>.+" , "$1" )
		$KEY = "HKLM\SOFTWARE\Microsoft\Shared Tools\MSConfig\startupreg\" & $KEYVAL
		If StringInStr ( $FIX , "Services" ) Then $KEY = "HKLM\SOFTWARE\Microsoft\Shared Tools\MSConfig\Services\" & $KEYVAL
		DELKEY ( $KEY )
		If StringInStr ( $FIX , "Services" ) Then DELKEY ( "HKLM\System\CurrentControlSet\Services\" & $KEYVAL )
	EndIf
	If StringInStr ( $FIX , "MSCONFIG\startupfolder" ) Then
		$KEYPATH = StringRegExpReplace ( $FIX , ".+?: (.+) =>.+" , "$1" )
		$KEY = "HKLM\SOFTWARE\Microsoft\Shared Tools\MSConfig\startupfolder\" & $KEYPATH
		DELKEY ( $KEY )
		$BACKPATH = StringRegExpReplace ( $FIX , ".+?=> (.+)" , "$1" )
		MOVEFILENORMAL ( $BACKPATH )
	EndIf
	If StringRegExp ( $FIX , "(?i)HKLM\\.+StartupApproved\\Run:" ) Then
		$VAL1 = StringRegExpReplace ( $FIX , ".+=> ""(.+)""" , "$1" )
		DELVALUE ( "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\StartupApproved\Run" , $VAL1 )
		DELVALUE ( "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run" , $VAL1 )
	EndIf
	If StringRegExp ( $FIX , "(?i)HKLM\\.+StartupApproved\\Run32:" ) Then
		$VAL1 = StringRegExpReplace ( $FIX , ".+=> ""(.+)""" , "$1" )
		DELVALUE ( "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\StartupApproved\Run32" , $VAL1 )
		DELVALUE ( "HKLM\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Run" , $VAL1 )
	EndIf
	If StringRegExp ( $FIX , "(?i)HKU.+StartupApproved\\Run:" ) Then
		$VAL1 = StringRegExpReplace ( $FIX , ".+=> ""(.+)""" , "$1" )
		$USER = StringRegExpReplace ( $FIX , "(?i)HKU\\(.+?)\\.+" , "$1" )
		DELVALUE ( "HKU\" & $USER & "\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\StartupApproved\Run" , $VAL1 )
		DELVALUE ( "HKU\" & $USER & "\SOFTWARE\Microsoft\Windows\CurrentVersion\Run" , $VAL1 )
	EndIf
	If StringRegExp ( $FIX , "HKU\\.+StartupApproved\\StartupFolder:" ) Then
		$USER = StringRegExpReplace ( $FIX , "(?i)HKU\\(.+?)\\.+" , "$1" )
		$VAL1 = StringRegExpReplace ( $FIX , ".+=> ""(.+)""" , "$1" )
		MOVEFILENORMAL ( @StartupDir & "\" & $VAL1 )
		DELVALUE ( "HKU\" & $USER & "\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\StartupApproved\StartupFolder" , $VAL1 )
	EndIf
	If StringRegExp ( $FIX , "HKLM\\.+StartupApproved\\StartupFolder:" ) Then
		$VAL1 = StringRegExpReplace ( $FIX , ".+=> ""(.+)""" , "$1" )
		MOVEFILENORMAL ( @StartupCommonDir & "\" & $VAL1 )
		DELVALUE ( "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\StartupApproved\StartupFolder" , $VAL1 )
	EndIf
EndFunc
Func MSCOREE ( $KEY , ByRef $DATA )
	$DATA1 = RegRead ( $KEY , "CodeBase" )
	If $DATA1 Then
		$DATA = StringRegExpReplace ( $DATA1 , "(?i)file:/+" , "" )
	Else
		$K = 1
		While 1
			$SUB = RegEnumKey ( $KEY , $K )
			If @error Then ExitLoop
			$DATA1 = RegRead ( $KEY & "\" & $SUB , "CodeBase" )
			If $DATA1 Then
				$DATA = StringRegExpReplace ( $DATA1 , "(?i)file:/+" , "" )
				ExitLoop
			EndIf
			$K += 1
		WEnd
	EndIf
EndFunc
Func MYERRFUNC ( )
	$COMERR = 5
EndFunc
Func NDELETED ( $PATH )
	FileWrite ( $HFIXLOG , """" & $PATH & """ => " & $NDELETED & @CRLF )
EndFunc
Func NETBIND0 ( ByRef $ARRBIN1 )
	$OBJWMISERVICE = ObjGet ( "winmgmts:{impersonationLevel=impersonate}!\\.\root\StandardCimv2" )
	If Not IsObj ( $OBJWMISERVICE ) Then Return
	$DEVCOLITEMS = $OBJWMISERVICE .ExecQuery ( "Select * from MSFT_NetAdapter" )
	If Not IsObj ( $DEVCOLITEMS ) Then Return
	For $OBJECT In $DEVCOLITEMS
		_ARRAYADD ( $ARRBIN1 , $OBJECT .Name & ": " & $OBJECT .InterfaceDescription & " -> " & StringRegExpReplace ( $OBJECT .DriverName , ".+\\" , "" ) , 0 , "||||" )
	Next
EndFunc
Func NETBIND1 ( ByRef $ARRBIN2 )
	$KEY = "HKLM\SYSTEM\CurrentControlSet\Control\Network"
	$HKEY = _REGOPENKEYEX3 ( $KEY )
	If @error Or $HKEY = 0 Then Return
	$K = + 4294967295
	While 1
		$K += 1
		$SUB = __REGENUMKEY ( $HKEY , $K )
		If @error Then ExitLoop
		$HKEY1 = _REGOPENKEYEX3 ( $KEY & "\" & $SUB )
		If @error Or $HKEY = 0 Then ContinueLoop
		$M = + 4294967295
		While 1
			$M += 1
			$SUB1 = __REGENUMKEY ( $HKEY1 , $M )
			If @error Then ExitLoop
			$COMPONENTID = RegRead ( $KEY & "\" & $SUB & "\" & $SUB1 , "ComponentId" )
			If @error Then ContinueLoop
			If StringRegExp ( $COMPONENTID , "(?i)^(ms_winvfp|netvsc_vfpp|ms_(ndiscap|netbios|vwifi|wfplwf_upper|nativewifip|wfplwf_vswitch|rdma_ndk|netbt|ndiswanlegacy|wanarp|tcpip_tunnel|tcpip6_tunnel|pppoe|wanarpv6|netbt_smb|ndisuio|ndiswan|xboxgip|wfplwf_lower|l2bridge|rmcast|server|implat|lltdio|tcpip6|tcpip|msclient|lldp|rspndr|pacer|bridge)|vms_pp)$" ) Then ContinueLoop
			$DESCRIPTION = RegRead ( $KEY & "\" & $SUB & "\" & $SUB1 , "Description" )
			$VAL = NETBIND2 ( $DESCRIPTION )
			_ARRAYADD ( $ARRBIN2 , $COMPONENTID & ": " & $VAL , 0 , "||||" )
		WEnd
	WEnd
EndFunc
Func NETBIND2 ( $FPATH )
	$STEXT = $FPATH
	If Not StringRegExp ( $FPATH , "@" ) Or StringRegExp ( $FPATH , ";" ) Then Return StringRegExpReplace ( $FPATH , ".+;" , "" )
	$FILE = StringRegExpReplace ( $FPATH , "@(.+),.+" , "$1" )
	$WINDIR = StringRegExpReplace ( @WindowsDir , "\\" , "\\\\" )
	Select
	Case StringRegExp ( $FILE , "(?i)(^\s*|%+)(systemroot|windir|Windows)(|%+)\\" )
		$FILE = StringRegExpReplace ( $FILE , "(?i)(\s*|%+)(systemroot|windir|Windows)(|%+)\\" , $WINDIR & "\\" )
	Case StringRegExp ( $FILE , "(?i)%+Programfiles%+" )
		$PROGRAMFDIR = StringRegExpReplace ( @ProgramFilesDir , "\\" , "\\\\" )
		$FILE = StringRegExpReplace ( $FILE , "(?i).*%+Programfiles%+" , $PROGRAMFDIR )
	Case StringRegExp ( $FILE , "(?i)%+ProgramFiles\(x86\)%+" )
		$FILE = StringRegExpReplace ( $FILE , "(?i)%+ProgramFiles\(x86\)%+" , $C & "\\Program Files \(x86\)" )
	Case StringRegExp ( $FILE , "(?i)%+ProgramData%+" )
		$FILE = StringRegExpReplace ( $FILE , "(?i)%+ProgramData%+" , $C & "\\ProgramData" )
	Case StringRegExp ( $FILE , "(?i)\Asystem32" )
		$FILE = StringRegExpReplace ( $FILE , "(?i)\Asystem32" , $WINDIR & "\\System32" )
	EndSelect
	$RESOURCEID = StringRegExpReplace ( $FPATH , ".+,\s*-(\d+)" , "$1" )
	$HINSTANCE = _WINAPI_LOADLIBRARYEX ( $FILE , 2 )
	If $HINSTANCE Then $STEXT = _WINAPI_LOADSTRING ( $HINSTANCE , $RESOURCEID )
	If @error Then Return $FPATH
	Return $STEXT
EndFunc
Func NETSVC ( )
	Local $NETSVC , $I , $SRSTR1 , $COMP
	$HNET = FileOpen ( @TempDir & "\net" , 2 + 256 )
	FileClose ( $FRSTLOG )
	$FRSTLOG = FileOpen ( @ScriptDir & "\FRST.txt" , 256 + 1 )
	$NETSVC = RegRead ( "HKLM\" & $SOFTWARE & "\Microsoft\Windows NT\CurrentVersion\SvcHost" , "netsvcs" )
	$NETSVC = StringRegExpReplace ( $NETSVC , "([^\v]+)[\v]*" , "$1" & @CRLF )
	$NETSVC = StringRegExpReplace ( $NETSVC , "(?i)(sacsvr|dcsvc|hns|HgClientService|nvagent|TroubleshootingSvc|WManSvc|LxpSvc|PushToInstall|InstallService|LxssManager|debugregsvc|6to4|AppMgmt|AudioSrv|Browser|CryptSvc|DMServer|DHCP|ERSvc|EventSystem|FastUserSwitchingCompatibility|HidServ|Ias|Iprip|Irmon|LanmanServer|LanmanWorkstation|Messenger|Netman|Nla|Ntmssvc|NWCWorkstation|Nwsapagent|Rasauto|Rasman|Remoteaccess|Schedule|Seclogon|SENS|Sharedaccess|SRService|Tapisrv|Themes|TrkWks|W32Time|WZCSVC|Wmi|WmdmPmSp|winmgmt|wscsvc|xmlprov|BITS|wuauserv|ShellHWDetection|helpsvc|WmdmPmSN|napagent|hkmsvc|AeLookupSvc|CertPropSvc|SCPolicySvc|gpsvc|IKEEXT|TermService|LogonHours|PCAudit|uploadmgr|iphlpsvc|AppInfo|msiscsi|MMCSS|wercplsupport|EapHost|ProfSvc|SessionEnv|BDESVC|hkmsvc|UxTuneUp|SystemEventsBroker|NcaSvc|DsmSvc|wlidsvc|lfsvc|MsKeyboardFilter|DmEnrollmentSvc|dosvc|DcpSvc|DiagTrack|NetSetupSvc|RetailDemo|UsoSvc|dmwappushservice|UserTrustedSignals|XblGameSave|XboxNetApiSvc|UserManager|XblAuthManager|shpamsvc|wisvc|WpnService|NaturalAuthentication|xbgm|TokenBroker|XboxGipSvc|TokenBroker)\v{2}" , "" )
	$NETSVC = StringRegExpReplace ( $NETSVC , "(NETSVC: \v{2})" , "" )
	FileWrite ( @TempDir & "\net" , $NETSVC )
	FileWrite ( $FRSTLOG , @CRLF & "==================== NetSvcs (" & $WLISTED & ") ===================" & @CRLF )
	FileWrite ( $FRSTLOG , @CRLF & "(" & $SERV1 & " " & $SERV2 & ".)" & @CRLF & @CRLF )
	$NETSVC = ""
	$I = 1
	While 1
		$NETSVC = FileReadLine ( @TempDir & "\net" , $I )
		If @error Then ExitLoop
		If $NETSVC <> "" Then
			$KEY = "HKLM\" & $SYSTEM & $BOOTSYSTEM & $DEF & "\Services\" & $NETSVC
			$SRSTR1 = RegRead ( $KEY , "ServiceDLL" )
			If @error Then $SRSTR1 = RegRead ( $KEY & "\Parameters" , "ServiceDLL" )
			Select
			Case @error = 1 Or @error = + 4294967295
				FileWrite ( $FRSTLOG , "NETSVC: " & $NETSVC & " -> " & $NO & " " & $FPAD & "." & @CRLF )
			Case @error = 0
				$SRSTR1 = StringRegExpReplace ( $SRSTR1 , "(?i)%systemroot%" , $C & "\\Windows" )
				$SRSTR1 = StringRegExpReplace ( $SRSTR1 , "(?i)\\systemroot" , $C & "\\Windows" )
				$SRSTR1 = StringRegExpReplace ( $SRSTR1 , "(?i)systemroot" , $C & "\\Windows" )
				$SRSTR1 = StringRegExpReplace ( $SRSTR1 , "(?i)%ProgramFiles\(x86\)%" , $C & "\\Program Files \(x86\)" )
				$SRSTR1 = StringRegExpReplace ( $SRSTR1 , "(?i)%ProgramFiles%" , $C & "\\Program Files" )
				$SRSTR1 = StringRegExpReplace ( $SRSTR1 , "(?i)[B-Z]:\\" , $C & "\\" )
				If FileExists ( $SRSTR1 ) Then
					$COMP = FileGetVersion ( $SRSTR1 , "CompanyName" )
					FileWrite ( $FRSTLOG , "NETSVC: " & $NETSVC & " -> " & $SRSTR1 & " (" & $COMP & ")" & @CRLF )
				Else
					FileWrite ( $FRSTLOG , "NETSVC: " & $NETSVC & " -> " & $SRSTR1 & " ==> " & $REGIST8 & @CRLF )
				EndIf
			EndSelect
		EndIf
		$I = $I + 1
	WEnd
	FileClose ( $HNET )
	FileDelete ( @TempDir & "\net" )
	$HNET = FileOpen ( @TempDir & "\net" , 2 + 256 )
	$NETSVC = RegRead ( "HKLM\" & $SOFTWARE & "\Wow6432Node\Microsoft\Windows NT\CurrentVersion\SvcHost" , "netsvcs" )
	$NETSVC = StringRegExpReplace ( $NETSVC , "([^\v]+)[\v]*" , "$1" & @CRLF )
	$NETSVC = StringRegExpReplace ( $NETSVC , "(?i)(TokenBroker\v{2}|AeLookupSvc\v{2}|CertPropSvc\v{2}|ezSharedSvc\v{2}|SCPolicySvc\v{2}|lanmanserver\v{2}|gpsvc\v{2}|AudioSrv\v{2}|FastUserSwitchingCompatibility\v{2}|Ias\v{2}|Irmon\v{2}|Nla\v{2}|Ntmssvc\v{2}|NWCWorkstation\v{2}|Nwsapagent\v{2}|Rasauto\v{2}|Rasman\v{2}|Remoteaccess\v{2}|SENS\v{2}|Sharedaccess\v{2}|SRService\v{2}|Tapisrv\v{2}|Themes\v{2}|Wmi\v{2}|WmdmPmSp\v{2}|TermService\v{2}|wuauserv\v{2}|BITS\v{2}|ShellHWDetection\v{2}|LogonHours\v{2}|PCAudit\v{2}|helpsvc\v{2}|uploadmgr\v{2}|iphlpsvc\v{2}|msiscsi\v{2}|schedule\v{2}|SessionEnv\v{2}|winmgmt\v{2}|AppMgmt\v{2}|UxTuneUp\v{2}|NetSetupSvc\v{2}|UserManager\v{2})" , "" )
	FileWrite ( @TempDir & "\net" , $NETSVC )
	$I = 1
	While 1
		$NETSVC = FileReadLine ( @TempDir & "\net" , $I )
		If @error Then ExitLoop
		If $NETSVC <> "" Then
			$KEY = "HKLM\" & $SYSTEM & $BOOTSYSTEM & $DEF & "\Services\" & $NETSVC
			$SRSTR1 = RegRead ( $KEY , "ServiceDLL" )
			If @error Then $SRSTR1 = RegRead ( $KEY & "\Parameters" , "ServiceDLL" )
			Select
			Case @error = 1 Or @error = + 4294967295
				FileWrite ( $FRSTLOG , "NETSVCx32: " & $NETSVC & " -> " & $NO & " " & $FPAD & "." & @CRLF )
			Case @error = 0
				$SRSTR1 = StringRegExpReplace ( $SRSTR1 , "(?i)%systemroot%\\system32" , $C & "\\Windows\\SysWOW64" )
				$SRSTR1 = StringRegExpReplace ( $SRSTR1 , "(?i)%ProgramFiles\(x86\)%" , $C & "\\Program Files \(x86\)" )
				$SRSTR1 = StringRegExpReplace ( $SRSTR1 , "(?i)%systemroot%" , $C & "\\Windows" )
				$SRSTR1 = StringRegExpReplace ( $SRSTR1 , "(?i)[B-Z]:\\" , $C & "\\" )
				$SRSTR1 = StringRegExpReplace ( $SRSTR1 , "(?i)system32" , "SysWOW64" )
				If FileExists ( $SRSTR1 ) Then
					$COMP = FileGetVersion ( $SRSTR1 , "CompanyName" )
					FileWrite ( $FRSTLOG , "NETSVCx32: " & $NETSVC & " -> " & $SRSTR1 & " (" & $COMP & ")" & @CRLF )
				Else
					FileWrite ( $FRSTLOG , "NETSVCx32: " & $NETSVC & " -> " & $SRSTR1 & " ==> " & $REGIST8 & @CRLF )
				EndIf
			EndSelect
		EndIf
		$I = $I + 1
	WEnd
	FileClose ( $HNET )
	FileDelete ( @TempDir & "\net" )
EndFunc
Func NETSVCFIX ( )
	Local $NETSVC , $RET1
	$NETSVC = RegRead ( "HKLM\" & $SOFTWARE & "\Microsoft\Windows NT\CurrentVersion\SvcHost" , "netsvcs" )
	If StringInStr ( $FIX , "->" ) Then $VAL = StringRegExpReplace ( $FIX , "(?i)NETSVC: (.+) ->.+" , "$1" )
	If Not StringInStr ( $FIX , "->" ) Then $VAL = StringRegExpReplace ( $FIX , "(?i)NETSVC:[ ]*(.+)" , "$1" )
	$RET1 = StringRegExp ( $NETSVC , "(?i)(^|\n)" & $VAL & "(\n|$)" )
	Select
	Case $RET1 = 0
		NFOUND ( "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SvcHost\\netsvcs " & $VAL )
	Case $RET1 = 1
		$FIX1 = StringRegExpReplace ( $NETSVC , "(?i)^" & $VAL & "\n|\n" & $VAL & "$" , "" )
		$FIX1 = StringRegExpReplace ( $FIX1 , "(?i)\n" & $VAL & "\n" , @LF )
		RegWrite ( "HKLM\" & $SOFTWARE & "\Microsoft\Windows NT\CurrentVersion\SvcHost" , "netsvcs" , "REG_MULTI_SZ" , $FIX1 )
		$NETSVC = RegRead ( "HKLM\" & $SOFTWARE & "\Microsoft\Windows NT\CurrentVersion\SvcHost" , "netsvcs" )
		$RET1 = StringRegExp ( $NETSVC , "(?i)(^|\n)" & $VAL & "(\n|$)" )
		Select
		Case $RET1 = 0
			FileWrite ( $HFIXLOG , "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SvcHost\\netsvcs " & $VAL & " => " & $DELETED & @CRLF )
		Case $RET1 = 1
			FileWrite ( $HFIXLOG , "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SvcHost\\netsvcs " & $VAL & "  " & $NDELETED & "." & @CRLF )
		EndSelect
	EndSelect
EndFunc
Func NETSVCFIX32 ( )
	Local $NETSVC , $RET1
	$NETSVC = RegRead ( "HKLM\" & $SOFTWARE & "\Wow6432Node\Microsoft\Windows NT\CurrentVersion\SvcHost" , "netsvcs" )
	If StringInStr ( $FIX , "->" ) Then $VAL = StringRegExpReplace ( $FIX , "(?i)NETSVCx32: (.+) ->.+" , "$1" )
	If Not StringInStr ( $FIX , "->" ) Then $VAL = StringRegExpReplace ( $FIX , "(?i)NETSVCx32:[ ]*(.+)" , "$1" )
	$RET1 = StringRegExp ( $NETSVC , "(?i)(^|\n)" & $VAL & "(\n|$)" )
	Select
	Case $RET1 = 0
		NFOUND ( "HKLM\SOFTWARE\Wow6432Node\Microsoft\Windows NT\CurrentVersion\SvcHost\\netsvcs " & $VAL )
	Case $RET1 = 1
		$FIX1 = StringRegExpReplace ( $NETSVC , "(?i)^" & $VAL & "\n" , "" )
		$FIX1 = StringRegExpReplace ( $FIX1 , "(?i)\n" & $VAL & "\n" , @LF )
		$FIX1 = StringRegExpReplace ( $FIX1 , "(?i)\n" & $VAL & "$" , "" )
		RegWrite ( "HKLM\" & $SOFTWARE & "\Wow6432Node\Microsoft\Windows NT\CurrentVersion\SvcHost" , "netsvcs" , "REG_MULTI_SZ" , $FIX1 )
		$NETSVC = RegRead ( "HKLM\" & $SOFTWARE & "\Wow6432Node\Microsoft\Windows NT\CurrentVersion\SvcHost" , "netsvcs" )
		$RET1 = StringRegExp ( $NETSVC , "(?i)(^|\n)" & $VAL & "(\n|$)" )
		Select
		Case $RET1 = 0
			FileWrite ( $HFIXLOG , "HKLM\SOFTWARE\Wow6432Node\Microsoft\Windows NT\CurrentVersion\SvcHost\\netsvcs " & $VAL & " => " & $DELETED & @CRLF )
		Case $RET1 = 1
			FileWrite ( $HFIXLOG , "HKLM\SOFTWARE\Wow6432Node\Microsoft\Windows NT\CurrentVersion\SvcHost\\netsvcs " & $VAL & " => Could not be deleted." & @CRLF )
		EndSelect
	EndSelect
EndFunc
Func NFOUND ( $PATH )
	FileWrite ( $HFIXLOG , """" & $PATH & """ => " & $NFOUND & @CRLF )
EndFunc
Func NMOVED ( $PATH )
	FileWrite ( $HFIXLOG , $PATH & " => " & $FIX8 & @CRLF )
EndFunc
Func OPERAFIX ( )
	$PROFILE = @AppDataDir & "\Opera Software\Opera Stable"
	$PATH = $PROFILE & "\Preferences"
	If StringRegExp ( $FIX , "(DefaultSearchKeyword|DefaultSearchURL):" ) Then $PATH = $PROFILE & "\Secure Preferences"
	$PREFERENCES = FileRead ( $PATH )
	$HPREF = FileOpen ( @TempDir & "\preferences00" , 2 + 256 )
	$ARRAYPRO = ProcessList ( )
	For $I = 1 To UBound ( $ARRAYPRO ) + 4294967295
		If StringInStr ( $ARRAYPRO [ $I ] [ 0 ] , "opera.exe" ) Then
			ProcessClose ( $ARRAYPRO [ $I ] [ 1 ] )
		EndIf
	Next
	Select
	Case StringInStr ( $FIX , "Notifications:" )
		$READ1 = StringRegExp ( $PREFERENCES , "(?i),""notifications"":\{\}," , 1 )
		If IsArray ( $READ1 ) Then Return NFOUND ( "OPR Notifications:" )
		$READ1 = StringRegExp ( $PREFERENCES , "(?i),""notifications"":\{.+?\}\}," , 1 )
		If Not IsArray ( $READ1 ) Then Return NFOUND ( "OPR Notifications:" )
		$PREFERENCES = StringRegExpReplace ( $PREFERENCES , "(?is),""notifications"":\{(.+?)\}\}," , ",""notifications"":\{\}," )
		FileWrite ( $HPREF , $PREFERENCES )
		FileClose ( $HPREF )
		FileMove ( @TempDir & "\preferences00" , $PATH , 1 )
		DELETED ( "OPR Notifications" )
	Case StringInStr ( $FIX , "DefaultSuggestURL:" )
		If Not StringRegExp ( $PREFERENCES , "\s*""suggest(?:ions|)_url""\s*:\s*""[^""]*?(?:[a-z]|\.)+.*?""" ) Then Return NFOUND ( "Opera DefaultSuggestURL" )
		$PREFERENCES = StringRegExpReplace ( $PREFERENCES , "\s*""suggest(?:ions|)_url""\s*:\s*""[^""]*?(?:[a-z]|\.)+.*?"",?\R*" , "" )
		FileWrite ( $HPREF , $PREFERENCES )
		FileClose ( $HPREF )
		FileMove ( @TempDir & "\preferences00" , $PATH , 1 )
		DELETED ( $FIX )
	Case StringInStr ( $FIX , "StartupUrls:" )
		If Not StringRegExp ( $PREFERENCES , "(?i)""startup_urls""\s*:\s*\[.*?\]" ) Then Return NFOUND ( $FIX )
		$PREFERENCES = StringRegExpReplace ( $PREFERENCES , "(?is)\s*""startup_urls""\s*:\s*\[.+?\],?\R*" , "" )
		FileWrite ( $HPREF , $PREFERENCES )
		FileClose ( $HPREF )
		FileMove ( @TempDir & "\preferences00" , $PATH , 1 )
		DELETED ( $FIX )
	Case StringInStr ( $FIX , "Session Restore:" )
		$RET = StringRegExp ( $PREFERENCES , """restore_on_startup""\s*:\s*(\d)(}|,)" , 1 )
		If Not IsArray ( $RET ) Or $RET [ 0 ] <> 1 Then Return NFOUND ( "Opera Session Restore:" )
		If StringRegExp ( $PREFERENCES , """restore_on_startup""\s*:\s*(\d)," ) Then $PREFERENCES = StringRegExpReplace ( $PREFERENCES , "(?is)""restore_on_startup""\s*:\s*\d," , """restore_on_startup"":5," )
		If StringRegExp ( $PREFERENCES , """restore_on_startup""\s*:\s*(\d)}" ) Then $PREFERENCES = StringRegExpReplace ( $PREFERENCES , "(?is)""restore_on_startup""\s*:\s*\d}" , """restore_on_startup"":5}" )
		FileWrite ( $HPREF , $PREFERENCES )
		FileClose ( $HPREF )
		FileMove ( @TempDir & "\preferences00" , $PATH , 1 )
		DELETED ( $FIX )
	Case StringInStr ( $FIX , "DefaultSearchKeyword:" )
		If Not StringRegExp ( $PREFERENCES , ",\s*""keyword""\s*:\s*""[^""]*?(?:[a-z]|\.)+.*?""" ) Then Return NFOUND ( "Opera DefaultSearchKeyword" )
		$PREFERENCES = StringRegExpReplace ( $PREFERENCES , "(?is),\s*""keyword""\s*:\s*""[^""]*?(?:[a-z]|\.)+.*?"",?\R*" , "" )
		FileWrite ( $HPREF , $PREFERENCES )
		FileClose ( $HPREF )
		FileMove ( @TempDir & "\preferences00" , $PATH , 1 )
		DELETED ( $FIX )
	Case StringInStr ( $FIX , "DefaultSearchURL:" )
		If Not StringRegExp ( $PREFERENCES , ",\s*""(?:search_|)url""\s*:\s*""[^""]*?(?:[a-z]|\.)+.*?""" ) Then Return NFOUND ( $FIX )
		$PREFERENCES = StringRegExpReplace ( $PREFERENCES , ",\s*""(?:search_|)url""\s*:\s*""[^""]*?(?:[a-z]|\.)+.*?"",?\R*" , "" )
		FileWrite ( $HPREF , $PREFERENCES )
		FileClose ( $HPREF )
		FileMove ( @TempDir & "\preferences00" , $PATH , 1 )
		DELETED ( $FIX )
	EndSelect
EndFunc
Func OSUPDATE ( )
	$OSUPDATE = ""
	If $OSNUM = 6.3 Then
		$UPD = RegRead ( "HKLM\" & $SOFTWARE & "\Microsoft\Windows NT\CurrentVersion" , "BuildLabEx" )
		If StringInStr ( $UPD , "140305-1710" ) Then $OSUPDATE = "(Update) "
		If StringRegExp ( $UPD , "9600\.\d+\." ) Then
			If StringRegExpReplace ( $UPD , "9600\.(\d+)\..+" , "$1" ) > 17031 Then $OSUPDATE = "(Update) "
		EndIf
	EndIf
	If $OSNUM = 10 Then
		$UPD = RegRead ( "HKLM\" & $SOFTWARE & "\Microsoft\Windows NT\CurrentVersion" , "DisplayVersion" )
		If @error Then $UPD = RegRead ( "HKLM\" & $SOFTWARE & "\Microsoft\Windows NT\CurrentVersion" , "ReleaseId" )
		If $UPD Then $OSUPDATE = $SCAN0 & " " & $UPD & " "
		$UPDCB = RegRead ( "HKLM\" & $SOFTWARE & "\Microsoft\Windows NT\CurrentVersion" , "CurrentBuild" )
		$UPDUBR = RegRead ( "HKLM\" & $SOFTWARE & "\Microsoft\Windows NT\CurrentVersion" , "UBR" )
		If $UPDCB And $UPDUBR Then $OSUPDATE &= $UPDCB & "." & $UPDUBR & " "
	EndIf
	Return $OSUPDATE
EndFunc
Func PART ( )
	GUICtrlSetData ( $LABEL1 , $SCANB & ", " & $PW0 & ":" & $MINFO )
	Local $MEM , $UNIQUEID , $SIZE , $CPU , $MB , $BPRO
	$MEM = MemGetStats ( )
	$MEM [ 1 ] = $MEM [ 1 ] / 1024
	$MEM [ 1 ] = Round ( $MEM [ 1 ] , 2 )
	$MEM [ 2 ] = $MEM [ 2 ] / 1024
	$MEM [ 2 ] = Round ( $MEM [ 2 ] , 2 )
	$MEM [ 3 ] = $MEM [ 3 ] / 1024
	$MEM [ 3 ] = Round ( $MEM [ 3 ] , 2 )
	$MEM [ 4 ] = $MEM [ 4 ] / 1024
	$MEM [ 4 ] = Round ( $MEM [ 4 ] , 2 )
	If $BOOTM = "Recovery" Then
		$TEMP00 = "FRST.txt"
	Else
		$TEMP00 = "Addition.txt"
	EndIf
	FileClose ( $HADDITION )
	FileClose ( $FRSTLOG )
	$HTEMP00 = FileOpen ( @ScriptDir & "\" & $TEMP00 , 256 + 1 )
	If $BOOTM <> "Recovery" Then
		$SUB = RegEnumKey ( "HKLM\HARDWARE\DESCRIPTION\System\CentralProcessor" , 1 )
		$CPU = RegRead ( "HKLM\HARDWARE\DESCRIPTION\System\CentralProcessor\" & $SUB , "ProcessorNameString" )
		If $CPU <> "" Then $CPU = $PROCESSOR & ": " & StringRegExpReplace ( $CPU , "\s{2,}" , " " ) & @CRLF
		$MBMAN = RegRead ( "HKLM\HARDWARE\DESCRIPTION\System\BIOS" , "BaseBoardManufacturer" )
		$MBPRO = RegRead ( "HKLM\HARDWARE\DESCRIPTION\System\BIOS" , "BaseBoardProduct" )
		If $MBMAN Then
			$MB = $MOTH & ": " & $MBMAN & " " & $MBPRO & @CRLF
		Else
			$MBMAN = PART1 ( "Win32_BaseBoard" )
			If StringRegExp ( $MBMAN , "\w" ) Then $MB = $MOTH & ": " & $MBMAN & @CRLF
		EndIf
		$BVEN = RegRead ( "HKLM\HARDWARE\DESCRIPTION\System\BIOS" , "BIOSVendor" )
		$BVER = RegRead ( "HKLM\HARDWARE\DESCRIPTION\System\BIOS" , "BIOSVersion" )
		$BDATE = RegRead ( "HKLM\HARDWARE\DESCRIPTION\System\BIOS" , "BIOSReleaseDate" )
		If $BVEN Then
			$BPRO = "BIOS: " & $BVEN & " " & $BVER & " " & $BDATE & @CRLF
		Else
			$BPRO = PART1 ( "Win32_BIOS" )
			If StringRegExp ( $BPRO , "\w" ) Then $BPRO = "BIOS: " & $BPRO & @CRLF
		EndIf
	EndIf
	FileWrite ( $HTEMP00 , @CRLF & "==================== " & $MINFO & " =========================== " & @CRLF & @CRLF & $BPRO & $MB & $CPU & $MEM1 & ": " & $MEM [ 0 ] & "%" & @CRLF & $MEM2 & ": " & $MEM [ 1 ] & " " & "MB" & @CRLF & $MEM3 & ": " & $MEM [ 2 ] & " MB" & @CRLF & $MEM4 & ": " & $MEM [ 3 ] & " MB" & @CRLF & $MEM5 & ": " & $MEM [ 4 ] & " MB" & @CRLF & @CRLF & "==================== " & $DRS0 & " ================================" & @CRLF & @CRLF )
	If FileExists ( @TempDir & "\tempS" ) Then FileDelete ( @TempDir & "\tempS" )
	RunWait ( @ComSpec & " /c " & "bcdedit /enum {bootmgr} >""" & @TempDir & "\tempS""" , "" , @SW_HIDE )
	Local $I = 3 , $LINE , $SYSPAR
	While 1
		$LINE = FileReadLine ( @TempDir & "\tempS" , $I )
		If @error Then ExitLoop
		If StringInStr ( $LINE , "device" ) Then
			$SYSPAR = StringRegExpReplace ( $LINE , "(?i)device.*Partition=([C-Z]:).*" , "$1" )
			ExitLoop
		EndIf
		$I = $I + 1
	WEnd
	FileDelete ( @TempDir & "\tempS" )
	Local $VAR , $DT , $DLABEL , $DSPT , $DSPACE , $DFS
	$VAR = DriveGetDrive ( "all" )
	If Not @error Then
		For $I = 1 To UBound ( $VAR ) + 4294967295
			If StringRegExp ( DriveStatus ( $VAR [ $I ] & "\" ) , "(?i)INVALID|NOTREADY" ) Then ContinueLoop
			$DSPT = DriveSpaceTotal ( $VAR [ $I ] & "\" )
			$DSPT = $DSPT / 1024
			$DSPT = Round ( $DSPT , 2 )
			$DT = DriveGetType ( $VAR [ $I ] & "\" )
			$DLABEL = DriveGetLabel ( $VAR [ $I ] & "\" )
			$DSPACE = DriveSpaceFree ( $VAR [ $I ] & "\" )
			$DSPACE = $DSPACE / 1024
			$DSPACE = Round ( $DSPACE , 2 )
			$DFS = DriveGetFileSystem ( $VAR [ $I ] & "\" )
			If $VAR [ $I ] = $SYSPAR Then
				$SYSPAR = " ==>[" & $DRIVE0 & " " & $WBOOTC & " (" & $OBTFROM & " BCD)]"
			Else
				If Not StringInStr ( $VAR [ $I ] , "X" ) And Not StringInStr ( $DLABEL , "dvd" ) And Not StringInStr ( $DT , "ROM" ) And Not StringInStr ( $DLABEL , "PQSERVICE" ) And Not StringInStr ( $DT , "Removable" ) And FileExists ( $VAR [ $I ] & "\boot\bcd" ) And FileExists ( $VAR [ $I ] & "\bootmgr" ) Then
					$SYSPAR = " ==>[" & $SYSTEM0 & " " & $WBOOTC & " (" & $OBTFROM & " " & $DRIVE0 & ")]"
				Else
					$SYSPAR = ""
				EndIf
			EndIf
			$ENC = ""
			If PART0 ( $VAR [ $I ] ) Then $ENC = "(Protected) "
			If PART0 ( $VAR [ $I ] , 1 ) Then
				$ENC &= "(Locked) "
				$DSPT = " ?"
				$DSPACE = " ?"
			EndIf
			$MODEL = ""
			If Not StringInStr ( $VAR [ $I ] , "X" ) And Not StringInStr ( $DLABEL , "dvd" ) And Not StringInStr ( $DT , "ROM" ) And Not StringInStr ( $DLABEL , "PQSERVICE" ) And Not StringInStr ( $DT , "Removable" ) Then
				$IINDEX = _GETVOLUMEDISKINDEX ( $VAR [ $I ] )
				$MODEL0 = _GETMODEL ( $IINDEX )
				If $MODEL0 And Not StringRegExp ( $MODEL0 , "(?i)^usb " ) Then $MODEL = "(Model: " & $MODEL0 & ") "
			EndIf
			FileWrite ( $HTEMP00 , "Drive " & $VAR [ $I ] & " (" & $DLABEL & ") (" & $DT & ") (Total:" & $DSPT & " GB) (Free:" & $DSPACE & " GB) " & $MODEL & $ENC & $DFS & $SYSPAR & @CRLF )
		Next
	EndIf
	FileWrite ( $HTEMP00 , @CRLF )
	MNT ( $HTEMP00 )
	FileDelete ( @TempDir & "\temp0" )
	FileDelete ( @TempDir & "\readmbr" )
	FileWrite ( @TempDir & "\readmbr" , @CRLF & "==================== MBR & " & $PARTT & " ====================" & @CRLF )
	$DRIVE = 0
	While 1
		If $DRIVE > 25 Then ExitLoop
		$SIZE = _WINAPI_IOCTLDISKGETLENGHTINFO ( $DRIVE )
		If Not @error Then
			$SIZE = CONVERTSIZE ( $SIZE )
			$REGEX = GETMBR ( "\\.\PhysicalDrive" & $DRIVE )
			If StringRegExp ( $REGEX , "55AA" ) Then
				$DISKID = StringRegExpReplace ( $REGEX , "\A.{880}(.{8}).+" , "$1" )
				$DISKID = StringRegExpReplace ( $DISKID , "(.{2})(.{2})(.{2})(.{2})" , "$4$3$2$1" )
				Select
				Case $DISKID = "00000000"
					$MBR = " (Protective MBR) "
				Case StringRegExp ( StringRegExpReplace ( $REGEX , "\A(.{870}).+" , "$1" ) , "33C08ED0BC007C8EC08ED8BE007CBF0006B90002FCF3A450681C06CBFBB90400BDBE07807E00007C0B0F850E0183C510E2F1CD1888560055C6461105C6461000B441BBAA55CD135D720F81FB55AA7509F7C101007403FE46106660807E1000742666680000000066FF760868000068007C680100681000B4428A56008BF4CD139F83C4109EEB14B80102BB007C8A56008A76018A4E028A6E03CD136661731CFE4E11750C807E00800F848A00B280EB845532E48A5600CD135DEB9E813EFE7D55AA756EFF7600E88D007517FAB0D1E664E88300B0DFE660E87C00B0FFE664E87500FBB800BBCD1A6623C0753B6681FB54435041753281F90201722C666807BB00006668000200006668080000006653665366556668000000006668007C0000666168000007CD1A5A32F6EA007C0000CD18A0B707EB08A0B607EB03A0B50732E40500078BF0AC3C007409BB0700B40ECD10EBF2F4EBFD2BC9E464EB002402E0F82402C3496E76616C696420706172746974696F6E207461626C65004572726F72206C6F6164696E67206F7065726174696E672073797374656D004D697373696E67206F7065726174696E672073797374656D00" )
					$MBR = " (MBR Code: Windows 7/8/10) "
				Case StringRegExp ( StringRegExpReplace ( $REGEX , "\A(.{870}).+" , "$1" ) , "33C08ED0BC007C8EC08ED8BE007CBF0006B90002FCF3A450681C06CBFBB90400BDBE07807E00007C0B0F85100183C510E2F1CD1888560055C6461105C6461000B441BBAA55CD135D720F81FB55AA7509F7C101007403FE46106660807E1000742666680000000066FF760868000068007C680100681000B4428A56008BF4CD139F83C4109EEB14B80102BB007C8A56008A76018A4E028A6E03CD136661731EFE4E110F850C00807E00800F848A00B280EB825532E48A5600CD135DEB9C813EFE7D55AA756EFF7600E88A000F851500B0D1E664E87F00B0DFE660E87800B0FFE664E87100B800BBCD1A6623C0753B6681FB54435041753281F90201722C666807BB00006668000200006668080000006653665366556668000000006668007C0000666168000007CD1A5A32F6EA007C0000CD18A0B707EB08A0B607EB03A0B50732E40500078BF0AC3C0074FCBB0700B40ECD10EBF22BC9E464EB002402E0F82402C3496E76616C696420706172746974696F6E207461626C65004572726F72206C6F6164696E67206F7065726174696E672073797374656D004D697373696E67206F7065726174696E672073797374656D0000" )
					$MBR = " (MBR Code: Windows 7 or Vista) "
				Case StringRegExp ( StringRegExpReplace ( $REGEX , "\A(.{760}).+" , "$1" ) , "33C08ED0BC007CFB5007501FFCBE1B7CBF1B065057B9E501F3A4CBBDBE07B104386E007C09751383C510E2F4CD188BF583C610497419382C74F6A0B507B4078BF0AC3C0074FCBB0700B40ECD10EBF2884E10E84600732AFE4610807E040B740B807E040C7405A0B60775D2804602068346080683560A00E821007305A0B607EBBC813EFE7D55AA740B807E100074C8A0B707EBA98BFC1E578BF5CBBF05008A5600B408CD1372238AC1243F988ADE8AFC43F7E38BD186D6B106D2EE42F7E239560A77237205394608731CB80102BB007C8B4E028B5600CD1373514F744E32E48A5600CD13EBE48A560060BBAA55B441CD13723681FB55AA7530F6C101742B61606A006A00FF760AFF76086A0068007C6A016A10B4428BF4CD136161730E4F740B32E48A5600CD13EBD661F9C3496E76616C696420706172746974696F6E207461626C65004572726F72206C6F6164696E67206F7065726174696E672073797374656D004D697373696E67206F7065726174696E672073797374656D00" )
					$MBR = " (MBR Code: Windows XP) "
				Case StringRegExp ( StringRegExpReplace ( $REGEX , "\A(.{870}).+" , "$1" ) , "33C08ED08EC08ED8BC007CBE007CBF0006B90002FCF3A450681C06CBFB60B95401BD2B068076004745E2F9CF513840C469544357E6544386A741E43241F30FF9C3408041C34059478A54F83340FE4E47AFA04721CC0353B87132414074B8AF5147F9FF4FCC49F34FB4E3E6F14FC28732AA26AD47474747278141E540578041E340464749C841EF408041E140F54F21B871D34021C841ED4021B871DF4021C841E9402107216E41ED4021C459E94047F305F9E540CD5138408A54FD434321B871ED4021C841C74021C671C7400115D105F9C74074876CB8749CCFD8F540B98432BFCDC8F54045434586CCBFCDEAF540CFE8F540CFCAF54001B98932436CB5CDB5B984329AF9F54FFD474548F19C48F18474B8B984CDC8F5404586CCBFCDEAF540CFCAF540CFE8F540458A75AACCBECDCAF540774B010D329D2684217487AF70B8C679F54F0F03334A21B849D34021C459DF4047ACA2CCAEFC4247F9FF4FB4E16CB2C28E334944B6C481676C8A44BECC8A0C32AD847470757176777473476C41" )
					$MBR = " (" & $UPD1 & ": ===> MBR IS INFECTED. Use FixMbr command in Recovery Mode) "
			Case Else
					$MBR = " "
				EndSelect
				FileWrite ( @TempDir & "\readmbr" , @CRLF & "==========================================================" & @CRLF & "Disk: " & $DRIVE & $MBR & "(Size: " & $SIZE & ") (Disk ID: " & $DISKID & ")" & @CRLF )
				$PARTS = StringRegExpReplace ( $REGEX , ".{892}(.+).{4}" , "$1" )
				$FLASH = StringRegExpReplace ( $PARTS , "(.{32}).*" , "$1" )
				$DISKIDCHECK = StringRegExpReplace ( $DISKID , 0 , "" )
				Select
				Case $DISKIDCHECK = ""
					FileWrite ( @TempDir & "\readmbr" , @CRLF & "Partition: GPT." & @CRLF )
			Case Else
					If StringRegExp ( $FLASH , "\A(80|00)" ) Then
						PARTITIONTABLE ( $PARTS )
					Else
						FileWrite ( @TempDir & "\readmbr" , "No partition Table on disk " & $DRIVE & "." & @CRLF )
						If StringRegExp ( $REGEX , "52656D6F7665206469736B73206F72206F74686572206D65646961" ) Then FileWrite ( @TempDir & "\readmbr" , "Disk " & $DRIVE & " is a removable device." & @CRLF )
					EndIf
				EndSelect
			Else
				FileWrite ( @TempDir & "\readmbr" , " Could not read MBR for disk " & $DRIVE & "." & @CRLF )
			EndIf
		EndIf
		$DRIVE += 1
	WEnd
	FileWrite ( $HTEMP00 , FileRead ( @TempDir & "\readmbr" ) )
	If $BOOTM <> "Recovery" Then
		FileWrite ( $HTEMP00 , @CRLF & "==================== " & $END & " " & $OF & " " & $TEMP00 & " =======================" )
		FileCopy ( @ScriptDir & "\Addition.txt" , $C & "\frst\logs\Addition.txt" , 1 )
		$CDATE = @MDAY & "-" & @MON & "-" & @YEAR & " " & @HOUR & "." & @MIN & "." & @SEC
		FileMove ( $C & "\frst\logs\Addition.txt" , $C & "\FRST\Logs\Addition_" & $CDATE & ".txt" , 1 )
	EndIf
	FileClose ( $HTEMP00 )
	FileDelete ( @TempDir & "\readmbr" )
EndFunc
Func PART0 ( $DRIVE , $CH = "" )
	Local $LOK
	$OBJWMISERVICE = ObjGet ( "winmgmts:{impersonationLevel=impersonate,authenticationLevel=pktPrivacy}!\\" & @ComputerName & "\root\CIMV2\Security\MicrosoftVolumeEncryption" )
	If Not IsObj ( $OBJWMISERVICE ) Then Return
	$OBJWMIQUERY = $OBJWMISERVICE .ExecQuery ( "SELECT * FROM Win32_EncryptableVolume WHERE DriveLetter='" & $DRIVE & "'" , "WQL" , 0 )
	If Not IsObj ( $OBJWMIQUERY ) Then Return
	For $OBJDRIVE In $OBJWMIQUERY
		If $CH Then $OBJDRIVE .GetLockStatus ( $LOK )
		If Not $CH Then $OBJDRIVE .GetProtectionStatus ( $LOK )
		Return $LOK
	Next
EndFunc
Func _GETMODEL ( $IINDEX )
	$OUTPUT = ""
	$OBJWMISERVICE = ObjGet ( "winmgmts:\\.\root\CIMV2" )
	$COLITEMS = $OBJWMISERVICE .ExecQuery ( "SELECT * FROM Win32_DiskDrive Where Index like '" & $IINDEX & "'" , "WQL" , 16 + 32 )
	If Not IsObj ( $COLITEMS ) Then Return
	For $OBJITEM In $COLITEMS
		Return $OBJITEM .Model
	Next
EndFunc
Func _GETVOLUMEDISKINDEX ( $SDRIVELETTER )
	Local $ODRIVE , $OPARTITION , $OLOGICALDISK
	Local $OWMISERVICE = ObjGet ( "winmgmts:\\.\root\cimv2" )
	If Not IsObj ( $OWMISERVICE ) Then Return
	Local $ODISKDRIVES = $OWMISERVICE .ExecQuery ( "SELECT * FROM Win32_DiskDrive" )
	If Not IsObj ( $ODISKDRIVES ) Then Return
	For $ODRIVE In $ODISKDRIVES
		$SDEVICEID = StringReplace ( $ODRIVE .DeviceID , "\" , "\\" )
		$OPARTITIONS = $OWMISERVICE .ExecQuery ( "ASSOCIATORS OF {Win32_DiskDrive.DeviceID=""" & $SDEVICEID & """} WHERE AssocClass = " & "Win32_DiskDriveToDiskPartition" )
		If Not IsObj ( $OPARTITIONS ) Then Return
		For $OPARTITION In $OPARTITIONS
			$OLOGICALDISKS = $OWMISERVICE .ExecQuery ( "ASSOCIATORS OF {Win32_DiskPartition.DeviceID=""" & $OPARTITION .DeviceID & """} WHERE AssocClass = " & "Win32_LogicalDiskToPartition" )
			If Not IsObj ( $OLOGICALDISKS ) Then Return
			For $OLOGICALDISK In $OLOGICALDISKS
				If $OLOGICALDISK .DeviceID = $SDRIVELETTER Then Return $ODRIVE .Index
			Next
		Next
	Next
EndFunc
Func PART1 ( $CLASS )
	$OUTPUT = ""
	$OBJWMISERVICE = ObjGet ( "winmgmts:{impersonationLevel=impersonate}!\\.\root\cimv2" )
	If Not IsObj ( $OBJWMISERVICE ) Then Return
	$COLITEMS = $OBJWMISERVICE .ExecQuery ( "SELECT * FROM " & $CLASS , "WQL" , 16 + 32 )
	If Not IsObj ( $COLITEMS ) Then Return
	For $OBJITEM In $COLITEMS
		If $CLASS = "Win32_BaseBoard" Then
			$OUTPUT = $OBJITEM .Manufacturer & " " & $OBJITEM .Product
		Else
			$OUTPUT = $OBJITEM .Manufacturer & " " & $OBJITEM .BIOSVersion ( 0 ) & " " & StringRegExpReplace ( $OBJITEM .ReleaseDate , "(\d{4})(\d{2})(\d{2}).*" , "$2/$3/$1" )
		EndIf
	Next
	Return $OUTPUT
EndFunc
Func PARTITIONTABLE ( $PARTS )
	$P = 0
	$PARTNR = 1
	$SIZE = ""
	$SIZE1 = ""
	While 1
		$SUS = ""
		If $P > 96 Then ExitLoop
		$A = "(Not Active) - "
		$PART = StringRegExpReplace ( $PARTS , ".{" & $P & "}(.{32}).*" , "$1" )
		If Not StringRegExp ( $PART , "00000000000000000000000000000000" ) Then
			$TYPE = StringRegExpReplace ( $PART , ".{8}(.{2}).+" , "$1" )
			If $TYPE == "EE" Then
				FileWrite ( @TempDir & "\readmbr" , @CRLF & "Partition: GPT." & @CRLF )
			Else
				If StringRegExp ( $PART , "\A8.+" ) Then $A = "(Active) - "
				If $TYPE = "0c" Or $TYPE = "0b" Then $TYPE = "FAT32"
				If $TYPE = "0F" Then $TYPE = "0F Extended"
				If $TYPE = "07" Then $TYPE = "07 NTFS"
				$SIZE = StringRegExpReplace ( $PART , ".{24}(.{8})" , "$1" )
				$SIZE = StringRegExpReplace ( $SIZE , "(.{2})(.{2})(.{2})(.{2})" , "$4$3$2$1" )
				$SIZE1 = Dec ( $SIZE )
				If $SIZE1 < 0 Then
					$SIZE = Dec ( $SIZE , 2 )
				Else
					$SIZE = $SIZE1
				EndIf
				$SIZE = $SIZE * 512
				If $SIZE < 3000 Then
					If $SIZE > 0 Then $SIZE = $SIZE & " byte"
					$SUS = 1
				Else
					$SIZE = $SIZE / 1024
					If $SIZE < 3000 Then
						$SIZE = Round ( $SIZE , 0 )
						$SIZE = $SIZE & " KB"
						$SUS = 1
					Else
						$SIZE = $SIZE / 1024
						If $SIZE < 1024 Then
							$SIZE = Round ( $SIZE , 0 )
							If $SIZE < 90 Then $SUS = 1
							$SIZE = $SIZE & " MB"
						Else
							$SIZE = $SIZE / 1024
							$SIZE = Round ( $SIZE , 1 )
							$SIZE = $SIZE & " GB"
						EndIf
					EndIf
				EndIf
				$PIHAR = ""
				If $TYPE == "00" And $SIZE = 0 Then
					$PARTNR = $PARTNR + 4294967295
					FileWrite ( @TempDir & "\readmbr" , "Partition 00" & ": " & $A & "(Size=" & $SIZE & ") - (Type=" & $TYPE & ") " & $UPD1 & " ===> 0 byte partition bootkit." & @CRLF )
				Else
					If $TYPE = "17" And $SUS = 1 Then $PIHAR = $UPD1 & " ===> Suspicious partition bootkit on partition " & $PARTNR
					FileWrite ( @TempDir & "\readmbr" , "Partition " & $PARTNR & ": " & $A & "(Size=" & $SIZE & ") - (Type=" & $TYPE & ")" & $PIHAR & @CRLF )
				EndIf
			EndIf
		EndIf
		$P += 32
		$PARTNR += 1
	WEnd
EndFunc
Func PDF ( $KEY , $MHIVE )
	GUICtrlSetData ( $LABEL1 , $SCANB & " Internet: " & $KEY )
	$HKEY = _REGOPENKEYEX3 ( $KEY )
	If @error Or Not $HKEY Then Return
	$I = 0
	While 1
		$SUB = __REGENUMKEY ( $HKEY , $I )
		If @error Then ExitLoop
		If StringRegExp ( $SUB , "\{.+\}" ) Then
			$FILEPATH = RegRead ( $KEY & "\" & $SUB & "\DownloadInformation" , "codebase" )
			$FILEPATH = StringRegExpReplace ( $FILEPATH , "(?i)http(s|):" , "hxxp\1:" )
			If GUICtrlRead ( $CHECKBOX11 ) = 1 Then
				If Not StringInStr ( $FILEPATH , "hxxp(|s)://java.sun.com/" ) Then FileWrite ( $HADDITION , "DPF: " & $MHIVE & $SUB & " " & $FILEPATH & @CRLF )
			Else
				FileWrite ( $HADDITION , "DPF: " & $MHIVE & $SUB & " " & $FILEPATH & @CRLF )
			EndIf
		EndIf
		$I = $I + 1
	WEnd
	If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
EndFunc
Func PDFFIX ( )
	Local $CLSID
	$KEY1 = "\Microsoft\Code Store Database\Distribution Units\"
	If StringInStr ( $FIX , "HKLM " ) Then $KEY = "HKLM\SOFTWARE" & $KEY1
	If StringInStr ( $FIX , "HKLM-x32" ) Then $KEY = "HKLM\SOFTWARE\Wow6432Node" & $KEY1
	$CLSID = StringRegExpReplace ( $FIX , "[^\{]+(\{.+\}).*" , "$1" )
	$KEY = $KEY & $CLSID
	DELKEY ( $KEY )
	If StringInStr ( $KEY , "Wow6432Node" ) Then
		$KEY = "HKLM\Software\Wow6432Node\Classes\CLSID\" & $CLSID
	Else
		$KEY = "HKLM\Software\Classes\CLSID\" & $CLSID
	EndIf
	If VAR ( $KEY ) Then DELKEY ( $KEY )
EndFunc
Func PERROUT ( )
	$VAL = StringRegExpReplace ( $FIX , "[^[]+:\s*\[([^]]*)\].*" , "$1" )
	DELVALUE ( "HKLM\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters\PersistentRoutes" , $VAL )
EndFunc
Func POL1 ( $VAL )
	$VALDATA = RegRead ( "HKLM\software\microsoft\windows\currentversion\policies\system" , $VAL )
	If $VALDATA Then _ARRAYADD ( $ARRAYREG , "HKLM\...\Policies\system: [" & $VAL & "] " & $VALDATA , 0 , "||||" )
EndFunc
Func POLICIES ( $HIVE )
	GUICtrlSetData ( $LABEL1 , $REGIST1 & ": Policies" )
	$KEY = $HIVE & $SOFTWARE & "\Microsoft\Windows\CurrentVersion\Policies\Explorer"
	$HKEY = _REGOPENKEYEX3 ( $KEY )
	If Not @error And IsPtr ( $HKEY ) Then
		$ARRAYNAME = _LISTVAL ( $HKEY )
		If UBound ( $ARRAYNAME ) > 0 Then
			For $V = 0 To UBound ( $ARRAYNAME ) + 4294967295
				$VALNAME = $ARRAYNAME [ $V ] [ 0 ]
				$VALDATA = $ARRAYNAME [ $V ] [ 1 ]
				$ATTEN = ""
				$SIZE = ""
				If $VALNAME = "NoDesktop" And $VALDATA = 1 Then $ATTEN = " <==== " & $UPD1
				$FILE = $VALDATA
				If StringRegExp ( $VALDATA , "(?i)[a-z]" ) Then
					AAAAFP ( )
					If FileExists ( $FILE ) Then $SIZE = " [" & $SIZE & " " & $CDATE & "]" & $COMPANY
				EndIf
				_ARRAYADD ( $ARRAYREG , $HIVE & "...\Policies\Explorer: [" & $VALNAME & "] " & $FILE & $SIZE & $ATTEN , 0 , "||||" )
			Next
		EndIf
		If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
	EndIf
	CERTDISALLOW ( "HKLM\" )
	CERTDISALLOW ( "HKLM\" , "\Policies" )
	$KEY = "HKLM\SOFTWARE\Policies\Microsoft\Windows NT\SystemRestore"
	POLICIES1 ( $KEY , "DisableConfig" )
	POLICIES1 ( $KEY , "DisableSR" )
	$KEY = "HKLM\SOFTWARE\Microsoft\Windows Defender"
	POLICIES1 ( $KEY , "DisableAntiSpyware" )
	POLICIES1 ( $KEY , "DisableAntiVirus" )
EndFunc
Func POLICIES1 ( $KEY , $VAL )
	$HKEY = _REGOPENKEYEX3 ( $KEY )
	If Not @error And IsPtr ( $HKEY ) Then
		$ARRAYNAME = _LISTVAL ( $HKEY )
		If UBound ( $ARRAYNAME ) > 0 Then
			For $V = 0 To UBound ( $ARRAYNAME ) + 4294967295
				If $ARRAYNAME [ $V ] [ 0 ] = $VAL And $ARRAYNAME [ $V ] [ 1 ] = 1 Then
					$ATTEN = " <==== " & $UPD1
					_ARRAYADD ( $ARRAYREG , $KEY & ": [" & $VAL & "] " & $RESTRICT & $ATTEN , 0 , "||||" )
					ExitLoop
				EndIf
			Next
		EndIf
		If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
	EndIf
EndFunc
Func POLICIESEEXP ( )
	$VAL = StringRegExpReplace ( $FIX , "(?i)HKLM\\\.\.\.\\Policies\\Explorer\\Run: \[(.*)\] =>.*" , "$1" )
	$KEY = "HKLM\" & $SOFTWARE & "\Microsoft\Windows\CurrentVersion\policies\Explorer\Run"
	DELVALUE ( $KEY , $VAL )
EndFunc
Func POLICIESRUN ( $HIVE )
	Local $ARRAYNAME
	$FULLKEY = "HKLM\" & $SOFTWARE & "\Microsoft\Windows\CurrentVersion\\policies\Explorer\Run"
	GUICtrlSetData ( $LABEL1 , $REGIST1 & ": " & $FULLKEY )
	$HKEY = _REGOPENKEYEX3 ( $FULLKEY )
	If @error Or $HKEY = 0 Then Return 1
	$ARRAYNAME = _LISTVAL ( $HKEY )
	If UBound ( $ARRAYNAME ) > 0 Then
		For $I = 0 To UBound ( $ARRAYNAME ) + 4294967295
			$ATTEN = ""
			$SIZE = ""
			$VALNAME = $ARRAYNAME [ $I ] [ 0 ]
			$FILE = $ARRAYNAME [ $I ] [ 1 ]
			Select
			Case StringInStr ( $VALNAME , "<*>" )
				$LRCHAR = " **"
				$LRCHAR = StringRegExp ( $LRCHAR , "\*(.)\*" , 3 )
				If IsArray ( $LRCHAR ) Then $LRCHAR = $LRCHAR [ 0 ]
				$FILE = StringRegExpReplace ( $FILE , $LRCHAR , "" )
				$ATTEN = " <==== " & $UPD1 & " (" & $REGIST4 & ")"
		Case Else
				If Not StringRegExp ( $ARRAYNAME [ $I ] [ 1 ] , "(?i)\bmsiexec\b" ) Then AAAAFP ( )
			EndSelect
			If FileExists ( $FILE ) Then
				If StringRegExp ( $FILE , "\\\w{6}~\d\\" ) Then $FILE = FileGetLongName ( $FILE )
				$SIZE = " [" & $SIZE & " " & $CDATE & "]" & $COMPANY
				$ARRAYNAME [ $I ] [ 1 ] = $FILE
			EndIf
			If StringRegExp ( $ARRAYNAME [ $I ] [ 1 ] , "\\Local\\.+?\\\w+\.exe" ) Then $ATTEN = " <==== " & $UPD1
			_ARRAYADD ( $ARRAYREG , $HIVE & "...\Policies\Explorer\Run: [" & $VALNAME & "] => " & $ARRAYNAME [ $I ] [ 1 ] & $SIZE & $ATTEN , 0 , "||||" )
		Next
		$ARRAYNAME = ""
	EndIf
	If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
EndFunc
Func POLICIESSR ( )
	$KEY = "HKLM\" & $SOFTWARE & "\Policies\Microsoft\Windows NT\SystemRestore"
	DELKEY ( $KEY )
EndFunc
Func POWERSHELL ( )
	$COM = StringRegExpReplace ( $FIX , "(?i)powershell:\s*(.+)" , "$1" )
	$COM = StringRegExpReplace ( $COM , "^\s+|\s+$" , "" )
	FileWrite ( $HFIXLOG , @CRLF & "========= " & $COM & " =========" & @CRLF & @CRLF )
	$PATH1 = $C & "\FRST\pw000.txt"
	FileDelete ( $PATH1 )
	$ITIME = _TIMER_SETTIMER ( $FORM1 , 3600000 , TIMEA )
	$SCMD = $C & "\Windows\System32\WindowsPowerShell\v1.0\powershell.exe"
	Select
	Case StringRegExp ( $COM , "(?i)^""?.:\\.+\.ps1""?$" )
		RunWait ( $SCMD & " -ExecutionPolicy Bypass " & $COM & " -File > " & $PATH1 , "" , @SW_HIDE )
		If Not FileRead ( $PATH1 ) Then RunWait ( $SCMD & " -ExecutionPolicy Bypass " & $COM & " -File Powershell 2>&1 > " & $PATH1 , "" , @SW_HIDE )
Case Else
		If Not StringInStr ( $COM , ";" ) Then $COM = $COM & ";"
		$COM = StringSplit ( $COM , ";" )
		If IsArray ( $COM ) Then
			$PATH0 = $C & "\FRST\tmp.ps1"
			$HFILE = FileOpen ( $PATH0 , 128 + 2 )
			For $P = 1 To UBound ( $COM ) + 4294967295
				$COM1 = StringRegExpReplace ( $COM [ $P ] , "^\s+|\s+$" , "" )
				FileWrite ( $HFILE , $COM1 & @CRLF )
			Next
			FileClose ( $HFILE )
			RunWait ( $SCMD & " -ExecutionPolicy Bypass " & $PATH0 & " -File > " & $PATH1 , "" , @SW_HIDE )
			If Not FileRead ( $PATH1 ) Then RunWait ( $SCMD & " -ExecutionPolicy Bypass " & $PATH0 & " -File Powershell 2>&1 > " & $PATH1 , "" , @SW_HIDE )
			FileDelete ( $PATH0 )
			FileWrite ( $HFIXLOG , FileRead ( $PATH1 ) )
		EndIf
	EndSelect
	_TIMER_KILLTIMER ( $FORM1 , $ITIME )
	FileDelete ( $PATH1 )
	FileWrite ( $HFIXLOG , @CRLF & "========= " & $END & " " & $OF & " Powershell: =========" & @CRLF & @CRLF )
EndFunc
Func POWERSHELLS ( ByRef $F )
	FileWrite ( $HFIXLOG , @CRLF & "========= Powershell: =========" & @CRLF & @CRLF )
	$PATH1 = $C & "\FRST\tmp000.ps1"
	$HPATH1 = FileOpen ( $PATH1 , 128 + 2 )
	$PATH2 = $C & "\FRST\pw000.txt"
	$ITIME = _TIMER_SETTIMER ( $FORM1 , 3600000 , TIMEA )
	$B = $F + 1
	While 1
		$BATCH = FileReadLine ( @ScriptDir & $FIXLIST , $B )
		If @error Then ExitLoop
		If StringInStr ( $BATCH , "endpowershell" ) Then ExitLoop
		FileWrite ( $HPATH1 , $BATCH & @CRLF )
		$B += 1
	WEnd
	$F = $B
	FileClose ( $HPATH1 )
	$SCMD = $C & "\Windows\System32\WindowsPowerShell\v1.0\powershell.exe"
	RunWait ( $SCMD & " -ExecutionPolicy Bypass " & $PATH1 & " -File > " & $PATH2 , "" , @SW_HIDE )
	If Not FileRead ( $PATH2 ) Then RunWait ( $SCMD & " -ExecutionPolicy Bypass " & $PATH1 & " -File Powershell 2>&1 > " & $PATH2 , "" , @SW_HIDE )
	_TIMER_KILLTIMER ( $FORM1 , $ITIME )
	FileDelete ( $PATH1 )
	FileWrite ( $HFIXLOG , FileRead ( $PATH2 ) & @CRLF & "========= " & $END & " " & $OF & " Powershell: =========" & @CRLF & @CRLF )
	FileDelete ( $PATH2 )
EndFunc
Func PROCRIT ( $PID )
	If _GETPROCESSCRITICAL ( $PID ) Then
		If Not _SETPROCESSCRITICAL ( $PID ) Then Return False
	EndIf
	Return True
EndFunc
Func PROVIDER ( )
	$KEY = "HKLM\SYSTEM\CurrentControlSet\Control\Print\Providers"
	$HKEY = _REGOPENKEYEX3 ( $KEY )
	$I = 0
	While 1
		$SUB = __REGENUMKEY ( $HKEY , $I )
		If @error Then ExitLoop
		$I += 1
		$VAL1 = RegRead ( $KEY & "\" & $SUB , "Name" )
		If @error Then ContinueLoop
		If StringRegExp ( $VAL1 , "(?i)local\d{2}spl\.dll" ) Then
			$ATT = " <==== " & $UPD1
		Else
			$ATT = ""
		EndIf
		$FILE = $VAL1
		AAAAFP ( )
		If FileExists ( $FILE ) Then
			_ARRAYADD ( $ARRAYREG , "HKLM\...\Providers\" & $SUB & ": " & $FILE & " [" & $SIZE & " " & $CDATE & "]" & $COMPANY & $ATT , 0 , "||||" )
		Else
			_ARRAYADD ( $ARRAYREG , "HKLM\...\Providers\" & $SUB & ": " & $VAL1 & $ATT , 0 , "||||" )
		EndIf
	WEnd
	If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
EndFunc
Func PROVIDERFIX ( )
	$VAL = StringRegExpReplace ( $FIX , "HKLM\\.+\\Providers\\(.+?):.+" , "$1" )
	$KEY = "HKLM\SYSTEM\CurrentControlSet\Control\Print\Providers"
	DELKEY ( $KEY & "\" & $VAL )
	$ORDER = RegRead ( $KEY , "order" )
	$RET1 = StringRegExp ( $ORDER , "(?i)(^|\n)" & $VAL & "(\n|$)" )
	Select
	Case $RET1 = 0
		NFOUND ( $KEY & "\\order " & $VAL )
	Case $RET1 = 1
		$ORDER2 = StringRegExpReplace ( $ORDER , "(?i)^" & $VAL & "\n" , "" )
		$ORDER2 = StringRegExpReplace ( $ORDER2 , "(?i)\n" & $VAL & "\n" , @LF )
		$ORDER2 = StringRegExpReplace ( $ORDER2 , "(?i)\n" & $VAL & "$" , "" )
		RegWrite ( $KEY , "order" , "REG_MULTI_SZ" , $ORDER2 )
		$ORDER = RegRead ( $KEY , "order" )
		$RET1 = StringRegExp ( $ORDER , "(?i)(^|\n)" & $VAL & "(\n|$)" )
		Select
		Case $RET1 = 0
			DELETED ( $KEY & "\\order " & $VAL )
		Case $RET1 = 1
			NDELETED ( $KEY & "\\order " & $VAL )
		EndSelect
	EndSelect
EndFunc
Func PROXYENABLEFIX ( )
	$USER = StringRegExpReplace ( $FIX , "ProxyEnable: \[(.+?)\] =>.*" , "$1" )
	$KEY1 = "\Microsoft\Windows\CurrentVersion\Internet Settings"
	$KEY = "HKU\" & $USER & "\Software" & $KEY1
	If $USER = "HKLM" Then $KEY = "HKLM\Software" & $KEY1
	If $USER = "HKLM-x32" Then $KEY = "HKLM\Software\Wow6432Node" & $KEY1
	$VAL = "ProxyEnable"
	DELVALUE ( $KEY , $VAL )
	DllCall ( "WININET.DLL" , "long" , "InternetSetOption" , "int" , 0 , "long" , 39 , "str" , 0 , "long" , 0 )
EndFunc
Func PROXYSERVERFIX ( )
	$USER = StringRegExpReplace ( $FIX , "ProxyServer: \[(.+?)\] =>.*" , "$1" )
	$KEY1 = "\Microsoft\Windows\CurrentVersion\Internet Settings"
	$KEY = "HKU\" & $USER & "\Software" & $KEY1
	If $USER = "HKLM" Then $KEY = "HKLM\Software" & $KEY1
	If $USER = "HKLM-x32" Then $KEY = "HKLM\Software\Wow6432Node" & $KEY1
	$VAL = "ProxyServer"
	DELVALUE ( $KEY , $VAL )
EndFunc
Func QUARANTINE ( $MAINFOLDER )
	FileDelete ( @TempDir & "\quar00" )
	FileDelete ( @TempDir & "\final00" )
	FileDelete ( @TempDir & "\final22" )
	$HQUAR00 = FileOpen ( @TempDir & "\quar00" , 2 + 256 )
	Local $SUBFOLDERS = _FILELISTTOARRAYREC ( $MAINFOLDER , "*" , 0 , 1 , 1 , 2 )
	If IsArray ( $SUBFOLDERS ) Then _FILEWRITEFROMARRAY ( $HQUAR00 , $SUBFOLDERS , 1 )
	FileClose ( $HQUAR00 )
	$HFINAL00 = FileOpen ( @TempDir & "\final00" , 2 + 256 )
	$G = 1
	While 1
		$PATH = FileReadLine ( @TempDir & "\quar00" , $G )
		If @error Then ExitLoop
		$SFILE = FileGetShortName ( $PATH )
		If Not StringRegExp ( $SFILE , "\\[ ]+" ) Then FileWrite ( $HFINAL00 , $SFILE & @CRLF )
		$G += 1
	WEnd
	FileDelete ( @TempDir & "\quar00" )
	FileClose ( $HFINAL00 )
	$HFINAL22 = FileOpen ( @TempDir & "\final22" , 2 + 256 )
	$G = 1
	While 1
		$PATH1 = FileReadLine ( @TempDir & "\final00" , $G )
		If @error Then ExitLoop
		$PATH2 = FileReadLine ( @TempDir & "\final00" , $G + 1 )
		If Not StringInStr ( $PATH2 , $PATH1 ) Then FileWrite ( $HFINAL22 , $PATH1 & @CRLF )
		$G += 1
	WEnd
	FileClose ( $HFINAL00 )
	FileDelete ( @TempDir & "\final00" )
	$G = 1
	While 1
		$PATH1 = FileReadLine ( @TempDir & "\finall22" , $G )
		If @error Then ExitLoop
		If Not StringInStr ( FileGetAttrib ( $PATH1 ) , "D" ) Then
			_GRANTE ( $PATH1 , 1 , 1 )
			If StringRegExp ( FileGetAttrib ( $PATH1 ) , "(?i)S|R|H" ) Then FileSetAttrib ( $PATH1 , "-SRH" )
			$RET = FileDelete ( $PATH1 )
			If $RET = 0 Then
				_GRANTE ( $PATH1 , 1 , 1 )
				If StringRegExp ( FileGetAttrib ( $PATH1 ) , "(?i)S|R|H" ) Then FileSetAttrib ( $PATH1 , "-SRH" )
				FileDelete ( $PATH1 )
			EndIf
		Else
			_GRANTE ( $PATH1 , 1 , 1 )
			$RET = DirRemove ( $PATH1 , 1 )
			If $RET = 0 Then
				_GRANTE ( $PATH1 , 1 , 1 )
				DirRemove ( $PATH1 , 1 )
			EndIf
		EndIf
		$G += 1
	WEnd
	FileClose ( $HFINAL22 )
	FileDelete ( @TempDir & "\final22" )
EndFunc
Func QUARFINAL ( )
	FileDelete ( @TempDir & "\rdoutp0" )
	RunWait ( @ComSpec & " /c " & "rd /s/q " & $C & "\FRST\Quarantine > """ & @TempDir & "\rdoutp0"" 2>&1 " , "" , @SW_HIDE )
	$F = 1
	While 1
		$FILE = FileReadLine ( @TempDir & "\rdoutp0" , $F )
		If @error Then ExitLoop
		$PATH = StringRegExpReplace ( $FILE , "(.+) - .+" , "$1" )
		_GRANTE ( $PATH , 1 , 1 )
		If StringInStr ( FileGetAttrib ( $PATH ) , "D" ) Then
			DirRemove ( $PATH , 1 )
			RunWait ( @ComSpec & " /c " & "rd /s/q """ & $PATH & """" , "" , @SW_HIDE )
			RunWait ( @ComSpec & " /c " & "rd /s/q " & $C & "\FRST\Quarantine" , "" , @SW_HIDE )
		Else
			FileDelete ( $PATH )
		EndIf
		$F += 1
	WEnd
	FileDelete ( @TempDir & "\rdoutp0" )
EndFunc
Func READ ( $PATH )
	$OFI = FileOpen ( $PATH , 256 )
	$READ = FileRead ( $OFI )
	FileClose ( $OFI )
	Return $READ
EndFunc
Func READSIZE ( )
EndFunc
Func REBOOT ( )
	Local $VALUAC
	FileDelete ( $C & "\FRST\Hives\uac" )
	$KEY = "HKLM\Software\Microsoft\Windows\CurrentVersion\Policies\System"
	$VALUAC = RegRead ( $KEY , "ConsentPromptBehaviorAdmin" )
	If Not @error And $VALUAC <> 0 Then
		FileWrite ( $C & "\FRST\Hives\uac" , $VALUAC )
		RegWrite ( $KEY , "ConsentPromptBehaviorAdmin" , "REG_DWORD" , 0 )
	EndIf
	$BOOTPATH = """" & @ScriptDir & "\" & @ScriptName & """"
	$BOOTPATH = StringRegExpReplace ( $BOOTPATH , "\\\\" , "\\" )
	RegWrite ( "HKLM\Software\Microsoft\Windows\CurrentVersion\RunOnce" , "*FRST" , "REG_SZ" , $BOOTPATH )
	MsgBox ( 262144 + 0 , $FRST , $REBOOT0 & @CRLF & $REBOOT3 )
	MOVEFILEONREBOOT ( $C & "\FRST\reb" , "" )
EndFunc
Func REG ( )
	$COM = StringRegExpReplace ( $FIX , "(?i)reg:\s*(.+)" , "$1" )
	FileWrite ( $HFIXLOG , @CRLF & "========= " & $COM & " =========" & @CRLF & @CRLF )
	If $BOOTM = "Recovery" Then $COM = _RMTOR ( $COM )
	$TPATH = $C & "\FRST\logs\reg" & Random ( 1000 , 9999 , 1 )
	If StringRegExp ( $COM , "(?i)reg (delete|add) " ) And Not StringInStr ( $COM , "/f" ) Then $COM = StringRegExpReplace ( $COM , "(.+)" , "$1 /f" )
	If StringRegExp ( $COM , "(?i)reg export " ) And Not StringInStr ( $COM , "/y" ) Then $COM = StringRegExpReplace ( $COM , "(.+)" , "$1 /y" )
	$ITIME = _TIMER_SETTIMER ( $FORM1 , 300000 , CMDUP )
	RunWait ( @ComSpec & " /c " & $COM & ">" & $TPATH & " 2>&1" , "" , @SW_HIDE )
	_TIMER_KILLTIMER ( $FORM1 , $ITIME )
	$REGKEY = FileRead ( $TPATH )
	If $BOOTM = "Recovery" Then $REGKEY = _RMTON ( $REGKEY )
	FileWrite ( $HFIXLOG , $REGKEY )
	FileWrite ( $HFIXLOG , @CRLF & @CRLF & "========= " & $END & " " & $OF & " Reg: =========" & @CRLF & @CRLF )
	FileDelete ( $TPATH )
EndFunc
Func REGASS ( ByRef $ARR )
	$RUN1 = RegRead ( "HKLM\software\Classes\.reg" , "" )
	If $RUN1 <> "regfile" Then
		$RET = RegRead ( "HKLM\software\Classes\" & $RUN1 & "\shell\open\command" , "" )
		_ARRAYADD ( $ARR , "HKLM\...\.reg: " & $RUN1 & " => " & $RET & " <==== " & $UPD1 , 0 , "|||" )
	EndIf
	$RUN1 = RegRead ( "HKLM\software\Classes\regfile\DefaultIcon" , "" )
	If $RUN1 <> "%SystemRoot%\regedit.exe,1" Then _ARRAYADD ( $ARR , "HKLM\...\regfile\DefaultIcon: " & $RUN1 & " <==== " & $UPD1 , 0 , "|||" )
	$RUN1 = RegRead ( "HKLM\software\Classes\regfile\shell\open\command" , "" )
	If $RUN1 <> "regedit.exe ""%1""" Then _ARRAYADD ( $ARR , "HKLM\...\regfile\shell\open\command: " & $RUN1 & " <==== " & $UPD1 , 0 , "|||" )
EndFunc
Func REGEDIT ( ByRef $F )
	$PATH1 = FileOpen ( $C & "\FRST\tmp111.reg" , 256 + 2 )
	$B = $F + 1
	While 1
		$BATCH = FileReadLine ( @ScriptDir & $FIXLIST , $B )
		If @error Then ExitLoop
		If StringInStr ( $BATCH , "EndRegedit" ) Then ExitLoop
		If StringRegExp ( $BATCH , "(?i)\[-?hk.+\]" ) Then
			$KEY = StringRegExpReplace ( $BATCH , "(?i)\[-?(hk.+)\]" , "$1" )
			If _REGOPENKEYEX3 ( $KEY , 0 , 131078 ) = 5 Then FileWrite ( $HFIXLOG , $REGB & " ====> " & $KEY & " <==== " & $NOACC & @CRLF )
		EndIf
		FileWrite ( $PATH1 , $BATCH & @CRLF )
		$B += 1
	WEnd
	FileClose ( $PATH1 )
	$F = $B
	If Not StringRegExp ( FileRead ( $C & "\FRST\tmp111.reg" ) , "REGEDIT4|Windows Registry Editor Version 5.00" ) Then _FILEWRITETOLINE ( $C & "\FRST\tmp111.reg" , 1 , "Windows Registry Editor Version 5.00" & @CRLF & @CRLF )
	If $BOOTM = "recovery" Then
		$READR = FileRead ( $C & "\FRST\tmp111.reg" )
		$READR = _RMTOR ( $READR )
		$PATH1 = FileOpen ( $C & "\FRST\tmp111.reg" , 256 + 2 )
		FileWrite ( $PATH1 , $READR & @CRLF )
		FileClose ( $PATH1 )
	EndIf
	$REG = $SYSTEMDIR & "\reg.exe"
	RunWait ( @ComSpec & " /c " & $REG & " import " & $C & "\FRST\tmp111.reg > " & $C & "\frst\debug 2>&1" , "" , @SW_HIDE )
	$HREAD = FileOpen ( $C & "\frst\debug" , 256 )
	$ERROR = FileRead ( $HREAD )
	FileClose ( $HREAD )
	FileWrite ( $FRSTLOG , $ERROR )
	FileDelete ( $C & "\frst\debug" )
	FileDelete ( $C & "\FRST\tmp111.reg" )
	FileWrite ( $HFIXLOG , $REGB & " ====> " & $ERROR )
EndFunc
Func REGKEYFIX ( )
	$KEY = StringRegExpReplace ( $FIX , "RegKey: \[(.+)?\].*" , "$1" )
	DELKEY ( $KEY )
EndFunc
Func REMFOLARR ( $PATH , $MASK )
	$ARRSTOR = _FILELISTTOARRAYREC ( $PATH , $MASK , 2 + 16 , 0 , 0 , 2 )
	For $Z = 1 To UBound ( $ARRSTOR ) + 4294967295
		_DIRREMOVE ( $ARRSTOR [ $Z ] )
		If FileExists ( $ARRSTOR [ $Z ] ) And _BBBBKP ( $ARRSTOR [ $Z ] ) Then DirRemove ( $ARRSTOR [ $Z ] , 1 )
	Next
EndFunc
Func REMOVEPROXY ( )
	FileWrite ( $HFIXLOG , @CRLF & "========= RemoveProxy: =========" & @CRLF & @CRLF )
	$KEY = "HKLM\SOFTWARE\Policies\Microsoft\Internet Explorer"
	If VAR ( $KEY ) Then DELKEY ( $KEY )
	For $U = 1 To UBound ( $USERREG ) + 4294967295
		$KEY = "HKU\" & $USERREG [ $U ] & "\SOFTWARE\Policies\Microsoft\Internet Explorer"
		If VAR ( $KEY , 1 ) Then DELKEY ( $KEY )
	Next
	$KEY1 = "\Microsoft\Windows\CurrentVersion\Internet Settings"
	REMOVEPROXYCHECK ( "HKLM\SOFTWARE\Policies" & $KEY1 , "ProxySettingsPerUser" )
	REMOVEPROXYCHECK ( "HKLM\SYSTEM\CurrentControlSet\services\NlaSvc\Parameters\Internet\ManualProxies" , "" )
	REMOVEPROXYSUB ( "HKLM\Software" & $KEY1 )
	REMOVEPROXYSUB ( "HKLM\Software\Wow6432Node" & $KEY1 )
	$KEY = "HKLM\SOFTWARE" & $KEY1 & "\Connections"
	REMOVEPROXYCHECK ( $KEY , "DefaultConnectionSettings" )
	REMOVEPROXYCHECK ( $KEY , "SavedLegacySettings" )
	$KEY = "HKLM\SOFTWARE\Wow6432Node" & $KEY1 & "\Connections"
	REMOVEPROXYCHECK ( $KEY , "DefaultConnectionSettings" )
	REMOVEPROXYCHECK ( $KEY , "SavedLegacySettings" )
	$KEY = "HKLM\SYSTEM\CurrentControlSet\Services\iphlpsvc\Parameters\ProxyMgr"
	$HKEY = _REGOPENKEYEX3 ( $KEY )
	Local $ARRKEY [ 1 ]
	$I = 0
	While 1
		$SKEY = __REGENUMKEY ( $HKEY , $I )
		If @error Then ExitLoop
		$VALDAT = RegRead ( $KEY & "\" & $SKEY , "AutoConfigURL" )
		If Not @error Then _ARRAYADD ( $ARRKEY , $KEY & "\" & $SKEY , 0 , "|||" )
		$I += 1
	WEnd
	If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
	_DELARR1 ( $ARRKEY )
	For $U = 1 To UBound ( $USERREG ) + 4294967295
		REMOVEPROXYSUB ( "HKU\" & $USERREG [ $U ] & "\Software" & $KEY1 )
		$KEY = "HKU\" & $USERREG [ $U ] & "\SOFTWARE" & $KEY1 & "\Connections"
		REMOVEPROXYCHECK ( $KEY , "DefaultConnectionSettings" )
		REMOVEPROXYCHECK ( $KEY , "SavedLegacySettings" )
	Next
	RunWait ( @ComSpec & " /c proxycfg -d" , "" , @SW_HIDE )
	$BITSADMIN = @SystemDir & "\bitsadmin.exe"
	Run ( @ComSpec & " /c " & $BITSADMIN & " /util /setieproxy localsystem NO_PROXY RESET" , "" , @SW_HIDE )
	FileWrite ( $HFIXLOG , @CRLF & @CRLF & "========= " & $END & " " & $OF & " RemoveProxy: =========" & @CRLF & @CRLF )
EndFunc
Func REMOVEPROXYCHECK ( $KEY , $VALUE , $YA = 0 )
	RegRead ( $KEY , $VALUE )
	If Not @error Then
		DELVALUE ( $KEY , $VALUE )
		DllCall ( "WININET.DLL" , "long" , "InternetSetOption" , "int" , 0 , "long" , 39 , "str" , 0 , "long" , 0 )
	Else
		If $YA Then NFOUND ( $KEY & "\\" & $VALUE )
	EndIf
EndFunc
Func REMOVEPROXYSUB ( $KEY )
	If RegRead ( $KEY , "ProxyEnable" ) Then DELVALUE ( $KEY , "ProxyEnable" )
	RegRead ( $KEY , "ProxyServer" )
	If Not @error Then DELVALUE ( $KEY , "ProxyServer" )
	RegRead ( $KEY , "AutoConfigURL" )
	If Not @error Then DELVALUE ( $KEY , "AutoConfigURL" )
	DllCall ( "WININET.DLL" , "long" , "InternetSetOption" , "int" , 0 , "long" , 39 , "str" , 0 , "long" , 0 )
EndFunc
Func REPLACE ( )
	Local $OWNER = "" , $DACL = "" , $SECDESC = ""
	$FILEP = StringRegExpReplace ( $FIX , "^""|""$" , "" )
	$SOURCE = StringRegExpReplace ( $FIX , "(?i)Replace:[ ]*([b-z]:\\[^:]+)[ ][b-z]:\\.+" , "$1" )
	If Not FileExists ( "\\?\" & $SOURCE ) Then Return FileWrite ( $HFIXLOG , """" & $SOURCE & """" & " -> " & $NFOUND & " => " & $REP & " " & $DESTIN & @CRLF )
	$DESTIN = StringRegExpReplace ( $FIX , "(?i)Replace:[ ]*[b-z]:\\[^:]+[ ]([b-z]:\\[^:]+)[ ]*" , "$1" )
	$DESDIR = StringRegExpReplace ( $DESTIN , "(.+)\\.+" , "$1" )
	If Not FileExists ( $DESDIR ) Then Return FileWrite ( $HFIXLOG , """" & $DESDIR & """" & " -> " & $NFOUND & " => " & $REP & " " & $DESTIN & @CRLF )
	If Not FileExists ( $DESTIN ) Then NFOUND ( $DESTIN )
	If FileExists ( "\\?\" & $DESTIN ) Then
		If Not StringInStr ( FileGetAttrib ( "\\?\" & $DESTIN ) , "D" ) Then
			If StringRegExp ( $DESTIN , "(?i)config\\system$" ) Then RunWait ( @ComSpec & " /c reg unload hklm\999" , "" , @SW_HIDE )
			If StringRegExp ( $DESTIN , "(?i)config\\software$" ) Then RunWait ( @ComSpec & " /c reg unload hklm\888" , "" , @SW_HIDE )
			MOVEFILE ( $DESTIN )
		Else
			If _BLACK ( $DESTIN ) Then Return FileWrite ( $HFIXLOG , """" & $DESTIN & """ => " & $WARN & ": " & $FIX13 & @CRLF )
			MOVEDIR ( $DESTIN )
		EndIf
	EndIf
	$RET = _CF ( $SOURCE , $DESTIN )
	$ERR = @error
	If FileCopy ( $SOURCE , $DESTIN , 1 ) Then
		FileWrite ( $HFIXLOG , $SOURCE & " " & $COP & " " & $DESTIN & @CRLF )
	Else
		If $ERR = 5 Then
			_GETACLOLD ( $DESDIR , $OWNER , $DACL , $SECDESC )
			_UNLOCK ( $DESDIR )
			$RET = _CF ( $SOURCE , $DESTIN )
			$ERR = @error
			If $SECDESC Then
				_SETACLOLD ( $DESDIR , $OWNER , $DACL , $SECDESC )
				LOCALFREE ( $SECDESC )
			EndIf
		EndIf
		If $RET Then
			FileWrite ( $HFIXLOG , $SOURCE & " " & $COP & " " & $DESTIN & @CRLF )
		Else
			If $ERR = 5 Then $ERR = "(" & $NOACC & ")"
			FileWrite ( $HFIXLOG , $REP & " -> " & $DESTIN & " " & $ERR0 & ": " & $ERR & @CRLF )
		EndIf
	EndIf
	If StringRegExp ( $DESTIN , "(?i)config\\system$" ) Then RunWait ( @ComSpec & " /c reg load hklm\999 c:\Windows\System32\config\System" , "" , @SW_HIDE )
	If StringRegExp ( $DESTIN , "(?i)config\\software$" ) Then RunWait ( @ComSpec & " /c reg load hklm\888 c:\Windows\System32\config\software" , "" , @SW_HIDE )
EndFunc
Func _GETACLOLD ( $PATH , ByRef $OWNER , ByRef $DACL , ByRef $SECDESC , $SE_OBJECT_TYPE = 1 )
	$SEC_INFO = BitOR ( 1 , 4 , 2147483648 )
	_SETPRIV0 ( )
	If $SE_OBJECT_TYPE = 4 Then $PATH = _SETKEYR ( $PATH )
	$RET = DllCall ( "Advapi32.Dll" , "dword" , "GetNamedSecurityInfoW" , "wstr" , $PATH , "dword" , $SE_OBJECT_TYPE , "dword" , $SEC_INFO , "ptr*" , 0 , "ptr" , 0 , "ptr*" , 0 , "ptr" , 0 , "ptr*" , 0 )
	If $RET [ 0 ] Then Return SetError ( 1 , 0 , 0 )
	$OWNER = $RET [ 4 ]
	$DACL = $RET [ 6 ]
	$SECDESC = $RET [ 8 ]
	$RET = DllCall ( "Advapi32.Dll" , "bool" , "IsValidAcl" , "ptr" , $RET [ 6 ] )
	If Not $RET [ 0 ] Then Return SetError ( 1 , 0 , 0 )
EndFunc
Func _SETACLOLD ( $PATH , $OWNER , $DACL , $SECDESC , $SE_OBJECT_TYPE = 1 )
	$SEC_INFO = BitOR ( 1 , 4 )
	If $SE_OBJECT_TYPE = 4 Then $PATH = _SETKEYR ( $PATH )
	$RET = DllCall ( "Advapi32.Dll" , "dword" , "SetNamedSecurityInfoW" , "wstr" , $PATH , "dword" , $SE_OBJECT_TYPE , "dword" , $SEC_INFO , "ptr" , $OWNER , "ptr" , 0 , "ptr" , $DACL , "ptr" , 0 )
	LOCALFREE ( $SECDESC )
EndFunc
Func RESETCATALOG ( $KEY )
	Local $VARS , $VARD
	$I = 1
	While 1
		$VARS = RegEnumKey ( $KEY , $I )
		If @error Then ExitLoop
		If $VARS > $I Then
			If $I < 10 Then $VARD = "00000000000" & $I
			If $I > 9 And $I < 100 Then $VARD = "0000000000" & $I
			If $I > 99 Then $VARD = "000000000" & $I
			_REGMOVEKEY ( $KEY & $VARS , $KEY & $VARD )
			If @error Then FileWrite ( $HFIXLOG , "Winsock reset error: " & $KEYY & ": " & $VARS & "=" & @error & @CRLF )
		EndIf
		$I += 1
	WEnd
EndFunc
Func RESFILE ( $PATH )
	If StringRegExp ( $PATH , ".xBAD$" ) Then
		$RENN = StringRegExpReplace ( $PATH , "(.+?).xBAD$" , "$1" )
		FileMove ( $PATH , $RENN , 1 )
	Else
		$RENN = $PATH
	EndIf
	$DES = StringRegExpReplace ( $RENN , "(?i)[a-z]:\\FRST\\Quarantine\\([a-z])(\\.+)" , "$1:$2" )
	If Not FileExists ( $DES ) Then
		_SETDEFAULTFILEACCESS ( $RENN )
		FileMove ( $RENN , $DES , 1 + 8 )
	EndIf
	FileWrite ( $HFIXLOG , $FIX & "=> " & $RESQUA & @CRLF )
EndFunc
Func RESFOL ( $PATH )
	$REN = _FILELISTTOARRAYREC ( $PATH , "*" , 1 , 1 , 0 , 2 )
	For $I = 1 To UBound ( $REN ) + 4294967295
		If StringRegExp ( $REN [ $I ] , ".xBAD$" ) Then
			$RENN = StringRegExpReplace ( $REN [ $I ] , "(.+?).xBAD$" , "$1" )
			FileMove ( $REN [ $I ] , $RENN , 1 )
		EndIf
	Next
	$REN = _FILELISTTOARRAYREC ( $PATH , "*" , 0 , 1 , 1 , 2 )
	For $I = 1 To UBound ( $REN ) + 4294967295
		$DES = StringRegExpReplace ( $REN [ $I ] , "(?i)[a-z]:\\FRST\\Quarantine\\([a-z])(\\.+)" , "$1:$2" )
		If Not FileExists ( $DES ) Then
			If StringInStr ( FileGetAttrib ( $REN [ $I ] ) , "D" ) Then
				DirMove ( $REN [ $I ] , $DES , 1 )
			Else
				_SETDEFAULTFILEACCESS ( $REN [ $I ] )
				FileMove ( $REN [ $I ] , $DES , 1 + 8 )
			EndIf
		EndIf
	Next
	$REN = _FILELISTTOARRAYREC ( $PATH , "*" , 0 , 1 , 1 , 2 )
	If IsArray ( $REN ) Then
		_ARRAYDELETE ( $REN , 0 )
		_ARRAYSORT ( $REN , 1 )
		For $I = 0 To UBound ( $REN ) + 4294967295
			DirRemove ( $REN [ $I ] )
		Next
	EndIf
	FileWrite ( $HFIXLOG , $FIX & "=> " & $RESQUA & @CRLF )
EndFunc
Func RESQUAR ( )
	If StringRegExp ( $FIX , "(?i)^Restore\s*Quarantine:$" ) Then Return RESFOL ( $C & "\FRST\Quarantine" )
	$PATH = StringRegExpReplace ( $FIX , "(?i)^Restore\s*Quarantine:\s*(.+)" , "$1" )
	If Not FileExists ( $PATH ) Then Return FileWrite ( $HFIXLOG , """" & $PATH & """=> " & $PAD & " " & $NFOUND & "." & @CRLF )
	If StringInStr ( FileGetAttrib ( $PATH ) , "D" ) Then
		RESFOL ( $PATH )
	Else
		RESFILE ( $PATH )
	EndIf
EndFunc
Func RESTOREFROMHIVEBACKUP ( $HIVE1 )
	Local $RET
	$RET = FileCopy ( $C & "\Windows\System32\config\HiveBackup\" & $HIVE1 , $C & "\Windows\System32\config\" , 1 )
	Select
	Case $RET = 1
		FileWrite ( $HFIXLOG , $HIVE1 & " => " & $COP & " System32\config" & @CRLF )
	Case $RET = 0
		FileWrite ( $HFIXLOG , $HIVE1 & " => " & $NCOPY & @CRLF )
	EndSelect
EndFunc
Func RESTOREFROMREGBACK ( $HIVE1 )
	Local $RET
	$SPATH = "\Windows\System32\config\"
	If FileExists ( $C & $SPATH & $HIVE1 ) Then
		$RET = FileCopy ( $C & $SPATH & $HIVE1 , $C & $SPATH & "\HiveBackup\" , 1 )
		Select
		Case $RET = 1
			FileWrite ( $HFIXLOG , $HIVE1 & " => " & $COP & " System32\config\HiveBackup" & @CRLF )
		Case $RET = 0
			FileWrite ( $HFIXLOG , $HIVE1 & " => " & $NCOPY & @CRLF )
		EndSelect
	Else
		NFOUND ( $C & $SPATH & $HIVE1 )
	EndIf
	If FileExists ( $C & $SPATH & "RegBack\" & $HIVE1 ) Then
		$RET = FileCopy ( $C & $SPATH & "RegBack\" & $HIVE1 , $C & $SPATH , 1 )
		Select
		Case $RET = 1
			FileWrite ( $HFIXLOG , $HIVE1 & " => " & $RESTORED & " " & $RESTORE & @CRLF )
		Case $RET = 0
			FileWrite ( $HFIXLOG , $HIVE1 & " => " & $NRESTORE & " " & $RESTORE & @CRLF )
		EndSelect
	Else
		NFOUND ( $C & $SPATH & "RegBack\" & $HIVE1 )
	EndIf
EndFunc
Func RESTOREHIVE ( )
	$HIVE0 = StringRegExpReplace ( $FIX , "(?i)Restore\s*From\s*Backup:\s*(.+)" , "$1" )
	If $HIVE0 = "SYSTEM" Or $HIVE0 = "SAM" Or $HIVE0 = "SECURITY" Then RunWait ( @ComSpec & " /c reg unload hklm\999" , "" , @SW_HIDE )
	If $HIVE0 = "SOFTWARE" Then RunWait ( @ComSpec & " /c reg unload hklm\888" , "" , @SW_HIDE )
	$REN = FileMove ( "C:\Windows\System32\config\" & $HIVE0 , "C:\Windows\System32\config\" & $HIVE0 & ".old" , 1 )
	If $REN = 1 Then FileWrite ( $HFIXLOG , """" & $HIVE0 & """ =>  " & $REN0 & " (" & $HIVE0 & ".old)" & @CRLF )
	$COPYHIVE = FileCopy ( "C:\FRST\Hives\" & $HIVE0 , "C:\Windows\System32\config" , 1 )
	Select
	Case $COPYHIVE = 1
		FileWrite ( $HFIXLOG , """" & $HIVE0 & """ => " & $RESTORED & @CRLF )
	Case $COPYHIVE = 0
		FileWrite ( $HFIXLOG , """" & $HIVE0 & """ => " & $NRESTORE & @CRLF )
	EndSelect
	If $HIVE0 = "SYSTEM" Or $HIVE0 = "SAM" Or $HIVE0 = "SECURITY" Then RunWait ( @ComSpec & " /c reg load hklm\999 c:\Windows\System32\config\System" , "" , @SW_HIDE )
	If $HIVE0 = "SOFTWARE" Then RunWait ( @ComSpec & " /c reg load hklm\888 c:\Windows\System32\config\SOFTWARE" , "" , @SW_HIDE )
EndFunc
Func RESTOREHIVEBACKUP ( )
	RunWait ( @ComSpec & " /c reg unload hklm\999" , "" , @SW_HIDE )
	RunWait ( @ComSpec & " /c reg unload hklm\888" , "" , @SW_HIDE )
	Local $HIVES [ 5 ] = [ "DEFAULT" , "SAM" , "SECURITY" , "SOFTWARE" , "SYSTEM" ]
	For $I = 0 To UBound ( $HIVES ) + 4294967295
		RESTOREFROMHIVEBACKUP ( $HIVES [ $I ] )
	Next
	RunWait ( @ComSpec & " /c reg load hklm\999 c:\Windows\System32\config\System" & " & reg load hklm\888 c:\Windows\System32\config\software" , "" , @SW_HIDE )
EndFunc
Func RESTOREHIVES ( )
	RunWait ( @ComSpec & " /c reg unload hklm\999" , "" , @SW_HIDE )
	RunWait ( @ComSpec & " /c reg unload hklm\888" , "" , @SW_HIDE )
	DirCreate ( "C:\Windows\System32\config\HiveBackup" )
	Local $HIVES [ 5 ] = [ "DEFAULT" , "SAM" , "SECURITY" , "SOFTWARE" , "SYSTEM" ]
	For $I = 0 To UBound ( $HIVES ) + 4294967295
		RESTOREFROMREGBACK ( $HIVES [ $I ] )
	Next
	RunWait ( @ComSpec & " /c reg load hklm\999 c:\Windows\System32\config\System" & " & reg load hklm\888 c:\Windows\System32\config\software" , "" , @SW_HIDE )
EndFunc
Func RESTOREPOINTCREATE ( )
	$DSPT = DriveSpaceTotal ( $C & "\" ) / 1024
	$DSPT = Round ( $DSPT , 2 )
	$DSPACE = DriveSpaceFree ( $C & "\" ) / 1024
	$DSPACE = Round ( $DSPACE , 2 )
	$PER = Round ( $DSPACE / $DSPT , 2 ) * 100
	If $PER < 10 Then Return SetError ( 1 , 0 , $PER & "%" )
	If $DSPACE < 10 Then Return SetError ( 2 , 0 , $DSPACE & " GB" & @CRLF )
	If $OSNUM < 6 Then
		$KEY = "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SystemRestore"
		If RegRead ( $KEY , "DisableSR" ) = 1 Then DELVALUE ( $KEY , "DisableSR" )
	EndIf
	$KEY = "HKLM\SOFTWARE\Policies\Microsoft\Windows NT\SystemRestore"
	If VAR ( $KEY ) Then DELKEY ( $KEY )
	$OBJ = ObjGet ( "winmgmts:{impersonationLevel=impersonate}!root/default:SystemRestore" )
	If Not IsObj ( $OBJ ) Then Return SetError ( 3 , 0 , "winmgmts" )
	$ENDIS = $OBJ .Enable ( $C & "\" )
	If $ENDIS Then SetError ( 4 , 0 , "SystemRestore: On => " & $ERR0 )
	If $OSNUM >= 6 And Not RegRead ( "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SPP\Clients" , "{09F7EDC5-294E-4180-AF6A-FB0E6A0E9513}" ) Then SetError ( 5 , 0 , $RP3 )
	If VAR ( $KEY ) Then DELKEY ( $KEY )
	_WINAPI_COINITIALIZE ( )
	If @error Then SetError ( 6 , 0 , @extended )
	$STRDESCRIPTION = "Restore Point Created by FRST"
	Local Const $MAX_DESC_W = 256
	Local Const $BEGIN_SYSTEM_CHANGE = 100
	Local Const $END_SYSTEM_CHANGE = 101
	Local Const $MODIFY_SETTINGS = 12
	Local $_RESTOREPTINFO = DllStructCreate ( "DWORD dwEventType;DWORD dwRestorePtType;INT64 llSequenceNumber;WCHAR szDescription[" & $MAX_DESC_W & "]" )
	DllStructSetData ( $_RESTOREPTINFO , "dwEventType" , $BEGIN_SYSTEM_CHANGE )
	DllStructSetData ( $_RESTOREPTINFO , "dwRestorePtType" , $MODIFY_SETTINGS )
	DllStructSetData ( $_RESTOREPTINFO , "llSequenceNumber" , 0 )
	DllStructSetData ( $_RESTOREPTINFO , "szDescription" , $STRDESCRIPTION )
	Local $PRESTOREPTSPEC = DllStructGetPtr ( $_RESTOREPTINFO )
	Local $_SMGRSTATUS = DllStructCreate ( "UINT  nStatus;INT64 llSequenceNumber" )
	Local $PSMGRSTATUS = DllStructGetPtr ( $_SMGRSTATUS )
	Local $ARET = DllCall ( "SrClient.dll" , "BOOL" , "SRSetRestorePointW" , "ptr" , $PRESTOREPTSPEC , "ptr" , $PSMGRSTATUS )
	If @error Or Not $ARET [ 0 ] Then Return SetError ( 7 , 0 , DllStructGetData ( $_SMGRSTATUS , "nStatus" ) )
	DllStructSetData ( $_RESTOREPTINFO , "dwEventType" , $END_SYSTEM_CHANGE )
	Local $ARET = DllCall ( "SrClient.dll" , "BOOL" , "SRSetRestorePointW" , "ptr" , $PRESTOREPTSPEC , "ptr" , $PSMGRSTATUS )
	If @error Or Not $ARET [ 0 ] Then Return SetError ( 8 , 0 , DllStructGetData ( $_SMGRSTATUS , "nStatus" ) )
EndFunc
Func RESTOREPOINTS ( )
	GUICtrlSetData ( $LABEL1 , $SCANB & " " & $RP1 )
	FileWrite ( $HADDITION , @CRLF & "==================== " & $RP1 & " =========================" & @CRLF & @CRLF )
	$SROFF = False
	If Not RegRead ( "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SPP\Clients" , "{09F7EDC5-294E-4180-AF6A-FB0E6A0E9513}" ) Then $SROFF = True
	If $SROFF Then
		$DSPT = DriveSpaceTotal ( $C & "\" ) / 1024
		$DSPT = Round ( $DSPT , 2 )
		$DSPACE = DriveSpaceFree ( $C & "\" ) / 1024
		$DSPACE = Round ( $DSPACE , 2 )
		$PER = Round ( $DSPACE / $DSPT , 2 ) * 100
		FileWrite ( $HADDITION , $UPD1 & ": " & $RP3 & " (Total:" & $DSPT & " GB) (Free:" & $DSPACE & " GB) (" & $PER & "%)" & @CRLF )
	EndIf
	Local $OBJWMISERVICE = ObjGet ( "winmgmts:root/default" )
	If Not IsObj ( $OBJWMISERVICE ) Then Return FileWrite ( $HADDITION , $RP2 & @CRLF )
	Local $DEVCOLITEMS = $OBJWMISERVICE .InstancesOf ( "SystemRestore" )
	If Not IsObj ( $DEVCOLITEMS ) Then Return FileWrite ( $HADDITION , $RP2 & @CRLF )
	$COMERR1 = 3
	For $OBJECT In $DEVCOLITEMS
		$NAME = $OBJECT .description
		$DATE = $OBJECT .CreationTime
		If $NAME <> "" Then
			$DATE = StringRegExpReplace ( $DATE , "(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2}).+" , "$2,$3,$1,$4,$5,$6" )
			$ARRT = StringSplit ( $DATE , "," )
			If IsArray ( $ARRT ) Then $DATE = _DATE_TIME_ENCODEFILETIME ( $ARRT [ 1 ] , $ARRT [ 2 ] , $ARRT [ 3 ] , $ARRT [ 4 ] , $ARRT [ 5 ] , $ARRT [ 6 ] )
			$DATE = _DATE_TIME_FILETIMETOLOCALFILETIME ( $DATE )
			$ARR = _DATE_TIME_FILETIMETOARRAY ( $DATE )
			For $R = 0 To UBound ( $ARR ) + 4294967295
				If $ARR [ $R ] < 10 Then $ARR [ $R ] = "0" & $ARR [ $R ]
			Next
			FileWrite ( $HADDITION , $ARR [ 1 ] & "-" & $ARR [ 0 ] & "-" & $ARR [ 2 ] & " " & $ARR [ 3 ] & ":" & $ARR [ 4 ] & ":" & $ARR [ 5 ] & " " & $NAME & @CRLF )
			$COMERR = ""
		EndIf
	Next
EndFunc
Func RESTOREVAL ( $KEY , $VAL , $VTYPE , $VDATA )
	$AKEY = _RMTON ( $KEY )
	$RET = RegWrite ( $KEY , $VAL , $VTYPE , $VDATA )
	If $VAL = "" Then $VAL = "Default"
	If $RET = 1 Then Return FileWrite ( $HFIXLOG , $AKEY & "\\""" & $VAL & """=""" & StringRegExpReplace ( $VDATA , "\v" , " " ) & """ => " & $VAL0 & " " & $RESTORED & @CRLF )
	_CHECKKEYPERMS ( $KEY )
	$RET = RegWrite ( $KEY , $VAL , $VTYPE , $VDATA )
	Select
	Case $RET = 1
		FileWrite ( $HFIXLOG , $AKEY & "\\""" & $VAL & """=""" & StringRegExpReplace ( $VDATA , "\v" , " " ) & """ => " & $VAL0 & " " & $RESTORED & @CRLF )
	Case $RET = 0
		FileWrite ( $HFIXLOG , $AKEY & "\\" & $VAL & " => " & $ERRSV & @CRLF )
	EndSelect
EndFunc
Func RESULT ( $PATH , $I = 1 )
	If $I Then Return FileWrite ( $HFIXLOG , """" & $PATH & """" & " => " & $UNLOCK & @CRLF )
	FileWrite ( $HFIXLOG , """" & $PATH & """" & " => " & $NUNLOCK & @CRLF )
EndFunc
Func RP ( )
	Local $AARRAY1 [ 1 ]
	FileWrite ( $FRSTLOG , @CRLF & "==================== " & $RP1 & "  =========================" & @CRLF & @CRLF )
	$AARRAY = _FILELISTTOARRAYREC ( $C & "\System Volume Information" , "{*}{*}" , 1 , 1 , 0 , 2 )
	For $I = 1 To UBound ( $AARRAY ) + 4294967295
		$DATECR = FILETIME ( $FILE )
		_ARRAYADD ( $AARRAY1 , $RESD0 & ": " & FILETIME ( $AARRAY [ $I ] ) , 0 , "||||" )
	Next
	_ARRAYDELETE ( $AARRAY1 , 0 )
	_ARRAYSORT ( $AARRAY1 )
	_FILEWRITEFROMARRAY ( $FRSTLOG , $AARRAY1 )
EndFunc
Func RUNKEY ( $RUN , $WOW = "" )
	Local $ARRAYNAME , $NAME
	$MKEY = "HKLM\"
	$WOW64 = ""
	If $WOW Then
		$MKEY = "HKLM-x32\"
		$WOW64 = "\WOW6432Node"
	EndIf
	$FULLKEY = "HKLM\" & $SOFTWARE & $WOW64 & "\Microsoft\Windows\CurrentVersion\" & $RUN
	GUICtrlSetData ( $LABEL1 , $REGIST1 & ": " & $FULLKEY )
	$HKEY = _REGOPENKEYEX3 ( $FULLKEY )
	If @error Or $HKEY = 0 Then Return 1
	$ARRAYNAME = _LISTVAL ( $HKEY )
	For $V = 0 To UBound ( $ARRAYNAME ) + 4294967295
		$ATTEN = ""
		$VALNAME = $ARRAYNAME [ $V ] [ 0 ]
		$FILE = $ARRAYNAME [ $V ] [ 1 ]
		If StringInStr ( $ARRAYNAME [ $V ] [ 1 ] , $VALNAME ) And StringRegExp ( $ARRAYNAME [ $V ] [ 1 ] , "(?i)\\App" ) And StringRegExp ( $ARRAYNAME [ $V ] [ 1 ] , "(?i)(REGSVR|rundll)" ) Then $ATTEN = " <==== " & $UPD1
		If StringInStr ( $ARRAYNAME [ $V ] [ 1 ] , "\Temp\" ) And Not StringInStr ( $ARRAYNAME [ $V ] [ 1 ] , "\spool\" ) Then $ATTEN = " <==== " & $UPD1
		If StringRegExp ( $VALNAME , "(?i)^(audiodg|WindowsUpdate|spoolsv|uerinit|explorer|iexplore|System|regdrv|taskhost|Isass|smss|csrss|wininit|services|lsass|lsm|winlogon|.*svchost.*|dwm|msdtc|VSSVC|alg|sihost|dllhost|cmd|msedge|conhost|fontdrvhost|SystemSettingsBroker|SystemSettings|SearchIndexer)(|\.exe)$" ) Then $ATTEN = " <==== " & $UPD1
		If StringRegExp ( $ARRAYNAME [ $V ] [ 1 ] , "(?i)\\(WmiPrvSE|audiodg|spoolsv|uerinit|explorer|iexplore|System|regdrv|taskhost|Isass|smss|csrss|wininit|services|lsass|lsm|winlogon|svchost|dwm|msdtc|VSSVC|alg|sihost|dllhost|taskhostw)\.(exe|vbs|bat)|ntuserlitelist|/e:VBScript.Encode|\.\.vbs|\\hola\\|Roaming\\vnlgp\\|\\sunnyday|\\BestCleaner|\\MyMemory|\\DPower|Max Driver Updater|(:\\Windows|%SystemRoot%)\\servicing\\(?!TrustedInstaller)[^\\]+\.exe|ProgramData\\Synaptics|\\PCAcceleratePro|\\InstantSupport|\\SQLAGENTIHC.exe|\\winnet\.exe|\\winsvc\.exe" ) Then $ATTEN = " <==== " & $UPD1
		If StringRegExp ( $VALNAME , "(?i)^(ProAccelerationOfPC|Svc host|uupdate|WifiAudio|NCH Sync Service|Lenovo.Modern.ImController|WmiPrvSE|BrowzarBrowser.*|system recover|Restoro|WAN Service|DiskFixer|AnonymizerGadget|VLC Update|Multitimer|updater|CloudNet|svcvmx|system_jconsole.jar|gplyra|\w{4}PRODUCT_(\w{5}|)|WebDiscoverBrowser|start\d*|WebBar Toolbar|bestDownloader|cleanComputerNew|VolID|firefox|ShutdownTime)$" ) Then $ATTEN = " <==== " & $UPD1
		If StringInStr ( $VALNAME , "<*>" ) Then
			$LRCHAR = " **"
			$LRCHAR = StringRegExp ( $LRCHAR , "\*(.)\*" , 3 )
			If IsArray ( $LRCHAR ) Then $LRCHAR = $LRCHAR [ 0 ]
			$FILE = StringRegExpReplace ( $FILE , $LRCHAR , "" )
			$ATTEN = " <==== " & $UPD1 & " (" & $REGIST4 & ")"
		Else
			If $WOW Then
				AAAAFPWOW ( )
			Else
				AAAAFP ( )
			EndIf
		EndIf
		If FileExists ( $FILE ) Then
			If StringRegExp ( $FILE , "\\\w{6}~\d\\" ) Then $FILE = FileGetLongName ( $FILE )
			If $SIZE > 314572800 And StringInStr ( $COMPANY , "[" ) Then $ATTEN = " <==== " & $UPD1
			If _CREATEFILE ( $FILE ) Then $ATTEN = " (" & $NOACC & ") <==== " & $UPD1
			If StringRegExp ( $COMPANY , "\(\) \[[^]]+\] \[[^]]+\]" ) Then $ATTEN = " <==== " & $UPD1
			If StringRegExp ( $ARRAYNAME [ $V ] [ 1 ] , "(?i)\b(msiexec|wscript|cmd)\b|(iexplore|firefox|chrome|MicrosoftEdge|opera|msedge|mshta)\.exe" ) Then $FILE = $ARRAYNAME [ $V ] [ 1 ]
			_ARRAYADD ( $ARRAYREG , $MKEY & "...\" & $RUN & ": [" & $VALNAME & "] => " & $FILE & " [" & $SIZE & " " & $CDATE & "]" & $COMPANY & $ATTEN , 0 , "||||" )
		Else
			$NOFILE = ""
			If $ARRAYNAME [ $V ] [ 1 ] = "" Or StringRegExp ( $ARRAYNAME [ $V ] [ 1 ] , "\A[ ]+\Z" ) Then
				$ARRAYNAME [ $V ] [ 1 ] &= "[X]"
			Else
				$NOFILE = " (" & $REGIST8 & ")"
				If StringRegExp ( $ARRAYNAME [ $V ] [ 1 ] , "(?i)\b(shutdown|wevtutil|vssadmin|wmic|REGSVR|regsvr32|Regsvcs|RegAsm|regedt32|regedit|rundll32|wscript|cscript|javaw|cmd|powershell|reg)\b.+.:\\|.:\\.+.:\\" ) Then
					$FILE = StringRegExpReplace ( $ARRAYNAME [ $V ] [ 1 ] , ".+(.:\\.)" , "$1" )
					If $WOW Then
						AAAAFPWOW ( )
					Else
						AAAAFP ( )
					EndIf
					If FileExists ( $FILE ) Then $NOFILE = " [" & $SIZE & " " & $CDATE & "]" & $COMPANY
				EndIf
			EndIf
			_ARRAYADD ( $ARRAYREG , $MKEY & "...\" & $RUN & ": [" & $VALNAME & "] => " & $ARRAYNAME [ $V ] [ 1 ] & $NOFILE & $ATTEN , 0 , "||||" )
		EndIf
	Next
	$ARRAYNAME = ""
	If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
	If $RUN <> "Run" Then Return
	$FULLKEY = _HKEYTRANS ( $FULLKEY )
	INVALIDSUBKEY ( $FULLKEY , $NAME )
	If $NAME <> "" Then _ARRAYADD ( $ARRAYREG , "InvalidSubkeyName: [HKLM\" & $SOFTWARE & $WOW64 & "\Microsoft\Windows\CurrentVersion\Run\" & $NAME & "] <==== " & $UPD1 , 0 , "||||" )
EndFunc
Func RUNKEYEX ( $VER32 = 0 , $HI = "HKLM" )
	Local $ARRAYNAME , $HKEY1
	$KEY = "HKLM\" & $SOFTWARE & "\Microsoft\Windows\CurrentVersion\RunOnceEx"
	If $VER32 Then
		$KEY = "HKLM\" & $SOFTWARE & "\Wow6432Node\Microsoft\Windows\CurrentVersion\RunOnceEx"
		$HI = "HKLM-x32"
	EndIf
	$HKEY = _REGOPENKEYEX3 ( $KEY )
	If @error Or $HKEY = 0 Then Return
	$W = 0
	While 1
		$SKEY = __REGENUMKEY ( $HKEY , $W )
		If @error Then ExitLoop
		$HKEY1 = _REGOPENKEYEX3 ( $KEY & "\" & $SKEY )
		If Not @error And IsPtr ( $HKEY1 ) Then $ARRAYNAME = _LISTVAL ( $HKEY1 )
		If UBound ( $ARRAYNAME ) > 0 Then
			For $V = 0 To UBound ( $ARRAYNAME ) + 4294967295
				$VALNAME = $ARRAYNAME [ $V ] [ 0 ]
				$VALDATA = $ARRAYNAME [ $V ] [ 1 ]
				$ATT = ""
				If StringInStr ( $VALDATA , "\Temp\" ) Then $ATT = " <==== " & $UPD1
				_ARRAYADD ( $ARRAYREG , $HI & "\...\RunOnceEx\" & $SKEY & ": [" & $VALNAME & "] => " & $VALDATA & $ATT , 0 , "$$&&" )
			Next
		EndIf
		$W += 1
	WEnd
	If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
	_REGCLOSE ( $HKEY1 )
EndFunc
Func SAFEBOOT ( )
	FileWrite ( $HADDITION , @CRLF & "==================== " & $SAFEB2 & " (" & $WLISTED & ") ==================" & @CRLF )
	GUICtrlSetData ( $LABEL1 , $REGIST1 & ": " & $SAFEB2 )
	$KEY = "HKLM\SYSTEM\CurrentControlSet\Control\SafeBoot"
	SAFEBOOT1 ( $KEY )
	$READVAL = RegRead ( $KEY , "AlternateShell" )
	If $READVAL <> "cmd.exe" Then _ARRAYADD ( $ARRSAFE , $KEY & " => ""AlternateShell""=""" & $READVAL & """" , 0 , "||||" )
	SAFEBOOT1 ( $KEY & "\Minimal" )
	SAFEBOOT1 ( $KEY & "\Network" )
	ENUMSAFE ( $KEY )
	If UBound ( $ARRSAFE ) > 1 Then
		FileWrite ( $HADDITION , @CRLF & "(" & $SERV1 & " " & $ALTSH & ".)" & @CRLF & @CRLF )
		_FILEWRITEFROMARRAY ( $HADDITION , $ARRSAFE , 1 )
	EndIf
	$ARRSAFE = ""
EndFunc
Func SAFEBOOT1 ( $KEY )
	$READVAL = RegRead ( $KEY , "" )
	If @error = 1 Then
		Return FileWrite ( $HADDITION , """" & $KEY & """" & " " & $SAFEB1 & @CRLF )
	Else
		If $READVAL Then _ARRAYADD ( $ARRSAFE , $KEY & " => """"=""" & $READVAL & """" , 0 , "||||" )
	EndIf
EndFunc
Func SAFEBOOTFIX ( )
	If StringInStr ( $FIX , "SafeBoot =>" ) Then
		RESTOREVAL ( "HKLM\" & $SYSTEM & $BOOTSYSTEM & $DEF & "\Control\SafeBoot" , "" , "REG_SZ" , "" )
		RESTOREVAL ( "HKLM\" & $SYSTEM & $BOOTSYSTEM & $DEF & "\Control\SafeBoot" , "AlternateShell" , "REG_SZ" , "cmd.exe" )
	EndIf
	If StringInStr ( $FIX , "Minimal => """"=" ) Then
		RESTOREVAL ( "HKLM\" & $SYSTEM & $BOOTSYSTEM & $DEF & "\Control\SafeBoot\Minimal" , "" , "REG_SZ" , "" )
	EndIf
	If StringInStr ( $FIX , "Network => """"=" ) Then
		RESTOREVAL ( "HKLM\" & $SYSTEM & $BOOTSYSTEM & $DEF & "\Control\SafeBoot\Network" , "" , "REG_SZ" , "" )
	EndIf
	If StringInStr ( $FIX , "\Minimal\" ) Then
		$SUBKEY = StringRegExpReplace ( $FIX , "(?i).+\\Minimal\\(.+) =>.*" , "$1" )
		$KEY = "HKLM\" & $SYSTEM & $BOOTSYSTEM & $DEF & "\Control\SafeBoot\Minimal\" & $SUBKEY
		DELKEY ( $KEY )
	EndIf
	If StringInStr ( $FIX , "\Network\" ) Then
		$SUBKEY = StringRegExpReplace ( $FIX , "(?i).+\\Network\\(.+) =>.*" , "$1" )
		$KEY = "HKLM\" & $SYSTEM & $BOOTSYSTEM & $DEF & "\Control\SafeBoot\Network\" & $SUBKEY
		DELKEY ( $KEY )
	EndIf
EndFunc
Func SAVEMBR ( $SFILENAME )
	Local $NBYTESRECEIVED
	$ICREATION = 2
	$IACCESS = 2
	$ISHARE = 2 + 4
	$HFILE = _WINAPI_CREATEFILE ( $SFILENAME , $ICREATION , $IACCESS , $ISHARE )
	If Not @error And Not $HFILE = Ptr ( 0 ) Then
		$TBUFFER = DllStructCreate ( "byte[512]" )
		_WINAPI_READFILE ( $HFILE , DllStructGetPtr ( $TBUFFER , 1 ) , 512 , $NBYTESRECEIVED )
		If @error Then
			MsgBox ( 262144 + 0 , "Error: _WinAPI_ReadFile" , StringFormat ( "Could not read file. (Error %d)\n" , @error ) )
		EndIf
		If $NBYTESRECEIVED < 512 Then
			MsgBox ( 262144 + 0 , "Error: _WinAPI_ReadFile" , StringFormat ( "Only %d bytes read.\n" , $NBYTESRECEIVED ) )
		Else
			Return ( DllStructGetData ( $TBUFFER , 1 ) )
		EndIf
	EndIf
EndFunc
Func SCRASS ( ByRef $ARR )
	$RUN1 = RegRead ( "HKLM\software\Classes\.scr" , "" )
	If $RUN1 <> "scrfile" Then
		$RET = RegRead ( "HKLM\software\Classes\" & $RUN1 & "\shell\open\command" , "" )
		$ATTEN = " <==== " & $UPD1
		If StringInStr ( $RUN1 , "CryptoPreventSCR" ) Then $ATTEN = ""
		_ARRAYADD ( $ARR , "HKLM\...\.scr: " & $RUN1 & " => " & $RET & $ATTEN , 0 , "|||" )
	EndIf
	$RUN1 = RegRead ( "HKLM\software\Classes\scrfile\shell\open\command" , "" )
	If $RUN1 <> """%1"" /S" Then _ARRAYADD ( $ARR , "HKLM\...\scrfile\shell\open\command: " & $RUN1 & " <==== " & $UPD1 , 0 , "|||" )
EndFunc
Func SCRNSAVE ( )
	$USER = StringRegExpReplace ( $FIX , "(?i)HKU\\(.+?)\\.+" , "$1" )
	RELOAD ( $USER )
	$KEY = "HKU\" & $USER & "\Control Panel\Desktop"
	If $OSNUM < 6.1 Then
		$PATH = $C & "\WINDOWS\system32\logon.scr"
		If $USER = "S-1-5-18" Then $PATH = $C & "\WINDOWS\sysWOW64\logon.scr"
		RESTOREVAL ( $KEY , "SCRNSAVE.EXE" , "REG_SZ" , $PATH )
	Else
		DELVALUE ( $KEY , "SCRNSAVE.EXE" )
	EndIf
	REUNLOAD ( $USER )
EndFunc
Func SDELETE ( )
	MsgBox ( 262144 + 0 , $FRST , "FRST " & $DELETED & @CRLF & @CRLF & $REBOOT2 & @CRLF & $REBOOT3 )
	$RAND = Random ( 100 , 999 , 1 )
	FileMove ( @ScriptDir & "\" & @ScriptName , @TempDir & "\FRST" & $RAND & ".TEMP" , 1 )
	If FileExists ( $C & "\frst" ) Then RegWrite ( "HKLM\Software\Microsoft\Windows\CurrentVersion\RunOnce" , "*Removed" , "REG_SZ" , "cmd /c rd /q/s " & $C & "\frst" )
	RegWrite ( "HKLM\Software\Microsoft\Windows\CurrentVersion\RunOnce" , "*DelTemp" , "REG_SZ" , "cmd /c DEL /F /Q /A """ & @TempDir & "\FRST" & $RAND & ".TEMP""" )
	Shutdown ( 6 )
	Exit
EndFunc
Func SDELETE1 ( )
	Dim $PATH1 , $SUBFOLDERS
	$FILEARRAY = _FILELISTTOARRAY ( @ScriptDir , "*.txt" , 1 , True )
	For $I = 1 To UBound ( $FILEARRAY ) + 4294967295
		If StringRegExp ( $FILEARRAY [ $I ] , "(?i)\\(frst|addition|fixlog|search|fixlist|Shortcut).*\.txt$" ) Then
			FileDelete ( $FILEARRAY [ $I ] )
			If FileExists ( $FILEARRAY [ $I ] ) Then MOVEFILEONREBOOT ( $FILEARRAY [ $I ] , "" )
		EndIf
	Next
	DirRemove ( @ScriptDir & "\FRST-OlderVersion" , 1 )
	$PATH = $C & "\frst"
	DirRemove ( $PATH , 1 )
	If Not FileExists ( $PATH ) Then Return SDELETE ( )
	$SUBFOLDERS = _GETALLSUBFOLDERSSHORT ( $PATH )
	If IsArray ( $SUBFOLDERS ) Then
		_ARRAYREVERSE ( $SUBFOLDERS , 1 )
		For $E = 1 To UBound ( $SUBFOLDERS ) + 4294967295
			DirRemove ( $SUBFOLDERS [ $E ] , 1 )
		Next
	EndIf
	$SUBFOLDERS = ""
	If Not FileExists ( $PATH ) Then Return SDELETE ( )
	If FILEACCN ( $PATH ) Then _GRANTE ( $PATH , 1 , 0 )
	$SUBFOLDERS = _GETALLSUBFOLDERSSHORT ( $PATH )
	If IsArray ( $SUBFOLDERS ) Then
		_ARRAYREVERSE ( $SUBFOLDERS , 1 )
		For $E = 1 To UBound ( $SUBFOLDERS ) + 4294967295
			_DIRREMOVE ( $SUBFOLDERS [ $E ] )
			If FileExists ( $SUBFOLDERS [ $E ] ) And _BBBBKP ( $SUBFOLDERS [ $E ] ) Then _DIRREMOVE ( $SUBFOLDERS [ $E ] )
		Next
	EndIf
	$AARREST = _FILELISTTOARRAYREC ( $PATH , "*" , 1 + 16 , 1 , 1 , 2 )
	If UBound ( $AARREST ) > 1 Then
		For $E = 1 To UBound ( $AARREST ) + 4294967295
			If $PATH & "\" & StringRegExpReplace ( $AARREST [ $E ] , ".+\\" , "" ) = $AARREST [ $E ] Then _FILEDELETE ( $AARREST [ $E ] )
			If FileExists ( $AARREST [ $E ] ) Then
				MOVEFILEONREBOOT ( $AARREST [ $E ] , "" )
			EndIf
		Next
	EndIf
	$RET = DirRemove ( $PATH , 1 )
	If Not $RET Then _BBBBDR ( $PATH )
	If FileExists ( $PATH ) Then MOVEFILEONREBOOT ( $PATH , "" )
	If FileExists ( $PATH ) Then RunWait ( @ComSpec & " /c " & "rd /s/q " & $PATH , "" , @SW_HIDE )
	SDELETE ( )
EndFunc
Func SEARCHBUTT ( )
	GUICtrlSetData ( $LABEL1 , $SEARCH0 & ", " & $PW0 )
	GUICtrlSetData ( $BUTTONSEARCH , $SEARCH1 & "..." )
	GUICtrlSetState ( $BUTTONSEARCH , 128 )
	$PROGRESS = GUICtrlCreateProgress ( 70 , 90 , 433 , 15 , 8 , 8192 )
	GUICtrlSendMsg ( $PROGRESS , 1034 , 1 , 50 )
	$HSERACH = FileOpen ( @ScriptDir & "\Search.txt" , 256 + 2 )
	$VAL = StringRegExpReplace ( $FIX , "^\s+|\s+$" , "" )
	$CDATE = DATE ( )
	FileWrite ( $HSERACH , "Farbar Recovery Scan Tool" & $VERSION & @CRLF & $SCAN11 & " " & @UserName & " (" & $CDATE & ")" & @CRLF & $SCAN13 & " " & @ScriptDir & @CRLF & $SCAN15 & ": " & $BOOTM & @CRLF & @CRLF & "================== " & $SEARCHBES & ": """ & $VAL & """ =============" & @CRLF & @CRLF )
	FileClose ( $HSERACH )
	Select
	Case StringInStr ( $FIX , "SearchAll:" )
		FILESEARCHALL ( )
	Case StringInStr ( $FIX , "FindFolder:" )
		$SEARCH = StringRegExpReplace ( $FIX , "(?i)FindFolder:\s*(.+)" , "$1" )
		FILESEARCHFOL ( $SEARCH )
Case Else
		FILESEARCH ( $VAL )
	EndSelect
	Sleep ( 1000 )
	GUICtrlDelete ( $PROGRESS )
	GUICtrlSetData ( $LABEL1 , $SEARCHB & " " & $DONE )
	GUICtrlSetData ( $BUTTONSEARCH , $SEARCHBES )
	MsgBox ( 262144 + 0 , $FRST , $SEARCHBES & " " & $DONE & ". ""Search.txt"" " & $COMPLETED )
	GUICtrlSetData ( $LABEL1 , "" )
	GUICtrlSetState ( $BUTTONSEARCH , 64 )
	FileWrite ( @ScriptDir & "\Search.txt" , @CRLF & "====== " & $END & " " & $OF & " " & $SEARCHB & " ======" )
	Run ( "notepad """ & @ScriptDir & "\Search.txt""" )
EndFunc
Func SEARCHREGBUTT ( )
	$SEARCH = GUICtrlRead ( $EDIT )
	$SEARCH = StringRegExpReplace ( $SEARCH , @CRLF , "" )
	$SEARCH = StringRegExpReplace ( $SEARCH , "(^[ ]+|[ ]+$)" , "" )
	If $SEARCH = "" Then Return MsgBox ( 262144 + 0 , "FRST64" , $SEARCH2 )
	GUICtrlSetData ( $LABEL1 , $SEARCH0 & ", " & $SEARCH3 & "  " & $PW0 & " ..." )
	GUICtrlSetData ( $BUTTONSEARCHREG , $SEARCH1 & "..." )
	GUICtrlSetState ( $BUTTONSEARCHREG , 128 )
	$PROGRESS = GUICtrlCreateProgress ( 70 , 90 , 433 , 15 , 8 , 8192 )
	GUICtrlSendMsg ( $PROGRESS , 1034 , 1 , 50 )
	$SEARCH = GUICtrlRead ( $EDIT )
	$SEARCH = StringRegExpReplace ( $SEARCH , @CRLF , "" )
	$SEARCH = StringRegExpReplace ( $SEARCH , "(^\s+|\s+$)" , "" )
	$SEARCH = StringRegExpReplace ( $SEARCH , "(^\*+|\*+$)" , "" )
	$SEARCH = StringRegExpReplace ( $SEARCH , "(^\?+|\?+$)" , "" )
	$SEARCH = StringRegExpReplace ( $SEARCH , "(^;|;$)" , "" )
	$SEARCH = StringRegExpReplace ( $SEARCH , "(\*;\*|\*;|;\*)" , ";" )
	If IsAdmin ( ) Then
		$ADMIN = " (" & $ADMINIS & ")"
	Else
		$ADMIN = ""
	EndIf
	$REGREAD = SEARCHREGE ( $SEARCH )
	$HREGSEARCH = FileOpen ( @ScriptDir & "\SearchReg.txt" , 2 + 256 )
	$CDATE = DATE ( )
	FileWrite ( $HREGSEARCH , "Farbar Recovery Scan Tool" & $VERSION & @CRLF & $SCAN11 & " " & @UserName & " (" & $CDATE & ")" & @CRLF & $SCAN13 & " " & @ScriptDir & @CRLF & $SCAN15 & ": " & $BOOTM & @CRLF & @CRLF & "================== " & $SEARCHREG & ": """ & $SEARCH & """ ===========" & @CRLF & @CRLF )
	If StringInStr ( $SEARCH , ";" ) Then
		$REGREAD = StringRegExpReplace ( $REGREAD , "(?m)^\[HK" , "[[[[[HK" )
		$REGREAD = $REGREAD & "[[[["
		$ARR = StringSplit ( $SEARCH , ";" , 2 )
		For $I = 0 To UBound ( $ARR ) + 4294967295
			FileWrite ( $HREGSEARCH , @CRLF & "===================== " & $SEARCH4 & " """ & $ARR [ $I ] & """ ==========" & @CRLF & @CRLF )
			$REGEXSERCH = StringRegExp ( $REGREAD , "(?is)(\[hk(?:.(?!\[hk))+?" & $ARR [ $I ] & ".+?)(?:\[\[\[\[)" , 3 )
			If IsArray ( $REGEXSERCH ) Then
				_FILEWRITEFROMARRAY ( $HREGSEARCH , $REGEXSERCH )
			EndIf
		Next
	Else
		FileWrite ( $HREGSEARCH , $REGREAD & @CRLF )
	EndIf
	FileWrite ( $HREGSEARCH , "====== " & $END & " " & $OF & " " & $SEARCHB & " ======" )
	FileClose ( $HREGSEARCH )
	GUICtrlDelete ( $PROGRESS )
	GUICtrlSetData ( $LABEL1 , $SEARCHB & " " & $DONE & "." )
	GUICtrlSetData ( $BUTTONSEARCHREG , $SEARCHREG )
	MsgBox ( 262144 + 0 , $FRST , $SEARCHB & " " & $DONE & ". " & """SearchReg.txt"" " & $COMPLETED )
	GUICtrlSetData ( $LABEL1 , "" )
	GUICtrlSetState ( $BUTTONSEARCHREG , 64 )
	Run ( "notepad """ & @ScriptDir & "\SearchReg.txt""" )
EndFunc
Func SEARCHREGE ( $SEARCHVAL )
	If $BOOTM = "recovery" Then Return
	Global $ARRREG [ 1 ]
	$ARRSEARCH = StringSplit ( $SEARCHVAL , ";" )
	SEARCHREGK ( "HKEY_LOCAL_MACHINE" , $ARRSEARCH )
	SEARCHREGK ( "HKEY_USERS" , $ARRSEARCH )
	$HSEARCH = FileOpen ( $C & "\frst\Search" , 2 + 256 )
	If UBound ( $ARRREG ) > 1 Then
		$ARRREG = _ARRAYUNIQUE ( $ARRREG , 0 , 0 , 0 , 0 , 1 )
		_FILEWRITEFROMARRAY ( $HSEARCH , $ARRREG , 1 )
	EndIf
	FileClose ( $HSEARCH )
	$HSEARCH = FileOpen ( $C & "\frst\Search" , 256 )
	$REGREAD = FileRead ( $HSEARCH )
	FileClose ( $HSEARCH )
	FileDelete ( $C & "\frst\Search" )
	Return $REGREAD
EndFunc
Func SEARCHREGK ( $STARTKEY , $ARR )
	Local $VAL , $I , $KEY , $Z
	$HKEY = _REGOPENKEYEX3 ( $STARTKEY )
	$I = + 4294967295
	While 1
		$I = $I + 1
		$KEY = __REGENUMKEY ( $HKEY , $I )
		If @error Then ExitLoop
		If StringRegExp ( $STARTKEY & "\" & $KEY , "(?i)^HKEY_LOCAL_MACHINE\\.+\\WOW6432Node\\(Classes|Clients|Policies|RegisteredApplications|AppId|PROTOCOLS|Typelib)|^HKEY_LOCAL_MACHINE\\.+\\ControlSet\d+|^HKEY_USERS\\([^\\]+_Classes|S-1-5-18)" ) Then ContinueLoop
		For $S = 1 To UBound ( $ARR ) + 4294967295
			If StringInStr ( $KEY , $ARR [ $S ] ) Then _ARRAYADD ( $ARRREG , "[" & $STARTKEY & "\" & $KEY & "]" , 0 , "||||" )
		Next
		$Z = 1
		While 1
			$VAL = RegEnumVal ( $STARTKEY & "\" & $KEY , $Z )
			If @error Then ExitLoop
			For $S = 1 To UBound ( $ARR ) + 4294967295
				If StringInStr ( $VAL , $ARR [ $S ] ) Then
					$READVAL = RegRead ( $STARTKEY & "\" & $KEY , $VAL )
					_ARRAYADD ( $ARRREG , "[" & $STARTKEY & "\" & $KEY & "]" & @CRLF & """" & $VAL & """=""" & $READVAL & """" , 0 , "||||" )
				Else
					$READVAL = RegRead ( $STARTKEY & "\" & $KEY , $VAL )
					If $READVAL <> "" And StringInStr ( $READVAL , $ARR [ $S ] ) Then
						_ARRAYADD ( $ARRREG , "[" & $STARTKEY & "\" & $KEY & "]" & @CRLF & """" & $VAL & """=""" & $READVAL & """" , 0 , "||||" )
					EndIf
				EndIf
			Next
			$Z = $Z + 1
		WEnd
		SEARCHREGK ( $STARTKEY & "\" & $KEY , $ARR )
	WEnd
	If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
EndFunc
Func SEARCHSCOPE ( $KEY , $SHIVE )
	Local $VALDATAD , $VALDATAURL , $SUBKEY , $ARRAYNAME
	GUICtrlSetData ( $LABEL1 , $SCANB & " Internet: " & $KEY )
	$VALDATAD = RegRead ( $KEY , "DefaultScope" )
	Select
	Case @error
		If $SHIVE = "HKLM" Or $SHIVE = "HKLM-x32" Then FileWrite ( $HADDITION , "SearchScopes: " & $SHIVE & " -> DefaultScope " & $INTERNET4 & @CRLF )
	Case Not @error And StringRegExp ( $VALDATAD , "^\s*$" )
		If $SHIVE = "HKLM" Or $SHIVE = "HKLM-x32" Then FileWrite ( $HADDITION , "SearchScopes: " & $SHIVE & " -> DefaultScope " & $INTERNET4 & @CRLF )
	Case Not @error And $VALDATAD <> ""
		$VALDATAURL = RegRead ( $KEY & "\" & $VALDATAD , "URL" )
		$VALDATAURL = StringRegExpReplace ( $VALDATAURL , "(?i)http(s|):" , "hxxp\1:" )
		If GUICtrlRead ( $CHECKBOX11 ) = 1 Then
			If Not StringRegExp ( $VALDATAURL , "(?i)hxxp(|s)://www.(bing|google|search.live).com/" ) Then FileWrite ( $HADDITION , "SearchScopes: " & $SHIVE & " -> DefaultScope " & $VALDATAD & " URL = " & $VALDATAURL & @CRLF )
		Else
			FileWrite ( $HADDITION , "SearchScopes: " & $SHIVE & " -> DefaultScope " & $VALDATAD & " URL = " & $VALDATAURL & @CRLF )
		EndIf
	EndSelect
	$HKEY = _REGOPENKEYEX3 ( $KEY )
	If Not @error And IsPtr ( $HKEY ) Then $ARRAYNAME = _LISTVAL ( $HKEY )
	If UBound ( $ARRAYNAME ) > 0 Then
		For $V = 0 To UBound ( $ARRAYNAME ) + 4294967295
			$VALNAME = $ARRAYNAME [ $V ] [ 0 ]
			$VALDATA = $ARRAYNAME [ $V ] [ 1 ]
			If StringRegExp ( $VALDATA , "\{.+\}" ) And $VALNAME <> "DefaultScope" Then
				$VALDATA = StringRegExpReplace ( $VALDATA , "(?i)http(s|):" , "hxxp\1:" )
				FileWrite ( $HADDITION , "SearchScopes: " & $SHIVE & " -> " & $VALNAME & " " & $VALDATA & @CRLF )
				ExitLoop
			EndIf
		Next
	EndIf
	$HKEY = _REGOPENKEYEX3 ( $KEY )
	$I = 0
	While 1
		$VALDATAURL = ""
		$SUBKEY = ""
		$SUBKEY = __REGENUMKEY ( $HKEY , $I )
		If @error Then ExitLoop
		$VALDATAURL = RegRead ( $KEY & "\" & $SUBKEY , "url" )
		$VALDATAURL = StringRegExpReplace ( $VALDATAURL , "(?i)http(s|):" , "hxxp\1:" )
		If GUICtrlRead ( $CHECKBOX11 ) = 1 Then
			If Not StringRegExp ( $VALDATAURL , "(?i)hxxp(|s)://www.(bing|google|search.live).com/" ) Then FileWrite ( $HADDITION , "SearchScopes: " & $SHIVE & " -> " & $SUBKEY & " URL = " & $VALDATAURL & @CRLF )
		Else
			FileWrite ( $HADDITION , "SearchScopes: " & $SHIVE & " -> " & $SUBKEY & " URL = " & $VALDATAURL & @CRLF )
		EndIf
		$I += 1
	WEnd
	If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
EndFunc
Func SEARCHSCOPEFIX ( )
	Local $RET , $CLSID , $KEY
	$KEY1 = "\Microsoft\Internet Explorer\SearchScopes"
	If StringInStr ( $FIX , "HKU\" ) Then
		$USER = StringRegExpReplace ( $FIX , ".+HKU\\(.+?) ->.+" , "$1" )
		$KEY = "HKU\" & $USER & "\SOFTWARE" & $KEY1
	EndIf
	If StringInStr ( $FIX , "HKLM " ) Then $KEY = "HKLM\SOFTWARE" & $KEY1
	If StringInStr ( $FIX , "HKLM-x32 " ) Then $KEY = "HKLM\SOFTWARE\Wow6432Node" & $KEY1
	If StringInStr ( $FIX , "-> DefaultScope" ) Then
		If StringRegExp ( $FIX , "(HKLM |HKLM-x32 )" ) Then
			RESTOREVAL ( $KEY , "DefaultScope" , "REG_SZ" , "{0633EE93-D776-472f-A0FF-E1416B8B2E3A}" )
		Else
			$VAL = "DefaultScope"
			DELVALUE ( $KEY , $VAL )
		EndIf
	Else
		Select
		Case StringRegExp ( $FIX , "SearchScopes: HK(U\\.+?|LM|LM-x32) -> .+ URL =" )
			$CLSID = StringRegExpReplace ( $FIX , "SearchScopes: HK(U\\.+?|LM|LM-x32) -> (.+) URL =.*" , "$2" )
			DELKEY ( $KEY & "\" & $CLSID )
			If StringInStr ( $FIX , "HKLM-x32 " ) Then
				$KEY = "HKLM\Software\Wow6432Node\Classes\CLSID\" & $CLSID
			Else
				$KEY = "HKLM\Software\Classes\CLSID\" & $CLSID
			EndIf
			If VAR ( $KEY ) Then DELKEY ( $KEY )
	Case Else
			$VAL = StringRegExpReplace ( $FIX , "SearchScopes: HK(U\\.+?|LM|LM-x32) -> ([^{]+) .*" , "$2" )
			DELVALUE ( $KEY , $VAL )
		EndSelect
	EndIf
EndFunc
Func SECCENT ( )
	FileWrite ( $HADDITION , @CRLF & "==================== " & $SECCENT & " ========================" & @CRLF )
	FileWrite ( $HADDITION , @CRLF & "(" & $SECCENT1 & ")" & @CRLF & @CRLF )
	SECCENTLIST ( "AntiVirusProduct" )
	If $COMERR = 5 Then $COMERR = ""
	SECCENTLIST ( "AntiSpywareProduct" )
	If $COMERR = 5 Then $COMERR = ""
	SECCENTLIST ( "FirewallProduct" )
	If $COMERR = 5 Then $COMERR = ""
EndFunc
Func SECCENTFIX ( )
	$COMERR = ""
	SECCENTFIXIT ( )
	If $COMERR = 5 Then $COMERR = ""
EndFunc
Func SECCENTFIXIT ( )
	Local $OBJWMISERVICE , $DEVCOLITEMS
	$PRO = StringRegExpReplace ( $FIX , "\A(..): .+" , "$1" )
	$GUI = StringRegExpReplace ( $FIX , "..: [^{]+(\{.+\})" , "$1" )
	If $PRO = "AV" Then $PRO = "AntiVirusProduct"
	If $PRO = "AS" Then $PRO = "AntiSpywareProduct"
	If $PRO = "FW" Then $PRO = "FirewallProduct"
	$STRINSTANCE = $PRO & ".instanceGuid='" & $GUI & "'"
	$OBJWMISERVICE = ObjGet ( "winmgmts:{impersonationLevel=impersonate}!\\.\root\SecurityCenter2" )
	If IsObj ( $OBJWMISERVICE ) Then
		$DEVCOLITEMS = $OBJWMISERVICE .ExecQuery ( "Select * from " & $PRO )
		$EXIST = ""
		If IsObj ( $DEVCOLITEMS ) Then
			For $OBJECT In $DEVCOLITEMS
				If $OBJECT .instanceGuid = $GUI Then
					$EXIST = 1
				EndIf
			Next
		EndIf
		If $EXIST = "" Then
			NFOUND ( $FIX )
		Else
			$OBJWMISERVICE .Delete ( $STRINSTANCE )
			If @error Then
				FileWrite ( $HFIXLOG , $FIX & " => " & $ERDEL & " ." & " Error: " & @error & @CRLF )
			Else
				$OBJWMISERVICE2 = ObjGet ( "winmgmts:{impersonationLevel=impersonate}!\\.\root\SecurityCenter2" )
				$DEVCOLITEMS2 = $OBJWMISERVICE2 .ExecQuery ( "Select * from " & $PRO )
				If IsObj ( $DEVCOLITEMS2 ) Then
					$DEL = ""
					For $OBJECT In $DEVCOLITEMS2
						If $OBJECT .instanceGuid = $GUI Then
							FileWrite ( $HFIXLOG , $FIX & " => " & $ITEMPRO & @CRLF )
							$DEL = 1
						EndIf
					Next
					If $DEL = "" Then DELETED ( $FIX )
				EndIf
			EndIf
		EndIf
	Else
		FileWrite ( $HFIXLOG , $FIX & " => " & $ERDEL & " . ErrorCode: " & @error & @CRLF )
	EndIf
EndFunc
Func SECCENTLIST ( $PRODUCT )
	Local $OBJWMISERVICE , $DEVCOLITEMS , $OBJECT , $NAME , $STATE , $GUI , $PATHTOEXE , $STATE1 , $STATE2
	$OBJWMISERVICE = ObjGet ( "winmgmts:{impersonationLevel=impersonate}!\\.\root\SecurityCenter2" )
	If Not @error And IsObj ( $OBJWMISERVICE ) Then
		$DEVCOLITEMS = $OBJWMISERVICE .ExecQuery ( "Select * from " & $PRODUCT )
		If IsObj ( $DEVCOLITEMS ) Then
			For $OBJECT In $DEVCOLITEMS
				$PRO = ""
				$TEST = ""
				$NAME = $OBJECT .displayName
				$STATE = $OBJECT .productState
				$TEST = Hex ( $STATE )
				If StringRegExpReplace ( $TEST , "....(.)..." , "$1" ) = 1 Then
					$STATE1 = "Enabled"
				Else
					$STATE1 = "Disabled"
				EndIf
				If StringRegExpReplace ( $TEST , "......(.)." , "$1" ) = 0 Then
					$STATE2 = " - Up to date"
				Else
					$STATE2 = " - Out of date"
				EndIf
				If $PRODUCT = "AntiVirusProduct" Then $PRO = "AV"
				If $PRODUCT = "AntiSpywareProduct" Then $PRO = "AS"
				If $PRODUCT = "FirewallProduct" Then
					$PRO = "FW"
					$STATE2 = ""
				EndIf
				$GUI = $OBJECT .instanceGuid
				If $NAME <> "" Then
					FileWrite ( $HADDITION , $PRO & ": " & $NAME & " (" & $STATE1 & $STATE2 & ") " & $GUI & @CRLF )
				EndIf
			Next
		EndIf
	EndIf
EndFunc
Func SECPRO ( )
	RESTOREVAL ( "HKLM\" & $SYSTEM & $BOOTSYSTEM & $DEF & "\Control\SecurityProviders" , "SecurityProviders" , "REG_SZ" , "credssp.dll" )
EndFunc
Func SEH ( $KEY )
	Local $VALN
	$I = 1
	While 1
		$COMPANY = ""
		$SIZE = ""
		$ATTEN = ""
		$FILEPATH = ""
		$CLSID = RegEnumVal ( $KEY , $I )
		If @error Then ExitLoop
		If $CLSID <> "" Then
			If StringRegExp ( $CLSID , "\{.+\}" ) Then
				If Not StringInStr ( $KEY , "Wow6432Node" ) Then
					$VALN = RegRead ( "HKCR\CLSID\" & $CLSID , "" )
					$FILEPATH = RegRead ( "HKCR\CLSID\" & $CLSID & "\InprocServer32" , "" )
					If StringInStr ( $FILEPATH , "mscoree.dll" ) Then MSCOREE ( "HKCR\CLSID\" & $CLSID & "\InprocServer32" , $FILEPATH )
					$FILE = $FILEPATH
					AAAAFP ( )
				Else
					$VALN = RegRead ( "HKCR\Wow6432Node\CLSID\" & $CLSID , "" )
					$FILEPATH = RegRead ( "HKCR\Wow6432Node\CLSID\" & $CLSID & "\InprocServer32" , "" )
					If StringInStr ( $FILEPATH , "mscoree.dll" ) Then MSCOREE ( "HKCR\Wow6432Node\CLSID\" & $CLSID & "\InprocServer32" , $FILEPATH )
					$FILE = $FILEPATH
					AAAAFPWOW ( )
				EndIf
				If FileExists ( $FILE ) Then
					$FILEPATH = FileGetLongName ( $FILE )
					$SIZE = " [" & $SIZE & " " & $CDATE & "]" & $COMPANY
				Else
					$FILEPATH = $FILEPATH & " -> " & $REGIST8
					$COMPANY = ""
				EndIf
				If Not $VALN Then $VALN = $FF1
			EndIf
		EndIf
		Select
		Case StringRegExp ( $FILEPATH , "(?i)\\AppData\\(Roaming|Local)\\.+?\\[^\\]+?\.dll" )
			$ATTEN = " <==== " & $UPD1
		Case StringRegExp ( $FILEPATH , "(?i)\\(ProgramData|Windows)\\[^\\]+?\.(dll|exe|dat|bat|vbs)" )
			$ATTEN = " <==== " & $UPD1
		Case StringRegExp ( $FILEPATH , "(?i)mcicda64.dll" )
			$ATTEN = " <==== " & $UPD1
		EndSelect
		_ARRAYADD ( $ARRCLSID , $HIVE & $VALN & " - " & $CLSID & " - " & $FILEPATH & $SIZE & $ATTEN , 0 , "||||" )
		$I = $I + 1
	WEnd
EndFunc
Func SEHFIX ( )
	$VAL = StringRegExpReplace ( $FIX , "[^\{]+(\{.+\}).*" , "$1" )
	$KEY2 = "\Microsoft\Windows\CurrentVersion\explorer\ShellExecuteHooks"
	If StringInStr ( $FIX , "ShellExecuteHooks: " ) Then
		$KEY1 = "HKLM\Software" & $KEY2
		$KEY = "HKLM\Software\Classes\CLSID\" & $VAL
	Else
		$KEY1 = "HKLM\Software\Wow6432Node" & $VAL
		$KEY = "HKLM\SOFTWARE\WOW6432Node\Classes\CLSID\" & $VAL
	EndIf
	DELVALUE ( $KEY1 , $VAL )
	If VAR ( $KEY ) Then DELKEY ( $KEY )
EndFunc
Func SETDEFBAT ( )
	RESTOREVAL ( "HKLM\Software\Classes\.bat" , "" , "REG_SZ" , "batfile" )
EndFunc
Func SETDEFCMD ( )
	RESTOREVAL ( "HKLM\Software\Classes\.cmd" , "" , "REG_SZ" , "cmdfile" )
EndFunc
Func SETDEFCOM ( )
	RESTOREVAL ( "HKLM\Software\Classes\.com" , "" , "REG_SZ" , "comfile" )
EndFunc
Func SETDEFCOMBAT ( )
	RESTOREVAL ( "HKLM\Software\Classes\batfile\shell\open\command" , "" , "REG_SZ" , """%1"" %*" )
EndFunc
Func SETDEFCOMCMD ( )
	RESTOREVAL ( "HKLM\Software\Classes\cmdfile\shell\open\command" , "" , "REG_SZ" , """%1"" %*" )
EndFunc
Func SETDEFCOMCOM ( )
	RESTOREVAL ( "HKLM\Software\Classes\comfile\shell\open\command" , "" , "REG_SZ" , """%1"" %*" )
EndFunc
Func SETDEFCOMEXE ( )
	RESTOREVAL ( "HKLM\" & $SOFTWARE & "\Classes\exefile\shell\open\command" , "" , "REG_SZ" , """%1"" %*" )
EndFunc
Func SETDEFCOMREG ( )
	RESTOREVAL ( "HKLM\Software\Classes\regfile\shell\open\command" , "" , "REG_SZ" , "regedit.exe ""%1""" )
EndFunc
Func SETDEFCOMSCR ( )
	RESTOREVAL ( "HKLM\Software\Classes\scrfile\shell\open\command" , "" , "REG_SZ" , """%1"" /S" )
EndFunc
Func SETDEFEXE ( )
	RESTOREVAL ( "HKLM\" & $SOFTWARE & "\Classes\.exe" , "" , "REG_SZ" , "exefile" )
EndFunc
Func SETDEFICON ( )
	RESTOREVAL ( "HKLM\" & $SOFTWARE & "\Classes\exefile\DefaultIcon" , "" , "REG_SZ" , "%1" )
EndFunc
Func SETDEFICONBAT ( )
	RESTOREVAL ( "HKLM\Software\Classes\batfile\DefaultIcon" , "" , "REG_EXPAND_SZ" , "%SystemRoot%\System32\imageres.dll,-68" )
EndFunc
Func SETDEFICONCMD ( )
	$KEY = "HKLM\Software\Classes\cmdfile\DefaultIcon"
	If $OSNUM < 6.1 Then
		RESTOREVAL ( $KEY , "" , "REG_EXPAND_SZ" , "%SystemRoot%\System32\shell32.dll,-153" )
	Else
		RESTOREVAL ( $KEY , "" , "REG_EXPAND_SZ" , "%SystemRoot%\System32\imageres.dll,-68" )
	EndIf
EndFunc
Func SETDEFICONCOM ( )
	RESTOREVAL ( "HKLM\Software\Classes\comfile\DefaultIcon" , "" , "REG_EXPAND_SZ" , "%SystemRoot%\System32\shell32.dll,2" )
EndFunc
Func SETDEFICONREG ( )
	RESTOREVAL ( "HKLM\Software\Classes\regfile\DefaultIcon" , "" , "REG_EXPAND_SZ" , "%SystemRoot%\regedit.exe,1" )
EndFunc
Func SETDEFLOGONUI ( )
	$32VERS = ""
	If StringInStr ( $FIX , "HKLM-x32" ) Then $32VERS = "\WOW6432Node"
	RESTOREVAL ( "HKLM\" & $SOFTWARE & $32VERS & "\Classes\CLSID\{7986d495-ce42-4926-8afc-26dfa299cadb}\InprocServer32" , "" , "REG_EXPAND_SZ" , "%SystemRoot%\system32\authui.dll" )
EndFunc
Func SETDEFREG ( )
	RESTOREVAL ( "HKLM\Software\Classes\.reg" , "" , "REG_SZ" , "regfile" )
EndFunc
Func SETDEFSCR ( )
	RESTOREVAL ( "HKLM\Software\Classes\.scr" , "" , "REG_SZ" , "scrfile" )
EndFunc
Func SETDEFWBEM ( )
	If $BOOTM <> "Recovery" Then KILLDLL ( )
	RESTOREVAL ( "HKLM\" & $SOFTWARE & "\Classes\CLSID\{F3130CDB-AA52-4C3A-AB32-85FFC23AF9C1}\InprocServer32" , "" , "REG_EXPAND_SZ" , "%systemroot%\system32\wbem\wbemess.dll" )
EndFunc
Func SETDEFWBEM7F ( )
	If $BOOTM <> "Recovery" Then KILLDLL ( )
	RESTOREVAL ( "HKLM\" & $SOFTWARE & "\Classes\CLSID\{5839FCA9-774D-42A1-ACDA-D6A79037F57F}\InprocServer32" , "" , "REG_EXPAND_SZ" , "%systemroot%\system32\wbem\fastprox.dll" )
EndFunc
Func SHELL ( )
	RESTOREVAL ( "HKLM\" & $SOFTWARE & "\Microsoft\Windows NT\CurrentVersion\Winlogon" , "Shell" , "REG_SZ" , "Explorer.exe" )
EndFunc
Func SHELL32 ( )
	RESTOREVAL ( "HKLM\" & $SOFTWARE & "\WOW6432Node\Microsoft\Windows NT\CurrentVersion\Winlogon" , "Shell" , "REG_SZ" , "Explorer.exe" )
EndFunc
Func SHELLTARGET ( $KEY )
	Select
	Case RegRead ( $SKEY , "Target" )
		$DATA = RegRead ( $SKEY , "Target" )
	Case RegRead ( $SKEY , "TargetFolderPath" )
		$DATA = RegRead ( $SKEY , "TargetFolderPath" )
	Case RegRead ( $SKEY , "TargetKnownFolder" )
		$DATA = RegRead ( $SKEY , "TargetKnownFolder" )
Case Else
		$DATA = RegRead ( $SKEY , "TargetSpecialFolder" )
	EndSelect
	Return $DATA
EndFunc
Func SHIM ( $SKEY , $WOW = "" )
	Local $ARRAYNAME , $WOWKEY , $HKEY1
	If $WOW Then $WOWKEY = "\Wow6432Node"
	$KEY = "HKLM\Software" & $WOWKEY & "\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\" & $SKEY
	$HKEY = _REGOPENKEYEX3 ( $KEY )
	If @error Or $HKEY = 0 Then Return
	$I = + 4294967295
	While 1
		$I += 1
		$SUBKEY = __REGENUMKEY ( $HKEY , $I )
		If @error Then ExitLoop
		$HKEY1 = _REGOPENKEYEX3 ( $KEY & "\" & $SUBKEY , 1 )
		If Not @error And IsPtr ( $HKEY ) Then $ARRAYNAME = _LISTVAL ( $HKEY1 )
		$PATH = ""
		$CDATE = ""
		For $V = 0 To UBound ( $ARRAYNAME ) + 4294967295
			If $SKEY = "Custom" Then
				$SSKEY = StringRegExpReplace ( $ARRAYNAME [ $V ] [ 0 ] , "(?i)(.+).sdb" , "$1" )
				$DESCR = RegRead ( "HKLM\Software" & $WOWKEY & "\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\InstalledSDB\" & $SSKEY , "DatabaseDescription" )
				If GUICtrlRead ( $CHECKBOX1 ) = 1 Then
					If StringRegExp ( $SUBKEY , "(?i)(setuphost|setupprep).exe" ) And $SSKEY = "{5534e02f-0f5d-40dd-ba92-bea38d22384d}" Then ContinueLoop
					If $SUBKEY = "iisexpress.exe" And StringRegExp ( $SSKEY , "(?i){08274920-8908-45c2-9258-8ad67ff77b09}|{ad846bae-d44b-4722-abad-f7420e08bcd9}" ) Then ContinueLoop
				EndIf
				_ARRAYADD ( $ARRAYREG , "HKLM\Software" & $WOWKEY & "\...\AppCompatFlags\" & $SKEY & "\" & $SUBKEY & ": [" & $ARRAYNAME [ $V ] [ 0 ] & "] -> " & $DESCR , 0 , "||||" )
			Else
				$CDATE = ""
				If $ARRAYNAME [ $V ] [ 0 ] = "DatabasePath" Then
					$PATH = $ARRAYNAME [ $V ] [ 1 ]
					$FILE = $ARRAYNAME [ $V ] [ 1 ]
					AAAAFP ( )
					If $CDATE Then
						$CDATE = " [" & $CDATE & "]"
						$PATH = $FILE
					EndIf
					ExitLoop
				EndIf
			EndIf
		Next
		If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
		_REGCLOSE ( $HKEY1 )
		If $SKEY <> "Custom" Then
			If GUICtrlRead ( $CHECKBOX1 ) = 1 Then
				If $SUBKEY = "{5534e02f-0f5d-40dd-ba92-bea38d22384d}" And StringRegExp ( $PATH , "(?i):\\Windows\\AppPatch\\(CustomSDB|Custom\\Custom64)\\{5534e02f-0f5d-40dd-ba92-bea38d22384d}.sdb" ) Then ContinueLoop
				If StringRegExp ( $SUBKEY , "(?i){08274920-8908-45c2-9258-8ad67ff77b09}|{ad846bae-d44b-4722-abad-f7420e08bcd9}" ) And StringRegExp ( $PATH , "(?i):\\Windows\\AppPatch\\(CustomSDB|Custom\\Custom64)\\{(ad846bae-d44b-4722-abad-f7420e08bcd9|08274920-8908-45c2-9258-8ad67ff77b09)}.sdb" ) Then ContinueLoop
			EndIf
			_ARRAYADD ( $ARRAYREG , "HKLM\Software\...\AppCompatFlags\" & $SKEY & "\" & $SUBKEY & ": [DatabasePath] -> " & $PATH & $CDATE , 0 , "||||" )
		EndIf
	WEnd
EndFunc
Func SHIMFIX ( )
	Local $WOWKEY
	If StringInStr ( $FIX , "\Wow6432Node\" ) Then $WOWKEY = "\Wow6432Node"
	$KEY = StringRegExpReplace ( $FIX , ".+\\AppCompatFlags\\(.+?):.+" , "$1" )
	$KEY = "HKLM\Software" & $WOWKEY & "\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\" & $KEY
	DELKEY ( $KEY )
EndFunc
Func SHIMU ( $SKEY )
	$KEY = "HKCU\Software\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\"
	$I = 1
	While 1
		$SUBKEY = RegEnumKey ( $KEY & $SKEY , $I )
		If @error Then ExitLoop
		_ARRAYADD ( $ARRAYREG , "HKCU\Software\...\AppCompatFlags\" & $SKEY & "\" & $SUBKEY & ": There is currently no automatic fix for this entry. Please report this entry to the developer of Farbar Recovery Scan Tool." , 0 , "||||" )
		$I += 1
	WEnd
EndFunc
Func SHORTCF ( )
	$PATH = StringRegExpReplace ( $FIX , "Shortcut: (.+?) ->.*" , "$1" )
	$PATH = StringRegExpReplace ( $PATH , "ShortcutWithArgument: (.+?) ->.*" , "$1" )
	If Not FileExists ( $PATH ) Then Return NFOUND ( $PATH )
	If StringInStr ( $FIX , "Shortcut:" ) Then Return MOVEFILE ( $PATH )
	$TARGET = FileGetShortcut ( $PATH )
	If Not IsArray ( $TARGET ) Then Return FileWrite ( $HFIXLOG , $PATH & " => " & $SHORTERR & @CRLF )
	$NFILE = StringRegExpReplace ( $PATH , "(?i)([a-z]):" , "$1" )
	$DES = $C & "\FRST\Quarantine\" & $NFILE
	FileMove ( $PATH , $DES & ".xBAD" , 1 + 8 )
	$TARGET0 = ""
	If StringInStr ( $PATH , "No Add-ons" ) Then $TARGET0 = " -extoff"
	FileCreateShortcut ( $TARGET [ 0 ] , $PATH , $TARGET [ 1 ] , $TARGET0 , $TARGET [ 3 ] , $TARGET [ 4 ] , "" , $TARGET [ 5 ] , $TARGET [ 6 ] )
	$TARGET = FileGetShortcut ( $PATH )
	If IsArray ( $TARGET ) Then
		If StringInStr ( $PATH , "No Add-ons" ) Then
			If StringInStr ( $TARGET [ 2 ] , " -extoff" ) Then
				FileWrite ( $HFIXLOG , $PATH & " => " & $SHORT0 & " " & $ARG0 & " " & $RESTORED & @CRLF )
			Else
				FileWrite ( $HFIXLOG , $PATH & " => " & $NRESTORE & " " & $SHORT0 & " " & $ARG0 & "." & @CRLF )
			EndIf
		Else
			If $TARGET [ 2 ] = "" Then
				FileWrite ( $HFIXLOG , $PATH & " => " & $SHORT0 & " " & $ARG0 & " " & $DELETED & @CRLF )
			Else
				FileWrite ( $HFIXLOG , $PATH & " => " & $NDELETED & " " & $NRESTORE & " " & $SHORT0 & "." & @CRLF )
			EndIf
		EndIf
	Else
		FileWrite ( $HFIXLOG , $PATH & " => " & $SHORTERR & @CRLF )
	EndIf
EndFunc
Func SILENTPROCESSEXIT ( )
	$SUB = StringRegExpReplace ( $FIX , "(?i).+SilentProcessExit\\([^:]+):.*" , "$1" )
	DELKEY ( "HKLM\" & $SOFTWARE & "\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\" & $SUB )
EndFunc
Func SIOI ( $HIVE , $KEY )
	$HKEY = _REGOPENKEYEX3 ( $KEY )
	If @error Or Not $HKEY Then Return
	$I = 0
	While 1
		$COMPANY = ""
		$CDATE = ""
		$FILE = ""
		$SUB = __REGENUMKEY ( $HKEY , $I )
		If @error Then ExitLoop
		$CLSID = RegRead ( $KEY & "\" & $SUB , "" )
		If StringRegExp ( $CLSID , "\{.+\}" ) Then
			$KEY1 = "HKCR\CLSID\" & $CLSID & "\InprocServer32"
			$KEY2 = "HKCR\Wow6432Node\CLSID\" & $CLSID & "\InprocServer32"
			$HIVE1 = $HIVE
			Select
			Case RegRead ( $KEY1 , "" )
				$FILE = RegRead ( $KEY1 , "" )
				If StringInStr ( $FILE , "mscoree.dll" ) Then MSCOREE ( $KEY1 , $FILE )
				AAAAFP ( )
			Case RegRead ( $KEY2 , "" )
				$FILE = RegRead ( $KEY2 , "" )
				If StringInStr ( $FILE , "mscoree.dll" ) Then MSCOREE ( $KEY2 , $FILE )
				$HIVE1 = $HIVE & "-x32"
				AAAAFPWOW ( )
		Case Else
			EndSelect
			If Not FileExists ( $FILE ) Then
				$FILE = $FILE & " -> " & $REGIST8
			Else
				$CDATE = " [" & $CDATE & "]"
			EndIf
			Select
			Case StringRegExp ( $FILE , "(?i)WINDOWS\\(system32|SysWOW64)\\(hvsiofficeiconoverlayshellextension|EhStorShell|cscui|syncui|shell32|ntshrui|WorkfoldersShell|appresolver)\.dll" ) And StringRegExp ( $COMPANY , "(?i)Microsoft Corporation" )
			Case StringRegExp ( $FILE , "(?i)\\Program Files\\Windows (Defender|Sidebar)\\(shellext|sbdrop)\.dll" ) And StringRegExp ( $COMPANY , "(?i)Microsoft Corporation" )
			Case StringRegExp ( $FILE , "(?i)\\Microsoft\\(SkyDrive|OneDrive)\\.+\\(SkyDriveShell|FileSyncShell)(64|)\.dll" ) And StringRegExp ( $COMPANY , "(?i)Microsoft Corporation" )
			Case StringRegExp ( $FILE , "(?i)\\Microsoft Office\\.+?\\(GrooveShellExtensions|GROOVEEX).dll" ) And StringRegExp ( $COMPANY , "(?i)Microsoft Corporation" )
		Case Else
				_ARRAYADD ( $ARRCLSID , $HIVE1 & ": [" & $SUB & "] -> " & $CLSID & " => " & $FILE & $CDATE & $COMPANY , 0 , "||||" )
			EndSelect
		EndIf
		$I += 1
	WEnd
	If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
EndFunc
Func SIOIFIX ( )
	Local $USER , $KEY
	$SUB = StringRegExpReplace ( $FIX , "(?i).+?: \[(.+)\] -> .+ =>.*" , "$1" )
	$CLSID = StringRegExpReplace ( $FIX , "(?i).+?: .+ -> (.+) =>.*" , "$1" )
	$KEY1 = "HKLM\Software\Classes\CLSID\" & $CLSID
	If StringInStr ( $FIX , "-x32:" ) Then $KEY1 = "HKLM\Software\Wow6432Node\Classes\CLSID\" & $CLSID
	If StringRegExp ( $FIX , "(?i)Handlers\d_(S|.DEFAULT)" ) Then
		$USER = StringRegExpReplace ( $FIX , "ContextMenuHandlers\d_([^:]+):.+" , "$1" )
		$KEY1 = "HKU\" & $USER & "\SOFTWARE\Classes\CLSID\" & $CLSID
	EndIf
	Select
	Case StringInStr ( $FIX , "Identifiers-x32: " )
		$KEY = "HKLM\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Explorer\ShellIconOverlayIdentifiers\" & $SUB
	Case StringInStr ( $FIX , "Identifiers: " )
		$KEY = "HKLM\Software\Microsoft\Windows\CurrentVersion\Explorer\ShellIconOverlayIdentifiers\" & $SUB
	Case StringRegExp ( $FIX , "ers1(|-x32):" )
		$KEY = "HKLM\Software\Classes\*\ShellEx\ContextMenuHandlers\" & $SUB
	Case StringRegExp ( $FIX , "ers2(|-x32):" )
		$KEY = "HKLM\Software\Classes\Drive\ShellEx\ContextMenuHandlers\" & $SUB
	Case StringRegExp ( $FIX , "ers3(|-x32):" )
		$KEY = "HKLM\Software\Classes\AllFileSystemObjects\ShellEx\ContextMenuHandlers\" & $SUB
	Case StringRegExp ( $FIX , "ers4(|-x32):" )
		$KEY = "HKLM\Software\Classes\Directory\ShellEx\ContextMenuHandlers\" & $SUB
	Case StringRegExp ( $FIX , "ers5(|-x32):" )
		$KEY = "HKLM\Software\Classes\Directory\Background\ShellEx\ContextMenuHandlers\" & $SUB
	Case StringRegExp ( $FIX , "ers6(|-x32):" )
		$KEY = "HKLM\Software\Classes\Folder\ShellEx\ContextMenuHandlers\" & $SUB
	Case StringInStr ( $FIX , "Handlers1_" )
		$KEY = "HKU\" & $USER & "\Software\Classes\*\ShellEx\ContextMenuHandlers\" & $SUB
	Case StringInStr ( $FIX , "Handlers2_" )
		$KEY = "HKU\" & $USER & "\Software\Classes\Drive\ShellEx\ContextMenuHandlers\" & $SUB
	Case StringInStr ( $FIX , "Handlers3_" )
		$KEY = "HKU\" & $USER & "\Software\Classes\AllFileSystemObjects\ShellEx\ContextMenuHandlers\" & $SUB
	Case StringInStr ( $FIX , "Handlers4_" )
		$KEY = "HKU\" & $USER & "\Software\Classes\Directory\ShellEx\ContextMenuHandlers\" & $SUB
	Case StringInStr ( $FIX , "Handlers5_" )
		$KEY = "HKU\" & $USER & "\Software\Classes\Directory\Background\ShellEx\ContextMenuHandlers\" & $SUB
	Case StringInStr ( $FIX , "Handlers6_" )
		$KEY = "HKU\" & $USER & "\Software\Classes\Folder\ShellEx\ContextMenuHandlers\" & $SUB
	EndSelect
	DELKEY ( $KEY )
	If VAR ( $KEY1 , 1 ) Then DELKEY ( $KEY1 )
EndFunc
Func SSO ( $WOV = "" )
	If $WOV Then
		$CLSID = "\WOW6432Node"
		$VERSI = "-x32"
	Else
		$CLSID = ""
		$VERSI = ""
	EndIf
	$KEY = "HKLM\SOFTWARE" & $CLSID & "\Microsoft\Windows\CurrentVersion\Explorer\ShellServiceObjects"
	$HKEY = _REGOPENKEYEX3 ( $KEY , 1 )
	If @error Then Return
	$J = + 4294967295
	While 1
		$J += 1
		$SUB = __REGENUMKEY ( $HKEY , $J )
		If @error Then ExitLoop
		$NAME = RegRead ( "HKCR" & $CLSID & "\CLSID\" & $SUB , "" )
		If @error Then $NAME = $FF1
		$FPATH = RegRead ( "HKCR" & $CLSID & "\CLSID\" & $SUB & "\InprocServer32" , "" )
		If StringInStr ( $FPATH , "mscoree.dll" ) Then MSCOREE ( "HKCR" & $CLSID & "\CLSID\" & $SUB & "\InprocServer32" , $FPATH )
		$FILE = $FPATH
		If $WOV Then
			AAAAFPWOW ( )
		Else
			AAAAFP ( )
		EndIf
		If FileExists ( $FILE ) Then
			$CDATE = " [" & $CDATE & "]"
			$FPATH = $FILE
		EndIf
		If $SUB = "{59EFE487-E5B8-4fae-9D2C-FCDF0B70CE70}" And Not $CDATE Then ContinueLoop
		If StringInStr ( $COMPANY , "Microsoft Corp" ) Then
			Select
			Case StringRegExp ( $FPATH , "(?i):\\WINDOWS\\(System32|SysWOW64)\\(Windows.FileExplorer.Common|wscntfy|webcheck|AltTab|netshell|authui|twinui|shell32|SndVolSSO|pwsso|dxp|Windows.CloudStore|stobject|windows.storage|hcproviders|wpdshserviceobj|SettingMonitor|pnidui|cscui|srchadmin|shdocvw|bthprops|SyncCenter|Actioncenter|hgcpl)\.dll" )
				ContinueLoop
			Case StringRegExp ( $FPATH , "(?i):\\WINDOWS\\(System32|SysWOW64)\\SystemResetPlatform\\SystemResetSSO\.dll" )
				ContinueLoop
			Case StringRegExp ( $FPATH , "(?i):\\WINDOWS\\(System32|SysWOW64)\\bthprops\.CPL" )
				ContinueLoop
			Case StringRegExp ( $FPATH , "(?i):\\Windows\\ehome\\ehSSO.dll" )
				ContinueLoop
			EndSelect
		EndIf
		_ARRAYADD ( $ARRCLSID , "ShellServiceObjects" & $VERSI & ": " & $NAME & " -> " & $SUB & " => " & $FPATH & $CDATE & $COMPANY , 0 , "||||" )
	WEnd
	If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
EndFunc
Func SSODL ( $KEY )
	$I = 0
	While 1
		$I = $I + 1
		$VALN = RegEnumVal ( $KEY , $I )
		If @error Then ExitLoop
		If $VALN <> "" Then
			$COMPANY = ""
			$FILE = ""
			$CLSID = RegRead ( $KEY , $VALN )
			If $CLSID = "" Then
				$CLSID = $REGIST7
				$FILE = $REGIST8
			Else
				If StringRegExp ( $CLSID , "\{.+\}" ) Then
					If Not StringInStr ( $KEY , "Wow6432Node" ) Then
						$FILEPATH = RegRead ( "HKLM\" & $SOFTWARE & "\Classes\CLSID\" & $CLSID & "\InprocServer32" , "" )
						If StringInStr ( $FILEPATH , "mscoree.dll" ) Then MSCOREE ( "HKLM\" & $SOFTWARE & "\Classes\CLSID\" & $CLSID & "\InprocServer32" , $FILEPATH )
						$FILE = $FILEPATH
						AAAAFP ( )
					Else
						$FILEPATH = RegRead ( "HKLM\" & $SOFTWARE & "\Wow6432Node\Classes\CLSID\" & $CLSID & "\InprocServer32" , "" )
						If StringInStr ( $FILEPATH , "mscoree.dll" ) Then MSCOREE ( "HKLM\" & $SOFTWARE & "\Wow6432Node\Classes\CLSID\" & $CLSID & "\InprocServer32" , $FILEPATH )
						$FILE = $FILEPATH
						AAAAFPWOW ( )
					EndIf
					If Not FileExists ( $FILE ) Then $FILE = $FILEPATH & " " & $REGIST8
				EndIf
			EndIf
			If $VALN = "WebCheck" And $CLSID = "{E6FB5E20-DE35-11CF-9C87-00AA005127ED}" And $FILEPATH = "" Then ContinueLoop
			_ARRAYADD ( $ARRCLSID , $HIVE & $VALN & " - " & $CLSID & " - " & $FILE & $COMPANY , 0 , "||||" )
		EndIf
	WEnd
EndFunc
Func SSODLFIX ( )
	Local $CLSID , $KEY1
	$KEY2 = "\Microsoft\Windows\CurrentVersion\ShellServiceObjectDelayLoad"
	If StringInStr ( $FIX , "SSODL: " ) Then
		$VAL = StringRegExpReplace ( $FIX , "SSODL: ([^\{]+) - .+ - .*" , "$1" )
		$KEY = "HKLM\Software" & $KEY2
		If StringRegExp ( $FIX , "\{.+\}" ) Then
			$CLSID = StringRegExpReplace ( $FIX , "[^\{]+(\{.+\}).*" , "$1" )
			$KEY1 = "HKLM\Software\Classes\CLSID\" & $CLSID
		EndIf
	EndIf
	If StringInStr ( $FIX , "SSODL-x32: " ) Then
		$VAL = StringRegExpReplace ( $FIX , "SSODL-x32: ([^\{]+) - .+ - .*" , "$1" )
		$KEY = "HKLM\Software\Wow6432Node" & $KEY2
		If StringRegExp ( $FIX , "\{.+\}" ) Then
			$CLSID = StringRegExpReplace ( $FIX , "[^\{]+(\{.+\}).*" , "$1" )
			$KEY1 = "HKLM\Software\Wow6432Node\Classes\CLSID\" & $CLSID
		EndIf
	EndIf
	DELVALUE ( $KEY , $VAL )
	If VAR ( $KEY1 ) Then DELKEY ( $KEY1 )
EndFunc
Func SSOFIX ( )
	If StringInStr ( $FIX , "-x32:" ) Then
		$CLSID = "\WOW6432Node"
	Else
		$CLSID = ""
	EndIf
	$SUB = StringRegExpReplace ( $FIX , "(?i).+->\s(.+)\s=>.*" , "$1" )
	DELKEY ( "HKLM\SOFTWARE" & $CLSID & "\Microsoft\Windows\CurrentVersion\Explorer\ShellServiceObjects\" & $SUB )
	DELKEY ( "HKLM\Software" & $CLSID & "\Classes\CLSID\" & $SUB )
EndFunc
Func STARTUPFOLDER ( $FOLDER )
	$FOLDER = StringRegExpReplace ( $FOLDER , "\\$" , "" )
	If Not FileExists ( $FOLDER ) Then Return
	Local $TARGET , $ARGUMENT
	$FILEARRAY = _FILELISTTOARRAY ( $FOLDER )
	For $I = 1 To UBound ( $FILEARRAY ) + 4294967295
		$FULLFILEPATH = $FOLDER & "\" & $FILEARRAY [ $I ]
		If Not StringInStr ( $FILEARRAY [ $I ] , "desktop.ini" ) Then
			$DATECR = FILETIMECM ( $FULLFILEPATH )
			$ATTEN = ""
			$COMPANY = ""
			Select
			Case StringInStr ( $FILEARRAY [ $I ] , ".lnk" )
				If StringRegExp ( $FILEARRAY [ $I ] , "(?i)(fastSecurity.*|Sidebar620|Wizard|ProW File Compressor|ITERHPGen|bckp_amgr|h.vbs|uploadHost.*|BitCleaner.*|PowerExpertNT|tlsCloud_debug|MUReader|Microsoft Startup|^\d+|python.*.exe|BrowserAssistant|SearchEngineOptimizer|^SEO|ncsyncer|PriceWatch|WindowsDefender|Shield|CDexFramework|CRaccoon|Host Services|SmartClock|QScan System-Check|produpd|WeatherBuddy|Zaxar Games Browser|monhost|IntelRapid|aut.+\.ini|Host Services(| x64)|RUNDLL32\.exe|^exe|Spywatch|^p2|^ws|colorui|system)\.lnk" ) Then $ATTEN = " <==== " & $UPD1
				$TARGET = FileGetShortcut ( $FULLFILEPATH )
				$ERR = @error
				If Not $ERR Then
					Select
					Case StringLen ( StringRegExpReplace ( $TARGET [ 0 ] , ".+\.(\w+)$" , "$1" ) ) > 3
						$ATTEN = " <==== " & $UPD1
					Case StringRegExp ( $TARGET [ 0 ] , "(?i)\\users\\.+.(vbs|js)\b|system\.vbs|\\(AutoIt3|python.*|VBoxSVC|NUP)\.exe)|Roaming\\(Adobe\\|firefox)" )
						$ATTEN = " <==== " & $UPD1
					Case StringRegExp ( $TARGET [ 0 ] , "(?i)local\\temp\\" )
						$ATTEN = " <==== " & $UPD1
					Case StringInStr ( $TARGET [ 0 ] , "\plugin-container.exe" ) And Not StringRegExp ( $TARGET [ 0 ] , "Program Files(| \(86\)\\Mozilla Firefox" )
						$ATTEN = " <==== " & $UPD1
					Case StringInStr ( $FILEARRAY [ $I ] , "Team Viewer.ink" ) And Not StringRegExp ( $TARGET [ 0 ] , "(?i)TeamViewer" )
						$ATTEN = " <==== " & $UPD1
					EndSelect
				EndIf
				_ARRAYADD ( $ARRAYREG , "Startup: " & $FULLFILEPATH & " [" & $DATECR & "]" & $ATTEN , 0 , "||||" )
				If Not $ERR Then
					$ARGUMENT = $TARGET [ 0 ]
					If $BOOTM = "Recovery" Then $ARGUMENT = StringRegExpReplace ( $ARGUMENT , "(?i)X:" , "C:" )
					If StringInStr ( $ARGUMENT , "rundll32.exe" ) Or _ARG ( $ARGUMENT ) Then
						$ARGUMENT1 = $TARGET [ 2 ]
						If StringRegExp ( $ARGUMENT1 , "(?i)\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows" ) Then $ATTEN = " <==== " & $UPD1
						If StringRegExp ( $ARGUMENT , "(?i)\b(powershell|wscript)\b" ) Then $ATTEN = " <==== " & $UPD1
						If StringLen ( $ARGUMENT1 ) > 300 Then $ARGUMENT1 = StringTrimRight ( $ARGUMENT1 , StringLen ( $ARGUMENT1 ) + 4294966996 ) & " (" & $DATAX & " " & StringLen ( $ARGUMENT1 ) + 4294966996 & " " & $DATAY & ")."
						_ARRAYADD ( $ARRAYREG , "ShortcutAndArgument: " & $FILEARRAY [ $I ] & " -> " & $ARGUMENT & " => " & $ARGUMENT1 & $ATTEN , 0 , "||||" )
					Else
						$FPATH = FileGetLongName ( $ARGUMENT )
						If StringLen ( StringRegExpReplace ( $FPATH , ".+\.(\w+)$" , "$1" ) ) > 3 Then $ATTEN = " <==== " & $UPD1
						$DR = StringRegExpReplace ( $FPATH , "^(.:\\).+" , "$1" )
						If DriveStatus ( $DR ) = "ready" And FileExists ( $FPATH ) Then
							If StringRegExp ( $ARGUMENT , "(?i)\\Compil32.exe|\\pwac\\|\\ITEinboxI2CFlash\\|Roaming.+\\(bckp_amgr|VSIXAutoUpdate).exe|ProgramData\\Windows\\|python.*.exe|Roaming\\Adobe\\" ) Then $ATTEN = " <==== " & $UPD1
							COMP ( $FPATH )
							Select
							Case StringInStr ( $COMPANY , "Microsoft Corporation" ) And ( StringInStr ( $FILEARRAY [ $I ] , ":\Users\" ) Or StringInStr ( $COMPANY , "][" ) )
								$ATTEN = " <==== " & $UPD1
							Case StringRegExp ( $COMPANY , "\(.+ -> .+\) \[" ) And Not StringInStr ( $ARGUMENT , "Program Files" )
								$ATTEN = " <==== " & $UPD1
							Case StringRegExp ( $COMPANY , "(?i)\(The Chromium Authors\) \[" )
								$ATTEN = " <==== " & $UPD1
							Case StringRegExp ( $ARGUMENT , "ProgramData\\[^\\]+\\\w+\.exe" ) And StringRegExp ( $COMPANY , "(?i)Node.js.+Joyent" )
								$ATTEN = " <==== " & $UPD1
							EndSelect
							_ARRAYADD ( $ARRAYREG , "ShortcutTarget: " & $FILEARRAY [ $I ] & " -> " & $FPATH & $COMPANY & $ATTEN , 0 , "||||" )
						Else
							_ARRAYADD ( $ARRAYREG , "ShortcutTarget: " & $FILEARRAY [ $I ] & " -> " & $ARGUMENT & " (" & $REGIST8 & ")" & $ATTEN , 0 , "||||" )
						EndIf
					EndIf
				EndIf
			Case StringRegExp ( $FILEARRAY [ $I ] , "(?i)\.(url|website)$" )
				$ARGUMENT = _GETURL ( $FULLFILEPATH )
				If StringRegExp ( $ARGUMENT , "(?i)\.(vbs|js)\b" ) Then $ATTEN = " <==== " & $UPD1
				_ARRAYADD ( $ARRAYREG , "InternetURL: " & $FULLFILEPATH & " -> " & $ARGUMENT & $ATTEN , 0 , "||||" )
			Case StringRegExp ( $FILEARRAY [ $I ] , "(?i)\.scr\b" ) And Not StringRegExp ( $FILEARRAY [ $I ] , "(?i)\s+\.scr\b" )
				$FILES = StringSplit ( $FILEARRAY [ $I ] , "" )
				For $I = 1 To UBound ( $FILES ) + 4294967295
					If AscW ( $FILES [ $I ] ) > 8100 Then
						$ATTEN = " <==== " & $UPD1
						ExitLoop
					EndIf
				Next
		Case Else
				If StringRegExp ( $FILEARRAY [ $I ] , "(?i)certlm.exe|\.cmd\b|local\\temp\\|SystemLogin.+\.vbs|^\w{2}\.(vbs|js)$|^Win.+\.vbs|^Windows\.|\s+\.scr\b|\A\.exe$|\b(cmd|chromium|SoundServices|Process|Microsoft Edge|Defender|windefender|spoolsv|uerinit|explorer|iexplore|System|regdrv|taskhost|Isass|smss|csrss|wininit|services|lsass|lsm|winlogon|.*svchost.*|dwm|msdtc|VSSVC|alg|sihost|dllhost|Windows Defender|taskhostw|Update|Run|document|nvopencl64|Lydian.+|OneDrive|updater-obfuscated|Wave-Setup)\.(exe|vbs|bat)" ) Then $ATTEN = " <==== " & $UPD1
				If Not StringInStr ( FileGetAttrib ( $FULLFILEPATH ) , "D" ) Then COMP ( $FULLFILEPATH )
				If StringInStr ( $COMPANY , "Microsoft Corporation" ) Then $ATTEN = " <==== " & $UPD1
				If StringRegExp ( $COMPANY , "\[.+\] \[.+\]|() [" ) Then $ATTEN = " <==== " & $UPD1
				_ARRAYADD ( $ARRAYREG , "Startup: " & $FULLFILEPATH & " [" & $DATECR & "]" & $COMPANY & $ATTEN , 0 , "||||" )
			EndSelect
		EndIf
	Next
EndFunc
Func STATUS_SUCCESS ( $RET )
	If $RET >= 0 And $RET <= 2147483647 Then Return 1
EndFunc
Func SUB ( )
	If $BOOTM <> "Recovery" Or Not RegRead ( "HKLM\" & $SYSTEM & $BOOTSYSTEM & $DEF & "\Control\Session Manager\KnownDLLs" , "DllDirectory32" ) Then Return
	$VD = ""
	$AAA = "%SystemRoot%\system32\csrss.exe ObjectDirectory=\Windows SharedSection=1024,20480,768 Windows=On SubSystemType=Windows ServerDll=basesrv,1 ServerDll=winsrv:UserServerDllInitialization,3 ServerDll="
	Select
	Case $OSNUM = 6
		$VD = $AAA & "winsrv:ConServerDllInitialization,2 ProfileControl=Off MaxRequestThreads=16"
	Case $OSNUM = 6.1
		$VD = $AAA & "winsrv:ConServerDllInitialization,2 ServerDll=sxssrv,4 ProfileControl=Off MaxRequestThreads=16"
	Case $OSNUM > 6.2
		$VD = $AAA & "sxssrv,4 ProfileControl=Off MaxRequestThreads=16"
	EndSelect
	Return $VD
EndFunc
Func SUBFIX ( )
	$VAR1 = SUB ( )
	$KEY = "HKLM\" & $SYSTEM & $BOOTSYSTEM & $DEF & "\Control\Session Manager\SubSystems"
	If $VAR1 Then
		RESTOREVAL ( $KEY , "Windows" , "REG_EXPAND_SZ" , $VAR1 )
	Else
		FileWrite ( $HFIXLOG , $KEY & "\\Windows => " & $ERRSV & @CRLF )
	EndIf
EndFunc
Func SYSTEMFILE ( $HASH )
	GUICtrlSetData ( $LABEL1 , $SCANB & " " & $FIL1 & ": " & $FILE )
	$FATT = FileGetAttrib ( $FILE )
	$FATT = StringRegExpReplace ( $FATT , "A" , "" )
	If _REPARSEPOINT ( $FILE ) Then $FATT = $FATT & "L"
	$ATT = StringFormat ( "%05s" , $FATT )
	$ATTS = StringRegExpReplace ( $ATT , "0" , "_" )
	$SIZE = FileGetSize ( $FILE )
	$SIZES = StringFormat ( "%09u" , $SIZE )
	$DATECR = FILETIME ( $FILE , 1 )
	$DATEMO = FILETIME ( $FILE )
	$VER = FileGetVersion ( $FILE , "CompanyName" )
	FileWrite ( $FRSTLOG , $FILE & @CRLF & "[" & $DATECR & "] - [" & $DATEMO & "] - " & $SIZES & " " & $ATTS & " (" & $VER & ") " & $HASH & @CRLF & @CRLF )
	If Not StringInStr ( $VER , "Microsoft" ) Then
		Select
		Case _REPARSEPOINT ( $FILE )
			FileWrite ( $FRSTLOG , $FILE & " => ATTENTION: Delete reparsepoint." & @CRLF )
		Case $HASH = "D41D8CD98F00B204E9800998ECF8427E"
			FileWrite ( $FRSTLOG , $FILE & " => D41D8CD98F00B204E9800998ECF8427E (0-byte MD5) <==== " & $UPD1 & @CRLF )
		Case Not $VER
			FileWrite ( $FRSTLOG , $FILE & " => " & $NO & " " & $COMP0 & " <==== " & $UPD1 & @CRLF )
	Case Else
			FileWrite ( $FRSTLOG , $FILE & " => " & $COMP0 & ": " & $VER & " <==== " & $UPD1 & @CRLF )
		EndSelect
	EndIf
EndFunc
Func TASKS32 ( $KEY )
	$HKEY = _REGOPENKEYEX3 ( $KEY )
	If @error Or Not $HKEY Then Return
	$I = 0
	While 1
		$PATH = ""
		$TASK = ""
		$SUB = __REGENUMKEY ( $HKEY , $I )
		If @error Then ExitLoop
		$PATH = RegRead ( $KEY & "\" & $SUB , "Path" )
		If @error = 0 Then
			$TASK = $C & "\Windows\SysWOW64\Tasks" & $PATH
			If Not FileExists ( $TASK ) Then
				$PATH = $PATH & " " & $REGIST8
				FileWrite ( $HADDITION , "Task-x32: " & $SUB & " - " & $PATH & @CRLF )
			Else
				$RTASK = FileRead ( $TASK )
				If StringRegExp ( $RTASK , "(?i)(.+\n)+.+Command>(.+)</Command(.+\n)+.*" ) Then
					$COMM = StringRegExpReplace ( $RTASK , "(?i)(.+\n)+.+Command>(.+)</Command(.+\n)+.*" , "$2" )
					If StringInStr ( $COMM , "(?i)rundll32" ) Then
						If StringRegExp ( $RTASK , "(?i)(.+\n)+.+Arguments>(.+)</Arguments(.+\n)+.*" ) Then
							$COMM1 = StringRegExpReplace ( $RTASK , "(?i)(.+\n)+.+Arguments>(.+)</Arguments(.+\n)+.*" , "$2" )
							$COMM1 = StringRegExpReplace ( $COMM1 , """" , "" )
							$COMM1 = StringRegExpReplace ( $COMM1 , "(?i)([C-Z]:\\.+\.dll).*" , "$1" )
							$FILE = $COMM1
						EndIf
					Else
						$COMM = StringRegExpReplace ( $COMM , """" , "" )
						$COMM = StringRegExpReplace ( $COMM , "(?i)\\ehrec\Z" , "\\ehrec\.exe" )
						$COMM = StringRegExpReplace ( $COMM , "(?i)\\mcupdate\Z" , "\\mcupdate\.exe" )
						$COMM = StringRegExpReplace ( $COMM , "(?i)aitagent\Z" , "aitagent\.exe" )
						$COMM = StringRegExpReplace ( $COMM , "(?i)rundll32\Z" , "rundll32\.exe" )
						$COMM = StringRegExpReplace ( $COMM , "(?i)%CommonProgramFiles%" , $C & "\\Program Files\\Common Files" )
						$COMM = StringRegExpReplace ( $COMM , "(?i)%Systemdrive%" , $C )
						$FILE = $COMM
					EndIf
					AAAAFPWOW ( )
					$TASK = StringRegExpReplace ( $TASK , $C & "\\Windows\\" , "" )
					FileWrite ( $HADDITION , "Task-x32: " & $SUB & " - " & $TASK & " => " & $FILE & " [" & $CDATE & "]" & $COMPANY & @CRLF )
				Else
					$TASK = StringRegExpReplace ( $TASK , $C & "\\Windows\\" , "" )
					FileWrite ( $HADDITION , "Task-x32: " & $SUB & " - " & $TASK & @CRLF )
				EndIf
			EndIf
		EndIf
		$I += 1
	WEnd
	If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
EndFunc
Func TASKSJOBFIX ( )
	$FILEP = StringRegExpReplace ( $FIX , "(?i)Task: ([A-Z]:\\.+) =>.*" , "$1" )
	If $BOOTM = "Recovery" Then
		MOVEFILE ( $FILEP )
	Else
		MOVEFILENORMAL ( $FILEP )
	EndIf
EndFunc
Func TELEPHONY ( $KEY )
	$I = 0
	While 1
		$I += 1
		$VAL = RegEnumVal ( $KEY , $I )
		If @error Then ExitLoop
		If Not StringInStr ( $VAL , "ProviderFileName" ) Then ContinueLoop
		$FILE = RegRead ( $KEY , $VAL )
		If StringInStr ( $KEY , "\wow6432node\" ) Then
			AAAAFPWOW ( )
		Else
			AAAAFP ( )
		EndIf
		If Not FileExists ( $FILE ) Then $COMPANY = " (" & $REGIST8 & ")"
		Select
		Case StringInStr ( $COMPANY , "Microsoft Corp" ) And StringRegExp ( $FILE , "(?i)Windows\\(system32|SysWOW64)\\(unimdm|kmddsp|ndptsp|hidphone|remotesp)\.tsp$" )
		Case StringInStr ( $COMPANY , "Gigaset Communication" ) And StringRegExp ( $FILE , "(?i)Windows\\(system32|SysWOW64)\\GQSTSP\.tsp$" )
	Case Else
			FileWrite ( $HADDITION , $KEY & " => " & $VAL & " -> " & $FILE & $COMPANY & @CRLF )
		EndSelect
	WEnd
EndFunc
Func TIMEA ( $HWND , $IMSG , $IIDTIMER , $ITIME )
	#forceref $hWnd, $iMsg, $iIDTimer, $itime
	FileWrite ( $HFIXLOG , @CRLF & "Fixing is terminated due to reaching maximum fixing time of 60 minutes. <==== " & $UPD1 & @CRLF )
	Exit
EndFunc
Func TOOLBAR ( $KEY )
	Local $CLSID , $VALNAME , $FILEPATH
	$I = 1
	While 1
		GUICtrlSetData ( $LABEL1 , $SCANB & " Internet: " & $KEY )
		$CLSID = RegEnumVal ( $KEY , $I )
		If @error Then ExitLoop
		If StringRegExp ( $CLSID , "\{.+\}" ) Then
			$VALNAME = RegRead ( $REGEXPR & $CLSID , "" )
			If $VALNAME = "" Then $VALNAME = $FF1
			$FILEPATH = RegRead ( $REGEXPR & $CLSID & "\InprocServer32" , "" )
			If StringInStr ( $FILEPATH , "mscoree.dll" ) Then MSCOREE ( $REGEXPR & $CLSID & "\InprocServer32" , $FILEPATH )
			$FILE = $FILEPATH
			$CDATE = ""
			If StringInStr ( $KEY , "Wow6432Node" ) Then
				AAAAFPWOW ( )
			Else
				AAAAFP ( )
			EndIf
			If FileExists ( $FILE ) Then
				$CDATE = " [" & $CDATE & "]"
				$FILEPATH = $FILE
			Else
				$FILEPATH = $FILEPATH & " " & $REGIST8
			EndIf
			FileWrite ( $HADDITION , $HIVE & $VALNAME & " - " & $CLSID & " - " & $FILEPATH & $CDATE & $COMPANY & @CRLF )
		EndIf
		$I = $I + 1
	WEnd
EndFunc
Func TOOLBARFIX ( )
	Local $KEY
	$REGEXPR = "HKLM\Software\Classes\CLSID\"
	If StringInStr ( $FIX , "Toolbar: HKLM " ) Then $KEY = "HKLM\SOFTWARE\Microsoft\Internet Explorer\Toolbar"
	If StringInStr ( $FIX , "Toolbar: HKU\" ) Then
		$USER = StringRegExpReplace ( $FIX , "(?i)Toolbar: HKU\\(.+?) ->.+" , "$1" )
		$KEY = "HKU\" & $USER & "\Software\Microsoft\Internet Explorer\Toolbar\WebBrowser"
	EndIf
	If StringInStr ( $FIX , "Toolbar: HKLM-x32 " ) Then
		$KEY = "HKLM\SOFTWARE\Wow6432Node\Microsoft\Internet Explorer\Toolbar"
		$REGEXPR = "HKLM\Software\Wow6432Node\Classes\CLSID\"
	EndIf
	$VAL = StringRegExpReplace ( $FIX , "[^{]+ ([!]*\{[^{]+\}).*" , "$1" )
	DELVALUE ( $KEY , $VAL )
	$KEY = $REGEXPR & $VAL
	If VAR ( $KEY ) Then DELKEY ( $KEY )
EndFunc
Func UDEBUG ( $KEY )
	$HKEY = _REGOPENKEYEX3 ( $KEY , 1 )
	If @error Or $HKEY = 0 Then Return
	$I = + 4294967295
	While 1
		$I = $I + 1
		$SUB = __REGENUMKEY ( $HKEY , $I )
		If @error Then ExitLoop
		$SKEY = $KEY & "\" & $SUB & "\DebugInformation"
		If RegRead ( $SKEY , "" ) Or @error = + 4294967295 Then
			$SHKEY = _REGOPENKEYEX3 ( $SKEY , 1 )
			If @error Or $HKEY = 0 Then ContinueLoop
			$II = + 4294967295
			While 1
				$II = $II + 1
				$SSUB = __REGENUMKEY ( $SHKEY , $II )
				If @error Then ExitLoop
				$DATA = RegRead ( $SKEY & "\" & $SSUB , "DebugPath" )
				If @error Then ContinueLoop
				$FILE = $DATA
				AAAAFP ( )
				If FileExists ( $FILE ) Then
					$CDATE = " [" & $CDATE & "]"
					$DATA = $FILE
				EndIf
				_ARRAYADD ( $ARRAYREG , $KEY & "\" & $SUB & ": -> " & $DATA & $CDATE & $COMPANY , 0 , "||||" )
			WEnd
		EndIf
	WEnd
	If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
EndFunc
Func UDEBUG0 ( $KEY )
	$HKEY = _REGOPENKEYEX3 ( $KEY , 1 )
	If @error Or $HKEY = 0 Then Return
	$I = 0
	While 1
		$SUB = __REGENUMKEY ( $HKEY , $I )
		If @error Then ExitLoop
		$DATA = RegRead ( $KEY & "\" & $SUB , "" )
		If Not @error Then
			$FILE = $DATA
			AAAAFP ( )
			If FileExists ( $FILE ) Then
				$CDATE = " [" & $CDATE & "]"
				$DATA = $FILE
			EndIf
			_ARRAYADD ( $ARRAYREG , $KEY & "\" & $SUB & ": -> " & $DATA & $CDATE & $COMPANY , 0 , "||||" )
		EndIf
		$I = $I + 1
	WEnd
	If IsPtr ( $HKEY ) Then _REGCLOSE ( $HKEY )
EndFunc
Func UDEBUGFIX ( )
	$KEY = StringRegExpReplace ( $FIX , "([^:]+):.*" , "$1" )
	If StringInStr ( $FIX , "ActivatableClasses\Package" ) Then $KEY = $KEY & "\DebugInformation"
	DELKEY ( $KEY )
EndFunc
Func UNHIDEP ( )
	$UNINS = StringRegExpReplace ( $FIX , ".+\\\.\.\.\\(.+?)\).+" , "$1" )
	$KEY1 = "\Microsoft\Windows\CurrentVersion\Uninstall"
	Select
	Case StringRegExp ( $FIX , "\(HKLM-x32" )
		$KEY = "HKLM\SOFTWARE\Wow6432Node" & $KEY1
	Case StringRegExp ( $FIX , "\(HKU\\" )
		$USER = StringRegExpReplace ( $FIX , ".+?\(HKU\\([^\\]+)\\.+" , "$1" )
		$KEY = "HKU\" & $USER & "\SOFTWARE" & $KEY1
Case Else
		$KEY = "HKLM\SOFTWARE" & $KEY1
	EndSelect
	DELVALUE ( $KEY & "\" & $UNINS , "SystemComponent" )
EndFunc
Func URLSEARCH ( )
	Local $VALURL , $VALNAME
	$KEY1 = "\Microsoft\Internet Explorer\URLSearchHooks"
	If StringInStr ( $HIVE , "HKU\" ) Then $KEY = $HIVE & "\SOFTWARE" & $KEY1
	If $HIVE = "HKLM" Then $KEY = "HKLM\SOFTWARE" & $KEY1
	If $HIVE = "HKLM-x32" Then $KEY = "HKLM\Software\Wow6432Node" & $KEY1
	$DEVALUE = RegRead ( $KEY , "" )
	If $DEVALUE <> "" Then FileWrite ( $HADDITION , "URLSearchHook: " & $HIVE & " -> " & $DEFA & " = " & $DEVALUE & @CRLF )
	$I = 1
	While 1
		GUICtrlSetData ( $LABEL1 , $SCANB & " Internet: " & $KEY & $VALURL )
		$COMPANY = ""
		$VALNAME = ""
		$KEYURL = ""
		$KEYURL32 = ""
		$FILEPATH = ""
		$VALNAME = ""
		$VALURL = RegEnumVal ( $KEY , $I )
		If @error Then ExitLoop
		If StringRegExp ( $VALURL , "\{.+\}" ) Then
			$VALNAME = RegRead ( "HKCR\CLSID\" & $VALURL , "" )
			If @error = 0 Then
				If $VALNAME = "" Then $VALNAME = "(" & $FF1 & ")"
				$FILEPATH = RegRead ( "HKCR\CLSID\" & $VALURL & "\InprocServer32" , "" )
				If StringInStr ( $FILEPATH , "mscoree.dll" ) Then MSCOREE ( "HKCR\CLSID\" & $VALURL & "\InprocServer32" , $FILEPATH )
				$FILE = $FILEPATH
				AAAAFP ( )
				If Not FileExists ( $FILE ) Then
					$FILEPATH = $FILEPATH & " " & $REGIST8
				Else
					$FILEPATH = $FILE
				EndIf
				If GUICtrlRead ( $CHECKBOX11 ) = 1 Then
					If $VALURL <> "{CFBFAE00-17A6-11D0-99CB-00C04FD64497}" Or Not StringInStr ( $FILEPATH , "\System32\ieframe.dll" ) Then FileWrite ( $HADDITION , "URLSearchHook: " & $HIVE & " - " & $VALNAME & " - " & $VALURL & " - " & $FILEPATH & $COMPANY & @CRLF )
				Else
					FileWrite ( $HADDITION , "URLSearchHook: " & $HIVE & " - " & $VALNAME & " - " & $VALURL & " - " & $FILEPATH & $COMPANY & @CRLF )
				EndIf
			Else
				$KEYURL = 1
			EndIf
			$VALNAME = RegRead ( "HKCR\Wow6432Node\CLSID\" & $VALURL , "" )
			If @error = 0 Then
				If $VALNAME = "" Then $VALNAME = "(" & $FF1 & ")"
				$FILEPATH = RegRead ( "HKCR\Wow6432Node\CLSID\" & $VALURL & "\InprocServer32" , "" )
				If StringInStr ( $FILEPATH , "mscoree.dll" ) Then MSCOREE ( "HKCR\Wow6432Node\CLSID\" & $VALURL & "\InprocServer32" , $FILEPATH )
				$FILE = $FILEPATH
				AAAAFPWOW ( )
				If Not FileExists ( $FILE ) Then
					$FILEPATH = $FILEPATH & " " & $REGIST8
				Else
					$FILEPATH = $FILE
				EndIf
				If GUICtrlRead ( $CHECKBOX11 ) = 1 Then
					If $VALURL <> "{CFBFAE00-17A6-11D0-99CB-00C04FD64497}" Or Not StringInStr ( $FILEPATH , "\SysWOW64\ieframe.dll" ) Then FileWrite ( $HADDITION , "URLSearchHook: " & $HIVE & " - " & $VALNAME & " - " & $VALURL & " - " & $FILEPATH & $COMPANY & @CRLF )
				Else
					FileWrite ( $HADDITION , "URLSearchHook: " & $HIVE & " - " & $VALNAME & " - " & $VALURL & " - " & $FILEPATH & $COMPANY & @CRLF )
				EndIf
			Else
				$KEYURL32 = 2
			EndIf
		EndIf
		If $KEYURL = 1 And $KEYURL32 = 2 Then FileWrite ( $HADDITION , "URLSearchHook: " & $HIVE & " - (" & $FF1 & ") - " & $VALURL & " - " & $REGIST8 & @CRLF )
		$I = $I + 1
	WEnd
EndFunc
Func URLSEARCHFIX ( )
	Local $RET , $DEFKEY1 , $CLSID
	$KEY1 = "\Microsoft\Internet Explorer\URLSearchHooks"
	If StringInStr ( $FIX , "HKU\" ) Then
		$USER = StringRegExpReplace ( $FIX , ".+?HKU\\(.+?) .+" , "$1" )
		$DEFKEY1 = "HKU\" & $USER & "\Software" & $KEY1
	EndIf
	If StringInStr ( $FIX , ": HKLM " ) Then $DEFKEY1 = "HKLM\Software" & $KEY1
	If StringInStr ( $FIX , ": HKLM-x32" ) Then $DEFKEY1 = "HKLM\Software\Wow6432Node" & $KEY1
	Select
	Case StringInStr ( $FIX , " => " )
		$RET = RegWrite ( $DEFKEY1 , "{CFBFAE00-17A6-11D0-99CB-00C04FD64497}" , "REG_SZ" , "" )
		Select
		Case $RET = 1
			FileWrite ( $HFIXLOG , $DEFA & " URLSearchHook " & $RESTORED & @CRLF )
		Case $RET = 0
			FileWrite ( $HFIXLOG , $NRESTORE & " " & $DEFA & " URLSearchHook." & @CRLF )
		EndSelect
	Case StringInStr ( $FIX , " -> " )
		$VAL = ""
		DELVALUE ( $DEFKEY1 , $VAL )
Case Else
		If Not StringInStr ( $FIX , "{CFBFAE00-17A6-11D0-99CB-00C04FD64497}" ) Then
			$CLSID = StringRegExpReplace ( $FIX , "URLSearchHook:[^\{]+(\{.+\}).+" , "$1" )
			$KEY = $DEFKEY1
			$VAL = $CLSID
			DELVALUE ( $KEY , $VAL )
			$KEY = $DEFKEY1 & "\" & $CLSID
			If VAR ( $KEY , 1 ) Then DELKEY ( $KEY )
			$KEY = "HKLM\Software\Classes\CLSID\" & $CLSID
			If VAR ( $KEY ) Then DELKEY ( $KEY )
			$KEY = "HKLM\Software\Wow6432Node\Classes\CLSID\" & $CLSID
			If VAR ( $KEY ) Then DELKEY ( $KEY )
		EndIf
	EndSelect
EndFunc
Func USERCHOICEFIX ( )
	$KEY = StringRegExpReplace ( $FIX , "(.+) =>.*" , "$1" )
	DELKEY ( $KEY )
EndFunc
Func USERINIT ( )
	$SYSTEMROOT = RegRead ( "HKLM\" & $SOFTWARE & "\Microsoft\Windows NT\CurrentVersion" , "SystemRoot" )
	If @error Then Return FileWrite ( $HFIXLOG , $FIX & " => " & $NRESTORE & @CRLF )
	RESTOREVAL ( "HKLM\" & $SOFTWARE & "\Microsoft\Windows NT\CurrentVersion\Winlogon" , "Userinit" , "REG_SZ" , $SYSTEMROOT & "\system32\userinit.exe," )
EndFunc
Func USERINIT32 ( )
	$KEY = "HKLM\" & $SOFTWARE & "\WOW6432Node\Microsoft\Windows NT\CurrentVersion\Winlogon"
	If $OSNUM < 10 Then
		RESTOREVAL ( $KEY , "Userinit" , "REG_SZ" , "userinit.exe" )
	Else
		DELVALUE ( $KEY , "Userinit" )
	EndIf
EndFunc
Func USERINITMPR ( $KEY )
	$ATTEN = ""
	$VALDATA = RegRead ( $KEY , "UserInitMprLogonScript" )
	If Not @error Then
		$FILE = $VALDATA
		AAAAFP ( )
		If FileExists ( $FILE ) Then
			$CDATE = " [" & $CDATE & "]"
			$VALDATA = $FILE
		EndIf
		If StringRegExp ( $VALDATA , "(?i)wmiprvse.exe" ) Then $ATTEN = " <==== " & $UPD1
		_ARRAYADD ( $ARRAYREG , $KEY & "\\UserInitMprLogonScript: -> " & $VALDATA & $CDATE & $COMPANY & $ATTEN , 0 , "||||" )
	EndIf
EndFunc
Func USERINITMPRFIX ( )
	If StringInStr ( $FIX , "HKU\" ) Then
		$USER = StringRegExpReplace ( $FIX , "HKU\\([^\\]+)\\.+" , "$1" )
		$KEY = "HKU\" & $USER & "\Environment"
	Else
		$KEY = "HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\Environment"
	EndIf
	DELVALUE ( $KEY , "UserInitMprLogonScript" )
EndFunc
Func USHELL ( )
	$USER = StringRegExpReplace ( $FIX , "(?i)HKU\\(.+?)\\.+Winlogon:.*" , "$1" )
	RELOAD ( $USER )
	$KEY = "HKU\" & $USER & "\Software\Microsoft\Windows NT\CurrentVersion\Winlogon"
	If _CHECKKEYLOCKED ( $KEY ) Then
		$ACCOUNTNAME = _SECURITY__LOOKUPACCOUNTSID ( $USER )
		If IsArray ( $ACCOUNTNAME ) Then $USER = $ACCOUNTNAME [ 0 ]
		_UNLOCK ( $KEY , 4 , "Administrators;System;Users;" & $USER )
	EndIf
	$VAL = "Shell"
	DELVALUE ( $KEY , $VAL )
	REUNLOAD ( $USER )
EndFunc
Func UUSERINIT ( )
	$USER = StringRegExpReplace ( $FIX , "(?i)HKU\\(.+?)\\.+Winlogon:.*" , "$1" )
	RELOAD ( $USER )
	$KEY = "HKU\" & $USER & "\Software\Microsoft\Windows NT\CurrentVersion\Winlogon"
	DELVALUE ( $KEY , "Userinit" )
	REUNLOAD ( $USER )
EndFunc
Func RELOAD ( $UNAME )
	If $BOOTM <> "Recovery" Then Return
	For $P = 1 To UBound ( $ALLUSERS ) + 4294967295
		If StringRegExp ( $ALLUSERS [ $P ] , "\\" & $UNAME & "\Z" ) Then ExitLoop
	Next
	RunWait ( @ComSpec & " /c reg load ""hku\" & $UNAME & """ """ & $ALLUSERS [ $P ] & "\ntuser.dat""" , "" , @SW_HIDE )
EndFunc
Func REUNLOAD ( $UNAME )
	If $BOOTM <> "Recovery" Then Return
	RunWait ( @ComSpec & " /c reg unload ""hku\" & $UNAME & """" , "" , @SW_HIDE )
EndFunc
Func VAR ( $KEY , $CH = "" )
	If Not $KEY Then Return
	$HKEY = 2147483650
	If $CH Then $HKEY = _ROOTHK ( $KEY )
	If Not $HKEY Then Return
	$SUB = StringRegExpReplace ( $KEY , "^[^\\]+\\" , "" )
	$ARET = DllCall ( "advapi32.dll" , "long" , "RegOpenKeyExW" , "hwnd" , $HKEY , "wstr" , $SUB , "dword" , 0 , "dword" , 131097 , "hwnd*" , "" )
	If Not $ARET [ 0 ] Then _REGCLOSE ( $ARET [ 5 ] )
	If Not $ARET [ 0 ] Or $ARET [ 0 ] = 5 Then Return True
EndFunc
Func WALLPAPER ( )
	For $U = 1 To UBound ( $USERREG ) + 4294967295
		If Not StringRegExp ( $USERREG [ $U ] , "(?i)^(S-1-5-19|S-1-5-20|.default)$" ) Then
			$KEY = "HKU\" & $USERREG [ $U ] & "\Control Panel\Desktop"
			$VALDATA = RegRead ( $KEY , "Wallpaper" )
			If Not @error Then FileWrite ( $HADDITION , $KEY & "\\Wallpaper -> " & $VALDATA & @CRLF )
		EndIf
	Next
EndFunc
Func WHITELISTDLL ( )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)\[.+\(Microsoft Corporation\) " & $C & "\\Windows\\(System32|SysWOW64)\\(advapi32|clbcatq|combase|coml2|comdlg32|DifxApi|gdi32|gdiplus|IERTUTIL|IMAGEHLP|IMM32|kernel32|LPK|lz32|MSCTF|MSVCRT|NORMALIZ|NSI|ole32|oleaut32|PSAPI|rpcrt4|sechost|Setupapi|shell32|SHLWAPI|url|urlmon|user32|USP10|version|wininet|wldap32|Wow64|Wow64cpu|Wow64win|WS2_32|SHCORE|wowarmhw).dll\v{2}" , "" )
EndFunc
Func WHITELISTDRV ( )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][12345] BattC; " & $C & "\\Windows\\system32\\Drivers\\BattC.sys \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] 5U877; " & $C & "\\Windows\\System32\\Drivers\\5U877.sys \[.+\] \(Ricoh.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] Winsock; " & $NO & " ImagePath\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] Acceler; " & $C & "\\Windows\\System32\\DRIVERS\\(Accelern|Acceler).sys \[.+\] \(ST Microele.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] acedrv11; " & $C & "\\Windows\\System32\\Drivers\\acedrv11.sys \[.+\] \(Protect.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (arc|arcsas|ADP80XX); " & $C & "\\Windows\\System32\\Drivers\\(arc|arcsas|ADP80XX).sys \[.+\] \(Microsoft Windows -> PMC.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] adfs; " & $C & "\\Windows\\(System32|SysWow64)\\drivers\\adfs.sys \[.+\] \(Adobe.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (Afc|ARCVCAM); " & $C & "\\Windows\\SysWow64\\drivers\\(Afc|ArcSoftVCapture).sys \[.+\] \(Arcsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] AF15BDA; " & $C & "\\Windows\\System32\\Drivers\\AF15BDA.sys \[.+\] \(ITETech.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] AFS; " & $C & "\\Windows\\SysWow64\\Drivers\\AFS.sys \[.+\] \(Oak.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] AgereSoftModem; " & $C & "\\Windows\\System32\\DRIVERS\\agrsm64.sys \[.+\] \((Agere|LSI).+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (aksdf|aksfridge); " & $C & "\\Windows\\System32\\Drivers\\(aksdf|aksfridge).sys \[.+\] \(SafeNet.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] aliide; " & $C & "\\Windows\\System32\\drivers\\aliide.sys \[.+\] \(Microsoft Windows -> Acer Laboratories.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] amdkmdag; " & $C & "\\Windows\\System32\\DRIVERS\\atikmdag.sys \[.+\] \((Microsoft|ATI Technologies).+-> ATI .+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (AmdLLD64|amdsbs); " & $C & "\\Windows\\System32\\DRIVERS\\(AmdLLD64|amdsbs).sys \[.+\] \(Microsoft Windows -> AMD.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] AmUStor; " & $C & "\\Windows\\System32\\drivers\\AmUStor.SYS \[.+\] \(AlcorMicro, Corp. -> Alcor Micro.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] androidusb; " & $C & "\\Windows\\System32\\Drivers\\androidusb.sys \[.+\] \(HTC.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] ADIHdAudAddService; " & $C & "\\Windows\\System32\\drivers\\ADIHdAud.sys \[.+\] \(Analog.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] androidusb; " & $C & "\\Windows\\System32\\Drivers\\ssadadb.sys \[.+\] \(google.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] ApfiltrService; " & $C & "\\Windows\\System32\\DRIVERS\\Apfiltr.sys \[.+\] \(Alps.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (AiCharger|AsDsm); " & $C & "\\Windows\\System32\\Drivers\\(AsDsm|AiCharger).sys \[.+\] \(ASUS.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (asmthub3|asmtxhci); " & $C & "\\Windows\\System32\\Drivers\\(asmthub3|asmtxhci).sys \[.+\] \(ASMedia.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] ASTRA64; " & $C & "\\Program Files(| \(x86\))\\ASTRA32\\ASTRA64.sys \[.+\] \(Licensed.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] ATSwpWDF; " & $C & "\\Windows\\System32\\Drivers\\ATSwpWDF.sys \[.+\] \(AuthenTec.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] BazisVirtualCDBus; " & $C & "\\Windows\\System32\\Drivers\\BazisVirtualCDBus.sys \[.+\] \(SysProgs.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (BthAudioHF|csr_a2dp); " & $C & "\\Windows\\System32\\Drivers\\(BthAudioHF|bthav).sys \[.+\] \((Sonic|CSR).*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] busenum; " & $C & "\\Windows\\System32\\DRIVERS\\SteelBus64.sys \[.+\] \(SteelSeries.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] BVRPMPR5a64; " & $C & "\\Windows\\system32\\drivers\\BVRPMPR5a64.SYS \[.+\] \(Avanquest.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] Cam5607; " & $C & "\\Windows\\System32\\Drivers\\BisonC07.sys \[.+\] \(Bison.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (CipcCdp|CVirtA|acsock); " & $C & "\\Windows\\System32\\Drivers\\(CipcCdp|CVirtA64|acsock64).sys \[.+\] \(Cisco.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] chdrvr0\d; " & $C & "\\Windows\\System32\\Drivers\\chdrvr0\d.sys \[.+\] \(CH.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (cht4iscsi|cht4vbd); " & $C & "\\Windows\\System32\\Drivers\\(cht4sx64|cht4vx64).sys \[.+\] \(Microsoft Windows -> Chelsio.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] CirrusFilter; " & $C & "\\Windows\\System32\\DRIVERS\\CS420x64.sys \[.+\] \(Cirrus.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] CLFS; " & $C & "\\Windows\\System32\\CLFS.sys \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] cmdide; " & $C & "\\Windows\\System32\\drivers\\cmdide.sys \[.+\] \(Microsoft Windows -> CMD Technology.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (CompositeBus|swenum|BasicDisplay|BasicRender); " & $C & "\\Windows\\System32\\DriverStore\\FileRepository\\(compositebus|swenum|BasicRender|BasicDisplay).+?\\(CompositeBus|swenum|BasicDisplay|BasicRender).sys \[.+\] \(Microsoft.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] cpuz135; " & $C & "\\windows\\system32\\drivers\\cpuz135_x64.sys \[.+\] \(CPUID.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] ctxusbm; " & $C & "\\Windows\\System32\\Drivers\\ctxusbm.sys \[.+\] \(Citrix.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (dalwdmservice|DigiNet); " & $C & "\\Windows\\System32\\drivers\\(dalwdm|DigiNet).sys \[.+\] \(Digidesign.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (danewFltr|rzudd); " & $C & "\\Windows\\System32\\drivers\\(danew|rzudd).sys \[.+\] \(Razer.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] DCamUSBEMPIA; " & $C & "\\Windows\\System32\\DRIVERS\\emDevice64.sys \[.+\] \(eMPIA.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (DefragFS|PDFSFilter); " & $C & "\\Windows\\System32\\Drivers\\(DefragFS|PDFSFilter).sys \[.+\] \(Raxco.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (DG003|DigiNet|DELTAII); " & $C & "\\Windows\\System32\\Drivers\\(DG003|DigiNet|MAudioDelta).sys \[.+\] \(Avid.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] DiskSec; " & $C & "\\Windows\\SysWow64\\Drivers\\DiskSec.sys \[.+\] \(MAGIX.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] DKbFltr; " & $C & "\\Windows\\SysWow64\\Drivers\\DKbFltr.sys \[.+\] \(Dritek.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (dlkmd|dlkmdldr); " & $C & "\\Windows\\System32\\Drivers\\(dlkmd|dlkmdldr).sys \[.+\] \(DisplayLink.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] DNE; " & $C & "\\Windows\\System32\\DRIVERS\\dne64x.sys \[.+\] \(Deterministic.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] driverhardwarev2x64; " & $C & "\\Program Files\\ma-config.com\\Drivers\\driverhardwarev2x64.sys \[.+\] \(CybelSoft.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] DrvAgent64; " & $C & "\\Windows\\SysWow64\\Drivers\\DrvAgent64.sys \[.+\] \(Phoenix.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (dsNcAdpt|NEOFLTR_650_1....); " & $C & "\\Windows\\System32\\Drivers\\(dsNcAdpt|NEOFLTR_650_1....).sys \[.+\] \(Juniper.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (dsnpfd|dsnpfdMP); " & $C & "\\Windows\\System32\\Drivers\\dsnpfd.sys \[.+\] \(DeskSoft.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] DVMIO; " & $C & "\\Program Files(| \(x86\))\\Dell Precision ON Flash\\config\\dvmio_x64.sys \[.+\] \(DeviceVM.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (b06bdrv|ebdrv0?); " & $C & "\\Windows\\System32\\Drivers\\(bxvbda|evbd0?a).sys \[.+\] \(Microsoft Windows -> (QLogic|Marvell).+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] ElbyCDIO; " & $C & "\\Windows\\System32\\Drivers\\ElbyCDIO.sys \[.+\] \(Elaborate.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] elxstor; " & $C & "\\Windows\\System32\\DRIVERS\\elxstor.sys \[.+\] \(Microsoft Windows -> Emulex.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] EMSC; " & $C & "\\Windows\\SysWow64\\Drivers\\EMSC.sys \[.+\] \(Windows.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (enecir|enecirhid|enecirhidma); " & $C & "\\Windows\\System32\\Drivers\\(enecir|enecirhid|enecirhidma).sys \[.+\] \(ENE.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] emAudio; " & $C & "\\Windows\\System32\\drivers\\emAudio64.sys \[.+\] \(eMPIA.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] ETD; " & $C & "\\Windows\\System32\\DRIVERS\\ETD.sys \[.+\] \(ELAN Microelectronic.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] EuMusDesignVirtualAudioCableWdm; " & $C & "\\Windows\\System32\\DRIVERS\\vrtaucbl.sys \[.+\] \(Eugene.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (EtronHub3|EtronXHCI); " & $C & "\\Windows\\System32\\Drivers\\(EtronHub3|EtronXHCI).sys \[.+\] \(Etron.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (EUBAKUP|EUDSKACS|EUFDDISK); " & $C & "\\Windows\\System32\\Drivers\\(EUBAKUP|EUDSKACS|EUFDDISK).sys \[.+\] \(CHENGDU.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] FACAP; " & $C & "\\Windows\\System32\\DRIVERS\\facap.sys \[.+\] \(Sensible Vision.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] FiltUSBEMPIA; " & $C & "\\Windows\\System32\\DRIVERS\\emFilter64.sys \[.+\] \(eMPIA.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] FLxHCI(c|h); " & $C & "\\Windows\\System32\\Drivers\\FLxHCI(c|h).sys \[.+\] \(Fresco.+-> Fresco.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (FNETTBOH_305|FNETURPX); " & $C & "\\Windows\\System32\\Drivers\\(FNETTBOH_305|FNETURPX).sys \[.+\] \(FNet Software.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (FTDIBUS|FTSER2K); " & $C & "\\Windows\\System32\\Drivers\\(FTDIBUS|FTSER2K).sys \[.+\] \(FTDI.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (fspad_wlh64|fspad_xp64); " & $C & "\\Windows\\System32\\Drivers\\(fspad_wlh64|fspad_xp64).sys \[.+\] \(Sentelic.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] GEARAspiWDM; " & $C & "\\Windows\\System32\\DRIVERS\\GEARAspiWDM.sys \[.+\] \(GEAR Software.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (akshasp|akshhl|aksusb|aksdf|aksfridge|Hardlock); " & $C & "\\Windows\\System32\\Drivers\\(akshasp|akshhl|aksusb|aksdf|aksfridge|Hardlock).sys \[.+\] \(Aladdin.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] grmnusb; " & $C & "\\Windows\\System32\\Drivers\\grmnusb.sys \[.+\] \(GARMIN.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] gttap1; " & $C & "\\Windows\\System32\\Drivers\\gttap1.sys \[.+\] \(The OpenVPN.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (hamachi|lmimirr|LMIRfsDriver); " & $C & "\\Windows\\System32\\Drivers\\(hamachi|lmimirr|LMIRfsDriver).sys \[.+\] \(LogMeIn.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] hidflt; " & $C & "\\Windows\\System32\\DRIVERS\\ETDUSB.sys \[.+\] \(ELAN.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] HssDrv; " & $C & "\\Windows\\System32\\drivers\\HssDrv.sys \[.+\] \(AnchorFree.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] HTCAND64; " & $C & "\\Windows\\System32\\Drivers\\ANDROIDUSB.sys \[.+\] \(HTC.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] hwinterface; " & $C & "\\Windows\\SysWow64\\Drivers\\hwinterface.sys \[.+\] \(Logix4u.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (ewusbmbb|ew_usbenumfilter|hwdatacard|hwusbfake|ew_hwusbdev|huawei_cdcacm|huawei_cdcecm|huawei_enumerator|huawei_ext_ctrl); " & $C & "\\Windows\\System32\\DRIVERS\\(ewusbmdm|ewusbfake|ew_usbenumfilter|ewusbwwan|ew_hwusbdev|ew_jucdcacm|ew_jucdcecm|ew_jubusenum|ew_juextctrl).sys \[.+\] \(Huawei.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] IDMWFP; " & $C & "\\Windows\\System32\\Drivers\\IDMWFP.sys \[.+\] \(Tonec.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] itecir; " & $C & "\\Windows\\System32\\Drivers\\itecir.sys \[.+\] \(ITE.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] int15; " & $C & "\\Windows\\SysWOW64\\drivers\\int15_64.sys \[.+\] \(Acer.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (iteatapi|iteraid); " & $C & "\\Windows\\System32\\drivers\\(iteatapi|iteraid).sys \[.+\] \(Microsoft Windows -> Integrated.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] ivusb; " & $C & "\\Windows\\System32\\Drivers\\ivusb.sys \[.+\] \(Initio.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (JMCR|JME|JRAID); " & $C & "\\Windows\\System32\\DRIVERS\\(jmcr|JME|JRAID).sys \[.+\] \(JMicron.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (HCW88AUD|HCW88BDA|HCW88TSE|HCW88TUNE|hcw88vid|HCW88XBAR|hcw85cir|HCW85BDA); " & $C & "\\Windows\\System32\\drivers\\(HCW88AUD|HCW88BDA|HCW88TSE|HCW88TUNE|hcw88vid|HCW88XBAR|hcw85cir|hcw88tun|HCW88BAR|HCW85BDA).sys \[.+\] \(Microsoft Windows -> Hauppauge.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] Leapfrog-USBLAN; " & $C & "\\Windows\\System32\\DRIVERS\\btblan.sys \[.+\] \(Belcarra.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (CeKbFilter|LPCFilter); " & $C & "\\Windows\\System32\\DRIVERS\\(CeKbFilter|LPCFilter).sys \[.+\] \(COMPAL.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] MADFUXPONENT; " & $C & "\\Windows\\System32\\DRIVERS\\MAudioXponent_DFU.sys \[.+\] \(M-Audio.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (Magic Tune|SSPORT); " & $C & "\\Windows\\System32\\Drivers\\(MtiCtwl|SSPORT).sys \[.+\] \(Samsung.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] ManyCam; " & $C & "\\Windows\\System32\\DRIVERS\\ManyCam_x64.sys \[.+\] \(ManyCam.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] massfilter; " & $C & "\\Windows\\System32\\Drivers\\massfilter.sys \[.+\] \(MBB.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] MAUSBXPONENT; " & $C & "\\Windows\\System32\\DRIVERS\\MAudioXponent.sys \[.+\] \(Avid.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (PinnacleMarvinAVS|MarvinBus); " & $C & "\\Windows\\System32\\DRIVERS\\(MarvinAVS64|MarvinBus64).sys \[.+\] \(Pinnacle.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] mcdbus; " & $C & "\\Windows\\(System32|SysWOW64)\\DRIVERS\\mcdbus.sys \[.+\] \(MagicISO.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] SmartSAMD; " & $C & "\\Windows\\System32\\Drivers\\SmartSAMD.sys \[.+\] \(Microsoft Windows -> Microsemi .+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] SurfaceAccessoryDevice; " & $C & "\\Windows\\System32\\Drivers\\SurfaceAccessoryDevice.sys \[.+\] \(OEMTest -> Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (mobiolavs|MOBIOLA_Wave); " & $C & "\\Windows\\System32\\Drivers\\(mobiolavs|mobiolawave).sys \[.+\] \(SHAPE.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] MotioninJoyXFilter; " & $C & "\\Windows\\System32\\DRIVERS\\MijXfilt.sys \[.+\] \(MotioninJoy.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (MREMP50|MRESP50|MREMP50a64|MRESP50a64|PcaSp50); " & $C & "\\PROGRA~2\\COMMON~1\\Motive\\(MREMP50|MRESP50|MREMP50a64|MRESP50a64|PcaSp50).SYS \[.+\] \(Printing.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (ATP|MTsensor|HIDSwitch); " & $C & "\\Windows\\System32\\DRIVERS\\(AsHIDSwitch64|ATK64AMD).sys \[.+\] \(ASUS.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (ATKWMIACPIIO|ASMMAP64); " & $C & "\\Program Files(| \(x86\))\\ASUS\\ATK Package\\(ATKGFNEX|ATK WMIACPI)\\(ASMMAP64|atkwmiacpi64).sys \[.+\] \(ASUS.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (NBVol|NBVolUp); " & $C & "\\Windows\\System32\\Drivers\\(NBVol|NBVolUp|AsusTP).sys \[.+\] \(Nero.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] nfrd960; " & $C & "\\Windows\\System32\\DRIVERS\\nfrd960.sys \[.+\] \(Microsoft Windows -> IBM.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (NLNdisMP|NLNdisPT); " & $C & "\\Windows\\System32\\DRIVERS\\nlndis.sys \[.+\] \(Locktime.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] nltdi; " & $C & "\\Programme\\NetLimiter .\\nltdi.sys \[.+\] \(Locktime.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] NTIDrvr; " & $C & "\\Windows\\system32\\drivers\\NTIDrvr.sys \[.+\] \(NewTech.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (NTIDrvr|UBHelper); " & $C & "\\Windows\\System32\\Drivers\\(NTIDrvr|UBHelper).sys \[.+\] \(NTI.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] ntk_dtv; " & $C & "\\Program Files(| \(x86\))\\DirecTV\\DirecTV\\Kernel\\DMP\\ntk_dtv_64.sys \[.+\] \(Cyberlink.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] ntk_PowerDVD; " & $C & "\\Program Files(| \(x86\))\\CyberLink\\PowerDVD11\\Kernel\\DMP\\ntk_PowerDVD_64.sys \[.+\] \(Cyberlink.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (r|n)(usb3hub|usb3xhc); " & $C & "\\Windows\\System32\\DRIVERS\\(r|n)(usb3hub|usb3xhc).sys \[.+\] \((Renesas|NEC).+-> (Renesas|NEC).*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] nuviocir; " & $C & "\\Windows\\System32\\DRIVERS\\nuviocir_win7_x64.sys \[.+\] \(Nuvoton.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (OlyCamComm|VNUSB); " & $C & "\\Windows\\System32\\DRIVERS\\OlyCamComm.sys \[.+\] \(OLYMPUS.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] VNUSB; " & $C & "\\Windows\\SysWow64\\Drivers\\VNUSB.sys \[.+\] \(OLYMPUS.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (optousb|optovcm); " & $C & "\\Windows\\System32\\Drivers\\(optousb|optovcm).sys \[.+\] \(OPTO.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] P1370Vfx; " & $C & "\\Windows\\System32\\Drivers\\P1370Vfx.sys \[.+\] \(EyePower.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] Packet; " & $C & "\\Windows\\(System32|SysWow64)\\Drivers\\Packet.sys \[.+\] \(SingleClick.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] PBADRV; " & $C & "\\Windows\\System32\\Drivers\\(PBADRV|V64).sys \[.+\] \(Dell.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] PcaSp60; " & $C & "\\Windows\\System32\\Drivers\\PcaSp60.sys \[.+\] \(Printing.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] pcouffin; " & $C & "\\Windows\\System32\\Drivers\\pcouffin.sys \[.+\] \(VSO.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] pfc; " & $C & "\\Windows\\System32\\Drivers\\pfc.sys \[.+\] \(Padus.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] pfmfs_359; " & $C & "\\Windows\\System32\\Drivers\\pfmfs_359.sys \[.+\] \(Pismo.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] pnarp; " & $C & "\\Windows\\System32\\DRIVERS\\pnarp.sys \[.+\] \(Pure.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (pneteth|pnetmdm); " & $C & "\\Windows\\System32\\DRIVERS\\(pneteth|pnetmdm64).sys \[.+\] \(June.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] PSI; " & $C & "\\Windows\\System32\\DRIVERS\\psi_mf.sys \[.+\] \(Secunia.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] PSSDK42; " & $C & "\\Windows\\System32\\Drivers\\PSSDK42.sys \[.+\] \(microOLAP.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (PTSimBus|PTSimHid); " & $C & "\\Windows\\System32\\Drivers\\(PTSimBus|PTSimHid).sys \[.+\] \(PenTablet.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] purendis; " & $C & "\\Windows\\System32\\DRIVERS\\purendis.sys \[.+\] \(Pure.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] pwipf6; " & $C & "\\Windows\\System32\\DRIVERS\\pwipf6.sys \[.+\] \(Privacyware.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] PxHlpa64; " & $C & "\\Windows\\System32\\Drivers\\PxHlpa64.sys \[.+\] \((Sonic|Rovi).*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (qicflt|ql2300|ql40xx); " & $C & "\\Windows\\System32\\DRIVERS\\(qicflt|ql2300|ql40xx).sys \[.+\] \(Microsoft Windows -> (QLogic|Quanta).+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] qrkis; " & $C & "\\Windows\\System32\\DRIVERS\\qrkis.sys \[.+\] \(Tether.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] Qcamain10x64; " & $C & "\\Windows\\System32\\DRIVERS\\Qcamain10x64.sys \[.+\] \(Microsoft Windows -> Qualcomm .*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] regi; " & $C & "\\Windows\\System32\\Drivers\\regi.sys \[.+\] \(InterVideo.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] Revoflt; " & $C & "\\Windows\\System32\\Drivers\\Revoflt.sys \[.+\] \(VS Revo.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234](RimUsb|RimVSerPort); " & $C & "\\Windows\\System32\\Drivers\\(RimUsb|RimSerial)_AMD64.sys \[.+\] \(Research.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] RTL8187B; " & $C & "\\Windows\\System32\\DRIVERS\\wg111v3.sys \[.+\] \(NETGEAR.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] S3XXx64; " & $C & "\\Windows\\System32\\Drivers\\S3XXx64.sys \[.+\] \(SCM.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] SABI; " & $C & "\\Windows\\System32\\Drivers\\SABI.sys \[.+\] \(SAMSUNG.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] SANDRA; " & $C & "\\Program Files\\SiSoftware\\SiSoftware Sandra Lite 201..SP..\\WNt500x64\\Sandra.sys \[.+\] \(SiSoftware.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] ScanUSBEMPIA; " & $C & "\\Windows\\System32\\DRIVERS\\emScan64.sys \[.+\] \(eMPIA Technology.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] SCManager; " & $C & "\\Program Files(| \(x86\))\\SafeConnect\\scManager.sys .* \[.+\] \(Impulse.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] SCDEmu; " & $C & "\\Windows\\System32\\Drivers\\SCDEmu.sys \[.+\] \(Power.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] ScreamBAudioSvc; " & $C & "\\Windows\\System32\\drivers\\ScreamingBAudio64.sys \[.+\] \(Screaming.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] secdrv; " & $C & "\\Windows\\System32\\Drivers\\secdrv.sys \[.+\] \(Microsoft Windows -> Macrovision.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] Ser2pl; " & $C & "\\Windows\\system32\\drivers\\ser2pl64.sys \[.+\] \(Prolific.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] sfhlp02; " & $C & "\\Windows\\System32\\Drivers\\sfhlp02.sys \[.+\] \(Protection.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] SiSRaid[24]; " & $C & "\\Windows\\System32\\DRIVERS\\SiSRaid[24].sys \[.+\] \(Microsoft Windows -> Silicon.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] Soluto; " & $C & "\\Windows\\System32\\Drivers\\Soluto.sys \[.+\] \(Soluto.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] speedfan; " & $C & "\\Windows\\SysWow64\\speedfan.sys \[.+\] \(Almico.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (stdflt|stdcfltn); " & $C & "\\Windows\\System32\\DRIVERS\\(stdcfltn|stdflt|stdfltn).sys \[.+\] \(ST Microelectronics\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] stdriver; " & $C & "\\Windows\\System32\\DRIVERS\\stdriver64.sys \[.+\] \(NCH.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] stexstor; " & $C & "\\Windows\\System32\\DRIVERS\\stexstor.sys \[.+\] \(Microsoft Windows -> Promise.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] STHDA; " & $C & "\\Windows\\System32\\DRIVERS\\stwrt64.sys \[.+\] \(IDT.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] StkCMini; " & $C & "\\Windows\\System32\\Drivers\\StkCMini.sys \[.+\] \(Syntek.\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] StMp3Recx64; " & $C & "\\Windows\\System32\\Drivers\\StMp3Recx64.sys \[.+\] \(Generic.\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] SWMX00; " & $C & "\\Windows\\System32\\DRIVERS\\swmx00.sys \[.+\] \(Sierra.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] SynasUSB; " & $C & "\\Windows\\System32\\DRIVERS\\SynUSB64.sys \[.+\] \(SIA*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] tap0901; " & $C & "\\Windows\\System32\\Drivers\\tap0901.sys \[.+\] \(The.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] taphss; " & $C & "\\Windows\\System32\\Drivers\\taphss.sys \[.+\] \(AnchorFree.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] tbhsd; " & $C & "\\Windows\\System32\\Drivers\\tbhsd.sys \[.+\] \(RapidSolution.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (TClass2k|UCTblHid); " & $C & "\\Windows\\System32\\Drivers\\(TClass2k|UCTblHid).sys \[.+\] \(Tablet.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] TcUsb; " & $C & "\\Windows\\System32\\Drivers\\tcusb.sys \[.+\] \(UPEK.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (MonitorFunction|teamviewervpn); " & $C & "\\Windows\\System32\\Drivers\\(TVMonitor|teamviewervpn).sys \[.+\] \(TeamViewer.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] TFsExDisk; " & $C & "\\Windows\\(System32|SysWow64)\\Drivers\\TFsExDisk.sys \[.+\] \(Teruten.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (SilvrLnk|TIEHDUSB|tihub3|tixhci); " & $C & "\\Windows\\System32\\Drivers\\(SilvrLnk|TIEHDUSB|tihub3|tixhci).sys \[.+\] \(Texas.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] Tpkd; " & $C & "\\Windows\\System32\\Drivers\\Tpkd.sys \[.+\] \(PACE.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] TVicPort64; " & $C & "\\Windows\\System32\\Drivers\\TVicPort64.sys \[.+\] \(EnTech.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] truecrypt; " & $C & "\\Windows\\System32\\drivers\\truecrypt.sys \[.+\] \(TrueCrypt.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] UBHelper; " & $C & "\\Windows\\system32\\drivers\\UBHelper.sys \[.+\] \(NewTech.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] uliahci; " & $C & "\\Windows\\System32\\drivers\\uliahci.sys \[.+\] \(Microsoft Windows -> ULI.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (UlSata|ulsata2); " & $C & "\\Windows\\System32\\drivers\\(ulsata|ulsata2).sys \[.+\] \(Microsoft Windows -> Promise.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] UltraMonUtility; " & $C & "\\Program Files(| \(x86\))\\Common Files\\Realtime Soft\\UltraMonMirrorDrv\\x64\\UltraMonUtility.sys \[.+\] \(Realtime.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] USB28xx(BGA|OEM); " & $C & "\\Windows\\System32\\DRIVERS\\em(BDA|OEM)64.sys \[.+\] \(eMPIA.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] UsbFltr; " & $C & "\\Windows\\System32\\Drivers\\UsbFltr.sys \[.+\] \(Waytech.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] USBPNPA; " & $C & "\\Windows\\System32\\drivers\\CM10864.sys \[.+\] \(C-Media.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] UVCFTR; " & $C & "\\Windows\\System32\\Drivers\\UVCFTR_S.SYS \[.+\] \(Chicony.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (VBoxDrv|VBoxNetAdp|VBoxNetFlt|VBoxUSBMon); " & $C & "\\Windows\\System32\\DRIVERS\\(VBoxDrv|VBoxNetAdp|VBoxNetFlt|VBoxUSBMon).sys \[.+\] \(Oracle Corporation -> Oracle.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] VBoxDrv; " & $C & "\\Program Files(| \(x86\))\\YouWave_Android\\vb\\VBoxDrv.sys \[.+\] \(Oracle Corporation -> Oracle.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] vcd10bus; " & $C & "\\Windows\\System32\\Drivers\\vcd10bus.sys \[.+\] \(H\+H.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] VClone; " & $C & "\\Windows\\System32\\DRIVERS\\VClone.sys \[.+\] \(Elaborate.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] VirtDiskBus; " & $C & "\\Windows\\System32\\DRIVERS\\VirtDiskBus64.sys \[.+\] \(Giga.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] VirtuWDDM; " & $C & "\\Windows\\System32\\Drivers\\VirtuWDDM.sys \[.+\] \(Lucidlogix.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (vflt|vnet); " & $C & "\\Windows\\System32\\DRIVERS\\(vfilter|virtualnet).sys \[.+\] \(Shrew.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (vm2uvcflt|vm332avs); " & $C & "\\Windows\\System32\\Drivers\\(vm2uvcflt|vm332avs).sys \[.+\] \(Vimicro.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] vncmirror; " & $C & "\\Windows\\System32\\Drivers\\vncmirror.sys \[.+\] \(RealVNC.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] vodafone_K3805-z_dc_enum; " & $C & "\\Windows\\System32\\Drivers\\vodafone_K3805-z_dc_enum.sys \[.+\] \(Vodafone.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][0] volsnap; " & $C & "\\Windows\\System32\\drivers\\volsnap.sys \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (CipcCdp|pnarp|purendis|vpnva); " & $C & "\\Windows\\System32\\DRIVERS\\(CipcCdp|pnarp|purendis|vpnva64).sys \[.+\] \(Cisco Systems.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] VSPerfDrv100; " & $C & "\\Program Files(| \(x86\))\\Microsoft Visual Studio 1..0\\Team Tools\\Performance Tools\\x64\\VSPerfDrv1.0.sys \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] wanatw; " & $C & "\\Windows\\System32\\DRIVERS\\wanatw64.sys \[.+\] \(America.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] WDC_SAM; " & $C & "\\Windows\\System32\\DRIVERS\\wdcsam64.sys \[.+\] \(Western.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] wdfsgusbV3; " & $C & "\\Windows\\System32\\DRIVERS\\wdfsgusb.sys \[.+\] \(Stenograph.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] WFLR6654; " & $C & "\\Windows\\System32\\drivers\\wfeaglxt.sys \[.+\] \(Leadtek.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] WinRing0_1_2_0; " & $C & "\\Program Files(| \(x86\))\\IObit\\Game Booster\\Driver\\WinRing0x64.sys \[.+\] \(OpenLibSys.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[U][01234] Winsock;  " & $NO & " ImagePath\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] WsAudio_DeviceS\((1|2|3|4|5)\); " & $C & "\\Windows\\System32\\Drivers\\WsAudio_DeviceS\((1|2|3|4|5)\).sys \[.+\] \(Wondershare.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (clwvd|wsvd|CLVirtualDrive); " & $C & "\\Windows\\System32\\Drivers\\(clwvd|wsvd|CLVirtualDrive).sys \[.+\] \(CyberLink Corp. -> CyberLink.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] xcbdaNtsc; " & $C & "\\Windows\\System32\\DRIVERS\\xcbdax64.sys \[.+\] \(ViXS.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (AX88179|AX88772); " & $C & "\\Windows\\System32\\DRIVERS\\(AX88772|ax88179_178a).sys \[.+\] \(Microsoft .+ -> ASIX.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] dg_ssudbus; " & $C & "\\Windows\\System32\\DRIVERS\\ssudbus.sys \[.+\] \(Samsung .+-> Samsung.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] VirtualButtons; " & $C & "\\Windows\\System32\\DRIVERS\\VirtualButtons.sys \[.+\] \(Softeq .+-> Softeq .*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] ScrHIDDriver2; " & $C & "\\Windows\\System32\\DRIVERS\\ScrHIDDriver2.sys \[.+\] \(Screenovate .+-> Screenovate .*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (afcdp|vididr|vidsflt67|snapman|tdrpman273|tdrpman|tifsfilter|timounter); " & $C & "\\Windows\\System32\\Drivers\\(afcdp|vididr|vsflt67|snapman|tdrpman|tdrpm273|tifsfilt|timntr).sys \[.+\] \(Acronis.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (amdgpio2|adp94xx|adpahci|adpu160m|adpu320|aic78xx|arc|arcsas); " & $C & "\\Windows\\System32\\DRIVERS\\(amdgpio2|adp94xx|adpahci|adpu160m|adpu320|djsvs|arc|arcsas).sys \[.+\] \(Microsoft Windows -> Adaptec.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (AMDRyzenMasterDriver(|V\d+)|amdxhci|stormmc|amdide64|amdefix|AMDCIR64|AmdSMBus|AmdGpio|amdlog|amdsfhkmdf|amdsfhspbi2c|amduart|AmdAS4|AMDPCIDev|amdkmcsp|amdkmpfd|AMDHDAudBusService|amdfendr|amdpsp|amdacpbus|amdacpksl|amdgpio\d|amdi2c|ahcix64s|PCORE|amdiox64|AmdLLD64|amdhub\d+|ahcix64|amdkmdag|amdkmdap|amdsata|amdxhc|amdxata|amd_sata|amd_xata|AtiHDAudioService|atikmdag|AtiPcie|R300|usbfilter); " & $C & "\\Windows\\System32\\(DRIVERS|DriverStore\\FileRepository\\.+)\\(amdxhci|stormmc|amdide64|amdefix|AMDCIR64|AmdSMBus|AmdGpio|amdlog|amdsfhkmdf|amdsfhspbi2c|amduart|amdsfhkmdfi2c|AmdAS4|AMDPCIDev|amdkmcsp|amdkmpfd|amdhdaudbus|amdfendr|amdpsp|amdacpbus|amdacpksl|amdgpio\d|amdi2c|ahcix64s|ahcix64|AmdLLD64|amdhub\d+|amdiox64|amdkmdag|amdsata|amd_sata|amdxata|amdxhc|PCORE|amd_xata|AtihdLH6|AtihdW\w{2}|atikmdag|atikmpag|AtiPcie|AtiPcie64|usbfilter|AMDRyzenMasterDriver).sys \[.+\] \((Microsoft|Advanced|AMD).+-> (Advanced|AMD).+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] AODDriver4.(01|2); " & $C & "\\Program Files\\ATI Technologies\\ATI.ACE\\Fuel\\amd64\\AODDriver2.sys \[.+\] \(Advanced.*-> (Advanced|AMD).+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (AmdMicroPEP|amdhub31|amdxhc31|rcbottom|rccfg|rcraid); " & $C & "\\Windows\\System32\\(DRIVERS|DriverStore\\FileRepository\\.+)\\(AmdMicroPEP|amdhub31|amdxhc31|rcbottom|rccfg|rcraid).sys \[.+\] \((Advanced|AMD|SEAGATE|Dot Hill|ASMedia|Microsoft).+-> (Advanced|AMD).+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (AMDRyzenMasterDriver(|V\d+|\d.\d.\d)|AMDRyzenMasterDriverForROGGC); " & $C & "\\Program Files(| \(x86\))\\(AMD|ASUS|GIGABYTE|ASRock Utility)\\.+\\AMDRyzenMasterDriver.sys \[.+\] \(Advanced.+-> (Advanced|AMD).+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (amdacpksd|AMDXE); " & $C & "\\Windows\\System32\\(DRIVERS|DriverStore\\FileRepository\\.+)\\(amdacpksd|AMDXE).sys \[.+\] \((Advanced|AMD).+-> \)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (AppleKmdfFilter|AppleLowerFilter|AppleBtBc|AppleHFS|AppleMNT|IRRemoteFlt|KeyAgent|KeyMagic|MacHALDriver|Netaapl|USBAAPL64); " & $C & "\\Windows\\System32\\Drivers\\(AppleKmdfFilter|AppleLowerFilter|AppleBtBc|AppleHFS|AppleMNT|KeyAgent|KeyMagic|MacHALDriver|netaapl64|IRFilter|usbaapl64).sys \[.+\] \(Apple.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (asahci64|asstahci64|asstor64); " & $C & "\\Windows\\System32\\Drivers\\(asahci64|asstahci64|asstor64).sys \[.+\] \(ASMedia.+-> ASMedia.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (AtiHDAudioService|AtiHdmiService|atikmdag|amdkmdag|AtiPcie|R300); " & $C & "\\Windows\\System32\\drivers\\(AtihdW\w{2}|AtiHdmi|atikmdag|atipmdag|AtiPcie|R300).sys \[.+\] \(ATI.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] atillk64; " & $C & "\\Program Files(| \(x86\))\\GIGABYTE\\atBIOS\\AtiTool\\atillk64.sys \[.+\] \(ATI.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (athr|athur|btath_avdt|BtFilte|AthBTPort|BTATH_A2DP|BTATH_BUS|BTATH_HCRP|BTATH_LWFLT|BTATH_RCP|BtFilter|JSWPSLWF|L1C|L1E); " & $C & "\\Windows\\System32\\DRIVERS\\(athrx|athurx|BtFilte|btath_flt|btath_avdt|BTATH_A2DP|BTATH_BUS|BTATH_HCRP|BTATH_LWFLT|BTATH_RCP|BtFilter|jswpslwfx|L1C62x64|L1E62x64).sys \[.+\] \(Atheros.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] AppleSSD; " & $C & "\\Windows\\System32\\Drivers\\AppleSSD.sys \[.+\] \(Microsoft Windows -> Apple.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (megasas(|\d+i)|percsas\di|lsi_sas\di|ItSas\d+i); " & $C & "\\Windows\\System32\\Drivers\\(megasas(|\d+i)|percsas\di|lsi_sas\di|ItSas\d+i).sys \[.+\] \(Microsoft Windows -> Avago.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (mpi3drvi|megasas35i|bcmfn2|BCMWL63A|bcbtums|ebdrv|b57xdbd|b57xdmp|bScsiMSa|bScsiSDa|b06bdrv|b57nd60a|Blfp|BCM42RLY|btwsecfl|BCM43XV|BCM43XX|DFUBTUSB|BCMH43XX|BcmVWL|btusbflt|btwampfl|btwaudio|btwavdt|btwl2cap|btwrchid|cvusbdrv|FlyUsb|k57nd60a); " & $C & "\\Windows\\System32\\DRIVERS\\(mpi3drvi|megasas35i|bcmfn2|BCMWL63A|bcbtums|evbda|b57xdbd|b57xdmp|bScsiMSa|bScsiSDa|bxvbda|basp|b57nd60a|btwsecfl|BCM42RLY|bcmwlhigh664|bcmwl664|bcmvwl64|BcmVWL|btusbflt|btwampfl|btwaudio|btwavdt|btwl2cap|btwrchid|cvusbdrv|FlyUsb|k57nd60a|frmupgr).sys \[.+\] \((Microsoft|Broadcom).+ -> (Broadcom|Windows).+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (serial|BrFiltLo|BrFiltUp|Brserib|Brserid|BrSerWdm|BrUsbMdm|BrUsbSib|BrUsbSer); " & $C & "\\Windows\\System32\\DRIVERS\\(BrFiltLo|BrFiltUp|Brserib|Brserid|BrSerWdm|BrUsbMdm|BrUsbSib|BrUsbSer|serial).sys \[.+\] \(Microsoft Windows -> Brother.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (COMMONFX|COMMONFX.SYS|CTAUDFX|CtClsFlt|CT20XUT|CT20XUT.SYS|CTAUDFX.SYS|CTEAPSFX|CTEAPSFX.SYS|CTEDSPFX|CTEDSPFX.SYS|CTEDSPSY|CTEDSPSY.SYS|CTEDSPIO|CTEDSPIO.SYS|CTSBLFX|CTSBLFX.sys|ctac32k|CTERFXFX|CTERFXFX.sys|P1764|ctaud2k|CTEXFIFX|CTEXFIFX.SYS|CTHWIUT|CTHWIUT.SYS|ctprxy2k|ctsfm2k|emupia|ha10kx2k|ha20x22k|hap16v2k|ha20x2k|hap17v2k|MBfilt|OA002Afx|OA001Ufd|OA002Ufd|OA001Vid|OA002Vid|ossrv|P1370Afx|P17|P1370Aud|P1370Aul|P1370VID|t3); " & $C & "\\Windows\\System32\\DRIVERS\\(COMMONFX|CtClsFlt|CTSBLFX|CT20XUT|CTERFXFX|ctac32k|ctaud2k|CTAUDFX|CTEAPSFX|CTEDSPSY|CTEDSPFX|CTEDSPIO|CTEXFIFX|CTHWIUT|ctprxy2k|ctsfm2k|emupia2k|ha20x2k|ha10kx2k|ha20x22k|hap16v2k|hap17v2k|P17|P1764|OA002Afx|OA001Ufd|OA002Ufd|OA001Vid|OA002Vid|MBfilt64|ctoss2k|P1370Afx|P1370Aud|P1370Aul|P1370VID|t3).sys \[.+\] \(Creative.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (CAXHWAZL|CAXHWBS2|cxpl_mhd|HSF_DPV|HSFHWAZL|mdmxsdk|SrvHsfHDA|SrvHsfPCI|SrvHsfV92|SrvHsfWinac|winachsf|XAudio); " & $C & "\\Windows\\System32\\DRIVERS\\(CAXHWAZL|CAXHWBS2|CAX_DPV|HSFHWAZL|CHDRT64|mdmxsdk|VSTAZL6|VSTDPV6|VSTCNXT6|CAX_CNXT|XAudio32|XAudio64|y_cx88x|VSTBS26).sys \[.+\] \(Conexant.*-> Conexant.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] CnxtHdAudService; " & $C & "\\Windows\\System32\\DRIVERS\\CHDRT64(LPAP|ISST)?.sys \[.+\] \((Conexant|Synaptics).*-> Conexant.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (dg_ssudbus|PTUMWCDF|PTUMWCSP|PTUMWFLT|PTUMWMdm|PTUMWNET|PTUMWNSP|PTUMWVsp|PTUMWBus|PTUMLBUS|PTUMLCVsp|PTUMLMdm|PTUMLNET61|PTUMLNVsp|PTUMLRMNET|PTUMLVsp|ssudmdm); " & $C & "\\Windows\\System32\\DRIVERS\\(ssudbus|PTUMWBus|PTUMWCDF|PTUMWCSP|PTUMWFLT|PTUMWMdm|PTUMWNET|PTUMWNSP|PTUMWVsp|PTUMLBUS|PTUMLCVsp|PTUMLMdm|PTUMLNET61|PTUMLNVsp|PTUMLRMNET|PTUMLVsp|ssudmdm).sys \[.+\] \(DEVGURU.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (EgisTecFF|FPSensor|mwlPSDFilter|mwlPSDNServ|mwlPSDVDisk); " & $C & "\\Windows\\System32\\DRIVERS\\(EgisTecFF|FPSensor|mwlPSDFilter|mwlPSDNServ|mwlPSDVDisk).sys \[.+\] \(Egis.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (ETDService|ETDHCF|etdhsa|ETDI2C|ETDMiniPTP|ETDSMBus|PTPFilter); " & $C & "\\Windows\\System32\\DRIVERS\\(ETDService|ETDHCF|etdhsa|ETDI2C|ETDMiniPTP|ETDSMBus|PTPFilter).sys \[.+\] \(ELAN.+\-> Elan.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] EzTouchFilter; " & $C & "\\Windows\\System32\\DRIVERS\\EzTouchFilter.sys \[.+\] \(ELAN.+\-> (Elan.*|)\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (EtronSTOR|EtronHub3|EtronXHCI); " & $C & "\\Windows\\System32\\DRIVERS\\(EtronSTOR|EtronHub3|EtronXHCI).sys \[.+\] \((Microsoft|Etron).+\-> (Etron.*|)\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (FTDIBUS|FTSER2K); " & $C & "\\Windows\\System32\\DRIVERS\\(FTDIBUS|FTSER2K).sys \[.+\] \((Future|FTDI).+\-> (Future.+|FTDI.*|)\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (sbapifs|SbFw|SBFWIMCL|SBFWIMCLMP|sbhips|SBRE|sbwtis); " & $C & "\\Windows\\System32\\Drivers\\(sbapifs|SbFw|sbfwim|sbhips|SBREdrv|sbwtis).sys \[.+\] \(GFI.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (dot4|Dot4Print|Dot4Scan|dot4usb|Accelerometer|HBtnKey|HPFXFAX|HPFXBULKLEDM|HPFXBULK|HPFXFAX|HpCISSs|hpdskflt|HpqKbFiltr|HpSAMD); " & $C & "\\Windows\\System32\\drivers\\(dot4|Dot4Print|Dot4Prt|Dot4Scan|dot4usb|Accelerometer|cpqbttn64|hpcisss|hpfx64bulk|hpfx64fax|hpdskflt|hppdfaxio|hppdbulkio|HpqKbFiltr|HpSAMD).sys \[.+\] \((Microsoft|HP|Hewlett).*-> (Hewlett|HP|Microsoft|Windows).*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (e1i68x64|iaLPSS2_UART2_CNL|iaLPSS2_SPI_CNL|iaisp|camera|ausb3xhc|ausb3hub|IntcOED|IntcDMic|IntcBTAu|IntelHSWPcc|iaLPSS2?i?_(I2C|SPI)|iaLPSS_GPIO|SPDx64|MEIx64|dptf_(pch|cpu|acpi)|ixgb(e|n|s|t)|e2fexpress|e1(c|d|i|k|q|r|s|y)?express|e1i65x64|igfxLP|iaVROC|iaStor(A|B|E|S|V)?(C|V|f)?(C|S)?|IaRNVMeF?|IaNVMeF?|iocbios2|XtuAcpiDriver|XTUComponent|VirtualButtons|IntcAudioBus|NETw(N|t|)(e|b|s|\d|\.|)(w|v|)\d*|UDE|bertreader|TXEIx64|nhi|MBI|iaLPSS2_I2C_CNL|iaLPSS2_GPIO2(|_CNL)|iactrllogic|esif_lf|IntcOED|igfxn|HidEventFilter|ibtusb|ISH|ISH_BusDriver|iaLPSS2_UART2|HID_PCI|igfx|IntcDAud|ov\d{4}|iaLPSS2i_GPIO2_(CNL|GLK|BXT_P)|iaLPSS2i_I2C_(CNL|GLK|BXT_P)|supportdriver|IntTouch|CSI2HostControllerDriver|iacamera64|IntelHaxm|SkcController|iagpio|iaLPSS2i_GPIO2|iai2c|iaLPSSi_GPIO|iBtFltCoex|ioatdma1|iusb3h(cs|ub)|iusb3xhc|ioatdma2|bpenum|bpmp|bpusb|btmaudio|btmaux|btmhsf|E1G60|EBIOS32|HECIx64|Impcd|intaud_WaveExtensible|IntcHdmiAddService|intelkmd|ICCWDT|iirsp|iwdbus|smbusp|TurboB|wdkmd); " & $C & "\\Windows\\System32\\(DRIVERS|DriverStore\\FileRepository\\[^\\]+)\\(e1i68x64|iaLPSS2_UART2_CNL|iaLPSS2_SPI_CNL|ausb3xhc|ausb3hub|IntcAudioBus|IntcOED|IntcDMic|IntcBTAu|iaLPSS2?i?_(I2C|SPI)|IntelPcc|iaLPSS_I2C|iaLPSS_GPIO|SPDx64|MEIx64|dptf_(pch|cpu|acpi)|ix(e|n|s|t)6(2|3|4|5|8)x64|e2f68|e1(c|d|i|k|q|r|s|y)6(0|2|3|4|5|8)x64|igdkmd64lp|iaVROC|iaStor(A|B|E|S|V)?(C|V|f)?(C|S)?|NETw(N|t|)(e|b|s|\d|\.|)(w|v|)\d*|IaRNVMeF?|IaNVMeF?|iocbios2|XtuAcpiDriver|VirtualButtons|UDE|bertreader|TXEIx64|tbt\d+x|MBI|iaLPSS2_I2C_CNL|iaLPSS2_GPIO2(|_CNL)|iactrllogic64|esif_lf|IntcOED|igdkmdn?64|HidEventFilter|ibtusb|ISH|ISH_BusDriver|iaLPSS2_UART2|HID_PCI|IntcDAud|(|x64\\)TeeDriver(|W8|W10)x64|ov\d{4}|iaLPSS2i_GPIO2_(CNL|GLK|BXT_P)|iaLPSS2i_I2C_(CNL|GLK|BXT_P)|iaLPSSi_GPIO|bpenum|bpmp|bpusb|btmaud|btmaux|btmhsf|E1G6032E|iBtFltCoex|intelaud|igdpmd64|iwdbus|EBIOS32|Impcd|qd(1|2)62x64|iusb3h(cs|ub)|e1e6232e|iusb3xhc|IntcHdmi|IntcHdmiAddService|ICCWDT|iirsp|HECIx64|TurboB|intelsmb|wdkmd|iai2c|iagpio|iaLPSS2i_GPIO2|CSI2HostControllerDriver|iacamera64|IntelHaxm|SkcController|iaPreciseTouch|iaisp64).sys \[.+\] \((Microsoft|Inte|Smart).+-> Inte.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] iocbios2; " & $C & "\\Program Files(| \(x86\))\\Intel\\.+\\iocbios2.sys \[.+\] \(Intel.+-> Intel.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] IOCBIOS; " & $C & "\\ProgramData\\Intel\\Extreme Tuning Utility\\IOCbios\\64bit\\IOCBIOS.SYS \[.+\] \(Inte.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] nhi; " & $C & "\\Windows\\System32\\DRIVERS\\(tbt\d+x|TbtBusDrv).SYS \[.+\] \(.*(TBT|inte).+-> Inte.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] SGXEPC; " & $C & "\\Windows\\System32\\DRIVERS\\sgx_driver.SYS \[.+\] \(Inte.*-> (Inte|Windows).+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] NAL; " & $C & "\\Windows\\System32\\DRIVERS\\iqvs?w64e.SYS \[.+\] \((ND_QV|Inte).*-> Inte.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (WiMan|INETMON|ISCT|ikbevent|imsevent|irstrtdv|pmxdrv|semav6msr64); " & $C & "\\Windows\\System32\\DRIVERS\\(WiMan|ISCTD|INETMON|ISCTD64|ikbevent|imsevent|irstrtdv|pmxdrv|semav6msr64).SYS \[.+\] \((Inte|PAIPTAC).+-> (|Inte.*)\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (ACPIVPC|BPntDrv|DzHDD64|fbfmon|IBMPMDRV|lenovo.smi|LHDmgr|TPPWRIF|Shockprf|TPDIGIMN|tvtumon|psadd); " & $C & "\\Windows\\System32\\Drivers\\(ApsHM64|ACPIVPC|BPntDrv|DzHDD64|fbfmon|IBMPMDRV|smiifx64|LhdX64|Tppwr64v|Apsx64|tvtumon|psadd).sys \[.+\] \(Lenovo.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] PHCORE; " & $C & "\\Program Files\\Lenovo\\RapidBoot\\PHCORE64.SYS \[.+\] \(Lenovo.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (andnetndis|Andbus|AndDiag|AndGps|ANDModem|AndNetDiag|AndNetGps|ANDNetModem|usbbus|UsbDiag|USBModem); " & $C & "\\Windows\\System32\\DRIVERS\\(lgandbus64|lganddiag64|lgandgps64|lgandmodem64|lgandnetdiag64|lgandnetgps64|lgandnetmodem64|lgandnetndis64|lgx64bus|lgx64diag|lgx64modem).sys\[.+\] \(LG.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (CompFilter64|CamDrL64|CompFilter64|LADF_CaptureOnly|L8042Kbd|L8042mou|LMouKE|LADF_RenderOnly|LEqdUsb|LGBusEnum|LGVirHid|LHidEqd|LHidFilt|LMouFilt|LUsbFilt|lvpepf64|lvpopf64|LVRS64|LVUSBS64|LVUVC64|PID_0928|PID_PEPI|WmBEnum|WmFilter|WmHidLo|WmVirHid|WmXlCore); " & $C & "\\Windows\\System32\\DRIVERS\\(ladfGSCamd64|L8042Kbd|L8042mou|LMouKE|ladfGSRamd64|LEqdUsb|LHidEqd|vbflt64|LGBusEnum|LGVirHid|LHidFilt|LMouFilt|LUsbFilt|lv302a64|lvpopf64|LVRS64|LVUSBS64|LVUVC64|LV302V64|LV561V64|WmBEnum|WmFilter|WmHidLo|WmVirHid|WmXlCore|lvbflt64|CamDrL64).sys \[.+\] \(Logitech.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (LSI_SAS(|2|3)i?|percsas2i|AGERESoftModem|3ware|LSI_SSS|LSI_FC|LSI_SCSI|megasas|MegaSR|Mraid35x|Symc8xx|Sym_hi|Sym_u3); " & $C & "\\Windows\\System32\\DRIVERS\\(LSI_SAS(|2|3)i?|agrsm(64|)|lsi_fc|LSI_SCSI|megasas|MegaSR|Mraid35x|LSI_SSS|Symc8xx|Sym_hi|Sym_u3|3ware|percsas2i).sys \[.+\] \(Microsoft.+-> LSI.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (ndfltr|ibbus|mlx4_bus|WinMad|WinVerbs); " & $C & "\\Windows\\System32\\DRIVERS\\(ndfltr|ibbus|mlx4_bus|WinMad|WinVerbs).sys \[.+\] \(Microsoft Windows -> Mellanox.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (ykinw8|mrvlpcie8897|MRV6X64P|mvumis|mv91cons|mvs91xx|mv91xx|yukonw7|yukonx64); " & $C & "\\Windows\\System32\\DRIVERS\\(ykinx64|mv91cons|mvumis|mvs91xx|MRVW13C|mv91xx|mvusbews|yk6[02]x64|mrvlpcie8897).sys \[.+\] \(Microsoft Windows -> Marvell.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (ss_bus|s117bus|s117mdfl|s117mdm|s117mgmt|s117nd5|s117obex|s117unic|ss_bmdm|ss_bbus|ss_bmdfl|ss_mdfl|ss_mdm|ssadbus|ssadmdm|ssadmdfl|ssadserd|sscdbus|sscdmdfl|sscdmdm|sscebus|sscemdfl|sscemdm|srvnet); " & $C & "\\Windows\\System32\\DRIVERS\\(ss_bus|ss_bbus|ss_mdfl|ss_mdm|ssadbus|s117bus|s117mdfl|s117mdm|s117mgmt|s117nd5|s117obex|s117unic|ss_bmdm|ssadmdm|ss_bmdfl|ssadmdfl|ssadserd|sscdbus|sscdmdfl|sscdmdm|sscebus|sscemdfl|sscemdm|srvnet).sys \[.+\] \(MCCI.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (BTCFilterService|BTMCOM|BTMUSB|BTMHID|MotDev|motandroidusb|motccgp|motccgpfl|motmodem|MotoSwitchService|Motousbnet|motusbdevice); " & $C & "\\Windows\\System32\\DRIVERS\\(BTMCOM|BTMUSB|BTMHID|motfilt|motodrv|motoandroid|motccgp|motccgpfl|motmodem|motswch|Motousbnet|motusbdevice).sys \[.+\] \(Motorola.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (a2djavsa2djusb_svc|ks4avs|ks4usb_svc|kx1avs|kx1usb_svc); " & $C & "\\Windows\\System32\\Drivers\\(a2djavs|a2djusb|ks4avs|ks4usb|kx1avs|kx1usb).sys \[.+\] \(Native.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (nmwcdnsux64|nmwcd|nmwcdc|nmwcdnsucx64|pccsmcfd|upperdev|UsbserFilt); " & $C & "\\Windows\\System32\\drivers\\(nmwcdnsux64|ccdcmbx64|ccdcmbox64|nmwcdnsucx64|pccsmcfdx64|usbser_lowerfltx64|usbser_lowerfltjx64).sys \[.+\] \(Nokia.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (NWADI|NWVNDIS|NWUSBCDFIL64|NWUSBModem_000|NWUSBPort2_000|NWUSBPort_000); " & $C & "\\Windows\\System32\\DRIVERS\\(NWADIenum|NWVNDIS|NWUSBCDFIL64|nwusbmdm_000|nwusbser2_000|nwusbser_000).sys \[.+\] \(Novatel.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (NvModuleTracker|(nvvad|nvrtxvad)_WaveExtensible|NVSWCFilter|nvvhci|UcmCxUcsiNvppc|NVENETFD|NVHDA|NVNET|nvlddmkm|nvpciflt|nvraid|nvsmu|nvstor|nvstor64|NvStUSB); " & $C & "\\Windows\\System32\\drivers\\(nvrtxvad64v|NvModuleTracker|nvvad64v|nvmfdx64|nvhda64v|nvlddmkm|nvpciflt|nvraid|nvsmu|nvstor|nvmf6264|nvm62x64|nvstor64|NvStUSB|NVSWCFilter|nvvhci|UcmCxUcsiNvppc).sys \[.+\] \((Microsoft Windows|NVIDIA Corporation) -> NVIDIA.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] NvStreamKms; " & $C & "\\Program Files(| \(x86\))\\NVIDIA Corporation\\.+\\NvStreamKms.sys \[.+\] \(NVIDIA.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (nvlddmkm|UcmCxUcsiNvppc|NvStreamKms|nvpciflt); " & $C & "\\Windows\\System32\\DriverStore\\FileRepository\\.+\\(nvpciflt|nvlddmkm|UcmCxUcsiNvppc|NvStreamKms).sys \[.+\] \(NVIDIA.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (O2MDFRDR|O2MDGRDR|O2SDRDR|O2MDRRDR|O2SDJRDR); " & $C & "\\Windows\\System32\\DRIVERS\\(O2MDFw7x64|o2mdgx64|o2sdx64|O2MDRw7x64|o2sdjw7x64).sys \[.+\] \(O2Micro.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (prl_boot|prl_dd|prl_fs|prl_mouf|prl_pv64|prl_sound|prl_strg|prl_tg|prl_time); " & $C & "\\Windows\\System32\\Drivers\\(prl_boot|prl_kmdd|prl_fs|prl_mouf|prl_pv64|prl_sound|prl_strg|prl_tg|prl_time).sys \[.+\] \(Parallels.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (e(2|3)(x|4|k)w\d+x64|KillerEth|qcusbser|Qcamain10x64|BTATH_A2DP|AthBTPort|athr|btath_avdt|BTATH_BUS|L1C|BTATH_HCRP|BTATH_HCRP|BTATH_RCP|BtFilter); " & $C & "\\Windows\\System32\\Drivers\\(e(2|3)(x|4|k)w\d+x64|qcusbser|Qcamain10x64|BTATH_A2DP|btath_avdt|BTATH_BUS|BTATH_HCRP|BTATH_HCRP|athrx|BTATH_RCP|BtFilter|btath_flt|L1C63x64|athw(8|10|n)x).sys \[.+\] \((Qualcomm|Microsoft|Rivet|Realtek).+-> (Qualcomm|Realtek).*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (bfadfcoei|bfadi|bxfcoe|bxois|qeois|ql2300i|ql40xx2i|qlfcoei); " & $C & "\\Windows\\System32\\Drivers\\(bfadfcoei|bfadi|bxfcoe|bxois|qeois|ql2300i|ql40xx2i|qlfcoei).sys \[.+\] \(Microsoft.+-> QLogic.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (netr28x|netr28ux|netr7364|RT2500|rt61x64); " & $C & "\\Windows\\System32\\DRIVERS\\(netr28x|netr28ux|netr7364|RT2500|netr6164).sys \[.+\] \((Ralink|Microsoft|MEDIATEK).+-> (Ralink|MEDIATEK).+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (RtkUsbAD|rtsuvc|rt640x64|rtux64w10|IntcAzAudAddService|RTWlanE|RtkBtFilter|RTWlanE\d+|RTSPER|RTSUER|RtlWlanu_OldIC|RSPCIESTOR|RTVLANPT|RSBASTOR|RSUSBSTOR|RTL2832UBDA|RTL8168|RTL2832UUSB|RTL2832U_IRHID|RSUSBVSTOR|RtNdPt60|TEAM|RTTEAMPT|RTHDMIAzAudService|RTL8167|RTL8192Ce|RTLWUSB|RTL8192su|rtl8192se|RTL8187|RTL8169|RTSTOR); " & $C & "\\Windows\\System32\\DRIVERS\\(RtUsbA64.*|rtsuvc|rt640x64|rtux64w10|RSUSBSTOR|RtsUVStor|RTL2832UBDA|RTL2832UUSB|RTL2832U_IRHID|RtTeam60|RtsUStor|RtNdPt60|Rt630x64|RtHDMIVX|Rt64win7|RTL8167|RTL8192Ce|rtl8192se|RTL8187|RTL8192su|Rtlh64|RtsBaStor|RTKVHD64|RTSTOR64|RtVlan620|RtsPStor|rtwlanu_oldIC|RTDVHD64|RTWlanE|RtkBtFilter|RTWlanE\d+|RTSPER|RTSUER).sys \[.+\] \(.+->.+(Realtek|Semiconductor).*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] IntcAzAudAddService; " & $C & "\\Windows\\System32\\DriverStore\\FileRepository\\[^\\]+\\RTKVHD64.sys \[.+\] \(.*Semiconductor.*->.+Semiconductor.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (rimmptsk|rimsptsk|rimspci|rimsptsk|risdsnpe|risdpcie|risdxc|rismxdp|rixdpcie); " & $C & "\\Windows\\System32\\DRIVERS\\(rimmpx64|rimspe64|rimssne64|rimspx64|risdpe64|risdxc|rimssn64|risdsne64|risdxc64|rixdpx64|rixdpe64).sys \[.+\] \(REDC.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (silabenm|SIS163u|silabser|SiSGbeLH|SIUSBXP); " & $C & "\\Windows\\System32\\DRIVERS\\(silabenm|silabser|SiSG664|SIUSBXP|SIS163u).sys \[.+\] \((Microsoft|Silicon).+-> Silicon.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (c2scsi64|RxFilter|Sahdad64|Saibad64|RxFilter|SaibVdAd64|SWIPsec|SWVNIC); " & $C & "\\Windows\\System32\\Drivers\\(c2scsi64|RxFilter|Sahdad64|Saibad64|SaibVdAd64|RxFilter|SWIPsec|SWVNIC).sys \[.+\] \(Sonic.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (ggflt|ggsemc|SFEP|VBTUSB); " & $C & "\\Windows\\System32\\DRIVERS\\(ggflt|ggsemc|SFEP|VBTUSB).sys \[.+\] \(Sony.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (SynTPFilterHID|SmbDrvI|SmbDrv|SynRMIHID|SynaMetSMI|SynTP); " & $C & "\\Windows\\System32\\DRIVERS\\(Smb_driver_Intel|Smb_driver_AMDASF|SynRMIHID|SynaSmi|SynTP).sys \[.+\] \(Synaptics.*-> Synaptics.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] SynaMetSMI; " & $C & "\\Windows\\System32\\DRIVERS\\SynaSmi.sys \[.+\] \(Synaptics.*-> Windows.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (FwLnk|KR10I64|KR10N64|PGEffect|tdcmdpst|Thpdrv|Thpevm|tosporte|tosrfbd|tosrfbnp|Tosrfcom|tosrfec|Tosrfhid|tosrfnds|TosRfSnd|QIOMem|Tosrfusb|tos_sps64|TVALZ|TVALZFL); " & $C & "\\Windows\\System32\\DRIVERS\\(FwLnk|KR10I64|KR10N64|PGEffect|QIOMem|tdcmdpst|Thpdrv|Thpevm|tosporte|tosrfbd|tosrfbnp|Tosrfcom|tosrfec|Tosrfhid|tosrfnds|TosRfSnd|Tosrfusb|tos_sps64|TVALZ_O|TVALZ|TVALZFL).sys \[.+\] \(TOSHIBA.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (xhcdrv|VUSBSTOR|VUSB3HUB|VSTXRAID|VIAHdAudAddService|viaide|vsmraid|viaagp|ViaC7); " & $C & "\\Windows\\System32\\drivers\\(xhcdrv|VUSBSTOR|ViaHub3|VSTXRAID|viahduaa|viaide|vsmraid||viaagp|ViaC7).sys \[.+\] \((Microsoft|VIA).+ -> VIA.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] vstor2-mntapi10-shared; " & $C & "\\Windows\\SysWow64\\Drivers\\vstor2-mntapi10-shared.sys \[.+\] \(VMware, Inc. -> VMware.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] vstor2-ws60; " & $C & "\\Program Files(| \(x86\))\\VMware\\VMware Workstation\\vstor2-ws60.sys \[.+\] \(VMware, Inc. -> VMware.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (hcmon|vm3dmp|VMAUDIO|vmci|vmdebug|vmhgfs|vmkbd|vmmouse|VMnetAdapter|VMnetuserif|vmusb|vmwvusb|vmx86|vstor2-mntapi10-shared); " & $C & "\\Windows\\System32\\Drivers\\(hcmon|vm3dmp|VMAUDIO|vmci|vmdebug|vmhgfs|vmkbd|vmmouse|VMnetAdapter|VMnetuserif|vmusb|vmwvusb|vmx86|vstor2-mntapi10-shared).sys \[.+\] \(VMware, Inc. -> VMware.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] pvscsi; " & $C & "\\Windows\\System32\\Drivers\\pvscsii.sys \[.+\] \(Microsoft Windows -> VMware.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] VMMEMCTL; " & $C & "\\Program Files\\VMware\\VMware Tools\\Drivers\\memctl\\vmmemctl.sys \[.+\] \(VMware, Inc. -> VMware.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] vmrawdsk; " & $C & "\\Program Files\\VMware\\VMware Tools\\vmrawdsk.sys \[.+\] \(VMware, Inc. -> VMware.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] bcmfn2; " & $C & "\\Windows\\System32\\DRIVERS\\bcmfn2.sys \[.+\] \(Microsoft.+ -> Windows.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] hidkmdf; " & $C & "\\Windows\\System32\\DRIVERS\\hidkmdf.sys \[.+\] \((Microsoft|Wacom).+-> Windows.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (AMPPAL|AMPPALP|ASCTRM|AsrAppCharger|ATHDFU|busenum|cpuz134|clwvd|ELANUSB|EMSC|htcnprot|iPodDrv|JLTECH0227|KMWDFILTER|lullaby|MungoDriver|rcmirror|RtlProt|RtDashPt|rtport|RTVLANPT|SCMNdisP|vhidmini|VKbms); " & $C & "\\Windows\\System32\\DRIVERS\\(AMPPAL|ASCTRM|AsrAppCharger|ATHDFU|cpuz134_x64|busenum|EMSC|clwvd|ELANUSB|htcnprot|iPodDrv|jl2005c|KMWDFILTER|lullaby|MungoDriver|rcmirror|RtlProt|RtVlan60|RtDashPt|rtport|scmndisp|vHidDev|VKbms).sys \[.+\] \(Broadcom Corporation -> Windows.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (HfAudio|ScrHIDDriver); " & $C & "\\Windows\\System32\\DRIVERS\\(HfAudio|ScrHIDDriver).sys \[.+\] \(SCREENOVATE.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (ST_Accel|STTub30); " & $C & "\\Windows\\System32\\DRIVERS\\(ST_Accel|STTub30).sys \[.+\] \((Microsoft|.*STMicroelectronics).+-> STMicroelectronics.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (WacomPen|WacHIDRouter(ISD|Pro|)|wacommousefilter|wacomvhid|WacomVKHid|wacmoumonitor|wacomrouterfilter); " & $C & "\\Windows\\System32\\Drivers\\(WacHIDRouter(ISDU|)|WacomPen|wacommousefilter|wacmoumonitor|wacomvhid|WacomVKHid|wacomrouterfilter).sys \[.+\] \((Wacom|Microsoft).*-> (Wacom|Microsoft).*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (massfilter|ZTEusbnet|ZTEusbvoice|ZTEusbmdm6k|ZTEusbnmea|ZTEusbser6k); " & $C & "\\Windows\\System32\\Drivers\\(massfilter|ZTEusbmdm6k|ZTEusbnet|ZTEusbvoice|ZTEusbnmea|ZTEusbser6k).sys \[.+\] \(ZTE.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (elxfcoe|elxstor|qebdrv|qefcoe|dbx|mrvlpcie8897|mt7612US_bc|mt7612US|umc_audio|umc_audioks|Qmux); " & $C & "\\Windows\\System32\\DRIVERS\\(elxfcoe|elxstor|qevbda|qefcoe|dbx|mrvlpcie8897|mt7612US_bc|mt7612US|umc_audio|umc_audioks|qcqmux).sys \[.+\] \(Microsoft .+->.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (SurfaceSystemTelemetry|ArcMouseConfiguration|SurfaceAccessoryDevice); " & $C & "\\Windows\\System32\\DRIVERS\\(ArcMouseConfiguration|SurfaceAccessoryDevice|SurfaceSystemTelemetryDriver).sys \[.+\] \((Hardware Group|OEMTest OS).+-> Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (SensorsAlsDriver|Usb4DeviceRouter|WifiCx); " & $C & "\\Windows\\System32\\DRIVERS\\(WUDFRd|Usb4DeviceRouter|WifiCx).sys \[.+\] \(Microsoft.+ -> Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] CDD; " & $C & "\\WINDOWS\\System32\\cdd.dll \[.+\] \(Microsoft.+ -> Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (cxwmbclass|hvsifltr|hvsocketcontrol|Acx01000|BthMini|hidspi|bindflt|hvcrash|bthl2cap|bam|bttflt|HwNClx0101|invdimm|IPT|Ramdisk|rhproxy|vnvdimm|wdnsfltr|BthLEEnum|CAD|CldFlt|BthA2DP|BthHFAud|dc1-controller|hvservice|clreg|AcpiDev|applockerfltr|AppvStrm|AppvVemgr|AppvVfs|IoQos|GpuEnergyDrv|FileCrypt|ebdrv|genericusbfn|buttonconverter|hidi2c|CapImg|cnghwassist|fcvsc|hidinterrupt|1394ohci|EhStorClass|ACPI|acpitime|acpipagr|ahcache|GPIOClx0101|gencounter|acpiex|CLFS|EhStorTcgDrv|FxPPM|condrv|acpials|bthhfhid|dam|AcpiPmi|AFD|BasicRender|BthAvrcpTg|BthHFEnum|agp440|BasicDisplay|amdagp|amdide|AmdK8|AmdPPM|AMPPAL|AppID|AsyncMac|atapi|Avc|AVCSTRM|BackupReader|Beep|bowser|blbdrive|Bridge|MsBridge|BridgeMP|BthEnum|BTHMODEM|BthPan|BTHPORT|BTHUSB|cdfs|cdrom|circlass|CmBatt|CNG|Compbatt|CompositeBus|crcdisk|CSC|dc3d|DfsC|discache|Disk|dmvsc|dot4|Dot4Print|Dot4Scan|dot4usb|drmkaud|DSFKSVCS|dsfroot|DXGKrnl|Ecache|ErrDev|exfat|fastfat|fdc|FileInfo|Filetrace|flpydisk|FltMgr|FsDepends|fssfltr|HRMCFGSPC|HRMINTS|HRMPORTS|Fs_Rec|fvevol|gagp30kx|HDAudBus|HidBatt|HidBth|HidIr|HidUsb|HTTP|hwpolicy); " & $C & "\\Windows\\System32\\DRIVERS\\(cxwmbclass|hvsifltr|hvsocketcontrol|Acx01000|BthMini|hidspi|bindflt|hvcrash|1394ohci|ACPI|ahcache|EhStorClass|hidi2c|EhStorTcgDrv|acpials|AcpiPmi|bthhfhid|BasicRender|BthAvrcpTg|BthHFEnum|acpiex|AFD|BasicDisplay|agp440|acpipagr|amdagp|amdide|AmdK8|AmdPPM|AppID|AsyncMac|atapi|Avc|msgpioclx|AVCSTRM|BackupReader|Beep|bowser|Bridge|blbdrive|BthEnum|BTHMODEM|BthPan|BTHPORT|BTHUSB|cdfs|cdrom|FxPPM|circlass|CmBatt|condrv|CNG|Compbatt|CLFS|CompositeBus|crcdisk|dam|CSC|dc3d|DfsC|discache|Disk|dmvsc|dot4|Dot4Prt|Dot4Print|Dot4Scan|dot4usb|drmkaud|buttonconverter|CapImg|cnghwassist|genericusbfnclass|fcvsc|hidinterrupt|DSFKSVCS|dsfroot|DXGKrnl|Ecache|ErrDev|exfat|fastfat|fdc|FileInfo|Filetrace|flpydisk|FltMgr|FsDepends|vmgencounter|fssfltr|HRMCFGSPC|HRMINTS|HRMPORTS|Fs_Rec|fvevol|gagp30kx|HDAudBus|HidBatt|HidBth|HidIr|HidUsb|HTTP|hwpolicy|evbda|FileCrypt|genericusbfn|GpuEnergyDrv|IoQos|BthLEEnum|AcpiDev|applockerfltr|AppvStrm|AppvVemgr|AppvVfs|registry|hvservice|BthA2DP|BthHFAud|dc1-controller|acpitime|CAD|CldFlt|Microsoft.Bluetooth.Legacy.LEEnumerator|bam|bttflt|mshwnclx|invdimm|IPT|Ramdisk|rhproxy|vnvdimm|wdnsfltr|bthl2cap).sys \[.+\] \(Microsoft.+ -> Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (bfadi|bxfcoe|bxois|elxfcoe|IPsecGW|elxstor|MsLbfoProvider|qebdrv|qeois|ql2300i|ql40xx2i|qlfcoei|RasGre|sacdrv|bfs|pvscsi|wtd|Hsp|ExecutionContext|HidSpiCx|IntelPMT|nvmedisk|LifeCamTrueColor|l2bridge|msdcb|intelpmax|MEIx64|lunparser|Microsoft_Bluetooth_AvrcpTransport|MbbCx|lxss|msux64w10|IndirectKmd|mausbip|mausbhost|NetAdapterCx|MsSecFlt|iorate|MQAC|SensorsHIDClassDriver|MMCSS|ReFSv1|intelpep|kbldfltr|i2omp|61883|i8042prt|igvlmcxc|irda|intelide|intelppm|MsLldp|msgpiowin32|IpFilterDriver|IPMIDRV|kdnic|HyperVideo|IPNAT|IRENUM|isapnp|iScsiPrt|HdAudAddService|kbdclass|kbdhid|KSecDD|KSecPkg|ksthunk|lltdio|luafv|mf|Modem|monitor|mouclass|mouhid|mountmgr|MpNWMon|mpio|mpkwlipi|mpsdrv|MRxDAV|mrxsmb|mrxsmb10|mrxsmb20|msahci|msdsm|MSDV|Msfs|mshidumdf|mshidkmdf|MSHUSBVideo|msisadrv|hyperkbd|MSKSSRV|msloop|MSPCLOCK|MSPQM|MsRPC|mssmbios|MSTAPE|MSTEE|MTConfig|Mup); " & $C & "\\Windows\\System32\\DRIVERS\\(bfadi|bxfcoe|bxois|elxfcoe|IPsecGW|elxstor|MsLbfoProvider|qebdrv|qeois|ql2300i|ql40xx2i|qlfcoei|RasGre|sacdrv|bfs|pvscsii|wtd|ExecutionContext|HidSpiCx|IntelPMT|nvmedisk|LifeCamTrueColor|l2bridge|msdcb|intelpmax|Microsoft\.Bluetooth\.AvrcpTransport|MbbCx|intelpep|kbldfltr|i2omp|i8042prt|igvlmcxc|intelide|intelppm|irda|ipfltdrv|IPMIDRV|kdnic|IPNAT|IRENUM|isapnp|msiscsi|HdAudio|kbdclass|kbdhid|KSecDD|KSecPkg|ksthunk|lltdio|luafv|mf|Modem|monitor|mouclass|mouhid|mountmgr|MpNWMon|mpio|mpkwlipi|mpsdrv|MRxDAV|WUDFRd|mrxsmb|mrxsmb10|mrxsmb20|MMCSS|ReFSv1|msahci|msdsm|MSDV|Msfs|MsLldp|msgpiowin32|mshidumdf|mshidkmdf|msisadrv|hyperkbd|MSKSSRV|MSPCLOCK|HyperVideo|MSPQM|MsRPC|mssmbios|MSTAPE|MSTEE|MTConfig|loop|Mup|nx6000|MQAC|IndirectKmd|MsSecFlt|iorate|mausbip|mausbhost|NetAdapterCx|lxss|msux64w10|lunparser|TeeDriverx64|Hsp).sys \[.+\] \(Microsoft.+ -> Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (PktMonApi|amdwps|kdnic_legacy|MsQuicPrev|UnionFS|ZTDNS|WinAccelCx0101|ov9734|CimFS|MsQuic|spaceparser|MsixPackagingToolMonitor|OemShZDigitizerIntegration|PrecisionMouseUSBIntegration|PrecisionMouseBLEIntegration|PsxDrv|NfsRdr|P9Rdr|pcip|PrjFlt|ramparser|RpcXdr|NDKPing|portcfg|vhdparser|pvhdparser|passthruparser|RtlWlanu|PktMon|nvdimm|NdisImPlatformMp|nvdimmn|pmem|NETVSCVFPP|ReFS|NdisVirtualBus|NativeWifiP|NDIS|NdisCap|NdisTapi|Ndisuio|NdisImPlatform|NDISWANLEGACY|pdc|npsvctrig|Ndu|NdisWan|NDProxy|NetBIOS|NetBT|netvsc|nm3|Npfs|nsiproxy|Ntfs|NuidFltr|Null|nv_agp|ohci1394|Parport|partmgr|Parvdm|pci|pciide|pcmcia|pcw|PEAUTH|Point64|PptpMiniport|pnpmem|Processor|Psched|QWAVEdrv|RsFx0151|RasAcd|RasAgileVpn|Rasl2tp|RasPppoe|RasSstp|rdbss|rdpbus|RDPCDD|RDPDISPM|RDPDR|RDPENCDD|RDPREFMP|RdpVideoMiniport|RDPWD|rdyboost|RFCOMM|RMCAST|ROOTMODEM|RsFx0150|RsFx010.|rspndr); " & $C & "\\Windows\\System32\\DRIVERS\\(PktMonApi|amdwps|kdnic_legacy|MsQuicPrev|UnionFS|ZTDNS|WinAccelCx|CimFS|MsQuic|spaceparser|MsixPackagingToolMonitor|OemShZDigitizerIntegration|PrecisionMouseUSBIntegration|PrecisionMouseBLEIntegration|PsxDrv|NfsRdr|P9Rdr|pcip|PrjFlt|ramparser|RpcXdr|NDKPing|portcfg|rtwlanu|PktMon|ReFS|nvdimm|netvsc\d\d|NdisVirtualBus|nwifi|NDIS|NdisCap|NdisTapi|NdisImPlatform|pdc|Ndisuio|npsvctrig|NdisWan|NDProxy|NetBIOS|NetBT|nm3|Npfs|nsiproxy|Ntfs|NuidFltr|Null|nv_agp|ohci1394|Parport|partmgr|Parvdm|pci|pciide|pcmcia|pcw|PEAUTH|pnpmem|Point64|Point64k|raspptp|processr|RsFx0151|netvsc|pacer|QWAVEdrv|RasAcd|AgileVpn|Rasl2tp|RasPppoe|RasSstp|Ndu|rdbss|rdpbus|RDPCDD|RDPDISPM|RDPDR|RDPENCDD|RDPREFMP|RdpVideoMiniport|RDPWD|rdyboost|RsFx0150|RFCOMM|RMCAST|RootMdm|RsFx010.|rspndr|nvdimmn|pmem|passthruparser|pvhdparser|vhdparser|ov9734).sys \[.+\] \(Microsoft.+ ->.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (UCPD|usbrndis6|Surface(PenBleLcAddrAdaptationDriver|ArcMouseIntegration|1824DigitizerIntegration|HidMini|AcpiNotify|3TypeCoverIntegration|Base2Integration|Battery|DialFilter|HotPlug|LightSensor|Pen217Integration|PowerFilter|PowerMeterDriver|PowerTrackerCore|Pro1\d+TypeCoverIntegration|Pro1\d+DigitizerIntegration|SerialHubDriver|TconDriver|UcmUcsiHidClient|Ucsi|UsbHubFwUpdate|VirtualFunctionEnum)|Synth3dVsp|uwfreg|uwfs|uwfvol|umbus|usbaudio\d*|SiSRaid2|UcmUcsiCx\d*|smbdirect|UcmUcsiAcpiClient|Surface(SoftwareServicing|AccessoryDevice|Button|CapacitiveHomeButton|CoSAR|DigitizerIntegration|DisplayCalibration|DockIntegration|IntegrationDriver|PciController|PenClickFilter|PenDriver|PenIntegration|Pro4TypeCoverIntegration|StorageFwUpdate|SystemTelemetryDriver|TouchServicingML|TypeCover|TypeCoverV3Integration)|SpatialGraphFilter|scmbus|scmdisk\d+|UdeCx|WindowsTrustedRTProxy|WindowsTrustedRT|UcmUcsi|UcmCx0101|storqosflt|ufxsynopsys|UfxChipidea|UrsChipidea|UrsCx01000|UrsSynopsys|storufs|Ufx01000|SerCx2|stornvme|UEFI|s3cap|sbp2port|scfilter|sdbus|Serenum|Serial|sermouse|USBHUB3|UASPStor|UCX01000|USBXHCI|sdstor|storahci|storvsp|SpbCx|SerCx|sffdisk|spaceport|sffp_mmc|sffp_sd|sfloppy|Sftfs|Sftplay|Sftredir|Sftvol|sisagp|Smb|softehci|SOFTHIDUSBK|SOFTUSBK|sonydcam|spldr|srv|srvnet|srv2|storflt|storvsc|swenum|Synth3dVsc|SynthVid|Tcpip|TCPIP6|tcpipreg|TDPIPE|TDTCP|tdx|StillCam|TermDD|terminpt|TPM|tssecsrv|TsUsbFlt|TsUsbhub|TsUsbGD|tunmp|tunnel|uagp35|udfs|uliagpkx|UmPass|usb_rndis|usb_rndisx|usbccgp|usbcir|usbehci|usbehci_dsf|usbser|usbhub|usbohci|usbprint|usbscan|USBSTOR|usbvideo|usbuhci); " & $C & "\\Windows\\System32\\DRIVERS\\(UCPD|usb80236|Surface(PenBleLcAddrAdaptationDriver|ArcMouseIntegration|1824DigitizerIntegration|HidMiniDriver|AcpiNotifyDriver|3TypeCoverIntegration|Base2Integration|Battery|DialFilter|HotPlug|LightSensor|Pen217Integration|PowerFilter|PowerMeterDriver|PowerTrackerCore|Pro1\d+TypeCoverIntegration|Pro1\d+DigitizerIntegration|SerialHubDriver|TconDriver|UcmUcsiHidClient|Ucsi|UsbHubFwUpdate|VirtualFunctionEnum)|Synth3dVsp|uwfreg|uwfs|uwfvol|usbaudio\d*|SiSRaid2|UcmUcsiCx\d*|smbdirect|UcmUcsiAcpiClient|SerCx2|stornvme|UEFI|vms3cap|sbp2port|scfilter|sdbus|SpbCx|UCX01000|USBHUB3|USBXHCI|storahci|storvsp|Serenum|SerCx|spaceport|sdstor|Serial|sermouse|sffdisk|sffp_mmc|sffp_sd|sfloppy|Sftfslh|Sftplaylh|Sftredirlh|Sftvollh|sisagp|Smb|softehci|SOFTHIDUSBK|SOFTUSBK|sonydcam|spldr|srv|srvnet|srv2|vmstorfl|storvsc|swenum|Synth3dVsc|Tcpip|UASPStor|tcpipreg|TDPIPE|TDTCP|tdx|TPM|serscan|TermDD|terminpt|tssecsrv|TsUsbFlt|TsUsbhub|TsUsbGD|tunmp|tunnel|uagp35|udfs|uliagpkx|UmPass|usb8023|usb8023x|usbccgp|usbcir|usbehci|usbehci_dsf|usbser|usbhub|usbohci|ufxsynopsys|UfxChipidea|UrsChipidea|UrsCx01000|UrsSynopsys|usbprint|usbscan|USBSTOR|usbvideo|usbuhci|VMBusVideoM|storufs|Ufx01000|storqosflt|UcmCx|UcmUcsi|WindowsTrustedRT|WindowsTrustedRTProxy|UdeCx|scmbus|scmdisk\d+|SpatialGraphFilter|Surface(AccessoryDevice|Button|CapacitiveHomeButton|CoSAR|DigitizerIntegration|DisplayCalibration|DockIntegration|IntegrationDriver|PciController|PenClickFilter|PenDriver|PenIntegration|Pro4TypeCoverIntegration|StorageFwUpdate|SystemTelemetryDriver|TouchServicingML|TypeCover|TypeCoverV3Integration|SoftwareServicingDriver)|umbus).sys \[.+\] \(Microsoft.+ -> Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (sftplay|sftfs|sftvol|RxFilter); " & $C & "\\Program Files(| \(x86\))\\Microsoft Application Virtualization Client\\drivers\\(sftplaylh|sftfslh|sftvollh).sys \[.+\] \(Microsoft.+ -> Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (MsSecCore|MsSecWfp|hnswfpdriver|vkrnlintvsp|vkrnlintvsc|WinSetupBoot|Telemetry|VMSNPXYMP|VMSNPXY|VfpExt|WmsVolFilter|WmsWlFltr|VMSMP|WinQuic|SgrmAgent|WdmCompanionFilter|VMSP|vmsproxy|VMSVSF|VMSVSP|WinNat|UcmTcpciCx\d+|UevAgentDriver|wcnfs|vmgid|volume|wcifs|xinputhid|xboxgip|xusb22|vhf|wdiwifi|Wof|vdrvroot|VX3000|vga|VgaSave|vhdmp|WUDFSensorLP|WUDFWpdMtp|Vid|VerifierExt|WFPLWFS|wpcfltr|WpdUpFltr|WUDFWpdFs|vpci|vmbus|VMBusHID|vmm|vpcivsp|vmbusr|volmgr|volmgrx|vpcbus|VPCNetS2|vpcnfltr|vpcusb|vpcuxd|vpcvmm|WpdUsb|vwifibus|vwififlt|vwifimp|WANARP|Wanarpv6|Wd|Wdf01000|WfpLwf|WimFltr|WIMMount|WinUsb|WpdUsb|ws2ifsl|WmiAcpi|WSDPrintDevice|WSDScan|WudfPf|WUDFRd|VX1000|VX6000|xnacc|xwvskpdi|xusb21|zmhtrqla); " & $C & "\\Windows\\System32\\DRIVERS\\(MsSecCore|MsSecWfp|hnswfpdriver|vkrnlintvsp|vkrnlintvsc|IntelTA|WinSetupBoot|VmsProxyHNic|VfpExt|WmsVolFilter|WmsWlFltr|WinQuic|SgrmAgent|WdmCompanionFilter|Wof|vdrvroot|vga|vgapnp|vhdmp|VerifierExt|WFPLWFS|wpcfltr|WpdUpFltr|WUDFWpdFs|vmbus|vpcivsp|VMBusHID|vmm|vmbusr|volmgr|volmgrx|vpchbus|vpcnfltr|vpcusb|vpcuxd|VMNetSrv|vpcvmm|WpdUsb|vwifibus|VX3000|vwififlt|vwifimp|WANARP|Wd|Wdf01000|WfpLwf|WimFltr|WIMMount|WinUsb|WmiAcpi|WpdUsb|ws2ifsl|xusb22|vhf|wdiwifi|WSDPrint|WSDScan|WudfPf|WUDFRd|VX1000|vpci|VX6000Xp|xnacc|xwvskpdi|Vid|WUDFRd|xusb21|zmhtrqla|xboxgip|xinputhid|UevAgentDriver|wcnfs|vmgid|volume|wcifs|UcmTcpciCx|WinNat|vmswitch|vmsproxy|vmswitch).sys \[.+\] \(Microsoft.+ -> Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (afunix|WimFltr|WIMMount); " & $C & "\\Windows\\(System32|SysWOW64)\\DRIVERS\\(afunix|WimFltr|WIMMount).sys \[.+\] \(Microsoft.+ -> Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] VSPerfDrv90; " & $C & "\\Program Files(| \(x86\))\\Microsoft Visual Studio 9.0\\Team Tools\\Performance Tools\\x64\\VSPerfDrv90.sys \[.+\] \(Microsoft.+ -> Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (KeyboardFingerprintIntegration|SurfaceAls290XXDriver); " & $C & "\\Windows\\(System32|SysWOW64)\\DRIVERS\\(KeyboardFingerprintIntegration|SurfaceAls290XXDriver).sys \[.+\] \(Microsoft.+ -> Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (acpipagr|AcpiPmi|devmap|DisplayMux|I3CHost|uiomap|UmPass|vwifibus|vwifimp|WinI3C|StillCam|GenPass|Usb4HostRouter|Usb4DeviceRouter|Surface(UcmUcsiHidClient|PowerFilter|HidMini)|AudioCompositor|PRM|Xvdd|gameflt|VirtualRender|UrsChipidea|UrsSynopsys|umbus|UfxChipidea|UEFI|genericusbfn); " & $C & "\\Windows\\System32\\DriverStore\\FileRepository\\[^\\]+\\(acpipagr|AcpiPmi|devmap|DisplayMux|I3CHost|uiomap|UmPass|vwifibus|vwifimp|WinI3C|pluton-heci|serscan|GenPass|Usb4HostRouter|Usb4DeviceRouter|Surface(UcmUcsiHidClient|PowerFilter|hidminidriver)|AudioCompositor|PRM|Xvdd|gameflt|vrd|UrsChipidea|UrsSynopsys|umbus|UfxChipidea|UEFI|genericusbfn).sys \[.+\] \(Microsoft.+ -> Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (NetworkPrivacyPolicy|PlutonHsp2|plutonheci); " & $C & "\\Windows\\System32\\DriverStore\\FileRepository\\[^\\]+\\(NetworkPrivacyPolicy|pluton-heci|PlutonHsp2).sys \[.+\] \(Microsoft.+ -> \)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][01234] (RoutePolicy|NDKPerf|SurfaceIntegrationDriver|TrueColor|SDFRd|Usb4HostRouter); " & $C & "\\Windows\\(System32|SysWOW64)\\DRIVERS\\(RoutePolicy|NDKPerf|SurfaceIntegrationDriver|TrueColor|SDFRd|Usb4HostRouter).sys \[.+\] \(Microsoft.+ -> (|Microsoft).*\)\v{2}" , "" )
EndFunc
Func WHITELISTREG ( )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)HKLM\\Software(|\\Wow6432Node)\\Microsoft\\Active Setup\\Installed Components: \[{.+}\] -> " & $C & "\\WINDOWS\\(SysWOW64|system32)\\Rundll32.exe " & $C & "\\WINDOWS\\(system32|SysWOW64)\\mscories.dll,Install\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)HKLM\\Software\\...\\Winlogon\\GPExtensions: \[{8472C2C4-6B70-4301-A20D-A6CEA5F82B7E}\] -> " & $C & "\\WINDOWS\\system32\\StartTileData\.dll \[.+\] \(Microsoft.+-> Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)HKLM\\Software\\...\\Winlogon\\GPExtensions: \[{9F02E2F5-5A41-4D1A-B473-4617E84BC957}\] -> " & $C & "\\WINDOWS\\system32\\WindowsProtectedPrintConfiguration\.dll \[.+\] \(Microsoft.+-> Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)HKLM\\...\\Print\\Monitors\\Virtual Port Monitor: " & $C & "\\WINDOWS\\system32\\VirtualMon.dll \[.+\] \(Microsoft.+-> Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)HKLM(|-x32)\\...\\Winlogon: \[Userinit\] " & $C & "\\WINDOWS\\(system32|sysWOW64)\\userinit\.exe \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)HKLM\\...\\Run: \[(HotKeysCmds|IgfxTray|Persistence)\] => [C-Z]:\\WINDOWS\\system32\\(igfxtray|hkcmd|igfxpers)\.exe \[.+\] \(Intel.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)HKU\\.+\\Run: \[Sidebar\] => .+\\Windows Sidebar\\Sidebar\.exe \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)HKU\\.+\\Run: \[Speech Recognition\] => .+\\WINDOWS\\Speech\\Common\\sapisvr.exe \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)HKU\\.+\\RunOnce: \[WAB Migrate\] => .+\\Program Files\\Windows Mail\\wab\.exe \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)HKLM\\.+\\Run: \[SecurityHealth\] => [C-Z]:\\WINDOWS\\system32\\SecurityHealthSystray\.exe \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)HKU\\.+\\Run: \[WindowsWelcomeCenter\] => rundll32.exe oobefldr.dll,ShowWelcomeCenter\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)HKU\\.+\\SCRNSAVE.EXE -> .:\\WINDOWS\\(system32|SysWOW64)\\logon.scr \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)HKU\\.+\\Run: \[OneDriveSetup\] => .+\\Windows\\(system32|SysWOW64)\\OneDriveSetup\.exe \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)HKU\\.+\\Run: \[OneDrive\] => .+\\Users\\.+?\\AppData\\Local\\Microsoft\\OneDrive\\OneDrive.exe \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)HKLM(|-x32)\\...\\Winlogon: \[Shell\] " & $C & "\\Windows(|\\SysWOW64)\\Explorer\.exe \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)HKLM(|-x32)\\...\\Winlogon: \[UIHost\] " & $C & "\\WINDOWS(|\\SysWOW64)\\system32\\logonui.exe \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)HKLM\\...\\Providers\\(Internet Print Provider|LanMan Print Services): .:\\Windows\\system32\\(inetpp|win32spl).dll \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)(HKLM|HKU)\\.+\\Policies\\Explorer: \[(NoDriveTypeAutoRun|NoDriveAutoRun)\] \d+\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)(HKLM|HKU)\\.+\\Policies\\Explorer: \[(NoSimpleNetIDList|ClearRecentDocsOnExit|NoResolveTrack|BindDirectlyToPropertySetStorage|HonorAutoRunSetting|NoActiveDesktop|NoActiveDesktopChanges)\] (1|0)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)(HKLM|HKU)\\.+\\Policies\\Explorer: \[(ForceActiveDesktopOn|NoRecentDocsHistory|NoLowDiskSpaceChecks|NoSMHelp|StartMenuLogoff|NoFileAssociate|NoPropertiesMyComputer|NoRun|NoClose|NoDrives|NoCDBurning|NoFolderOptions|NoControlPanel)\] 0\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)Lsa: \[Authentication Packages\] msv1_0(| SshdPinAuthLsa)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)Lsa: \[Notification Packages\] (rassfm |)scecli( rassfm|)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)SecurityProviders: credssp.dll\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)IFEO\\svchost.exe: \[MinimumStackCommitInBytes\] 32768\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)(HKLM|HKU)\\.+\[(DisableTaskMgr|DisableRegistryTools|NoDesktop|DisableRegedit|DisableCMD)\] 0\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)HKU\\.+\\RunOnce: \[mctadmin\] => " & $C & "\\WINDOWS\\system32\\mctadmin\.exe \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)(HKLM|HKU\\.+)\\ DisallowedCertificates: (D3FD325D0F2259F693DD789430E3A9430BB59B98|C597D4E7FF9CE5BD3EC321C11827FCA9294A6BA1|9FEB091E053D1C453C789E8E9C446D31CB177ED9|8835437D387BBB1B58FF5A0FF8D003D8FE04AED4|6B6FA65B1BDC2A0F3A7E66B590F93297B8EB56B9|6A2C691767C2F1999B8C020CBAB44756A99A0C41|3AD010247A8F1E991F8DDE5D47989CB5202E5614|1990649205B55EAB5D692E9EDB1BE0DDD3B037DE|AC06108CA348CC03B53795C64BF84403C1DBD341|929BF3196896994C0A201DF4A5B71F603FEFBF2E|22BBE981F0694D246CC1472ED2B021DC8540A22F|1916A2AF346D399F50313C393200F14140456616|2A83E9020591A55FC6DDAD3FB102794C52B24E70|2B84BFBB34EE2EF949FE1CBE30AA026416EB2216|305F8BD17AA2CBC483A4C41B19A39A0C75DA39D6|367D4B3B4FCBBC0B767B2EC0CDB2A36EAB71A4EB|3A850044D8A195CD401A680C012CB0A3B5F8DC08|40AA38731BD189F9CDB5B9DC35E2136F38777AF4|43D9BCB568E039D073A74A71D8511F7476089CC3|471C949A8143DB5AD5CDF1C972864A2504FA23C9|51C3247D60F356C7CA3BAF4C3F429DAC93EE7B74|5DE83EE82AC5090AEA9D6AC4E7A6E213F946E179|61793FCBFA4F9008309BBA5FF12D2CB29CD4151A|637162CC59A3A1E25956FA5FA8F60D2E1C52EAC6|63FEAE960BAA91E343CE2BD8B71798C76BDB77D0|6431723036FD26DEA502792FA595922493030F97|7D7F4414CCEF168ADF6BF40753B5BECD78375931|80962AE4D6C5B442894E95A13E4A699E07D694CF|86E817C81A5CA672FE000F36F878C19518D6F844|8E5BD50D6AE686D65252F843A9D4B96D197730AB|9845A431D51959CAF225322B4A4FE9F223CE6D15|B533345D06F64516403C00DA03187D3BFEF59156|B86E791620F759F17B8D25E38CA8BE32E7D5EAC2|C060ED44CBD881BD0EF86C0BA287DDCF8167478C|CEA586B2CE593EC7D939898337C57814708AB2BE|D018B62DC518907247DF50925BB09ACF4A5CB3AD|F8A54E03AADC5692B850496A4C4630FFEAA29D83|FA6660A94AB45F6A88C0D7874D89A863D74DEE97|02C2D931062D7B1DC2A5C7F5F0685064081FB221|08738A96A4853A52ACEF23F782E8E1FEA7BCED02|08E4987249BC450748A4A78133CBF041A3510033|09271DD621EBD3910C2EA1D059F99B8181405A17|09FF2CC86CEEFA8A8BB3F2E3E84D6DA3FABBF63E|23EF3384E21F70F034C467D4CBA6EB61429F174E|330D8D3FD325A0E5FDDDA27013A2E75E7130165F|374D5B925B0BD83494E656EB8087127275DB83CE|3A26012171855D4020C973BEC3F4F9DA45BD2B83|3EB44E5FFE6DC72DED703E99902722DB38FFD1CB|4822824ECE7ED1450C039AA077DC1F8AE3489BBF|4D8547B7F864132A7F62D9B75B068521F10B68E3|4DF13947493CFF69CDE554881C5F114E97C3D03B|4ED8AA06D1BC72CA64C47B1DFE05ACC8D51FC76F|587B59FB52D8A683CBE1CA00E6393D7BB923BC92|5CE339465F41A1E423149F65544095404DE6EBE2|5D5185DF1EB7DC76015422EC8138A5724BEE2886|6690C02B922CBD3FF0D0A5994DBD336592887E3F|7311E77EC400109D6A5326D8F6696204FD59AA3B|7613BF0BA261006CAC3ED2DDBEF343425357F18B|838FFD509DE868F481C29819992E38A4F7082873|8977E8569D2A633AF01D0394851681CE122683A6|8B2E65A5DA17FCCCBCDE7EF87B0C0ED5D0701F9F|915A478DB939925DA8D9AEA12D8BBA140D26599C|98A04E4163357790C4A79E6D713FF0AF51FE6927|A1505D9843C826DD67ED4EA5209804BDBB0DF502|A221D360309B5C3C4097C44CC779ACC5A9845B66|A35A8C727E88BCCA40A3F9679CE8CA00C26789FD|A7B5531DDC87129E2C3BB14767953D6745FB14A6|A81706D31E6F5C791CD9D3B1B9C63464954BA4F5|BED412B1334D7DFCEBA3015E5F9F905D571C45CF|C6796490CDEEAAB31AED798752ECD003E6866CB2|C69F28C825139E65A646C434ACA5A1D200295DB1|D0BB3E3DFBFB86C0EEE2A047E328609E6E1F185E|D2DBF71823B2B8E78F5958096150BFCB97CC388A|D43153C8C25F0041287987250F1E3CABAC8C2177|D8CE8D07F9F19D2569C2FB854401BC99C1EB7C3B|DB5042ED256FF426867B332887ECCE2D95E79614|E1F3591E769865C4E447ACC37EAFC9E2BFE4C576|E38A2B7663B86796436D8DF5898D9FAA6835B238|E95DD86F32C771F0341743EBD75EC33C74A3DED9|E9809E023B4512AA4D4D53F40569C313C1D0294D|F5A874F3987EB0A9961A564B669A9050F770308A|F92BE5266CC05DB2DC0DC3F2DC74E02DEFD949CB) \(U\)\v{2}" , "" )
EndFunc
Func WHITELISTSRV ( )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] AESTFilters; " & $C & "\\Windows\\System32\\DriverStore\\FileRepository\\.+\\AESTSr64.exe \[.+\] \(Andrea.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] AESTFilters; " & $C & "\\Program Files\\IDT\\WDM\\AESTSr64.exe \[.+\] \(Andrea.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] AFBAgent; " & $C & "\\Windows\\system32\\FBAgent.exe \[.+\] \(ASUSTeK Computer.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] AlotService; " & $C & "\\Users\\Lanre\\AppData\\LocalLow\\alotservice\\alotservice.exe \[.+\] \(Vertro.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] AgereModemAudio; " & $C & "\\Program Files\\LSI SoftModem\\agr64svc.exe \[.+\] \(LSI.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] AgereModemAudio; " & $C & "\\Windows\\system32\\agr64svc.exe \[.+\] \(Agere.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] Akamai; " & $C & "\\program files(| \(x86\))\\common files\\akamai/netsession_win_4f7fccd.dll \[.+\] \(Akamai.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] AlienFusionService; " & $C & "\\Program Files\\Alienware\\Command Center\\AlienFusionService.exe \[.+\] \(Alienware.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] Amazon Download Agent; " & $C & "\\Program Files(| \(x86\))\\Amazon\\Amazon Games & Software Downloader\\AmazonGSDownloaderService.exe \[.+\] \(Amazon.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] AOL ACS; " & $C & "\\Program Files(| \(x86\))\\Common Files\\AOL\\ACS\\AOLAcsd.exe \[.+\] \(AOL.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] AOL TopSpeedMonitor; " & $C & "\\Program Files(| \(x86\))\\Common Files\\AOL\\TopSpeed\\2.0\\aoltsmon.exe \[.+\] \(AOL.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] Apache2.2; " & $C & "\\Program Files(| \(x86\))\\Common Files\\Dell\\apache\\bin\\httpd.exe -k runservice \[.+\] \(Apache.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] Apple Mobile Device; " & $C & "\\Program Files(| \(x86\))\\Common Files\\Apple\\Mobile Device Support\\AppleMobileDeviceService.exe \[.+\] \(Apple.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] AppleTimeSrv; " & $C & "\\Windows\\system32\\AppleTimeSrv.exe \[.+\] \(Apple.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] Application Updater; " & $C & "\\Program Files(| \(x86\))\\Application Updater\\ApplicationUpdater.exe \[.+\] \(Spigot.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (ATKGFNEXSrv|ASLDRService); " & $C & "\\Program Files(| \(x86\))\\ASU(S|S\\ATK Package)\\(ATK Hotkey|ATKGFNEX)\\(ASLDRSrv|GFNEXSrv).exe \[.+\] \(ASUS.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] ASUS InstantOn; " & $C & "\\Program Files(| \(x86\))\\Common Files\\InstantOn\\InsOnSrv.exe \[.+\] \(ASUS.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] arXfrSvc; " & $C & "\\Program Files\\Windows Server\\Bin\\Microsoft.HomeServer.Archive.TransferService.exe \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (Wms|WmsRepair); " & $C & "\\Program Files\\Windows MultiPoint Server\\(WmsSvc|WmsSelfHealingSvc).exe \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] aspnet_state; " & $C & "\\Windows\\Microsoft.NET\\Framework64\\v.........\\aspnet_state.exe \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] atashost; " & $C & "\\Windows\\SysWOW64\\atashost.exe \[.+\] \(Cisco.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] AtherosSvc; " & $C & "\\Program Files(| \(x86\))(\\|\\Dell Wireless\\)Bluetooth Suite\\adminservice.exe \[.+\] \(Atheros.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] Autodesk Licensing Service; " & $C & "\\Program Files(| \(x86\))\\Common Files\\Autodesk Shared\\Service\\AdskScSrv.exe  \[.+\] \(Autodesk.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] Ati External Event Utility; " & $C & "\\Windows\\System32\\Ati2evxx.exe \[.+\] \(ATI.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] ATService; " & $C & "\\Program Files\\Fingerprint Sensor\\ATService.exe \[.+\] \(AuthenTec.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (BBSvc|BBUpdate); " & $C & "\\Program Files(| \(x86\))\\Microsoft\\BingBar(\\|\\.........\\)(BBSvc|SeaPort).EXE.*\[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] BcmSqlStartupSvc; " & $C & "\\Program Files(| \(x86\))\\Microsoft Small Business\\Business Contact Manager\\BcmSqlStartupSvc.exe \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] BCUService; " & $C & "\\Program Files(| \(x86\))\\DeviceVM\\Browser Configuration Utility\\BCUService.exe \[.+\] \(DeviceVM.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] bgsvcgen; " & $C & "\\Windows\\SysWOW64\\bgsvcgen.exe.*\[.+\] \(B.H.A Corporation.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] BingDesktopUpdate; " & $C & "\\Program Files(| \(x86\))\\Microsoft\\BingDesktop\\BingDesktopUpdater.exe [.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] Bonjour Service; " & $C & "\\Program Files(| \(x86\))\\Bonjour\\mDNSResponder.exe \[.+\] \(Apple.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] BPowMon; " & $C & "\\Program Files\\Broadcom\\BPowMon\\BPowMon.exe \[.+\] \(Broadcom.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (Bluetooth Device Manager|Bluetooth Device Monitor|Bluetooth Media Service|Bluetooth OBEX Service|PST Service); " & $C & "\\Program Files(| \(x86\))\\(Intel|Motorola)\\(Bluetooth|MotForwardDaemon)\\(audiosrv|devmgrsrv|obexsrv|ForwardDaemon|devmonsrv|mediasrv|obexsrv).exe \[.+\] \((Motorola|Intel).*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] BrYNSvc; " & $C & "\\Program Files(| \(x86\))\\Browny02\\BrYNSvc.exe \[.+\] \(Brother.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] BTHSSecurityMgr; " & $C & "\\Program Files\\Intel\\BluetoothHS\\BTHSSecurityMgr.exe \[.+\] \(Inte.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] btwdins; " & $C & "\\Program Files\\(WIDCOMM|ThinkPad)\\Bluetooth Software\\btwdins.exe \[.+\] \(Broadcom.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] btwdins; " & $C & "\\Program Files\\(WIDCOMM|Lenovo)\\Bluetooth Software\\bin\\btwdins.exe \[.+\] \(Broadcom.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] buttonsvc64; " & $C & "\\Program Files\\Dell\\Dell ControlPoint\\DCPButtonSvc.exe \[.+\] \(Dell.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] CalendarSynchService; " & $C & "\\Program Files(| \(x86\))\\Hewlett-Packard\\TouchSmart\\Calendar\\Service\\GCalService.exe \[.+\] \(Hewlett.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] CarboniteService; " & $C & "\\Program Files(| \(x86\))\\Carbonite\\Carbonite Backup\\carboniteservice.exe.* \[.+\] \(Carbonite.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] CcmExec; " & $C & "\\Windows\\SysWOW64\\CCM\\CcmExec.exe \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (cfWiMAXService|ConfigFree Service); " & $C & "\\Program Files(| \(x86\))\\TOSHIBA\\ConfigFree\\(CFIWmxSvcs64|CFSvcs).exe \[.+\] \(TOSHIBA.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] CinemaNow Service; " & $C & "\\Program Files(| \(x86\))\\CinemaNow\\CinemaNow Media Manager\\CinemanowSvc.exe \[.+\] \(CinemaNow.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] CLKMSVC10_\w{8}; " & $C & "\\Program Files(| \(x86\))\\CyberLink\\PowerDVD\d+\\NavFilter\\kmsvc.exe .+ \[.+\] \(CyberLink.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] CodeMeter.exe; " & $C & "\\Program Files(| \(x86\))\\CodeMeter\\Runtime\\bin\\CodeMeter.exe \[.+\] \(WIBU.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[SR][123] (vmvss|COMSysApp); " & $C & "\\Windows\\(system32|SysWow64)\\dllhost.exe /Processid:\{.+\} \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] Com4QLBEx; " & $C & "\\Program Files(| \(x86\))\\Hewlett-Packard\\HP Quick Launch Buttons\\Com4QLBEx.exe \[.+\] \(Hewlett.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] ConfigFree Gadget Service; " & $C & "\\Program Files(| \(x86\))\\TOSHIBA\\ConfigFree\\CFProcSRVC.exe \[.+\] \(TOSHIBA.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] ConfigFree Service; " & $C & "\\Program Files(| \(x86\))\\TOSHIBA\\ConfigFree\\CFSvcs.exe \[.+\] \(TOSHIBA.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] clr_optimization_v2\.0\.50727_32; " & $C & "\\Windows\\Microsoft.NET\\F.+k\\.+\\mscorsvw.exe \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] clr_optimization_v2.0.50727_64; " & $C & "\\Windows\\Microsoft.NET\\Framework64\\v2.0.50727\\mscorsvw.exe \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] clr_optimization_v4.0.30319_32; " & $C & "\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\mscorsvw.exe \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] clr_optimization_v4.0.30319_64; " & $C & "\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\mscorsvw.exe \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] CoordinatorServiceHost; " & $C & "\\Program Files\\SolidWorks Corp\\SolidWorks\\swScheduler\\DTSCoordinatorService.exe \[.+\] \(Dassault.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] cphs; " & $C & "\\Windows\\SysWow64\\IntelCpHeciSvc.exe \[.+\] \(Intel.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] Creative (ALchemy AL6|Audio Engine|Media Toolbox 6) Licensing Service; " & $C & "\\Program Files(| \(x86\))\\Common Files\\Creative Labs Shared\\Service\\(AL6Licensing|CTAELicensing|MT6Licensing).exe \[.+\] \(Creative.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] Credential Vault Host (Control Service|Storage); " & $C & "\\Program Files\\Broadcom Corporation\\Broadcom USH Host Components\\CV\\bin\\(HostControlService|HostStorageService).exe \[.+\] \(Broadcom.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] CryptSvc; " & $C & "\\Windows\\(System32|SysWow64)\\cryptsvc.dll \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] CscService; " & $C & "\\Windows\\System32\\cscsvc.dll \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] CTAudSvcService; " & $C & "\\Program Files(| \(x86\))\\Creative\\Shared Files\\CTAudSvc.exe \[.+\] \(Creative.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] cvhsvc; " & $C & "\\Program Files(| \(x86\))\\Common Files\\Microsoft Shared\\Virtualization Handler\\CVHSVC.exe \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] CVPND; " & $C & "\\Program Files(| \(x86\))\\Cisco Systems\\VPN Client\\cvpnd.exe \[.+\] \(Cisco.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] CyMiniProg3Service; " & $C & "\\Program Files(| \(x86\))\\Cypress\\Programmer\\....\\Service\\CyMiniProg3Service.exe \[.+\] \(Cypress.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] DAUpdaterSvc; " & $C & "\\Program Files(| \(x86\))\\Dragon Age\\bin_ship\\DAUpdaterSvc.Service.exe \[.+\] \(BioWare.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] dcpsysmgrsvc; " & $C & "\\Program Files\\Dell\\Del(l|l ControlPoint\\) System Manager\\DCPSysMgrSvc.exe \[.+\] \(Dell.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (DDNIMSGService|DDNIService); " & $C & "\\Program Files(| \(x86\))\\DDNI\\(DIBS|Lenovo Idea Notes)\\(DDNIService|DDNIMSGService).exe \[.+\] \(Digital.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] DellDigitalDelivery; " & $C & "\\Program Files(| \(x86\))\\Dell Digital Delivery\\DeliveryService.exe \[.+\] \(Dell.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] DellOSDservice; " & $C & "\\Program Files\\Dell\\OSD\\DellOSDservice.exe \[.+\] \(Microsoft.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] Desura Install Service; " & $C & "\\Program Files(| \(x86\))\\Common Files\\Desura\\desura_service.exe \[.+\] \(Desura.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] Device Handle Service; " & $C & "\\Windows\\SysWOW64\\AsHookDevice.exe \[.+\] \(ASUSTeK.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] DeviceMonitorService; " & $C & "\\Program Files(| \(x86\))\\Motorola Media Link\\Lite\\NServiceEntry.exe \[.+\] \(Nero.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] Dhcp; " & $C & "\\Windows\\SysWow64\\(dhcpcore|dhcpcsvc).dll \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] DigiRefresh; " & $C & "\\Program Files(| \(x86\))\\Digidesign\\Drivers\\MMERefresh.exe -s \[.+\] \(Avid.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] digiSPTIService; " & $C & "\\Program Files(| \(x86\))\\Digidesign\\Pro Tools\\digiSPTIService.exe \[.+\] \(Avid.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] diagnosticshub.standardcollector.service; " & $C & "\\Windows\\system32\\DiagSvcs\\DiagnosticsHub\.StandardCollector\.Service\.exe \[.+\] \(Microsoft.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] DMAgent; " & $C & "\\Program Files\\Intel\\WiMAX\\Bin\\DMAgent.exe \[.+\] \(Red.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] DockLoginService; " & $C & "\\Program Files\\Dell\\DellDock\\DockLogin.exe \[.+\] \(Stardock.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] DpHost; " & $C & "\\Program Files(| \(x86\))\\DigitalPersona\\Bin\\DpHostW.exe \[.+\] \(DigitalPersona.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] DPS; " & $C & "\\Windows\\System32\\dps.dll \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] dsl-fs-sync; " & $C & "\\Program Files(| \(x86\))\\Common Files\\Dell\\Remote Access File Sync Service\\dsl_fs_sync.exe \[.+\] \(SingleClick.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] DragonSvc; " & $C & "\\Program Files(| \(x86\))\\Common Files\\Nuance\\dgnsvc.exe \[.+\] \(Nuance.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] DsiWMIService; " & $C & "\\Program Files(| \(x86\))\\Launch Manager\\dsiwmis.exe \[.+\] \(Dritek.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] dsNcService; " & $C & "\\Program Files(| \(x86\))\\Juniper Networks\\Common Files\\dsNcService.exe \[.+\] \(Juniper.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] DTSAudioService; " & $C & "\\Program Files\\Realtek\\Audio\\HDA\\DTSAudioService64.exe \[.+\] \(Egis.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] DvmMDES; " & $C & "\\Program Files(| \(x86\))\\Dell Precision ON Flash\\config\\DVMExportService.exe \[.+\] \(DeviceVM.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] EFI License Manager; " & $C & "\\Program Files(| \(x86\))\\FlexLM\\lmgrd.exe \[.+\] \(Acresso.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] EFI XF Server; " & $C & "\\Program Files\\EFI\\EFI XF\\Server\\EFI_XF_Server.exe.* \[.+\] \(Electronics.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] EgisTec Service; " & $C & "\\Program Files(| \(x86\))\\EgisTec BioExcess\\EgisService.exe \[.+\] \(Egis.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] EgisTec Service Help; " & $C & "\\Program Files(| \(x86\))\\EgisTec Port Locker\\Egishlpsvc.exe \[.+\] \(DTS.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] EgisTec Ticket Service; " & $C & "\\Program Files(| \(x86\))\\Common Files\\EgisTec\\Services\\EgisTicketService.exe \[.+\] \(Egis.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (ehRecvr|ehSched|ehstart); " & $C & "\\Windows\\ehome\\(ehRecvr.exe|ehsched.exe|ehstart.dll) \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] ePowerSvc; " & $C & "\\Program Files\\(Acer|Gateway)\\(Acer ePower|Gateway Power) Management\\ePowerSvc.exe \[.+\] \(Acer.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] EPSON_EB_RPCV4_01; " & $C & "\\ProgramData\\EPSON\\EPW!3 SSRP\\E_S40STB.EXE \[.+\] \(SEIKO.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] EPSON_PM_RPCV4_01; " & $C & "\\ProgramData\\EPSON\\EPW!3 SSRP\\E_S40RPB.EXE \[.+\] \(SEIKO.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] EPSON_EB_RPCV4_04; " & $C & "\\Program Files\\Common Files\\EPSON\\EPW!3 SSRP\\E_S50STB.EXE \[.+\] \(SEIKO.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] EPSON_PM_RPCV4_0.; " & $C & "\\Program Files\\Common Files\\EPSON\\EPW!3 SSRP\\(E_S50RPB|E_WT50RP).EXE \[.+\] \(SEIKO.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] EpsonBidirectionalService; " & $C & "\\Program Files(| \(x86\))\\Common Files\\EPSON\\EBAPI\\eEBSVC.exe \[.+\] \(SEIKO.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] EpsonCustomerParticipation; " & $C & "\\Program Files\\EPSON\\EpsonCustomerParticipation\\EPCP.exe \[.+\] \(SEIKO.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] ePowerSvc; " & $C & "\\Program Files\\Acer\\Acer ePower Management\\ePowerSvc.exe \[.+\] \(Acer.*+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] ERDAS; " & $C & "\\Program Files(| \(x86\))\\Leica Geosystems\\Shared\\Bin\\NTx86\\lmgrd.exe \[.+\] \(Macrovision.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] EvtEng; " & $C & "\\Program Files\\Intel\\WiFi\\bin\\EvtEng.exe \[.+\] \(Intel.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] ExpatSrv; " & $C & "\\Program Files(| \(x86\))\\Expat Shield\\HssWPR\\hsssrv.exe \[.+\] \(AnchorFree.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] ezSharedSvc; " & $C & "\\Windows\\SysWow64\\(ezSharedSvcHost.exe|ezsvc7.dll) \[.+\] \(EasyBits.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (Fabs|FirebirdServerMAGIXInstance); " & $C & "\\Program Files(| \(x86\))\\Common Files\\MAGIX Services\\Database\\bin\\(FABS|fbserver).exe.* \[.+\] \(MAGI.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] UPnPService; " & $C & "\\Program Files(| \(x86\))\\Common Files\\MAGIX Shared\\UPnPService\\UPnPService.exe \[.+\] \(MAGIX.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (dnWhoDisp|Harmony); " & $C & "\\Program Files(| \(x86\))\\Rockwell Software\\(RSLINX|RSCommon)\\(dnwhodisp|RSOBSERV).exe \[.+\] \(Rockwell.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (EventClientMultiplexer|EventServer|NmspHost|RNADiagReceiver|RdcyHost|RNADiagnosticsService|RNADirectory|RNADirMultiplexor|RoxMediaDB13|RsvcHost); " & $C & "\\Program Files(| \(x86\))\\Common Files\\Rockwell\\(EventClientMultiplexer|EventServer|NmspHost|RNADiagReceiver|RdcyHost|RNADiagnosticsSrv|RnaDirServer|RNADirMultiplexor|RoxMediaDB13|RsvcHost).exe \[.+\] \(Rockwell.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] FAService; " & $C & "\\Program Files(| \(x86\))\\Sensible Vision\\Fast Access\\FAService.exe.* \[.+\] \(Sensible.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] Fitbit; " & $C & "\\Program Files(| \(x86\))\\Fitbit\\fitbit.exe \[.+\] \(Fitbit.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] FLEXnet Licensing Service; " & $C & "\\Program Files(| \(x86\))\\Common Files\\Macrovision Shared\\FLEXnet Publisher\\FNPLicensingService.exe.*\[.+\] \((Acresso|Flexera|Macrovision).+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] FLEXnet Licensing Service 64; " & $C & "\\Program Files\\Common Files\\Macrovision Shared\\FLEXnet Publisher\\FNPLicensingService64.exe \[.+\] \((Acresso|Flexera|Macrovision).+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] FontCache3.0.0.0; " & $C & "\\Windows\\Microsoft.Net\\Framework64\\v3.0\\WPF\\PresentationFontCache.exe \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] FPLService; " & $C & "\\Program Files(| \(x86\))\\HP SimplePass 2011\\TrueSuiteService.exe \[.+\] \(HP.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] FreeAgentGoNext Service; " & $C & "\\Program Files(| \(x86\))\\Seagate\\SeagateManager\\Sync\\FreeAgentService.exe \[.+\] \(Seagate.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] fsssvc; " & $C & "\\Program Files(| \(x86\))\\Windows Live\\Family Safety\\fsssvc.exe \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] fussvc; " & $C & "\\Program Files\\Windows Kits\\..0\\App Certification Kit\\fussvc.exe [.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] Futuremark SystemInfo Service; " & $C & "\\Program Files(| \(x86\))\\Futuremark\\Futuremark SystemInfo\\FMSISvc.exe \[.+\] \(Futuremark.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] GamesAppService; " & $C & "\\Program Files(| \(x86\))\\WildTangent Games\\App\\GamesAppService.exe \[.+\] \(WildTangent.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] GameConsoleService; " & $C & "\\Program Files(| \(x86\))\\WildTangent\\Dell Games\\Dell Game Console\\GameConsoleService.exe \[.+\] \(WildTangent.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] GameConsoleService; " & $C & "\\Program Files(| \(x86\))\\(Gateway|TOSHIBA|HP|Acer) Games\\(Gateway|TOSHIBA|HP|Acer) Game Console\\GameConsoleService.exe \[.+\] \(WildTangent.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] GameConsoleService; " & $C & "\\Program Files(| \(x86\))\\WildGames\\Game Console - WildGames\\GameConsoleService.exe \[.+\] \(WildTangent.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] GameConsoleService; " & $C & "\\Program Files(| \(x86\))\\HP Games\\My HP Game Console\\GameConsoleService.exe \[.+\] \(WildTangent.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] GoToAssis(t|t Express Customer); " & $C & "\\Program Files(| \(x86\))\\Citrix\\GoToAssis(t|t Express Customer)\\\d{3}\\g2aservice.exe.* \[.+\] \(Citrix.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] GoToMyPC; " & $C & "\\Program Files(| \(x86\))\\Citrix\\GoToMyPC\\g2svc.exe.*\[.+\] \(Citrix.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (GREGService|Greg_Service); " & $C & "\\Program Files(| \(x86\))\\(Gateway|Acer)\\Registration\\(GREGsvc|GregHSRW).exe \[.+\] \(acer.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (gupdate|gupdatem|GoogleUpdaterInternalService\d+.+?|GoogleUpdaterService\d+.+?); " & $C & "\\Program Files(| \(x86\))\\Google\\(Update\\GoogleUpdate|GoogleUpdater\\[^\\]+\\updater).exe.*\[.+\] \(Google LLC -> Google LLC\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] GoogleChromeElevationService; " & $C & "\\Program Files(| \(x86\))\\Google\\Chrome\\Application\\[^\\]+\\elevation_service.exe.*\[.+\] \(Google.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] GS In-Game Service; " & $C & "\\Program Files(| \(x86\))\\GameTracker\\GSInGameService.exe \[.+\] \(ClanServers.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] hasplms; " & $C & "\\Windows\\system32\\hasplms.exe.* \[.+\] \(Aladdin.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] gusvc; " & $C & "\\Program Files(| \(x86\))\\Google\\Common\\Google Updater\\GoogleUpdaterService.exe \[.+\] \(Google.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] Hamachi2Svc; " & $C & "\\Program Files(| \(x86\))\\LogMeIn Hamachi\\hamachi-2.exe.* \[.+\] \(LogMeIn.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] HFGService; " & $C & "\\Windows\\System32\\HFGService.dll \[.+\] \(CSR.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] HiPatchService; " & $C & "\\Program Files(| \(x86\))\\Hi-Rez Studios\\HiPatchService.exe \[.+\] \(Hi-Rez.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] hnmsvc; " & $C & "\\Program Files(| \(x86\))\\Common Files\\Dell\\Advanced Networking Service\\hnm_svc.exe \[.+\] \(Dell.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] HP Power Assistant Service; " & $C & "\\Program Files\\Hewlett-Packard\\HP Power Assistant\\HPPA_Service.exe \[.+\] \(Hewlett.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] HP Wireless Assistant Service; " & $C & "\\Program Files\\Hewlett-Packard\\HP Wireless Assistant\\HPWA_Service.exe \[.+\] \(Hewlett.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] HPClientSvc; " & $C & "\\Program Files\\Hewlett-Packard\\HP Client Services\\HPClientServices.exe \[.+\] \(Hewlett.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (HPDayStarterService|HPWMISVC); " & $C & "\\Program Files(| \(x86\))\\Hewlett-Packard\\HP Quick(Look| Launch)\\32-bit\\(HPDayStarterService|HPWMISVC).exe \[.+\] \(Hewlett.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (hpCMSrv|HPFSService); " & $C & "\\Program Files(| \(x86\))\\Hewlett-Packard\\(File Sanitizer|HP Connection Manager)\\(hpCMSrv|HPFSService).exe \[.+\] \(Hewlett.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (HP Health Check Service|HP Support Assistant Service|HPWMISVC); " & $C & "\\Program Files(| \(x86\))\\Hewlett-Packard\\(HP Health Check|HP Quick Launch|HP Support Framework)\\(hphc_service|hpsa_service|HPWMISVC).exe \[.+\] \(Hewlett.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] HP LaserJet Service; " & $C & "\\Program Files(| \(x86\))\\HP\\HPLaserJetService\\HPLaserJetService.exe \[.+\] \(HP.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] HPSIService; " & $C & "\\Windows\\system32\\HPSIsvc.exe \[.+\] \(HP.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] hpsrv; " & $C & "\\Windows\\System32\\Hpservice.exe \[.+\] \(Hewlett.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (HPDrvMntSvc.exe|hpqwmiex); " & $C & "\\Program Files(| \(x86\))\\Hewlett-Packard\\Shared\\(HPDrvMntSvc|hpqwmiex).exe \[.+\] \(Hewlett.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (hpqcxs08|hpqddsvc|HPSLPSVC); " & $C & "\\Program Files(| \(x86\))\\HP\\Digital Imaging\\bin\\(hpqcxs08|hpqddsvc|HPSLPSVC64).dll \[.+\] \(Hewlett.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] HssSrv; " & $C & "\\Program Files(| \(x86\))\\Hotspot Shield\\HssWPR\\hsssrv.exe \[.+\] \(AnchorFree.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] IAANTMON; " & $C & "\\Program Files(| \(x86\))\\Intel\\Intel Matrix Storage Manager\\IAANTMon.exe \[.+\] \(Intel.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (IAStorDataMgrSvc|ICCS); " & $C & "\\Program Files(| \(x86\))\\Intel\\Intel.+\\(IAStorDataMgrSvc|ICCProxy).exe \[.+\] \(Intel.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] IconMan_R; " & $C & "\\Program Files(| \(x86\))\\Realtek\\Realtek PCIE Card Reader\\RIconMan.exe \[.+\] \(Realsil.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] IDriverT; " & $C & "\\Program Files(| \(x86\))\\Common Files\\InstallShield\\Driver\\(11|1050|1150)\\Intel 32\\IDriverT.exe \[.+\] \(Macrovision.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] idsvc; " & $C & "\\Windows\\Microsoft.NET\\Framework64\\v3.0\\Windows Communication Foundation\\infocard.exe \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] IDVaultSvc; " & $C & "\\Program Files(| \(x86\))\\Constant Guard Protection Suite\\IDVaultSvc.exe \[.+\] \(White.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] c\dwts; " & $C & "\\Program Files\\Windows Identity Foundation\\v\d.\d\\c\dwtshost.exe \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] JungleDiskWorkgroupService; " & $C & "\\Program Files\\Jungle Disk Workgroup\\JungleDiskWorkgroup.exe \[.+\] \(Jungle.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] OpcEnum; " & $C & "\\Windows\\SysWOW64\\OpcEnum.exe\[.+\] \(OPC.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] Power Manager DBC Service; " & $C & "\\Program Files(| \(x86\))\\ThinkPad\\Utilities\\PWMDBSVC.exe \[.+\] \(Lenovo.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] PwmEWSvc; " & $C & "\\Program Files(| \(x86\))\\ThinkPad\\Utilities\\PWMEWSVC.EXE \[.+\] \(Lenovo.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (IBMPMSVC|TPHDEXLGSVC); " & $C & "\\Windows\\System32\\(ibmpmsvc|TPHDEXLG64).exe \[.+\] \(Lenovo.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] IncSvc; " & $C & "\\Program Files(| \(x86\))\\Lenovo\\ReadyComm\\IncSvc.dll \[.+\] \(Lenovo.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (AcPrfMgrSvc|AcSvc|HyperW7Svc|LENOVO.CAMMUTE|LENOVO.TPKNRSVC|Lenovo.VIRTSCRLSVC|SUService|LENOVO.MICMUTE|TPHKLOAD|TPHKSVC); " & $C & "\\Program Files(| \(x86\))\\Lenovo\\(Access Connections|Access Connections|RapidBoot|Communications Utility|System Update|HOTKEY)\\(AcPrfMgrSvc|AcSvc|HyperW7Svc64|CAMMUTE|TPKNRSVC|VIRTSCRL|lvvsst|SUService|MICMUTE|TPHKLOAD|TPHKSVC).exe \[.+\] \(Lenovo.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (IntuitUpdateService|IntuitUpdateServiceV4); " & $C & "\\Program Files(| \(x86\))\\Common Files\\Intuit\\Update Servic(e|e v4)\\IntuitUpdateService.exe \[.+\] \(Intuit.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] IviRegMgr; " & $C & "\\Program Files(| \(x86\))\\Common Files\\InterVideo\\RegMgr\\iviRegMgr.exe \[.+\] \(InterVideo.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] iWinTrusted; " & $C & "\\Program Files(| \(x86\))\\iWin Games\\iWinTrusted.exe \[.+\] \(iWin.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] HssSrv; " & $C & "\\Program Files(| \(x86\))\\Hotspot Shield\\HssWPR\\hsssrv.exe \[.+\] \(Lenovo.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] iPod Service; " & $C & "\\Program Files\\iPod\\bin\\iPodService.exe \[.+\] \(Apple.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] jswpsapi; " & $C & "\\Program Files(| \(x86\))\\NETGEAR\\WNA1100\\jswpsapi.exe \[.+\] \(Atheros.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] IxiaEndpoint; " & $C & "\\Program Files\\Ixia\\Endpoint\\endpoint.exe \[.+\] \(Ixia.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] JuniperAccessService; " & $C & "\\Program Files(| \(x86\))\\Common Files\\Juniper Networks\\JUNS\\dsAccessService.exe \[.+\] \(Juniper.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] Kodak AiO (Network Discovery|Status Monitor) Service; " & $C & "\\Program Files(| \(x86\))\\Kodak\\AiO\\(Center|StatusMonitor)\\(ekdiscovery|EKAiOHostService|EKPrinterSDK).exe \[.+\] \(Eastman.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] KodakSvc; " & $C & "\\Program Files(| \(x86\))\\Kodak\\AiO\\center\\KodakSvc.exe .+ \[.+\] \(Eastman*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] LANConfig; " & $C & "\\Program Files\\Windows Server\\Bin\\LANConfigSvc.exe \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] LBTServ; " & $C & "\\Program Files\\Common Files\\LogiShrd\\Bluetooth\\lbtserv.exe \[.+\] \(Logitech.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] LeapFrog Connect Device Service; " & $C & "\\Program Files(| \(x86\))\\LeapFrog\\LeapFrog Connect\\CommandService.exe \[.+\] \(LeapFrog.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] LightScribeService; " & $C & "\\Program Files(| \(x86\))\\Common Files\\LightScribe\\LSSrvc.exe \[.+\] \(Hewlett.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] LVPrcS64; " & $C & "\\Program Files\\Common Files\\LogiShrd\\LVMVFM\\LVPrcSrv.exe \[.+\] \(Logitech.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (lxddCATSCustConnectService|lxdiCATSCustConnectService); " & $C & "\\Windows\\system32\\spool\\DRIVERS\\x64\\3\\\\(lxddserv|lxdiserv).exe \[.+\] \(Lexmark.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] maconfservice; " & $C & "\\Program Files\\ma-config.com\\x64\\maconfservice.exe \[.+\] \(CybelSoft.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] Marvell Storage Management; " & $C & "\\Program Files(| \(x86\))\\Marvell\\storage\\svc\\mvraidsvc.exe \[.+\] \(Marvell.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] MatrikonOPC Server for Simulation and Testing; " & $C & "\\Program Files(| \(x86\))\\Matrikon\\OPC\\Simulation\\OPCSim.exe \[.+\] \(Matrikon.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] MatrikonSauronMarshal; " & $C & "\\Program Files(| \(x86\))\\Common Files\\MatrikonOPC\\Common\\Marshal.exe \[.+\] \(Matrikon.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (MboxAudioDevMon|MboxMiniAudioDevMon|MboxProAudioDevMon); " & $C & "\\Program Files(| \(x86\))\\Avid\\(Mbox|Mbox Mini|Mbox Pro)\\AudioDevMon.exe \[.+\] \(Avid.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (McciCMService|McciCMService64|McciServiceHost|pcCMService|pcServiceHost); " & $C & "\\Program Files(| \(x86\))\\Common Files\\Motive\\(McciCMService|McciServiceHost|pcCMService|pcCMService64|pcServiceHost).exe \[.+\] \(Alcatel.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] MemeoBackgroundService; " & $C & "\\Program Files(| \(x86\))\\Memeo\\AutoBackup\\MemeoBackgroundService.exe \[.+\] \(Memeo.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] MDM; " & $C & "\\Program Files(| \(x86\))\\Common Files\\Microsoft Shared\\VS7DEBUG\\MDM.exe \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] Micro Star SCM; " & $C & "\\Program Files(| \(x86\))\\System Control Manager\\MSIService.exe \[.+\] \(Micro-Star.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (Microsoft SharePoint Workspace Audit Service|Microsoft Office Groove Audit Service); " & $C & "\\Program Files(| \(x86\))\\Microsoft Office\\Office1.\\(GROOVE|GrooveAuditService).exe.* \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] MozillaMaintenance; " & $C & "\\Program Files(| \(x86\))\\Mozilla Maintenance Service\\maintenanceservice.exe \[.+\] \(Mozilla.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] MouseWithoutBordersSvc; " & $C & "\\Program Files(| \(x86\))\\Microsoft Garage\\Mouse without Borders\\MouseWithoutBordersSvc.exe \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] MSCamSvc; " & $C & "\\Program Files\\Microsoft LifeCam\\MSCamS64.exe \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] MSCamSvc; " & $C & "\\Program Files\\Microsoft LifeCam\\MSCamS64.exe \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] msiserver; " & $C & "\\Windows\\(System32|SysWow64)\\msiexec.exe /V \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (SQLAgent\$SQLEXPRESS|MSSQL\$SQLEXPRESS|MSSQL\$SONY_MEDIAMGR2|MSSQL10_50.MAPS|SQLAgent\$MAPS|MSSQL\$MSSMLBIZ|SQLAgent\$ACT7); " & $C & "\\Program Files(| \(x86\))\\Microsoft SQL Server\\.+\\MSSQL\\Binn\\(SQLAGENT|sqlservr).exe.+ \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (MSSQLServerADHelper100|MSSQLServerADHelper); " & $C & "\\Program Files(| \(x86\))\\Microsoft SQL Server\\(90|100)\\Shared\\SQLADHL(P|p90).exe \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] MSUWebService; " & $C & "\\Program Files(| \(x86\))\\Marvell\\storage\\Apache2\\bin\\httpd.exe.+ \[.+\] \(Apache.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] msvsmon(\d0|\d); " & $C & "\\Program Files\\Microsoft Visual Studio [\d]*.0\\Common7\\IDE\\Remote Debugger\\x64\\msvsmon.exe .+ \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] Multi-user Cleanup Service; " & $C & "\\Program Files(| \(x86\))\\IBM\\Lotus\\Notes\\ntmulti.exe \[.+\] \(IBM.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] NAUpdate; " & $C & "\\Program Files(| \(x86\))\\Nero\\Update\\NASvc.exe \[.+\] \(Nero.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] NBService; " & $C & "\\Program Files(| \(x86\))\\Nero\\Nero .\\Nero BackItUp\\NBService.exe \[.+\] \(Nero.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] Nero BackItUp Scheduler (3|4.0); " & $C & "\\Program Files(| \(x86\))[\\Common Files]*\\Nero\\Nero BackItUp[ 4]*\\NBService.exe \[.+\] \(Nero.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] Net Driver HPZ12; " & $C & "\\Windows\\system32\\HPZinw12.dll \[.+\] \(Hewlett.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (NetTcpPortSharing|NetMsmqActivator|NetPipeActivator|NetTcpActivator); " & $C & "\\Windows\\Microsoft.NET\\Framewor(k|k64)\\v.+\\SMSvcHost.exe \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] NIHardwareService; " & $C & "\\Program Files\\Common Files\\Native Instruments\\Hardware\\NIHardwareService.exe \[.+\] \(Native.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] NMIndexingService; " & $C & "\\Program Files(| \(x86\))\\Common Files\\(Ahead|Nero)\\Lib\\NMIndexingService.exe [.+\] \(Nero.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] NitroDriverReadSpool2; " & $C & "\\Program Files\\Common Files\\Nitro PDF\\Professional\\..0\\NitroPDFDriverService2x64.exe [.+\] \(Nitro.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] nlsX86cc; " & $C & "\\Windows\\SysWOW64\\NLSSRV32.EXE \[.+\] \(Nalpeiron.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] nmraapache; " & $C & "\\Program Files(| \(x86\))\\Pure Networks\\Network Magic\\WebServer\\bin\\nmraapache.exe.* \[.+\] \(Microsoft|Pure).+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] nmservice; " & $C & "\\Program Files(| \(x86\))\\Common Files\\Pure Networks Shared\\Platform\\nmsrvc.exe.* \[.+\] \((Cisco|Pure).+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] NOBU; " & $C & "\\Program Files(| \(x86\))\\Dell\\Dell Datasafe Online\\NOBuAgent.exe.* \[.+\] \(Dell.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] NTI IScheduleSvc; " & $C & "\\Program Files(| \(x86\))\\NewTech Infosystems\\(Gateway MyBackup|Acer Backup Manager|NTI Backup Now \d)\\(SchedulerSvc|IScheduleSvc).exe \[.+\] \((NewTech|NTI).+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] NTIBackupSvc; " & $C & "\\Program Files(| \(x86\))\\NewTech Infosystems\\NTI Backup Now 5\\BackupSvc.exe \[.+\] \(NewTech.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] NTISchedulerSvc; " & $C & "\\Program Files(| \(x86\))\\NewTech Infosystems\\NTI Backup Now 5\\SchedulerSvc.exe \[.+\] \(NewTech.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] O2FLASH; " & $C & "\\Windows\\System32\\DRIVERS\\o2flash.exe \[.+\] \(O2Micro.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] o2flash; " & $C & "\\Program Files(| \(x86\))\\O2Micro Flash Memory Card Driver\\o2flash.exe \[.+\] \(O2Micro.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] Oasis2Service; " & $C & "\\Program Files(| \(x86\))\\DDNi\\Oasis2Service\\Oasis2Service.exe \[.+\] \(Digital.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] odserv; " & $C & "\\Program Files(| \(x86\))\\Common Files\\Microsoft Shared\\OFFICE12\\ODSERV.exe \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] Olympus DVR Service; " & $C & "\\Program Files(| \(x86\))\\Common Files\\Olympus Shared\\DeviceManager\\olydvrsv.exe \[.+\] \(OLYMPUS.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] OpcEnum; " & $C & "\\Windows\\SysWOW64\\OpcEnum.exe \[.+\] \(OPC.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (ose|ose64); " & $C & "\\Program File(s|s \(x86\))\\Common Files\\Microsoft Shared\\Source Engine\\OSE.exe \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] osppsvc; " & $C & "\\Program Files\\Common Files\\Microsoft Shared\\OfficeSoftwareProtectionPlatform\\OSPPSVC.exe \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] PaceLicenseDServices; " & $C & "\\Program Files(| \(x86\))\\Common Files\\PACE\\Services\\LicenseServices\\LDSvc.exe \[.+\] \(PACE.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (Parallels Coherence|Parallels Tools) Service; " & $C & "\\Program Files(| \(x86\))\\Parallels\\Parallels Tools\\Services\\(coherence|prl_tools_service).exe \[.+\] \(Parallels.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] Partner Service; " & $C & "\\ProgramData\\Partner\\Partner.exe \[.+\] \(Google.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] PerfHost; " & $C & "\\Windows\\SysWow64\\perfhost.exe \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] PCLEPCI; " & $C & "\\Windows\\SysWow64\\drivers\\pclepci.sys \[.+\] \(Pinnacle+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] PD(Agent|Engine); " & $C & "\\Program Files\\(Common Files\\Raxco|Raxco)\\(PerfectDisk|Shared)\\PD(Agent|Engine).exe \[.+\] \(Raxco.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] PDEngine; " & $C & "\\Program Files\\Common Files\\Raxco\\Shared\\PDEngine.exe \[.+\] \(Raxco.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] pdfcDispatcher; " & $C & "\\Program Files(| \(x86\))\\PDF Complete\\pdfsvc.exe .+ \[.+\] \(PDF.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] PDFProFiltSrvPP; " & $C & "\\Program Files(| \(x86\))\\Nuance\\PaperPort\\PDFProFiltSrvPP.exe .+ \[.+\] \(Nuance.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] PdiService; " & $C & "\\Program Files(| \(x86\))\\Common Files\\Portrait Displays\\Drivers\\pdisrvc.exe \[.+\] \(Portrait.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] PMBDeviceInfoProvider; " & $C & "\\Program Files(| \(x86\))\\Sony\\PMB\\PMBDeviceInfoProvider.exe \[.+\] \(Sony.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] Pml Driver HPZ12; " & $C & "\\Windows\\system32\\HPZipm12.dll \[.+\] \(Hewlett.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] Printer Control; " & $C & "\\Windows\\system32\\PrintCtrl.exe \[.+\] \(ActMask.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] PrintNotify; " & $C & "\\Windows\\system32\\spool\\DRIVERS\\x64\\3\\PrintConfig.dll \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] PSI_SVC_2; " & $C & "\\Program Files(| \(x86\))\\Common Files\\Protexis\\License Service\\PsiService_2.exe \[.+\] \(Protexis.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] ptumlcmsvc; " & $C & "\\Windows\\system32\\ptumlcmsvc64.exe \[.+\] \(DEVGURU.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (QBCFMonitorService|QBFCService|QBVSS); " & $C & "\\Program Files(| \(x86\))\\Common Files\\Intuit\\(DataProtect|QuickBooks|QuickBooks\\FCS)\\(QBCFMonitorService|Intuit.QuickBooks.FCS|QBIDPService).exe \[.+\] \(Intuit.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] RalinkRegistryWrite(r|r64); " & $C & "\\Program Files(| \(x86\))\\(Edimax|Ralink)\\Common\\RaRegistr(y|y64).exe \[.+\] \(Ralink.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] Realtek87B; " & $C & "\\Program Files(| \(x86\))\\Realtek\\RTL8187 Wireless LAN Utility\\RtlService.exe \[.+\] \(Realtek.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] RegSrvc; " & $C & "\\Program Files\\Common Files\\Intel\\WirelessCommon\\RegSrvc.exe \[.+\] \(Intel.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] Remote Solver for Flow Simulation 2010; " & $C & "\\Program Files\\SolidWorks Corp\\SolidWorks Flow Simulation\\binCFW\\StandAloneSlv.exe \[.+\] \(Mentor.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] RosettaStoneDaemon; " & $C & "\\Program Files(| \(x86\))\\RosettaStoneLtdServices\\RosettaStoneDaemon.exe \[.+\] \(Rosetta.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] Retrospect Client; " & $C & "\\Program Files(| \(x86\))\\Retrospect\\Retrospect Client\\RemotSvc.exe \[.+\] \(EMC.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] Rohos; " & $C & "\\Program Files(| \(x86\))\\Rohos\\ntserv.exe \[.+\] \(Tesline.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] Roxio UPnP Renderer 9; " & $C & "\\Program Files(| \(x86\))\\Roxio\\Digital Home 9\\RoxioUPnPRenderer9.exe \[.+\] \(Sonic.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] Roxio Upnp Server 9; " & $C & "\\Program Files(| \(x86\))\\Roxio\\Digital Home 9\\RoxioUpnpService9.exe \[.+\] \(Sonic.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] RoxLiveShare(9|10|11|12); " & $C & "\\Program Files(| \(x86\))\\Common Files\\Roxio Shared\\(9|10|11|12|13).0\\SharedCOM\\RoxLiveShare(9|10|11|12|13).exe \[.+\] \(Sonic.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (RoxMediaDB|RoxWatch)(9|10|11|13|12|12oem); " & $C & "\\Program Files(| \(x86\))\\Common Files\\Roxio Share(d|d\\OEM)\\(9|10|11|12|13).0\\SharedCOM\\(RoxMediaDB|RoxWatch)(9|10|11|12|12oem).exe \[.+\] \(Sonic.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] RoxioNow Service; " & $C & "\\Program Files(| \(x86\))\\Roxio\\RoxioNow Player\\RNowSvc.exe \[.+\] \(Roxio.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] RoxWatch(9|10|11|13|12); " & $C & "\\Program Files(| \(x86\))\\Common Files\\Roxio Shared\\(9|10|11|13|12).0\\SharedCOM\\RoxWatch(9|10|11|12|13|12oem).exe \[.+\] \(Sonic.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] rpcnet; " & $C & "\\Windows\\SysWOW64\\rpcnet.exe \[.+\] \(Absolute.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] RSELSVC; " & $C & "\\Program Files\\TOSHIBA\\rselect\\RSelSvc.exe .*\[.+\] \(TOSHIBA.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] RtVOsdService; " & $C & "\\Program Files\\Realtek\\RtVOsd\\RtVOsdService.exe \[.+\] \(Realtek.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] Samsung UPD Service; " & $C & "\\windows\\System32\\SUPDSvc.exe \[.+\] \(Samsung.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] SamsungAllShareV2.0; " & $C & "\\Program Files(| \(x86\))\\Samsung\\AllShare\\AllShareDMS\\AllShareDMS.exe \[.+\] \(Samsung.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] SecureStorageService; " & $C & "\\Program Files\\Dell\\Dell Data Protection\\Access\\Advanced\\Wave\\Secure Storage Manager\\SecureStorageService.exe \[.+\] \(Wave.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] SimpleSlideShowServer; " & $C & "\\Program Files(| \(x86\))\\Samsung\\AllShare\\AllShareSlideShowService.exe \[.+\] \(Samsung.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] SandraAgentSrv; " & $C & "\\Program Files\\SiSoftware\\SiSoftware Sandra (Lite 2010.SP1a|Professional Business 201..SP..)\\RpcAgentSrv.exe \[.+\] \(SiSoftware.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] SeagateDashboardService; " & $C & "\\Program Files(| \(x86\))\\Seagate\\Seagate Dashboard\\SeagateDashboardService.exe \[.+\] \(Memeo\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] sedsvc; " & $C & "\\Program Files\\rempl\\sedsvc.exe \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] SeaPort; " & $C & "\\Program Files(| \(x86\))\\Microsoft\\Search Enhancement Pack\\SeaPort\\SeaPort.exe \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] SeaPort; " & $C & "\\Program Files(| \(x86\))\\Microsoft\\BingBar\\SeaPort.exe \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (SecureStorageService|TdmService); " & $C & "\\Program Files\\Wave Systems Corp\\(Secure Storage Manager|Trusted Drive Manager)\\(SecureStorageService|TdmService).exe \[.+\] \(Wave.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] ServiceLayer; " & $C & "\\Program Files(| \(x86\))\\PC Connectivity Solution\\ServiceLayer.exe \[.+\] \(Nokia\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] ServicepointService; " & $C & "\\Program Files(| \(x86\))\\Verizon\\VSP\\ServicepointService.exe \[.+\] \(Radialpoint.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] ServiceLayer; " & $C & "\\Program Files(| \(x86\))\\PC Connectivity Solution\\ServiceLayer.exe \[.+\] \(Nokia.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] SessionSvc; " & $C & "\\Windows\\System32\\Drivers\\SessionService.exe \[.+\] \((Microsoft|Shenzhen).+-> (Goodix|)\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] sftlist; " & $C & "\\Program Files(| \(x86\))\\Microsoft Application Virtualization Client\\sftlist.exe \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] SftService; " & $C & "\\Program Files(| \(x86\))\\(Dell DataSafe Local Backup|AlienRespawn)\\sftservice.exe \[.+\] \(SoftThinks.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] sftvsa; " & $C & "\\Program Files(| \(x86\))\\Microsoft Application Virtualization Client\\sftvsa.exe \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] SgtSch2Svc; " & $C & "\\Program Files(| \(x86\))\\Common Files\\Seagate\\Schedule2\\schedul2.exe \[.+\] \(Seagate.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] Skype C2C Service; " & $C & "\\ProgramData\\Skype\\Toolbars\\Skype C2C Service\\c2c_service.exe \[.+\] \(Skype.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] SmartFaceVWatchSrv; " & $C & "\\Program Files\\TOSHIBA\\SmartFaceV\\SmartFaceVWatchSrv.exe \[.+\] \(Toshiba.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] SkypeUpdate; " & $C & "\\Program Files(| \(x86\))\\Skype\\Updater\\Updater.exe \[.+\] \(Skype.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] smstsmgr; " & $C & "\\Windows\\SysWOW64\\CCM\\TSManager.exe .+ \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (SOHCImp|SOHDs|SOHDms|Sony SCSI Helper Service); " & $C & "\\Program Files(| \(x86\))\\Common Files\\Sony Shared\\(SOHLib|Fsk)\\(SOHCImp|SOHDs|SOHDms|SonySCSIHelperService).exe \[.+\] \(Sony.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] SolidWorks Licensing Service; " & $C & "\\Program Files(| \(x86\))\\Common Files\\SolidWorks Shared\\Service\\SolidWorksLicensing.exe \[.+\] \(SolidWorks.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] SolutoService; " & $C & "\\Program Files\\Soluto\\SolutoService.exe \[.+\] \(Soluto.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] SonicWALL SSO Agent; " & $C & "\\Program Files(| \(x86\))\\SonicWALL\\DCON\\CIAService.exe \[.+\] \(Sonic.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] Sony PC Companion; " & $C & "\\Program Files(| \(x86\))\\Sony\\Sony PC Companion\\PCCService.exe \[.+\] \(Avanquest.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] SpfService; " & $C & "\\Program Files\\Common Files\\Sony Shared\\VAIO Entertainment Platform\\SPF\\SpfService64.exe \[.+\] \(Sony.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] Sound Blaster X-Fi MB Licensing Service; " & $C & "\\Program Files(| \(x86\))\\Common Files\\Creative Labs Shared\\" & "Service\\XMBLicensing.exe \[.+\] \(Creative.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] SECOMNService; " & $C & "\\Windows\\System32\\SECOMN64.exe \[.+\] \(Sound.+-> Sound.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] sprtsvc_DellComms; " & $C & "\\Program Files(| \(x86\))\\Dell\\DellComms\\bin\\sprtsvc.exe.*\[.+\] \(SupportSoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] sprtsvc_DellSupportCenter; " & $C & "\\Program Files(| \(x86\))\\Dell Support Center\\bin\\sprtsvc.exe.+\[.+\] \(SupportSoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (sprtsvc_verizondm|tgsrvc_verizondm); " & $C & "\\Program Files(| \(x86\))\\VERIZONDM\\bin\\(sprtsvc|tgsrvc).exe /service /p verizondm \[.+\] \(SupportSoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (SQLBrowser|sqlwriter); " & $C & "\\Program File(s|s \(x86\))\\Microsoft SQL Server\\90\\Shared\\(sqlbrowser|sqlwriter).exe \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (SQLBrowser|sqlwriter); " & $C & "\\Program File(s|s \(x86\))\\Microsoft SQL Server\\90\\Shared\\(sqlbrowser|sqlwriter).exe \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (SplashtopRemoteService|SSUService); " & $C & "\\Program Files(| \(x86\))\\Splashtop\\Splashtop (Remote\\Server|Software Updater)\\(SRService|SSUService).exe \[.+\] \(Splashtop.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] STacSV; " & $C & "\\Windows\\System32\\DriverStore\\FileRepository\\stwrt64.inf_amd64_neutral_(0057cbec48a2d7cf|afc3018f8cfedd20)\\STacSV64.exe  \[.+\] \(IDT.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] STacSV; " & $C & "\\Program Files\\IDT\\WDM\\STacSV64.exe \[.+\] \(IDT.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] STacSV; " & $C & "\\Windows\\System32\\DriverStore\\FileRepository\\stwrt64.inf_15f4e438\\STacSV64.exe \[.+\] \(IDT.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] StarWindServiceAE; " & $C & "\\Program Files(| \(x86\))\\Alcohol Soft\\Alcohol 120\\StarWind\\StarWindServiceAE.exe .*\[.+\] \(StarWind.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] Steam Client Service; " & $C & "\\Program Files(| \(x86\))\\Common Files\\Steam\\SteamService.exe .*\[.+\] \(Valve.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] Stereo Service; " & $C & "\\Program Files(| \(x86\))\\NVIDIA Corporation\\3D Vision\\nvSCPAPISvr.exe \[.+\] \(NVIDIA.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] stllssvr; " & $C & "\\Program Files(| \(x86\))\\Common Files\\SureThing Shared\\stllssvr.exe \[.+\] \((MicroVision|Adobe).+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] SWGVCSvc; " & $C & "\\Program Files\\SonicWALL\\SonicWALL Global VPN Client\\SWGVCSvc.exe.* \[.+\] \(Sonic.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] SwitchBoard; " & $C & "\\Program Files(| \(x86\))\\Common Files\\Adobe\\SwitchBoard\\SwitchBoard.exe \[.+\] \(Adobe.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] System_Repair_UpdateMonitor; " & $C & "\\Program Files\\Lenovo\\OneKey App\\System Repair\\UpdateMonitor.exe [.+\] \(Lenovo.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] TdmService; " & $C & "\\Program Files\\Dell\\Dell Data Protection\\Access\\Advanced\\Wave\\Trusted Drive Manager\\TdmService.exe \[.+\] \(Wave.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] TeamViewer.; " & $C & "\\Program Files(| \(x86\))\\TeamViewer\\Version.\\TeamViewer_Service.exe \[.+\] \(TeamViewer.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] Themes; " & $C & "\\Windows\\SysWow64\\shsvcs.dll \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] TMachInfo; " & $C & "\\Program Files(| \(x86\))\\TOSHIBA\\TOSHIBA Service Station\\TMachInfo.exe \[.+\] \(TOSHIBA.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] TTNaviSrv; " & $C & "\\Program Files(| \(x86\))\\Toshiba\\TOSHIBA DVD PLAYER\\TNaviSrv.exe \[.+\] \(TOSHIBA.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (Thpsrv|TODDSrv); " & $C & "\\Windows\\system32\\(Thpsrv|TODDSrv).exe \[.+\] \(TOSHIBA.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] TomTomHOMEService; " & $C & "\\Program Files(| \(x86\))\\TomTom HOME 2\\TomTomHOMEService.exe \[.+\] \(TomTom.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] TosCoSrv; " & $C & "\\Program Files\\TOSHIBA\\Power Saver\\TosCoSrv.exe \[.+\] \(TOSHIBA.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] TOSHIBA Bluetooth Service; " & $C & "\\Program Files(| \(x86\))\\Toshiba\\Bluetooth Toshiba Stack\\TosBtSrv.exe \[.+\] \(TOSHIBA.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] TOSHIBA eco Utility Service; " & $C & "\\Program Files\\TOSHIBA\\TECO\\TecoService.exe \[.+\] \(TOSHIBA.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] TOSHIBA HDD SSD Alert Service; " & $C & "\\Program Files\\TOSHIBA\\TOSHIBA HDD SSD Alert\\TosSmartSrv.exe \[.+\] \(TOSHIBA.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] TOSHIBA SMART Log Service; " & $C & "\\Program Files\\TOSHIBA\\SMARTLogService\\TosIPCSrv.exe \[.+\] \(TOSHIBA.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] TPAutoConnSvc; " & $C & "\\Program Files\\VMware\\VMware Tools\\TPAutoConnSvc.exe \[.+\] \(ThinPrint.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] TPCHSrv; " & $C & "\\Program Files\\TOSHIBA\\TPHM\\TPCHSrv.exe \[.+\] \(TOSHIBA.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] TPVCGateway; " & $C & "\\Program Files\\VMware\\VMware Tools\\TPVCGateway.exe \[.+\] \(ThinPrint.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] TrustedInstaller; " & $C & "\\Windows\\servicing\\TrustedInstaller.exe \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] TurboBoost; " & $C & "\\Program Files\\Intel\\TurboBoost\\TurboBoost.exe \[.+\] \(Intel.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] UleadBurningHelper; " & $C & "\\Program Files(| \(x86\))\\Common Files\\Ulead Systems\\DVD\\ULCDRSvr.exe \[.+\] \(Ulead.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] UMVPFSrv; " & $C & "\\Program Files(| \(x86\))\\Common Files\\logishrd\\LVMVFM\\UMVPFSrv.exe \[.+\] \(Logitech.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] UNS; " & $C & "\\Program Files(| \(x86\))\\Intel\\Inte.+\\UNS\\UNS.exe \[.+\] \(Intel.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (Live U|U)pdater Service; " & $C & "\\Program Files\\(acer|Gateway)\\(Gateway|acer) Updater\\UpdaterService.exe \[.+\] \(Acer.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] vpnagent; " & $C & "\\Program Files(| \(x86\))\\Cisco\\Cisco AnyConnect Secure Mobility Client\\vpnagent.exe \[.+\] \(Cisco.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] usnjsvc; " & $C & "\\Program Files(| \(x86\))\\MSN Messenger\\usnsvc.exe \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] UStorage Server Service; " & $C & "\\Windows\\SysWOW64\\UStorSrv.exe.* \[.+\] \(OTi.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] UxSms; UxTuneUp; " & $C & "\\Windows\\(System32|SysWow64)\\uxtuneup.dll \[.+\] \(TuneUp.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (VAIO Event Service|VAIO Power Management|VcmIAlzMgr|VcmINSMgr|VcmXmlIfHelper|VCService|VSNService|VUAgent); " & $C & "\\Program File(s \(x86\)|s)\\Sony\\(VAIO Control Center|VAIO Event Service|VAIO Power Management|VCM Intelligent Analyzing Manager|VCM Intelligent Network Service Manager|VcmXml|VAIO Care|VAIO Smart Network|VAIO Update Common)\\(VESMgr|SPMService|VcmIAlzMgr|VcmINSMgr|VcmXmlIfHelper64|VESMgr|VCService|VSNService|VUAgent).exe \[.+\] \(Sony.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (SOHDs|VCFw|SOHCImp|SOHDms|VcmXmlIfHelper|SpfService); " & $C & "\\Program Files\\Common Files\\Sony Shared\\(VAIO Content Folder Watcher|VcmXml|SOHLib|VAIO Entertainment Platform\\SPF)\\(VCFw|VcmXmlIfHelper64|SOHCImp|SOHDms|SOHDs|SpfService).exe \[.+\] \(Sony.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (VcmINSMgr|VAIO Power Management|VAIO Event Service|VCService|VSNService|NSUService|VUAgent|SampleCollector|VcmIAlzMgr); " & $C & "\\Program Files\\Sony\\(VAIO Care|VAIO Smart Network|VAIO Update Common|VAIO Update \d|VCM Intelligent Network Service Manager|VCM Intelligent Analyzing Manager|Network Utility|VAIO Event Service|VAIO Power Management) \\(VcmINSMgr|VCService|SPMService|VSNService|VUAgent|VESMgr|VCPerfService|NSUService|VcmIAlzMgr).exe \[.+\] \(Sony.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] vcsFPService; " & $C & "\\Windows\\(system32|SysWow64)\\vcsFPService.exe \[.+\] \(Validity.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] VMAuthdService; " & $C & "\\Program Files(| \(x86\))\\VMware\\(VMware Player|VMware Workstation)\\vmware-authd.exe \[.+\] \(VMware.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] VmbService; " & $C & "\\Program Files(| \(x86\))\\Vodafone\\Vodafone Mobile Broadband\\Bin\\VmbService.exe \[.+\] \(Vodafone.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] BUpdate; " & $C & "\\Program Files(| \(x86\))\\Microsoft\\BingBar\\SeaPort.exe \[.+\] \(Microsoft.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] VMnetDHCP; " & $C & "\\Windows\\SysWow64\\vmnetdhcp.exe \[.+\] \(VMware.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] VMTools; " & $C & "\\Program Files\\VMware\\VMware Tools\\vmtoolsd.exe \[.+\] \(VMware.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] VMUpgradeHelper; " & $C & "\\Program Files\\VMware\\VMware Tools\\VMUpgradeHelper.exe /service \[.+\] \(VMware.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] VMUSBArbService; " & $C & "\\Program Files(| \(x86\))\\Common Files\\VMware\\USB\\vmware-usbarbitrato(r|r76|r64).exe \[.+\] \(VMware.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] VMware NAT Service; " & $C & "\\Windows\\SysWow64\\vmnat.exe \[.+\] \(VMware.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] vpnagent; " & $C & "\\Program Files(| \(x86\))\\Cisco\\Cisco AnyConnect VPN Client\\vpnagent.exe \[.+\] \(Cisco Systems.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] wampapache; " & $C & "\\wamp\\bin\\apache\\apache2.2.22\\bin\\httpd.exe.* \[.+\] \(Apache.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] WavesSysSvc; " & $C & "\\(Program Files\\Waves\\MaxxAudio|WINDOWS\\System32\\DriverStore\\FileRepository.+)\\WavesSysSvc64.exe \[.+\] \(Waves.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] WatAdminSvc; " & $C & "\\Windows\\System32\\Wat\\WatAdminSvc.exe \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] wbengine; " & $C & "\\Windows\\system32\\wbengine.exe \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] WCUService_STC_IE; " & $C & "\\Program Files(| \(x86\))\\Splashtop\\Splashtop Connect IE Software Updater\\WCUService.exe \[.+\] \(Splashtop.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (WDDMService|WDDMService.exe); " & $C & "\\Program Files\\Western Digital\\WD SmartWare\\WD Drive Manager\\WDDMService.exe \[.+\] \(WDC\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] WDSmartWareBackgroundService; " & $C & "\\Program Files(| \(x86\))\\Western Digital\\WD SmartWare\\Front Parlor\\WDSmartWareBackgroundService.exe \[.+\] \(Memeo\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] WhsMcClient; " & $C & "\\Program Files\\Windows Server\\Bin\\WhsMcClient.exe \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] WiMAXAppSrv; " & $C & "\\Program Files\\Intel\\WiMAX\\Bin\\AppSrv.exe \[.+\] \(Inte.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] WindowBlinds; " & $C & "\\Program Files(| \(x86\))\\Stardock\\MyColors\\VistaSrv.exe \[.+\] \(Stardock.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (WinHttpAutoProxySvc|WinHttpAutoProxySvc); winhttp.dll \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[SRU][234] Winmgmt; " & $C & "\\Windows\\System32\\wbem\\WMIsvc.dll \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[SRU][234] wmiApSrv; " & $C & "\\Windows\\System32\\wbem\\WmiApSrv.exe \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] LxssManager; " & $C & "\\Windows\\System32\\lxss\\LxssManager.dll \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] WinTabService; " & $C & "\\Windows\\System32\\Drivers\\WTSRV.exe \[.+\] \(Tablet.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] wlcrasvc; " & $C & "\\Program Files\\Windows Live\\Mesh\\wlcrasvc.exe \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] WMPNetworkSvc; " & $C & "\\Program Files\\Windows Media Player\\wmpnetwk.exe \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (ZuneWlanCfgSvc|WMZuneComm|ZuneNetworkSvc); " & $C & "\\Program Files\\Zune\\(WMZuneComm|ZuneWlanCfgSvc|ZuneNss).exe \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (ftpsvc|W3SVC|w3logsvc|AppHostSvc|IISADMIN|WAS); " & $C & "\\Windows\\(SysWow64|system32)\\inetsrv\\(apphostsvc|IISADMIN|iisw3adm|w3logsvc|ftpsvc).dll \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] WPFFontCache_v0400; " & $C & "\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\WPF\\WPFFontCache_v0400.exe \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] WSConnectorUpdate; " & $C & "\\Program Files\\Windows Server\\Bin\\WSConnectorUpdate.exe \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (wsnm|wsnm_usbctrl); " & $C & "\\Program Files\\VMware\\VMware View\\Client\\bin\\(wsnm|wsnm_usbctrl).exe.* \[.+\] \(VMware.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] XMouseButton Launcher; " & $C & "\\Program Files\\Highresolution Enterprises\\X-Mouse Button Control\\XMouseButtonSvc.exe \[.+\] \(Highresolution.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] UxTuneUp; " & $C & "\\Windows\\(System32|SysWow64)\\uxtuneup.dll \[.+\] \(TuneUp.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] YahooAUService; " & $C & "\\Program Files(| \(x86\))\\Yahoo!\\SoftwareUpdate\\YahooAUService.exe \[.+\] \(Yahoo.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] ZcfgSvc7; " & $C & "\\Program Files\\Intel\\WiFi\\bin\\ZCfgSvc7.exe \[.+\] \(Inte.*+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] perceptionsimulation; " & $C & "\\WINDOWS\\system32\\PerceptionSimulation\\PerceptionSimulationService.exe \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] FirmwareSwitchService; " & $C & "\\WINDOWS\\Firmware\\FwSwitchbin\\FwSwitchService.exe \[.+\] \(Fibocom.+-> Fibocom.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (edgeupdate|edgeupdatem); " & $C & "\\Program Files(| \(x86\))\\Microsoft\\EdgeUpdate\\MicrosoftEdgeUpdate.exe \[.+\] \(Microsoft.+-> Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] MicrosoftEdgeElevationService; " & $C & "\\Program Files(| \(x86\))\\Microsoft\\Edge\\Application\\(\d+\.)+\d+\\elevation_service.exe \[.+\] \(Microsoft.+-> Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (WslInstaller|wslservice|GamingServicesNet|GamingServices|uhssvc|GameInput.*); " & $C & "\\Program Files(| \(x86\))\\(WSL|Microsoft Update Health Tools|Microsoft GameInput\\x64|WindowsApps\\.+)\\(WslInstaller|wslservice|GamingServicesNet|GamingServices|gameinputsvc|uhssvc).exe \[.+\] \(Microsoft.+-> Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (ssh-agent|sshd); " & $C & "\\Windows\\System32\\OpenSSH\\(ssh-agent|sshd).exe \[.+\] \(Microsoft.+->.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] SurfaceColorService; " & $C & "\\Windows\\(System32|SysWow64)\\SurfaceColorService.exe \[.+\] \((OEMTest OS|Microsoft).+-> Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (ReFsDedupSvc|KPSSVC|RSoPProv|GameInputSvc|SurfaceUsbHubFwUpdateService|SurfaceDtxService|TlntSvr|SNMP|IISADMIN|MSMQTriggers|LxssManagerUser_\w+|gcs|NfsClnt|UwfServicingSvc|WMSVC|vmcompute|CredentialEnrollmentManagerUserSvc(|_\w+)|vmms|SgrmBroker|ssh-agent|xbgm|WebManagement|SurfaceService|DeveloperToolsService|spectrum|SecurityHealthService|WpnUserService.*|UevAgentService|cplspcon|AppVClient|MSMQ|TieringEngineService|MessagingService_\w+|SensorDataService|ALG|CISVC|COMSysApp|DFSR|stisvc|IEEtwCollectorService|SDRSVC|swprv|EFS|vmvss|Fax|KeyIso|MSDTC|Netlogon|ProtectedStorage|RpcLocator|SamSs|simptcp|slsvc|SNMPTRAP|Spooler|sppsvc|UI0Detect|VaultSvc|vds|VSS|WSearch); " & $C & "\\Windows\\(System32|SysWow64)\\(ReFsDedupSvc|KPSSVC|RSoPProv|SurfaceUsbHubFwUpdateService|SurfaceDtxService|TlntSvr|SNMP|inetsrv\\inetinfo|vmcomputeagent|NfsClnt|UwfServicingSvc|inetsrv\\wmsvc|vmcompute|CredentialEnrollmentManager|vmms|(Sgrm\\|)SgrmBroker|ssh-agent|DeveloperToolsSvc|alg|CISVC|DFSR|fxssvc|MSDTC|lsass|locator|tcpsvcs|SLsvc|SNMPTRAP|spoolsv|sppsvc|UI0Detect|vds|vssvc|SearchIndexer|IEEtwCollector|SensorDataService|mqsvc|TieringEngineService|mqsvc|AppVClient|IntelCpHDCPSvc|AgentService|SecurityHealthService|spectrum|SurfaceService|WebManagement|xbgmsvc|svchost|mqtgsvc|GameInputSvc).exe \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (WSAIFabricSvc|CDD|ApxSvc|LocalKdc|PrintDeviceConfigurationService|PrintScanBrokerService|KPSSVC|sacsvr|ualsvc|CloudBackupRestoreSvc|TextInputManagementService|InventorySvc|dcsvc|webthreatdefusersvc|webthreatdefsvc|P9RdrService|NPSMSvc|McpManagementService|FrameServerMonitor|cloudidsvc|DialogBlockingService|iprip|LxssManagerUser|hns|LPDSVC|hvsics|DsRoleSvc|CmService|HgClientService|nvagent|DispBrokerDesktopSvc|TroubleshootingSvc|DeviceAssociationBrokerSvc|autotimesvc); " & $C & "\\Windows\\(System32|SysWOW64)\\(WSAIFabricHost|CDD|ApxSvc|localkdcsvc|PrintDeviceConfigurationService|PrintScanBrokerService|KPSSVC|sacsvr|ualsvc|CloudRestoreLauncher|TabSvc|InventorySvc|dcsvc|webthreatdefusersvc|webthreatdefsvc|P9RdrService|npsm|McpManagementService|FrameServerMonitor|cloudidsvc|DialogBlockingService|iprip|lxss\\(LxssManager|wslclient)|HostNetSvc|LPDSVC|hvsicontainerservice|dsrolesrv|CmService|HgClientService|nvagent|DispBroker.Desktop|MitigationClient|autotimesvc|deviceaccess)\.dll \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (SshdBroker|MixedRealityOpenXRSvc|TroubleshootingSvc|AarSvc|WManSvc|DisplayEnhancementService|ConsentUxUserSvc|cbdhsvc|BrokerInfrastructure|LxpSvc|DevicePickerUserSvc|BTAGService|BthAvctpSvc|CaptureService|BluetoothUserService|BcastDVRUserService|xbgm|diagsvc|AssignedAccessManagerSvc|camsvc|GraphicsPerfSvc|InstallService|debugregsvc|wlpasvc|NaturalAuthentication|IpxlatCfgSvc|DusmSvc|DevicesFlowUserSvc|CDPUserSvc|FrameServer|HvHost|MessagingService|MapsBroker|LicenseManager|icssvc|EntAppSvc|embeddedmode|DmEnrollmentSvc|CoreMessagingRegistrar|CDPSvc|BthHFSrv|UsoSvc|UserTrustedSignals|dmwappushservice|CoreUIRegistrar|CommsAPHost|PimIndexMaintenance|NgcSvc|NgcCtnrSvc|NetSetupSvc|AJRouter|ClipSVC|DcpSvc|DevQueryBroker|DoSvc|DsSvc|MosHost|DiagTrack|AeLookupSvc|NcbService|MsKeyboardFilter|AppReadiness|lfsvc|AppXSvc|AppIDSvc|Appinfo|AppMgmt|EFS|AllUserInstallAgent|Audiosrv|fhsvc|LSM|KeyIso|NcaSvc|NcdAutoSetup|Netlogon|svsvc|VaultSvc|AudioEndpointBuilder|DsmSvc|DeviceAssociationService|BrokerInfrastructure|AxInstSV|BDESVC|BFE|BITS|Browser|CertPropSvc|bthserv|DcomLaunch|defragsvc|Dhcp|Dnscache|dot3svc|EapHost|ehstart|EMDMgmt|eventlog|EventSystem|fdPHost|FDResPub|FontCache|gpsvc|hidserv|hkmsvc|HomeGroupListener|HomeGroupProvider|IKEEXT|IPBusEnum|iphlpsvc|Irmon|KtmRm|LanmanServer|LanmanWorkstation|lltdsvc|lmhosts|Mcx2Svc|MMCSS|MpsSvc|MSiSCSI|napagent|Netman|NlaSvc|nsi|netprofm); " & $C & "\\Windows\\(System32|SysWOW64)\\(SshdBroker|MixedRealityRuntime|AarSvc|UsoSvc|Windows.Management.Service|Microsoft.Graphics.Display.DisplayEnhancementService|ConsentUxClient|cbdhsvc|LanguageOverlayServer|Windows.Devices.Picker|BTAGService|BthAvctpSvc|CaptureService|Microsoft.Bluetooth.UserService|BcastDVRUserService|AssignedAccessManagerSvc|CapabilityAccessManager|GraphicsPerfSvc|InstallService|diagsvc|AppReadiness|GeofenceMonitorService|appxdeploymentserver|aelupsvc|AppIDSvc|Appinfo|appmgmts|efssvc|fhsvc|LSM|KeyIso|netprofmsvc|Audiosrv|AxInstSV|BDESVC|NcaSvc|NcdAutoSetup|Netlogon|svsvc|VaultSvc|AudioEndpointBuilder|BFE|qmgr|Browser|certprop|NcbService|bthserv|rpcss|defragsvc|dhcpcore|dhcpcsvc|dnsrslvr|dot3svc|eapsvc|ehstart|EMDMgmt|es|fdPHost|FDResPub|FntCache|gpsvc|hidserv|kmsvc|ListSvc|provsvc|IKEEXT|IPBusEnum|Irmon|iphlpsvc|msdtckrm|srvsvc|DeviceSetupManager|wkssvc|bisrv|lltdsvc|das|lmhsvc|Mcx2Svc|MMCSS|AUInstallAgent|usocore|MpsSvc|KeyboardFilterSvc|iscsiexe|qagentRT|Netman|NlaSvc|nsisvc|netprofm|wevtsvc|diagtrack|PimIndexMaintenance|NgcSvc|NgcCtnrSvc|NetSetupSvc|AJRouter|ClipSVC|DcpSvc|DevQueryBroker|DoSvc|DsSvc|lfsvc|MosHost|APHostService|coremessaging|dmwappushsvc|BthHFSrv|CDPSvc|Windows\.Internal\.Management|embeddedmodesvc|EnterpriseAppMgmtSvc|tetheringservice|LicenseManagerSvc|MessagingService|CDPUserSvc|FrameServer|hvhostsvc|NaturalAuth|IpxlatCfg|DevicesFlowBroker|dusmsvc|lpasvc|debugregsvc|xbgmsvc|psmsrv).dll \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (WebManagementUser|PenService|vmicvss|UdkUserSvc|wlidsvc|PrintWorkflowUserSvc|PushToInstall|SharedRealitySvc|WarpJITSvc|SshProxy|SshBroker|SEMgrSvc|TokenBroker|WFDSConMgrSvc|XboxGipSvc|TimeBrokerSvc|tzautoupdate|W3SVC|w3logsvc|XboxNetApiSvc|XblGameSave|XblAuthManager|WalletService|vmicvmsession|UserDataSvc|UnistoreSvc|StateRepository|RetailDemo|PimIndexMaintenanceSvc|OneSyncSvc|UserTrustedSignals|UserManager|UnistoreService|WpnService|TPAutoConnSvc|TPVCGateway|UserDataService|tiledatamodelsvc|THREADORDER|SmsRouter|RetailDemo|PhoneSvc|SensorService|p2psvc|vmicguestinterface|ScDeviceEnum|WEPHOSTSVC|workfolderssvc|smphost|p2pimsvc|PNRPsvc|PcaSvc|PeerDistSvc|WiaRpc|Wcmsvc|WSService|SystemEventsBroker|vmicheartbeat|vmickvpexchange|vmicrdv|vmicshutdown|vmictimesync|TimeBroker|pla|DeviceInstall|PlugPlay|PNRPAutoReg|PolicyAgent|Power|ProfSvc|QWAVE|RasAuto|RasMan|RemoteAccess|RemoteRegistry|RpcEpMap|RpcEptMapper|RpcSs|SCardSvr|Schedule|SCPolicySvc|SDRSVC|SENS|SensrSvc|SessionEnv|SharedAccess|ShellHWDetection|seclogon|SLUINotify|sppuinotify|SSDPSRV|SstpSvc|StiSvc|StorSvc|swprv|SysMain|TabletInputService|TapiSrv|TBS|TermService|Themes|TrkWks|UmRdpService|upnphost|UxSms|W32Time|WbioSrvc|WcesComm|wcncsvc|WcsPlugInService|WdiServiceHost|WdiSystemHost|WebClient|Wecsvc|wercplsupport|WerSvc|WinHttpAutoProxySvc|WinRM|Wlansvc|WPCSvc|WPDBusEnum|wscsvc|wuauserv|wudfsvc|WwanSvc); [""]*" & $C & "\\Windows\\(System32|SysWOW64)\\(WebManagementUser|PenService|icsvcext|icsvcvss|(windowsudkservices|windowsudk).shellcommon|wlidsvc|PrintWorkflowService|PushToInstall|SharedRealitySvc|Windows.WARP.JITService|Windows\.DeviceManagement\.Enrollment|ipnathlp|pnrpsvc|PcaSvc|PeerDistSvc|pla|WiaRpc|Wcmsvc|WSService|umpnpmgr|TimeBrokerServer|pnrpauto|p2psvc|ipsecsvc|umpo|ProfSvc|QWAVE|RasAuto|RasMans|mprdim|regsvc|RpcSs|RpcEpMap|SCardSvr|schedsvc|certprop|SDRSVC|SENS|SensrSvc|sessenv|shsvcs|seclogon|ScDeviceEnum|SLUINotify|sppuinotify|SSDPSRV|SstpSvc|wiaservc|StorSvc|swprv|SysMain|TabSvc|TapiSrv|tbssvc|termsrv|Themes|SystemEventsBrokerServer|themeservice|mmcss|TrkWks|umrdp|upnphost|UxSms|W32Time|WbioSrvc|WcesComm|wcncsvc|WcsPlugInService|wdi|WpnService|TPAutoConnSvc|TPVCGateway|Windows.UserTrustedSignals|usermgr|UserDataService|webclnt|unistore|Wecsvc|smphost|tileobjserver|PhoneService|wercplsupport|THREADORDER|WerSvc|WEPHOSTSVC|workfolderssvc|RetailDemoService|winhttp|WsmSvc|Wlansvc|WPCSvc|SmsRouterSvc|WPDBusEnum|wscsvc|wuaueng|wuauserv|wudfsvc|WwanSvc|SensorService|APHostService|PimIndexMaintenance|RDXService|windows\.staterepository|unistore|WalletService|XblAuthManager|XblGameSave|XboxNetApiSvc|w3logsvc|iisw3adm|tzautoupdate|ICSvc|SEMgrSvc|TokenBroker|WFDSConMgrSvc|XboxGipSvc|SshBroker|SshProxy).dll[""]* \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] .+(SVC|Service|User)_.+; [""]*" & $C & "\\Windows\\(System32|SysWOW64)\\svchost\.exe[""]* \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (osrss|wisvc|VacSvc|WaaSMedicSvc|WpcMonSvc|RmSvc|shpamsvc|vmicrdv|wisvc|WpnUserService); [""]*" & $C & "\\Windows\\(System32|SysWOW64)\\(flightsettings|vac|WaaSMedicSvc|WpcDesktopMonSvc|RMapi|Windows.SharedPC.AccountManager|WpnUserService|flightsettings|osrss).dll[""]* \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] SurfaceService; " & $C & "\\WINDOWS\\System32\\DriverStore\\FileRepository.+\\SurfaceService.exe \[.+\] \(Microsoft.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (AMD External Events Utility|AMD Crash Defender Service|AMD Log Utility); " & $C & "\\Windows\\System32\\(|DriverStore\\FileRepository\\.+\\)(atiesrxx|amdfendrsr|amdlogsr).exe \[.+\] \((Advanced Micro|AMD|Microsoft).*-> (Advanced Micro|AMD).*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (AMD_RAIDXpert|AMDFusionSVC); " & $C & "\\Program Files(| \(x86\))\\AMD\\.+\\(RAIDXpertService|FusionSVC).exe.* \[.+\] \(AMD.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] AMD FUEL Service; " & $C & "\\Program Files\\ATI Technologies\\ATI.ACE\\Fuel\\Fuel.Service.exe /launchService \[.+\] " & "\(Advanced Micro.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] BcmBtRSupport; [""]*" & $C & "\\Windows\\System32\\BtwRSupportService\.exe[""]* \[.+\] \(Broadcom.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] XAudioService; " & $C & "\\Windows\\System32\\DRIVERS\\xaudio64.exe \[.+\] \(Conexant.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (SAService|UIUService); " & $C & "\\Windows\\SysWow64\\(SAsrv|UIUSrv).exe \[.+\] \(Conexant.*-> conexant.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] ; " & $C & "\\Windows\\SysWOW64\\ \[.+\] \(Conexant.*-> conexant.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] HsfXAudioService; " & $C & "\\Windows\\SysWOW64\\XAudio64.dll \[.+\] \(Conexant.*-> conexant.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (CxAudMsg|CxUIUSvc|SynaAudioService|SAService); " & $C & "\\Windows\\system32\\(CxAudMsg64|CxUIUSvc\d+|CxAudioSvc|SAsrv).exe \[.+\] \((Conexant|Microsoft).*-> conexant.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (CxAudioSvc|CxUtilSvc|CxMonSvc); " & $C & "\\Windows\\CxSvc\\(CxAudioSvc|CxUtilSvc|CxMonSvc).exe \[.+\] \(Conexant.*-> Conexant.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] CxUtilSvc; " & $C & "\\Program Files(| \(x86\))\\Conexant\\.+\\CxUtilSvc.exe \[.+\] \(Conexant.*-> Conexant.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] SAService; " & $C & "\\Program Files\\WindowsApps\\.+\\SASrv.exe \[.+\] \(Conexant.*-> Conexant.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] SynaAPOService; " & $C & "\\Windows\\system32\\SynAudSrv.exe \[.+\] \(Conexant.*-> Synaptics.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (ELANFPService|ETDService); " & $C & "\\Windows\\System32\\(ETDService|ELANFPService).exe \[.+\] \(ELAN.+-> ELAN.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (ELANFPService|ETDService); " & $C & "\\Program Files(| \(x86\))\\(Elantech|ElanFP)\\(ETDService|ELANFPService).exe \[.+\] \(ELAN.+-> ELAN.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] ELAN_MOC_IAP_Service; " & $C & "\\Windows\\System32\\ELAN_MOC_IAP_Service.exe \[.+\] \(ELAN.+-> (|ELAN.+)\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] ICEsoundService; " & $C & "\\Windows\\System32(|\\DriverStore\\FileRepository\\.+)\\ICEsoundService64.exe \[.+\] \((ICEpower|Microsoft|Realtek).*-> ICEpower.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (WMIRegistrationService|Int.+ PROSet Monitoring Service|IntcHdmiAddService|LMS|AESMService|igccservice|Inte.+TPM Provisioning Service|Inte.+Capability Licensing Service TCP IP Interface|PIEServiceNew|HfcDisableService|RstMwService|esifsvc|cphs|cplspcon|IntelSSTSvc|irstrtsv|XTU3SERVICE|ModemAuthenticatorService|igfxCUIService\d.0.0.0|Inte.+TPM Provisioning Service|Inte.+Capability Licensing Service TCP IP Interface|iaStorAfsService|ibtsiva|jhi_service|esifsvc); " & $C & "\\Windows\\(System32|SysWOW64|IAStorAfsService)\\(|DriverStore\\FileRepository\\.+\\|Intel.+\\)(WMIRegistrationService|LMS|aesm_service|OneApp.IGCC.WinService|TPMProvisioningService|SocketHeciServer|Intel_PIE_Service|HfcDisableService|RstMwService|esif_uf|IntelCpHeciSvc|IntelCpHDCPSvc|igfxCUIServiceN|ParameterService|irstrtsv|XtuService|esif_uf|ModemAuthenticator|igfxCUIService|TPMProvisioningService|SocketHeciServer|iaStorAfsService|ibtsiva|jhi_service|IProsetMonitor|IntcHdmi).exe \[.+\] \((Inte|Microsoft|ND_Apps).+-> Inte.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (LMS|XTU3SERVICE|Inte.+ ME Service|ModemAuthenticatorService|ZeroConfigService|ThunderboltService|USER_ESRV_SVC_QUEENCREEK|SystemUsageReportSvc_QUEENCREEK|ESRV_SVC_QUEENCREEK|Inte.+SUR QC SAM|AESMService|jhi_service|Inte.+TPM Provisioning Service|Inte.+Capability Licensing Service (TCP IP |)Interface|AMPPALR3|Bluetooth Device Monitor|Bluetooth Media Service|Bluetooth OBEX Service); " & $C & "\\Program Files(| \(x86\))\\Intel.+\\(LMS|XtuService|IntelMeFWService|IntelModemAuthenticator|ZeroConfigService|tbtsvc|SurSvc|esrv_svc|IntelSoftwareAssetManagerService|aesm_service|jhi_service|TPMProvisioningService|BTHSAmpPalService|devmonsrv|mediasrv|obexsrv|SocketHeciServer|HeciServer).exe \[.+\] \(Inte.+-> Inte.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (DSAService|DSAUpdateService); " & $C & "\\Program Files(| \(x86\))\\Intel\\.+\\(DSAService|DSAUpdateService).exe \[.+\] \(IDSA.+-> Inte.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] ThunderboltService; " & $C & "\\Program Files(| \(x86\))\\Intel\\.+\\tbtsvc.exe \[.+\] \(Key for TBT.+-> Inte.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] IntelAudioService; " & $C & "\\Windows\\System32\\cAVS\\[^\\]+\\IntelAudioService.exe \[.+\] \((Intel|Smart|Microsoft).+-> Intel.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] TbtHostControllerService; " & $C & "\\Windows(|\\System32)\\ThunderboltService.exe \[.+\] \((Intel|TBT).+-> (Intel.*|)\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] LMS; " & $C & "\\Windows\\Intel\\.+Management Engine Components\\LMS\\LMS.exe \[.+\] \(Intel.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (MyWiFiDHCPDNS|Inte.+ ME Service|USER_ESRV_SVC_QUEENCREEK|SystemUsageReportSvc_QUEENCREEK|ESRV_SVC_QUEENCREEK); " & $C & "\\Program Files(| \(x86\))\\Intel.+\\(PanDhcpDns|IntelMeFWService|SurSvc|esrv_svc).exe \[.+\] \(Inte.+-> \)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] igccservice; " & $C & "\\Windows\\System32\\DriverStore\\FileRepository\\.+\\OneApp.IGCC.WinService.exe \[.+\] \(Inte.*-> \)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] nvsvc; " & $C & "\\Windows\\system32\\nvvsvc.exe \[.+\] \(NVIDIA.*-> Nvidia.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (NvBroadcast.ContainerLocalSystem|FvSvc|NvStreamNetworkSvc|GfExperienceService|NvNetworkService|NvStreamSvc|NvTelemetryContainer|nvUpdatusService|NvContainerLocalSystem|NvContainerNetworkService|NVDisplay.ContainerLocalSystem); " & $C & "\\Program Files(| \(x86\))\\NVIDIA Corporation\\.+\\(NvBroadcast.Container|nvfvsdksvc_x64|NvStreamNetworkService|NvStreamService|GfExperienceService|NvNetworkService|NvStreamSvc|daemonu|nvcontainer|NVDisplay.Container|NvTelemetryContainer).exe \[.+\] \(NVIDIA.*-> Nvidia.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] RtkAudioUniversalService; " & $C & "\\Windows\\System32\\(|DriverStore\\FileRepository\\[^\\]+\\)RtkAudUService64.exe \[.+\] \(Realtek.+-> Realtek Semiconductor.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] RtkAudioService; " & $C & "\\Program Files(| \(x86\))\\Realtek\\.+\\RtkAudioService64.exe \[.+\] \(Realtek.+-> Realtek Semiconductor.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] RtkBtManServ; " & $C & "\\Windows\\RtkBtManServ.exe \[.+\] \(.+-> Realtek Semiconductor.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] SynTPEnhService; " & $C & "\\Program Files(| \(x86\))\\Synaptics\\.+\\SynTPEnhService.exe \[.+\] \(Synaptics.+-> Synaptics.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] SynTPEnhService; " & $C & "\\Windows\\System32\\SynTPEnhService.exe \[.+\] \((Microsoft|Synaptics).+-> Synaptics.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] QcomWlanSrv; " & $C & "\\Windows\\System32(|\\Drivers)\\QcomWlanSrvx64.exe \[.+\] \(Qualcomm.+ -> Qualcomm.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] AtherosSvc; " & $C & "\\Windows\\System32(|\\Drivers)\\AdminService.exe \[.+\] \((Qualcomm Atheros|Microsoft.+) -> Windows.+\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (WTabletService(Pro|ISD|Wacom|Con)|TouchService(Wacom|Pen)|TabletServicePen); " & $C & "\\Program Files\\Tablet\\(Wacom|Pen|ISD)\\(WTabletService(Pro|ISD|Wacom|Con)|Wacom_Tablet|Wacom_TouchService|Pen_Tablet|Pen_TouchService).exe \[.+\] \(Wacom.*-> Wacom.*\)\v{2}" , "" )
	$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)[RSU][234] (WTabletServiceISD|TabletServicePen); " & $C & "\\Windows\\System32(|\\DriverStore\\FileRepository\\[^\\]+)\\(WTabletServiceISD|Pen_Tablet).exe \[.+\] \(Wacom.*-> Wacom.*\)\v{2}" , "" )
EndFunc
Func WINLOGON ( $VALUE )
	Local $ATTEN
	$VALUSER = RegRead ( "HKLM\" & $SOFTWARE & "\Microsoft\Windows NT\CurrentVersion\Winlogon" , $VALUE )
	If @error = 0 And $VALUSER <> "" Then
		$FILE = $VALUSER
		AAAAFP ( )
		If $VALUE = "Taskman" Then $ATTEN = " <=== " & $UPD1
		If FileExists ( $FILE ) Then
			_ARRAYADD ( $ARRAYREG , "HKLM\...\Winlogon: [" & $VALUE & "] " & $FILE & " [" & $SIZE & " " & $CDATE & "]" & $COMPANY & $ATTEN , 0 , "||||" )
		Else
			$VALUSER = $VALUSER & " " & $REGIST8
			_ARRAYADD ( $ARRAYREG , "HKLM\...\Winlogon: [" & $VALUE & "] " & $VALUSER & $ATTEN , 0 , "||||" )
		EndIf
	EndIf
EndFunc
Func WINLOGON1 ( $WINLOGKEY , $VNAME )
	$VAR1 = RegRead ( $WINLOGKEY , $VNAME )
	If Not $VAR1 Then Return
	$VAR1 = StringRegExpReplace ( $VAR1 , "(?s)\R+" , " - " )
	_ARRAYADD ( $ARRAYREG , "HKLM\...\Winlogon: [" & $VNAME & "] " & $VAR1 , 0 , "||||" )
EndFunc
Func WINLOGONSYS ( )
	If StringInStr ( $FIX , "System" ) Then
		$VAL = "System"
	Else
		$VAL = "Taskman"
	EndIf
	$KEY = "HKLM\" & $SOFTWARE & "\Microsoft\Windows NT\CurrentVersion\Winlogon"
	DELVALUE ( $KEY , $VAL )
EndFunc
Func WINSOCK ( )
	$HWINSOCK = FileOpen ( @TempDir & "\winsock" , 2 + 256 )
	Local $I = 1
	$KEY = "HKLM\SYSTEM\CurrentControlSet\Services\WinSock2\Parameters\"
	While 1
		$WSCHECK = ""
		$COMPANY = ""
		$SIZE = ""
		$VAR = RegEnumKey ( $KEY & "NameSpace_Catalog5\Catalog_Entries" , $I )
		If @error Then ExitLoop
		$VAL = RegRead ( $KEY & "NameSpace_Catalog5\Catalog_Entries\" & $VAR , "LibraryPath" )
		If @error <> 0 Then ExitLoop
		$REGEXPR = $VAL
		If StringRegExp ( $REGEXPR , "(?i)(%SystemRoot%|%windir%)" ) Then
			$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)%SystemRoot%|%windir%" , $WINDOWSDIR )
			$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)([a-z]:)" , "$1\\" )
		EndIf
		If Not StringInStr ( $REGEXPR , "\" ) And StringRegExp ( $REGEXPR , "\A\w+\..{3}\Z" ) Then
			$FILE = $REGEXPR
			FILENAMEONLY ( $FILE )
			If FileExists ( $FILE ) Then $REGEXPR = $FILE
		EndIf
		$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)\\System32\\" , "\\SysWOW64\\" )
		If StringRegExp ( $REGEXPR , "(?i)%Programfiles%" ) Then $REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)%Programfiles%" , $C & "\\Program Files \(x86\)" )
		$VAL2 = RegRead ( $KEY & "NameSpace_Catalog5\Catalog_Entries\" & $VAR , "ProviderId" )
		Select
		Case $VAL2 = "0x409D05229E7ECF11AE5A00AA00A7112B"
			If $REGEXPR <> EnvGet ( "SystemRoot" ) & "\SysWOW64\mswsock.dll" Then $WSCHECK = " " & $UPD1 & ": LibraryPath " & $INTERNET5 & " ""%SystemRoot%\System32\mswsock.dll"""
		Case $VAL2 = "0xA2CB4A96BCB2EB408C6AA6DB40161CAE"
			If $REGEXPR <> EnvGet ( "SystemRoot" ) & "\SysWOW64\napinsp.dll" Then $WSCHECK = " " & $UPD1 & ": LibraryPath " & $INTERNET5 & " ""%SystemRoot%\system32\napinsp.dll"""
		Case $VAL2 = "0xCE89FE036D767649B9C1BB9BC42C7B4D" Or $VAL2 = "0xCD89FE036D767649B9C1BB9BC42C7B4D"
			If $REGEXPR <> EnvGet ( "SystemRoot" ) & "\SysWOW64\pnrpnsp.dll" Then $WSCHECK = " " & $UPD1 & ": LibraryPath " & $INTERNET5 & " ""%SystemRoot%\system32\pnrpnsp.dll"""
		Case $VAL2 = "0x3A244266A83BA64ABAA52E0BD71FDD83"
			If Not StringRegExp ( $REGEXPR , "(?i)^" & StringRegExpReplace ( EnvGet ( "SystemRoot" ) , "\\" , "\\\\" ) & "\\SysWOW64\\nla(nsp_c|api).dll" ) Then $WSCHECK = " " & $UPD1 & ": LibraryPath " & $INTERNET5 & " ""%SystemRoot%\system32\NLAapi.dll"""
		Case $VAL2 = "0xEE37263B80E5CF11A55500C04FD8D4AC"
			If $REGEXPR <> EnvGet ( "SystemRoot" ) & "\SysWOW64\winrnr.dll" Then $WSCHECK = " " & $UPD1 & ": LibraryPath " & $INTERNET5 & " ""%SystemRoot%\System32\winrnr.dll"""
		EndSelect
		$VAR = StringRegExpReplace ( $VAR , "0000000000" , "" )
		If Not FileExists ( $REGEXPR ) Then
			$SIZE = " => " & $REGIST8 & " "
		Else
			COMP ( $REGEXPR )
			$VAL = $REGEXPR
			$SIZE = " [" & $SIZE & " " & $CDATE & "]"
		EndIf
		FileWrite ( @TempDir & "\winsock" , "Winsock: Catalog5 " & $VAR & " " & $VAL & $SIZE & $COMPANY & $WSCHECK & @CRLF )
		$I = $I + 1
	WEnd
	$NUM = RegRead ( $KEY & "NameSpace_Catalog5" , "Num_Catalog_Entries" )
	If $NUM > $I + 4294967295 Then FileWrite ( @TempDir & "\winsock" , "Winsock: -> Catalog5 - " & $WINSOCKBR & " <==== " & $UPD1 & @CRLF )
	$I = 1
	While 1
		$COMPANY = ""
		$SIZE = ""
		$VAR = RegEnumKey ( $KEY & "Protocol_Catalog9\Catalog_Entries" , $I )
		If @error Then ExitLoop
		$VAL = RegRead ( $KEY & "Protocol_Catalog9\Catalog_Entries\" & $VAR , "PackedCatalogItem" )
		$VAL = StringRegExpReplace ( $VAL , "00.+" , "" )
		$VAL = _HEXTOSTRING ( $VAL )
		$REGEXPR = $VAL
		If StringRegExp ( $REGEXPR , "(?i)(%SystemRoot%|%windir%)" ) Then
			$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)(%SystemRoot%|%windir%)" , $WINDOWSDIR )
			$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)([a-z]:)" , "$1\\" )
			$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)\\System32\\" , "\\SysWOW64\\" )
		EndIf
		If Not StringInStr ( $REGEXPR , "\" ) And StringRegExp ( $REGEXPR , "\A\w+\..{3}\Z" ) Then
			$FILE = $REGEXPR
			FILENAMEONLY ( $FILE )
			If FileExists ( $FILE ) Then $REGEXPR = $FILE
		EndIf
		$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)\\System32\\" , "\\SysWOW64\\" )
		If StringRegExp ( $REGEXPR , "(?i)%Programfiles%" ) Then $REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)%Programfiles%" , $C & "\\Program Files \(x86\)" )
		$VAR = StringRegExpReplace ( $VAR , "0000000000" , "" )
		If Not FileExists ( $REGEXPR ) Then
			$SIZE = " => " & $REGIST8 & " "
		Else
			COMP ( $REGEXPR )
			$VAL = $REGEXPR
			$SIZE = " [" & $SIZE & " " & $CDATE & "]"
		EndIf
		FileWrite ( @TempDir & "\winsock" , "Winsock: Catalog9 " & $VAR & " " & $VAL & $SIZE & $COMPANY & @CRLF )
		$I = $I + 1
	WEnd
	If $I > 99 Then FileWrite ( $FRSTLOG , "ATTENTION: There are more than 99 Catalog9 entries. Turn off the whitelisting to see all the entries. You may check Device Manager for presence of unusual amount of ""Microsoft 6to4 Adapter"" devices." & @CRLF )
	$NUM = RegRead ( $KEY & "Protocol_Catalog9" , "Num_Catalog_Entries" )
	If $NUM > $I + 4294967295 Then FileWrite ( @TempDir & "\winsock" , "Winsock: -> Catalog9 - " & $WINSOCKBR & " <==== " & $UPD1 & @CRLF )
	WINSOCK64 ( )
	$REGEXP = FileRead ( @TempDir & "\winsock" )
	If GUICtrlRead ( $CHECKBOX11 ) = 4 Then
		FileWrite ( $FRSTLOG , $REGEXP )
	Else
		$REGEXP = StringRegExpReplace ( $REGEXP , "(?i)Winsock: Catalog(5|9|5-x64|9-x64) \d+ ([a-z]:\\Windows|%SystemRoot%)\\(system32|SysWOW64)\\(nlansp_c|NLAapi|napinsp|pnrpnsp|mswsock|winrnr|wshbth).dll \[.+\] \(Microsoft .+ -> Microsoft .+\)\v{2}" , "" )
		FileWrite ( $FRSTLOG , $REGEXP )
	EndIf
	FileClose ( $HWINSOCK )
	FileDelete ( @TempDir & "\winsock" )
EndFunc
Func WINSOCK64 ( )
	$KEY = "HKLM\SYSTEM\CurrentControlSet\Services\WinSock2\Parameters\"
	Local $I = 1
	While 1
		$WSCHECK = ""
		$COMPANY = ""
		$VAR = RegEnumKey ( $KEY & "NameSpace_Catalog5\Catalog_Entries64" , $I )
		If @error Then ExitLoop
		$VAL = RegRead ( $KEY & "NameSpace_Catalog5\Catalog_Entries64\" & $VAR , "LibraryPath" )
		If @error = 0 Then
			$REGEXPR = $VAL
			$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)%SystemRoot%" , $C & "\\Windows" )
			$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)%windir%" , $C & "\\Windows" )
			$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)%Programfiles%" , $C & "\\Program Files" )
			If Not StringInStr ( $REGEXPR , "\" ) And StringRegExp ( $REGEXPR , "\A\w+\..{3}\Z" ) Then
				$FILE = $REGEXPR
				FILENAMEONLY ( $FILE )
				If FileExists ( $FILE ) Then $REGEXPR = $FILE
			EndIf
			$VAL2 = RegRead ( $KEY & "NameSpace_Catalog5\Catalog_Entries64\" & $VAR , "ProviderId" )
			Select
			Case $VAL2 = "0x409D05229E7ECF11AE5A00AA00A7112B"
				If $REGEXPR <> EnvGet ( "SystemRoot" ) & "\System32\mswsock.dll" Then $WSCHECK = " " & $UPD1 & ": LibraryPath " & $INTERNET5 & " ""%SystemRoot%\System32\mswsock.dll"""
			Case $VAL2 = "0xA2CB4A96BCB2EB408C6AA6DB40161CAE"
				If $REGEXPR <> EnvGet ( "SystemRoot" ) & "\System32\napinsp.dll" Then $WSCHECK = " " & $UPD1 & ": LibraryPath " & $INTERNET5 & " ""%SystemRoot%\system32\napinsp.dll"""
			Case $VAL2 = "0xCE89FE036D767649B9C1BB9BC42C7B4D" Or $VAL2 = "0xCD89FE036D767649B9C1BB9BC42C7B4D"
				If $REGEXPR <> EnvGet ( "SystemRoot" ) & "\System32\pnrpnsp.dll" Then $WSCHECK = " " & $UPD1 & ": LibraryPath " & $INTERNET5 & " ""%SystemRoot%\system32\pnrpnsp.dll"""
			Case $VAL2 = "0x3A244266A83BA64ABAA52E0BD71FDD83"
				If Not StringRegExp ( $REGEXPR , "(?i)^" & StringRegExpReplace ( EnvGet ( "SystemRoot" ) , "\\" , "\\\\" ) & "\\System32\\nla(nsp_c|api).dll" ) Then $WSCHECK = " " & $UPD1 & ": LibraryPath " & $INTERNET5 & " ""%SystemRoot%\system32\NLAapi.dll"""
			Case $VAL2 = "0xEE37263B80E5CF11A55500C04FD8D4AC"
				If $REGEXPR <> EnvGet ( "SystemRoot" ) & "\System32\winrnr.dll" Then $WSCHECK = " " & $UPD1 & ": LibraryPath " & $INTERNET5 & " ""%SystemRoot%\System32\winrnr.dll"""
			EndSelect
			$VAR = StringRegExpReplace ( $VAR , "0000000000" , "" )
			If Not FileExists ( $REGEXPR ) Then
				$SIZE = " => " & $REGIST8 & " "
			Else
				COMP ( $REGEXPR )
				$VAL = $REGEXPR
				$SIZE = " [" & $SIZE & " " & $CDATE & "]"
			EndIf
			If StringRegExp ( $VAL , "(?i):\\Windows\\system32\\NSBlock(A|B).dll" ) Then
				$ATT = " <==== " & $UPD1
			Else
				$ATT = ""
			EndIf
			FileWrite ( @TempDir & "\winsock" , "Winsock: Catalog5-x64 " & $VAR & " " & $VAL & $SIZE & $COMPANY & $WSCHECK & $ATT & @CRLF )
		EndIf
		$I = $I + 1
	WEnd
	$NUM = RegRead ( $KEY & "NameSpace_Catalog5" , "Num_Catalog_Entries64" )
	If $NUM > $I + 4294967295 Then FileWrite ( @TempDir & "\winsock" , "Winsock: -> Catalog5-x64 - " & $WINSOCKBR & " <==== " & $UPD1 & @CRLF )
	$I = 1
	While 1
		$COMPANY = ""
		$SIZE = ""
		$VAR = RegEnumKey ( $KEY & "Protocol_Catalog9\Catalog_Entries64" , $I )
		If @error Then ExitLoop
		$VAL = RegRead ( $KEY & "Protocol_Catalog9\Catalog_Entries64\" & $VAR , "PackedCatalogItem" )
		$VAL = StringRegExpReplace ( $VAL , "00.+" , "" )
		$VAL = _HEXTOSTRING ( $VAL )
		$REGEXPR = StringRegExpReplace ( $VAL , "(?i)%SystemRoot%" , $C & "\\Windows" )
		$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)%windir%" , $C & "\\Windows" )
		$REGEXPR = StringRegExpReplace ( $REGEXPR , "(?i)%Programfiles%" , $C & "\\Program Files" )
		If Not StringInStr ( $REGEXPR , "\" ) And StringRegExp ( $REGEXPR , "\A\w+\..{3}\Z" ) Then
			$FILE = $REGEXPR
			FILENAMEONLY ( $FILE )
			If FileExists ( $FILE ) Then $REGEXPR = $FILE
		EndIf
		$VAR = StringRegExpReplace ( $VAR , "0000000000" , "" )
		If Not FileExists ( $REGEXPR ) Then
			$SIZE = " => " & $REGIST8 & " "
		Else
			COMP ( $REGEXPR )
			$VAL = $REGEXPR
			$SIZE = " [" & $SIZE & " " & $CDATE & "]"
		EndIf
		FileWrite ( @TempDir & "\winsock" , "Winsock: Catalog9-x64 " & $VAR & " " & $VAL & $SIZE & $COMPANY & @CRLF )
		$I = $I + 1
	WEnd
	$NUM = RegRead ( $KEY & "Protocol_Catalog9" , "Num_Catalog_Entries64" )
	If $NUM > $I + 4294967295 Then FileWrite ( @TempDir & "\winsock" , "Winsock: -> Catalog9-x64 - " & $WINSOCKBR & " <==== " & $UPD1 & @CRLF )
EndFunc
Func WINSOCKFIX ( )
	$ID = ""
	$LP = ""
	$VAL = ""
	$SIZE = ""
	$KEY1 = "HKLM\SYSTEM\CurrentControlSet\Services\WinSock2\Parameters\"
	$VAL = StringRegExpReplace ( $FIX , "(?i)Winsock: Catalog\d[-]*[x]*[6]*[4]* (\d+) .+" , "$1" )
	If StringLen ( $VAL ) = 2 Then $VAL = StringRegExpReplace ( $VAL , $VAL , "0000000000" & $VAL )
	If StringInStr ( $FIX , "Winsock: Catalog5" ) Then
		If StringInStr ( $FIX , "Winsock: Catalog5 " ) Then $KEY = $KEY1 & "NameSpace_Catalog5\Catalog_Entries\"
		If StringInStr ( $FIX , "Winsock: Catalog5-x64" ) Then $KEY = $KEY1 & "NameSpace_Catalog5\Catalog_Entries64\"
		$ID = RegRead ( $KEY & $VAL , "ProviderId" )
		Select
		Case $ID = "0x409D05229E7ECF11AE5A00AA00A7112B"
			$LP = "%SystemRoot%\System32\mswsock.dll"
			FIXCATALOG5 ( $KEY , $VAL )
		Case $ID = "0xA2CB4A96BCB2EB408C6AA6DB40161CAE"
			$LP = "%SystemRoot%\system32\napinsp.dll"
			FIXCATALOG5 ( $KEY , $VAL )
		Case $ID = "0xCE89FE036D767649B9C1BB9BC42C7B4D" Or $ID = "0xCD89FE036D767649B9C1BB9BC42C7B4D"
			$LP = "%SystemRoot%\system32\pnrpnsp.dll"
			FIXCATALOG5 ( $KEY , $VAL )
		Case $ID = "0x3A244266A83BA64ABAA52E0BD71FDD83"
			$LP = "%SystemRoot%\system32\NLAapi.dll"
			FIXCATALOG5 ( $KEY , $VAL )
		Case $ID = "0xEE37263B80E5CF11A55500C04FD8D4AC"
			$LP = "%SystemRoot%\System32\winrnr.dll"
			FIXCATALOG5 ( $KEY , $VAL )
	Case Else
			DELCATALOG ( $KEY , $VAL )
			If StringInStr ( $FIX , "Winsock: Catalog5 " ) Then FileWrite ( @TempDir & "\catalog0" , "Catalog5 " )
			If StringInStr ( $FIX , "Winsock: Catalog5-x64 " ) Then FileWrite ( @TempDir & "\catalog0" , "Catalog5-x64 " )
		EndSelect
	EndIf
	If StringInStr ( $FIX , "Winsock: Catalog9" ) Then
		If StringInStr ( $FIX , "Winsock: Catalog9 " ) Then $KEY = $KEY1 & "Protocol_Catalog9\Catalog_Entries\"
		If StringInStr ( $FIX , "Winsock: Catalog9-x64 " ) Then $KEY = $KEY1 & "Protocol_Catalog9\Catalog_Entries64\"
		If StringInStr ( $FIX , "mswsock" ) Or StringInStr ( $FIX , "rsvpsp" ) Then
			FileWrite ( $HFIXLOG , $CAT1 & " """ & $VAL & """ " & $CAT2 & "." & @CRLF )
		Else
			DELCATALOG ( $KEY , $VAL )
			If StringInStr ( $FIX , "Winsock: Catalog9 " ) Then FileWrite ( @TempDir & "\catalog0" , "Catalog9 " )
			If StringInStr ( $FIX , "Winsock: Catalog9-x64 " ) Then FileWrite ( @TempDir & "\catalog0" , "CCatalog9-x64 " )
		EndIf
	EndIf
EndFunc
Func WL ( $IN )
	If GUICtrlRead ( $IN ) = 1 Then
		$IT = $WLISTED
	Else
		$IT = $ALL
	EndIf
	Return $IT
EndFunc
Func WMI_HJK ( $PATH , ByRef $ARR )
	Local $OBJWMISERVICE , $DEVCOLITEMS , $OBJECT , $NAME
	Local $CLASSES [ 10 ] = [ "__FilterToConsumerBinding" , "__TimerInstruction" , "__AbsoluteTimerInstruction" , "__IntervalTimerInstruction" , "__EventFilter" , "NTEventLogEventConsumer" , "ActiveScriptEventConsumer" , "CommandLineEventConsumer" , "LogFileEventConsumer" , "SMTPEventConsumer" ]
	$OBJWMISERVICE = ObjGet ( "winmgmts:{impersonationLevel=impersonate}!\\.\root\" & $PATH )
	If Not @error And IsObj ( $OBJWMISERVICE ) Then
		For $P = 0 To UBound ( $CLASSES ) + 4294967295
			If $PATH = "CIMV2" And $P > 5 Then ContinueLoop
			$DEVCOLITEMS = $OBJWMISERVICE .ExecQuery ( "Select * from " & $CLASSES [ $P ] )
			If IsObj ( $DEVCOLITEMS ) Then
				For $OBJECT In $DEVCOLITEMS
					$FLAG = ""
					$PROP1 = ""
					$PROP2 = ""
					$PROP3 = ""
					If $P = 0 Then
						$NAME = $OBJECT .Consumer
						$FILTER = $OBJECT .Filter
						If $NAME <> "" Then
							$NAME = $NAME & """,Filter=""" & $FILTER
							$NAME = StringRegExpReplace ( $NAME , "Name=" , "Name=\\" )
							$NAME = StringRegExpReplace ( $NAME , """""" , "\\""""" )
							$NAME = StringRegExpReplace ( $NAME , """$" , "\\""" )
						EndIf
					ElseIf $P = 1 Or $P = 2 Or $P = 3 Then
						$NAME = $OBJECT .TimerId
					Else
						$NAME = $OBJECT .Name
					EndIf
					If $NAME <> "" Then
						Select
						Case $P = 4
							$PROP1 = $OBJECT .Query
							If $PROP1 Then $PROP1 = "[Query => " & $PROP1 & "]"
						Case $P = 6
							$PROP1 = $OBJECT .ScriptFileName
							If $PROP1 Then $PROP1 = "[ScriptFileName => " & $PROP1 & "]"
							$PROP2 = $OBJECT .ScriptText
							If StringLen ( $PROP2 ) > 300 Then $PROP2 = StringTrimRight ( $PROP2 , StringLen ( $PROP2 ) + 4294966996 ) & " (" & $DATAX & " " & StringLen ( $PROP2 ) + 4294966996 & " " & $DATAY & ")."
							If $PROP2 Then $PROP2 = "[ScriptText => " & $PROP2 & "]"
						Case $P = 7
							$PROP1 = $OBJECT .CommandLineTemplate
							If StringLen ( $PROP1 ) > 300 Then $PROP1 = StringTrimRight ( $PROP1 , StringLen ( $PROP1 ) + 4294966996 ) & " (" & $DATAX & " " & StringLen ( $PROP1 ) + 4294966996 & " " & $DATAY & ")."
							If $PROP1 Then $PROP1 = "[CommandLineTemplate => " & $PROP1 & "]"
							$PROP2 = $OBJECT .ExecutablePath
							If $PROP2 Then $PROP2 = "[ExecutablePath => " & $PROP2 & "]"
							$PROP3 = $OBJECT .WorkingDirectory
							If $PROP3 Then $PROP3 = "[WorkingDirectory => " & $PROP3 & "]"
						Case $P = 8
							$PROP1 = $OBJECT .Filename
							If $PROP1 Then $PROP1 = "[Filename => " & $PROP1 & "]"
							$PROP2 = $OBJECT .Text
							If $PROP2 Then $PROP2 = "[Text => " & $PROP2 & "]"
						EndSelect
						If StringRegExp ( $NAME , "(?i)ASEC|fuck|Powershell|sethomePage|Windows Events|coronav|SCM Event\d+ Log Consumer|SCM Event\d+ Log Filter|systemcore_Updater\d+" ) Then
							$FLAG = " <==== " & $UPD1
						Else
							If $PATH = "subscription" Then
								Select
								Case $CLASSES [ $P ] = "__EventFilter"
									If StringRegExp ( $NAME , "(?i)SCM Event Log Filter|Dell(Command|)PowerManager(Alert|PolicyChange|PowerPlanChange|PowerPlanSettingChange|PowerStateChange|UserLogin)" ) Then ContinueLoop
								Case $CLASSES [ $P ] = "NTEventLogEventConsumer"
									If $NAME = "SCM Event Log Consumer" Then ContinueLoop
								Case $CLASSES [ $P ] = "ActiveScriptEventConsumer"
									If StringRegExp ( $NAME , "(?i)Dell(Command|)PowerManager(Alert|PolicyChange|PowerPlanChange|PowerPlanSettingChange|PowerStateChange|UserLogin)" ) Then ContinueLoop
								Case $CLASSES [ $P ] = "__FilterToConsumerBinding"
									If StringRegExp ( $NAME , "(?i)NTEventLogEventConsumer.Name=\\""SCM Event Log Consumer\\"""",|ActiveScriptEventConsumer.Name=\\""Dell(Command|)PowerManager(Alert|PolicyChange|PowerPlanChange|PowerPlanSettingChange|PowerStateChange|UserLogin)" ) Then ContinueLoop
								EndSelect
							EndIf
						EndIf
						_ARRAYADD ( $ARR , "WMI:" & $PATH & "\" & $CLASSES [ $P ] & "->" & $NAME & "::" & $PROP1 & $PROP2 & $PROP3 & $FLAG , 0 , "|||" )
					EndIf
				Next
			EndIf
		Next
	EndIf
EndFunc
Func WMI_HJKFIX ( )
	WMI_HJKFIXIT ( )
	$COMERR = ""
EndFunc
Func WMI_HJKFIXIT ( )
	Local $OBJWMISERVICE , $DEVCOLITEMS , $OBJECT
	$NAMESPACE = StringRegExpReplace ( $FIX , "WMI:(.+)\\.+->.+::.*" , "$1" )
	$ACLASS = StringRegExpReplace ( $FIX , "WMI:.+\\(.+?)->.+::.*" , "$1" )
	$NAMEE = StringRegExpReplace ( $FIX , "WMI:.+->(.+?)::.*" , "$1" )
	$OBJWMISERVICE = ObjGet ( "winmgmts:{impersonationLevel=impersonate}!\\.\root\" & $NAMESPACE )
	If Not @error And IsObj ( $OBJWMISERVICE ) Then
		$DEVCOLITEMS = $OBJWMISERVICE .ExecQuery ( "Select * from " & $ACLASS )
		$EXIST = ""
		If IsObj ( $DEVCOLITEMS ) Then
			For $OBJECT In $DEVCOLITEMS
				If $ACLASS = "__FilterToConsumerBinding" Then
					$NAME = $OBJECT .Consumer
					$FILTER = $OBJECT .Filter
					If $NAME <> "" Then
						$NAME = $NAME & """,Filter=""" & $FILTER
						$NAME = StringRegExpReplace ( $NAME , "Name=" , "Name=\\" )
						$NAME = StringRegExpReplace ( $NAME , """""" , "\\""""" )
						$NAME = StringRegExpReplace ( $NAME , """$" , "\\""" )
					EndIf
				ElseIf StringRegExp ( $ACLASS , "(?i)__TimerInstruction|__AbsoluteTimerInstruction|__IntervalTimerInstruction" ) Then
					$NAME = $OBJECT .TimerId
				Else
					$NAME = $OBJECT .Name
				EndIf
				If $NAME = $NAMEE Then $EXIST = 1
			Next
		EndIf
		If $EXIST = "" Then
			NFOUND ( $NAMEE )
		Else
			If $ACLASS = "__FilterToConsumerBinding" Then
				$DEL = "__FilterToConsumerBinding.Consumer=""" & $NAMEE & """"
			ElseIf StringRegExp ( $ACLASS , "(?i)__TimerInstruction|__AbsoluteTimerInstruction|__IntervalTimerInstruction" ) Then
				$DEL = $ACLASS & ".TimerId=""" & $NAMEE & """"
			Else
				$DEL = $ACLASS & ".Name=""" & $NAMEE & """"
			EndIf
			$DEL = StringRegExpReplace ( $DEL , "\\(?!"")" , "\\\\" )
			$OBJWMISERVICE .Delete ( $DEL )
			If @error Then
				FileWrite ( $HFIXLOG , $NAMEE & " => " & $ERDEL & " ." & " Error: " & @error & @CRLF )
			Else
				DELETED ( $NAMEE )
			EndIf
		EndIf
	Else
		FileWrite ( $HFIXLOG , $NAMEE & " => " & $ERDEL & ". ErrorCode: " & @error & @CRLF )
	EndIf
EndFunc
Func WORKDIR ( $READ )
	$RET = StringRegExp ( $READ , "(?i)WorkingDirectory>(.+)</WorkingDirectory" , 1 )
	If IsArray ( $RET ) Then Return $RET [ 0 ]
	Return ""
EndFunc
Func ZB ( )
	Local $ZB [ 1 ]
	ZB2 ( $WINDOWSDIR , "*.exe;*.dll" , $ZB )
	ZB2 ( $WINDOWSDIR86 , "*.exe;*.dll" , $ZB )
	ZB2 ( $SYSTEMDIR , "*.exe;*.dll" , $ZB )
	ZB2 ( $SYSTEMDIR & "\Drivers" , "*.sys" , $ZB )
	ZB2 ( $WINDOWSDIR86 & "\Drivers" , "*.sys" , $ZB )
	Return $ZB
EndFunc
Func ZB2 ( $PATH , $SEARCH , ByRef $RESULT )
	$WIN = _FILELISTTOARRAYREC ( $PATH , $SEARCH , 1 , 0 , 0 , 2 )
	For $I = 1 To UBound ( $WIN ) + 4294967295
		If FileGetSize ( $WIN [ $I ] ) = 0 Then
			$ATTEN = FILEACC ( $WIN [ $I ] )
			_ARRAYADD ( $RESULT , $WIN [ $I ] & " [" & FILETIMECM ( $WIN [ $I ] ) & "]" & $ATTEN , 0 , "||||" )
		EndIf
	Next
EndFunc
Func ZBFILESINDIR ( )
	Local $ZB [ 1 ]
	For $P = 1 To UBound ( $ALLUSERS ) + 4294967295
		$ARR = _FILELISTTOARRAY ( $ALLUSERS [ $P ] , "*" , 1 , True )
		For $I = 1 To UBound ( $ARR ) + 4294967295
			If StringRegExp ( $ARR [ $I ] , "(?i)\.(reg|bat|pad|dat|dll|exe|plz|ctrl|pff|js|dss|pss|fvv|bxx|fdd|jss|zvv|odd|fee|vbs|cmd)\Z" ) And Not StringRegExp ( $ARR [ $I ] , "(?i)\\(FullRemove.exe|MakeMarkerFile.exe|EasySurvey.exe|ezsidmv.dat|g2mdlhlpx.exe|ntuser.dat|nvModes.dat|GoToAssistDownloadHelper.exe|PKP_DL|jagex_cl.+.dat|random\.dat|SetStretch\.|Lenovo-\d+.vbs|pswi_preloaded.exe)" ) Then
				ZBFILESINDIR3 ( $ARR [ $I ] , $ZB )
			EndIf
		Next
	Next
	ZBFILESINDIR2 ( @ProgramFilesDir , $ZB )
	ZBFILESINDIR2 ( $PROGRAMFILES86 , $ZB )
	ZBFILESINDIR2 ( EnvGet ( "CommonProgramFiles" ) , $ZB )
	ZBFILESINDIR2 ( EnvGet ( "CommonProgramFiles(x86)" ) , $ZB )
	ZBFILESINDIR2 ( @AppDataDir , $ZB )
	ZBFILESINDIR2 ( @AppDataDir & "\Microsoft" , $ZB )
	ZBFILESINDIR2 ( @LocalAppDataDir , $ZB )
	Return $ZB
EndFunc
Func ZBFILESINDIR2 ( $PATH , ByRef $RESULT )
	$WIN = _FILELISTTOARRAYREC ( $PATH , "*" , 1 + 16 , 0 , 0 , 2 )
	For $I = 1 To UBound ( $WIN ) + 4294967295
		If Not StringRegExp ( $WIN [ $I ] , "(?i)(desktop.ini|iconcache|gdipfontcache|ntuser.|LastFlashConfig.wfc)" ) Then ZBFILESINDIR3 ( $WIN [ $I ] , $RESULT )
	Next
EndFunc
Func ZBFILESINDIR3 ( $PATH , ByRef $RESULT )
	$FATT = FileGetAttrib ( $PATH )
	$FATT = StringRegExpReplace ( $FATT , "A" , "" )
	If _REPARSEPOINT ( $PATH ) Then $FATT = $FATT & "L"
	$ATT = StringFormat ( "%05s" , $FATT )
	$ATTS = StringRegExpReplace ( $ATT , "0" , "_" )
	$SIZE = FileGetSize ( $PATH )
	$SIZES = StringFormat ( "%09u" , $SIZE )
	$DATECR = FILETIME ( $PATH , 1 )
	$DATEMO = FILETIME ( $PATH )
	$VER = FileGetVersion ( $PATH , "CompanyName" )
	$VER = StringRegExpReplace ( $VER , "(?i)http(s|):" , "hxxp\1:" )
	_ARRAYADD ( $RESULT , $DATECR & " - " & $DATEMO & " - " & $SIZES & " " & $ATTS & " (" & $VER & ") " & $PATH , 0 , "||||" )
EndFunc
Func ZIP ( )
	FileWrite ( $HFIXLOG , "================== Zip: ===================" & @CRLF )
	$PATHSALL = StringRegExpReplace ( $FIX , "(?i)zip:\s*(.+)" , "$1" )
	$PATHS = StringSplit ( $PATHSALL , ";" )
	If Not IsArray ( $PATHS ) Then Return FileWrite ( $HFIXLOG , "Error reading paths" & @CRLF )
	$ZIPPATH = @DesktopDir & "\" & @MDAY & "." & @MON & "." & @YEAR & "_" & @HOUR & "." & @MIN & "." & @SEC & ".zip"
	$ZIPTEMP = @TempDir & "\zip" & @MDAY & "." & @MON & "." & @YEAR & "_" & @HOUR & "." & @MIN & "." & @SEC
	DirCreate ( $ZIPTEMP )
	$PTEMP = $C & "\FRST\tempzip"
	$OTEMP = FileOpen ( $PTEMP , 256 + 2 )
	FileClose ( $OTEMP )
	If _ZIP_CREATE ( $ZIPPATH , 1 ) <> $ZIPPATH Then Return FileWrite ( $HFIXLOG , "Error creating zip folder" & @CRLF & @CRLF )
	For $P = 1 To UBound ( $PATHS ) + 4294967295
		If StringInStr ( $PATHS [ $P ] , "~" ) Then $PATHS [ $P ] = FileGetLongName ( $PATHS [ $P ] )
		$PATHS [ $P ] = StringRegExpReplace ( $PATHS [ $P ] , "^\s+|\s+$" , "" )
		$PATHS [ $P ] = StringRegExpReplace ( $PATHS [ $P ] , "^""(.+)""$" , "$1" )
		$FPNAME = StringRegExpReplace ( $PATHS [ $P ] , ".+\\(.+)" , "|$1|" )
		Select
		Case Not FileExists ( $PATHS [ $P ] )
			NFOUND ( $PATHS [ $P ] )
			If UBound ( $PATHS ) = 2 Then FileDelete ( $ZIPPATH )
		Case Not StringInStr ( FileGetAttrib ( $PATHS [ $P ] ) , "D" ) And Not FileCopy ( $PATHS [ $P ] , $ZIPTEMP , 1 )
			FileWrite ( $HFIXLOG , $PATHS [ $P ] & " -> " & $NCOPY & @CRLF )
		Case StringInStr ( FileGetAttrib ( $PATHS [ $P ] ) , "D" ) And Not DirCopy ( $PATHS [ $P ] , $ZIPTEMP , 1 )
			FileWrite ( $HFIXLOG , $PATHS [ $P ] & " -> " & $NCOPY & @CRLF )
		Case StringInStr ( FileGetAttrib ( $PATHS [ $P ] ) , "D" ) And Not DirGetSize ( $PATHS [ $P ] )
			FileWrite ( $HFIXLOG , $PATHS [ $P ] & " -> " & $SZ0 & "=" & $ZBYTE & @CRLF )
		Case Not StringInStr ( FileRead ( $PTEMP ) , $FPNAME )
			If _ZIP_ADDITEM ( $ZIPPATH , $PATHS [ $P ] ) Then
				FileWrite ( $PTEMP , $FPNAME )
				FileWrite ( $HFIXLOG , $PATHS [ $P ] & " -> " & $COP & " " & $ZIPPATH & @CRLF )
			Else
				FileWrite ( $HFIXLOG , $PATHS [ $P ] & " -> " & $NCOPY & @CRLF )
			EndIf
	Case Else
			Sleep ( 1002 )
			$ZIPPATH1 = @DesktopDir & "\" & @MDAY & "." & @MON & "." & @YEAR & "_" & @HOUR & "." & @MIN & "." & @SEC & ".zip"
			If _ZIP_CREATE ( $ZIPPATH1 , 1 ) <> $ZIPPATH1 Then
				FileWrite ( $HFIXLOG , "Error creating another zip folder" & @CRLF & @CRLF )
				ContinueLoop
			EndIf
			If _ZIP_ADDITEM ( $ZIPPATH1 , $PATHS [ $P ] ) Then
				FileWrite ( $HFIXLOG , $PATHS [ $P ] & " -> " & $COP & " " & $ZIPPATH1 & @CRLF )
			Else
				FileWrite ( $HFIXLOG , $PATHS [ $P ] & " -> " & $NCOPY & @CRLF )
				FileDelete ( $ZIPPATH1 )
			EndIf
		EndSelect
	Next
	FileDelete ( $PTEMP )
	DirRemove ( $ZIPTEMP , 1 )
	FileWrite ( $HFIXLOG , "=========== " & "Zip: " & $END & " ===========" & @CRLF )
EndFunc
